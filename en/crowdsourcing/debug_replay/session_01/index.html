<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z2ZY6ZE84"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4Z2ZY6ZE84")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?6aacb1c7ca0a3ef4e3aa84c1eaa237dd",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Mulish:wght@300;400;600;700;800&family=Frank+Ruhl+Libre:wght@200;300;400;500;600&family=Encode+Sans+Semi+Condensed:wght@400&display=swap" rel=stylesheet><link rel=stylesheet type=text/css href=/css/bootstrap.min.css><link rel=stylesheet type=text/css href=/css/all.min.css><link disabled id=dark-mode-theme rel=stylesheet href=/css/dark.css><link rel=stylesheet type=text/css href=/css/style.css><link rel=stylesheet type=text/css href=/css/my_style.css><title>UnityChip Verification | Regression Verification Phase I: Reproduction of Bug Test Cases for the Third Generation Xiangshan (Kunming Lake) (In Progress)</title>
<meta name=description content="Design regression test cases to reproduce bugs based on the published bug tasks."></head><body style=max-width:90%;min-width:575px;margin:auto><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class=container><a class=navbar-brand href=https://open-verify.cc/en><b style=font-weight:800>Home</b>
</a><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarNavDropdown aria-controls=navbarNavDropdown aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarNavDropdown><ul class="navbar-nav ms-auto mt-2 mt-lg-0"><li class=nav-item><a class=nav-link href=/en/crowdsourcing/>Verification Tasks</a></li><li class=nav-item><a class=nav-link href=/en/learningresource/>Learning Resources</a></li><li class=nav-item><a class=nav-link href=/en/about/>About Us</a></li><li class=nav-item><a class=nav-link href=https://open-verify.cc/crowdsourcing/debug_replay/session_01/>中文</a></li><li class="nav-item px-2 pt-1"><a class="btn fas fa-moon" id=dark-mode-toggle></a></li></ul></div></div></nav><div id=content><div class=container><div class="py-4 rounded-3"><div class="container-fluid py-2"><h1 class="display-2 mb-4 text-center">Regression Verification Phase I: Reproduction of Bug Test Cases for the Third Generation Xiangshan (Kunming Lake) (In Progress)</h1></div><p class="text-center fs-4 fst-italic serif">Design regression test cases to reproduce bugs based on the published bug tasks.</p><div class="text-center pt-4"></div></div><div class="row justify-content-center mb-5"><div class=col-12><p class="card-date m-0">Created Jan 11, 2024 -
Last updated: Jan 11, 2024</p><hr class=dropdown-divider><div class="row justify-content-between"><div class=col-sm-4></div><div class=col-sm-8 style=text-align:right></div></div></div></div><div class="container-fluid py-2"><div class="serif main-content"><blockquote><p>UT (Unit Testing), IT (Integration Testing), and ST (System Testing) are three critical phases in processor verification, each targeting different levels of the verification process. Among them, UT focuses on testing the smallest functional units (modules) within the processor design to ensure they meet the design requirements. However, in practice, some module bugs are not detected during the UT phase but are discovered and reported in subsequent verification stages. Therefore, it is necessary to construct test cases in UT to reproduce these bugs. Additionally, the test cases need to be rerun on the version where the bug has been fixed to ensure the bug has been correctly resolved. This process is also known as regression testing.</p></blockquote><h2 id=task-overview>Task Overview</h2><p>This phase of the task will provide 18 bugs to be regressed. Participants are required to use the specified toolchain (<a href=https://github.com/XS-MLVP/picker target=_blank>picker</a>, <a href=https://github.com/XS-MLVP/toffee target=_blank>toffee</a> (optional)) to construct test cases for bug regression.</p><p>For most bugs, we will provide detailed descriptions, including the module where the bug occurs, the cause, and how to reproduce it. For some bugs, participants may need to locate the relevant module or set up the verification environment based on the description. Depending on the workload, different levels of rewards will be provided. For each bug regression completed and a Pull Request (PR) submitted to the <a href=https://github.com/XS-MLVP/UnityChipForXiangShan target=_blank>UnityChipForXiangShan</a> repository, a reward of 100 RMB will be granted. Additional rewards are available for contributing to the bug verification infrastructure. We hope everyone can actively participate and complete the tasks!(<a href=https://www.wjx.top/vm/ryUKH5T.aspx>Click here</a> to fill out the application form.)</p><h2 id=test-content>Test Content</h2><p>For each bug, you need to complete the following tasks:</p><h4 id=1environment-setup>1、Environment Setup</h4><p>First, based on the test environment provided by <a href=https://github.com/XS-MLVP/UnityChipForXiangShan target=_blank>UnityChipForXiangShan</a>, construct test cases to perform bug regression.</p><ul><li>If the module is not explicitly mentioned in the description, you need to locate the relevant module yourself.</li><li>If the verification environment for the target module does not exist in the repository, please refer to the <strong>Prepare Verification Environment</strong> and <strong>Add Tests</strong> sections in the <a href=https://open-verify.cc/UnityChipForXiangShan/docs/01_verfiy_env/ target=_blank>documentation</a> to set up the verification environment according to the specifications.</li></ul><h4 id=2test-case-construction>2、Test Case Construction</h4><p>Next, based on the cause of the bug, construct the corresponding test cases. For this task, you will be provided with <strong>the RTL where the bug occurred</strong> and <strong>the commit date that fixed the bug</strong>.</p><p>For the constructed test cases, the following two aspects need to be fulfilled:</p><ol><li><p>In the RTL with a bug: The test case can be executed, but it fails when running the test case.</p></li><li><p>In the RTL downloaded from the <a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs target=_blank>repository</a> after the commit date: The test case can be executed, and the test case passes.</p></li></ol><h4 id=3commit-message>3、Commit Message</h4><p>Finally, write a description specifying which module the bug belongs to, briefly outline the relevant test environment and test case, and explain how to run the test.</p><p>After completing the above tasks, submit the PR to the <a href=https://github.com/XS-MLVP/UnityChipForXiangShan target=_blank>UnityChipForXiangShan</a> repository.</p><h2 id=task-reward>Task Reward</h2><p>For each completed bug regression and submission of a PR to the <a href=https://github.com/XS-MLVP/UnityChipForXiangShan target=_blank>UnityChipForXiangShan</a> repository, a reward of 100 RMB will be granted for the first accepted PR. Additional rewards may be provided for contributions to the bug verification infrastructure.</p><h2 id=bug-to-be-reproduced>Bug to Be Reproduced</h2><p>For each bug, the following table lists the corresponding task ID, bug description, root cause, RTL version where the bug occurred, and the commit date of the fix. For more details, please refer to the issue or <a href="https://iz9a87wn37.feishu.cn/base/GmASbpeYcagtmGsE9WncMqwDnhb?from=from_copylink" target=_blank>task details</a>.</p><p>Note: <strong>Commit</strong>: Click to navigate to the commit page that fixed the bug; <strong>RTL</strong>: Click to download the RTL at the time the bug occurred.</p><style>.table-container{margin:20px auto;width:90%;border-collapse:collapse;table-layout:fixed}.table-container th,.table-container td{border:1px solid #ddd;padding:8px;text-align:left;position:relative}.table-container th{background-color:#f2f2f2}.table-container .id-column{width:11ch}.table-container .commit-column{width:12ch}.table-container .rtl-column{width:9ch}.table-container .description-column,.table-container .reason-column{width:35%}.table-container .issue-column{width:8ch}.table-container .index-column{width:6ch}.table-container .ellipsis{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;max-width:100%;cursor:pointer}.table-container .tooltip{visibility:hidden;position:absolute;background-color:#555;color:#fff;text-align:center;border-radius:4px;padding:5px;z-index:1;bottom:125%;left:50%;transform:translateX(-50%);opacity:0;transition:opacity .3s;max-width:300px;word-wrap:break-word}.table-container .ellipsis:hover .tooltip{visibility:visible;opacity:1}</style><table class=table-container><thead><tr><th class=index-column>Serial Number</th><th class=id-column>Task ID</th><th class=description-column>Bug Description</th><th class=commit-column>Commit</th><th class=rtl-column>RTL</th><th class=reason-column>Cause</th><th class=issue-column>Issue</th><th class=issue-column>Contributor</th></tr></thead><tbody><tr><td class=index-column>1</td><td class=id-column>KMH22-242</td><td class=description-column><div class=ellipsis>A misalignment occurred during memory access, and the GPA (Guest Physical Address) was not passed, resulting in an error.<span class=tooltip>A misalignment occurred during memory access, and the GPA (Guest Physical Address) was not passed, resulting in an error.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/052738a target=_blank>2024-09-12</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024080301/openxiangshan-kmh-a061b23-24080301.tar.gz target=_blank>24080301</a></td><td class=reason-column><div class=ellipsis>A misalignment occurred during memory access, and the GPA (Guest Physical Address) was not passed, resulting in an error.<span class=tooltip>A misalignment occurred during memory access, and the GPA (Guest Physical Address) was not passed, resulting in an error.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/15 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>2</td><td class=id-column>KMH22-118</td><td class=description-column><div class=ellipsis>The stopcount and stoptime functionalities in DCSR (Debug Control and Status Register) have not been implemented. <span class=tooltip>The stopcount and stoptime functionalities in DCSR (Debug Control and Status Register) have not been implemented.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/1e49aee target=_blank>2024-11-14</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024080301/openxiangshan-kmh-a061b23-24080301.tar.gz target=_blank>24080301</a></td><td class=reason-column><div class=ellipsis>The stopcount and stoptime functionalities in DCSR (Debug Control and Status Register) have not been implemented. Implement these features in the design code.<span class=tooltip>The stopcount and stoptime functionalities in DCSR (Debug Control and Status Register) have not been implemented. Implement these features in the design code.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/16 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>3</td><td class=id-column>KMH22-351</td><td class=description-column><div class=ellipsis>An error occurred in the calculation of the gpaddr (Guest Physical Address) during L1 TLB refill.<span class=tooltip>An error occurred in the calculation of the gpaddr (Guest Physical Address) during L1 TLB refill.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/08ae0d2 target=_blank>2024-09-04</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024082801/openxiangshan-kmh-19bd5ff8-24082801.tar.gz target=_blank>24082801</a></td><td class=reason-column><div class=ellipsis>During the first-stage address translation in Bare mode and the second-stage address translation in Sv39x4 mode, when a GPF (Guest Page Fault) occurs, mtval2 is 0. In the case of "onlys2," an error occurs in the calculation of the gpaddr (Guest Physical Address) during L1 TLB refill. The s1 ppn (Page Physical Number) was used instead of the s2 tag, which is incorrect.<span class=tooltip>During the first-stage address translation in Bare mode and the second-stage address translation in Sv39x4 mode, when a GPF (Guest Page Fault) occurs, mtval2 is 0. In the case of "onlys2," an error occurs in the calculation of the gpaddr (Guest Physical Address) during L1 TLB refill. The s1 ppn (Page Physical Number) was used instead of the s2 tag, which is incorrect.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/17 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>4</td><td class=id-column>KMH22-397</td><td class=description-column><div class=ellipsis>The RAS (Return Address Stack) misprediction caused speculation stack blockage, leading to front-end stalling and freezing.<span class=tooltip>The RAS (Return Address Stack) misprediction caused speculation stack blockage, leading to front-end stalling and freezing.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/c776f0d target=_blank>2024-09-10</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024082801/openxiangshan-kmh-19bd5ff8-24082801.tar.gz target=_blank>24082801</a></td><td class=reason-column><div class=ellipsis>There is an issue with the Call and Ret signals sent to the RAS (Return Address Stack) module during redirection. When the RAS implementation is blocked, it misjudges the speculation stack blockage, causing the front-end to stall and freeze.<span class=tooltip>There is an issue with the Call and Ret signals sent to the RAS (Return Address Stack) module during redirection. When the RAS implementation is blocked, it misjudges the speculation stack blockage, causing the front-end to stall and freeze.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/18 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>5</td><td class=id-column>KMH22-398</td><td class=description-column><div class=ellipsis>When a miss_req continuously waits for probing and replay in the MSHR (Miss Status Handling Register), the refill_req can block store_req and probe_req, leading to a deadlock. <span class=tooltip>When a miss_req continuously waits for probing and replay in the MSHR (Miss Status Handling Register), the refill_req can block store_req and probe_req, leading to a deadlock.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/be007c1 target=_blank>2024-09-04</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024082801/openxiangshan-kmh-19bd5ff8-24082801.tar.gz target=_blank>24082801</a></td><td class=reason-column><div class=ellipsis>n the previous design, when a miss_req continuously waited for probing and replay in the MSHR (Miss Status Handling Register), the refill_req would block store_req and probe_req, leading to a deadlock. Now, the unnecessary blocking has been removed to fix this issue.<span class=tooltip>n the previous design, when a miss_req continuously waited for probing and replay in the MSHR (Miss Status Handling Register), the refill_req would block store_req and probe_req, leading to a deadlock. Now, the unnecessary blocking has been removed to fix this issue.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/19 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>6</td><td class=id-column>KMH22-399</td><td class=description-column><div class=ellipsis>The unit-stride address is hardcoded with 39 bits. After switching to Sv48, the higher bits are lost.<span class=tooltip>The unit-stride address is hardcoded with 39 bits. After switching to Sv48, the higher bits are lost.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/b528775 target=_blank>2024-09-16</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024082801/openxiangshan-kmh-19bd5ff8-24082801.tar.gz target=_blank>24082801</a></td><td class=reason-column><div class=ellipsis>After enabling Sv48, there is an issue where the bit width for vector memory access has not been modified or adapted accordingly.<span class=tooltip>After enabling Sv48, there is an issue where the bit width for vector memory access has not been modified or adapted accordingly.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/20 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>7</td><td class=id-column>KMH22-400</td><td class=description-column><div class=ellipsis>The PCredit for MMIO and cacheable spaces are not arbitrated together, resulting in the loss of PCrdGrant.<span class=tooltip>The PCredit for MMIO and cacheable spaces are not arbitrated together, resulting in the loss of PCrdGrant.</span></div></td><td class=commit-column>TBD</td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024082801/openxiangshan-kmh-19bd5ff8-24082801.tar.gz target=_blank>24082801</a></td><td class=reason-column><div class=ellipsis>The PCredit for MMIO and cacheable spaces should be arbitrated together. The allocation of MMIO's rxrsp to a specific MMIO entry is determined by the TxnID. However, PCrdGrant does not carry a TxnID. According to the previous PCrdGrant allocation logic, if a transaction receives PCrdGrant before receiving RetryAck, this PCrdGrant will be lost.<span class=tooltip>The PCredit for MMIO and cacheable spaces should be arbitrated together. The allocation of MMIO's rxrsp to a specific MMIO entry is determined by the TxnID. However, PCrdGrant does not carry a TxnID. According to the previous PCrdGrant allocation logic, if a transaction receives PCrdGrant before receiving RetryAck, this PCrdGrant will be lost.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/21 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>8</td><td class=id-column>KMH22-1547</td><td class=description-column><div class=ellipsis>The PLRU (Pseudo Least Recently Used) replacement algorithm in the TLB has replaced a recently accessed TLB entry, causing the TLB's gpf (general protection fault) handling process to be disrupted and resulting in a system hang.<span class=tooltip>The PLRU (Pseudo Least Recently Used) replacement algorithm in the TLB has replaced a recently accessed TLB entry, causing the TLB's gpf (general protection fault) handling process to be disrupted and resulting in a system hang.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/4fc3a30 target=_blank>2024-12-02</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024103001/openxiangshan-kmh-7a8dfe4f-24103001.tar.gz target=_blank>24103001</a></td><td class=reason-column><div class=ellipsis>The L1TLB does not store physical addresses (gpaddr), but gpaddr is essential when a guest page fault (GPF) occurs. In such cases, the L1TLB needs to send a page table walk (PTW) request to obtain the gpaddr, which we refer to as getGpa. The getGpa mechanism can only handle one GPF TLB request (i.e., the first request) and expects the corresponding TLB entry to still reside in the L1TLB. The L1TLB replacement algorithm uses PLRU (Pseudo Least Recently Used), which may replace entries that are not necessarily the least recently used. We observed a scenario where the L1TLB replaced the GPF TLB entry even though it had been accessed recently. This led to a deadlock issue in the getGpa mechanism, ultimately causing the entire core to freeze. To resolve this issue, we decided to block any unrelated PTW fills while the getGpa mechanism is active (i.e., when gpaddr is needed). After addressing this problem, we found that, in some cases, other PTW responses were not being filled, and other TLB requests continued to trigger PTW requests, occupying the L2TLB request path and preventing the GPF PTW request from being serviced, eventually causing the processor to freeze. To solve this, we decided to block any unrelated PTW requests when gpaddr is required.<span class=tooltip>The L1TLB does not store physical addresses (gpaddr), but gpaddr is required when a guest page fault (GPF) occurs. In such cases, the L1TLB needs to send a page table walk (PTW) request to obtain the gpaddr, which we refer to as getGpa. The getGpa mechanism can only handle one GPF TLB request (i.e., the first request) and assumes that the corresponding TLB entry still resides in the L1TLB. The L1TLB replacement algorithm uses PLRU (Pseudo Least Recently Used), which may replace entries that are not necessarily the least recently used. We observed a scenario where the L1TLB replaced the GPF TLB entry even though it had been accessed recently. This led to a deadlock issue in the getGpa mechanism, ultimately causing the entire core to freeze. To resolve this issue, we decided to block any unrelated PTW fills while the getGpa mechanism is active (i.e., when gpaddr is needed). After addressing this problem, we found that, in some cases, other PTW responses were not being filled, and other TLB requests continued to trigger PTW requests, occupying the L2TLB request path and preventing the GPF PTW request from being serviced, eventually causing the processor to freeze. To solve this, we decided to block any unrelated PTW requests when gpaddr is required.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/22 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>9</td><td class=id-column>KMH22-1572</td><td class=description-column><div class=ellipsis>Xvisor fails to handle GPF (Guest Page Fault) correctly, resulting in an infinite loop.<span class=tooltip>Xvisor fails to handle GPF (Guest Page Fault) correctly, resulting in an infinite loop.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/e3e0af7 target=_blank>2024-11-14</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024110801/openxiangshan-kmh-fbdb359d-24110801.tar.gz target=_blank>24110801</a></td><td class=reason-column><div class=ellipsis>The L1TLB has added logic to handle gpaddr for cross-page scenarios, but this logic only considers the DTLB case and fails to account for the fact that the ITLB does not utilize the fullva and related pathways. As a result, during exceptions, a value of 0 is incorrectly passed as htval. Xvisor's exception handling mechanism relies on htval to process GPF (Guest Page Fault) exceptions, and the incorrect htval causes the system to hang.<span class=tooltip>The L1TLB has added logic to handle gpaddr for cross-page scenarios, but this logic only considers the DTLB case and fails to account for the fact that the ITLB does not utilize the fullva and related pathways. As a result, during exceptions, a value of 0 is incorrectly passed as htval. Xvisor's exception handling mechanism relies on htval to process GPF (Guest Page Fault) exceptions, and the incorrect htval causes the system to hang.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/23 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>10</td><td class=id-column>KMH22-1786</td><td class=description-column><div class=ellipsis>In the RTL, the vs (vector state) is incorrectly set to dirty for certain instructions that are incapable of modifying the vector state.<span class=tooltip>In the RTL, the vs (vector state) is incorrectly set to dirty for certain instructions that are incapable of modifying the vector state.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/547d96a target=_blank>2024-12-01</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024111901/openxiangshan-kmh-3b733a2b-24111901.tar.gz target=_blank>24111901</a></td><td class=reason-column><div class=ellipsis>do not set vs.dirty for some type of vecInsts<span class=tooltip>do not set vs.dirty for some type of vecInsts</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/24 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>11</td><td class=id-column>KMH22-1824</td><td class=description-column><div class=ellipsis>The vset instruction should not respond to clock interrupts, but it has been incorrectly marked as interrupt_safe.<span class=tooltip>The vset instruction should not respond to clock interrupts, but it has been incorrectly marked as interrupt_safe.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/493f6e1 target=_blank>2024-12-07</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024111901/openxiangshan-kmh-3b733a2b-24111901.tar.gz target=_blank>24111901</a></td><td class=reason-column><div class=ellipsis>Modify the vset instruction to not respond to clock interrupts.<span class=tooltip>Modify the vset instruction to not respond to clock interrupts.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/25 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>12</td><td class=id-column>KMH22-1844</td><td class=description-column><div class=ellipsis>The frontend incorrectly handles exceptions when fetching instructions across page boundaries.<span class=tooltip>The frontend incorrectly handles exceptions when fetching instructions across page boundaries.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/547d96a target=_blank>2024-12-01</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024112601/openxiangshan-kmh-3956160f-24112601.tar.gz target=_blank>24112601</a></td><td class=reason-column><div class=ellipsis>It is likely an issue with ebsin.<span class=tooltip>It is likely an issue with ebsin.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/26 target=_blank>链接</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>13</td><td class=id-column>KMH22-1861</td><td class=description-column><div class=ellipsis>The issue involves reading vsie/vsip in non-V mode and reading sie/sip in V mode.<span class=tooltip>The issue involves reading vsie/vsip in non-V mode and reading sie/sip in V mode.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/e9ba7f2 target=_blank>2024-12-06</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024120301/openxiangshan-kmh-2e5ebf51-24120301.tar.gz target=_blank>24120301</a></td><td class=reason-column><div class=ellipsis>When a VS interrupt occurs on the host, the VM will experience an S interrupt. Therefore, the interrupt numbers need to be synchronized. The issue of reading vsie/vsip in non-V mode and reading sie/sip in V mode has been fixed. We enable interrupts by writing the corresponding bits in mstatus/sstatus/vsstatus, so we need to update xtopi when writing to them. Xu Zefan: Although measures have been taken in the L1TLB to block ptw refill requests when need_gpf is active, it fails to block ptw refill requests that enter at the critical moment when need_gpf is about to be asserted.<span class=tooltip>When a VS interrupt occurs on the host, the VM will trigger an S interrupt. Therefore, the interrupt numbers need to be synchronized. The issue of reading vsie/vsip in non-V mode and sie/sip in V mode has been fixed. We enable interrupts by writing the corresponding bits in mstatus/sstatus/vsstatus, so we need to update xtopi when writing to these registers. Xu Zefan: Although measures have been taken in the L1TLB to block ptw refill requests when need_gpf is active, it fails to block ptw refill requests that enter at the critical moment when need_gpf is about to be asserted.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/27 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>14</td><td class=id-column>KMH22-1872</td><td class=description-column><div class=ellipsis>vecExcpInfo.valid is incorrectly updated when an interrupt occurs.<span class=tooltip>vecExcpInfo.valid is incorrectly updated when an interrupt occurs.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/7876e67 target=_blank>2024-12-06</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024120301/openxiangshan-kmh-2e5ebf51-24120301.tar.gz target=_blank>24120301</a></td><td class=reason-column><div class=ellipsis>In Rob, vecExcpInfo.valid := exceptionHappen && exceptionDataRead.bits.vstartEn && exceptionDataRead.bits.isVecLoad && !exceptionDataRead.bits.isEnqExcp. When this signal is high, it indicates that a vector memory-related exception needs to be handled. At this point, a submodule under backend called vecExcpMod enters a state machine that temporarily blocks instructions from entering Dispatch. However, when an interrupt occurs, exceptionHappen will also be high, and the data in exceptionDataRead will be invalid. If this invalid data coincidentally causes vecExcpInfo.valid to be high, it will incorrectly block instructions from entering Dispatch, leading to a deadlock. Therefore, the assignment for this signal needs to exclude the interrupt scenario, changing it to vecExcpInfo.valid := exceptionHappen && !intrEnable && exceptionDataRead.bits.vstartEn && exceptionDataRead.bits.isVecLoad && !exceptionDataRead.bits.isEnqExcp.<span class=tooltip>In Rob, vecExcpInfo.valid := exceptionHappen && exceptionDataRead.bits.vstartEn && exceptionDataRead.bits.isVecLoad && !exceptionDataRead.bits.isEnqExcp. When this signal is high, it indicates that a vector memory-related exception needs to be handled. At this point, a submodule under backend called vecExcpMod enters a state machine that temporarily blocks instructions from entering Dispatch. However, when an interrupt occurs, exceptionHappen will also be high, and the data in exceptionDataRead will be invalid. If this invalid data coincidentally causes vecExcpInfo.valid to be high, it will incorrectly block instructions from entering Dispatch, leading to a deadlock. Therefore, the assignment for this signal needs to exclude the interrupt scenario, changing it to vecExcpInfo.valid := exceptionHappen && !intrEnable && exceptionDataRead.bits.vstartEn && exceptionDataRead.bits.isVecLoad && !exceptionDataRead.bits.isEnqExcp.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/28 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>15</td><td class=id-column>KMH22-1947</td><td class=description-column><div class=ellipsis>During an interrupt, vecExcpInfo.valid is incorrectly updated, leading to vecExcpInfo.bits potentially containing uninitialized values, which can cause X-state propagation or random deadlocks.<span class=tooltip>During an interrupt, vecExcpInfo.valid is incorrectly updated, leading to vecExcpInfo.bits potentially containing uninitialized values, which can cause X-state propagation or random deadlocks.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/7876e67 target=_blank>2024-12-06</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024101101/openxiangshan-kmh-ecac006d-24101101.tar.gz target=_blank>24101101</a></td><td class=reason-column><div class=ellipsis>vecExcpInfo.valid := exceptionHappen && exceptionDataRead.bits.vstartEn && exceptionDataRead.bits.isVecLoad && !exceptionDataRead.bits.isEnqExcp. When this signal is high, it indicates that a vector memory-related exception needs to be handled. At this point, a submodule under backend called vecExcpMod enters a state machine that temporarily blocks instructions from entering Dispatch. However, when an interrupt occurs, exceptionHappen will also be high, and the data in exceptionDataRead will be invalid. If this invalid data coincidentally causes vecExcpInfo.valid to be high, it will cause the vecExcpMod module to incorrectly block instructions from entering Dispatch, leading to a deadlock. Therefore, the assignment for this signal needs to exclude the interrupt scenario, changing it to vecExcpInfo.valid := exceptionHappen && !intrEnable && exceptionDataRead.bits.vstartEn && exceptionDataRead.bits.isVecLoad && !exceptionDataRead.bits.isEnqExcp.<span class=tooltip>vecExcpInfo.valid := exceptionHappen && exceptionDataRead.bits.vstartEn && exceptionDataRead.bits.isVecLoad && !exceptionDataRead.bits.isEnqExcp. When this signal is high, it indicates that a vector memory-related exception needs to be handled. At this point, a submodule under backend called vecExcpMod enters a state machine that temporarily blocks instructions from entering Dispatch. However, when an interrupt occurs, exceptionHappen will also be high, and the data in exceptionDataRead will be invalid. If this invalid data coincidentally causes vecExcpInfo.valid to be high, it will cause the vecExcpMod module to incorrectly block instructions from entering Dispatch, leading to a deadlock. Therefore, the assignment for this signal needs to exclude the interrupt scenario, changing it to vecExcpInfo.valid := exceptionHappen && !intrEnable && exceptionDataRead.bits.vstartEn && exceptionDataRead.bits.isVecLoad && !exceptionDataRead.bits.isEnqExcp.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/29 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>16</td><td class=id-column>KMH22-1957</td><td class=description-column><div class=ellipsis>IF the ITLB is not synchronized during a specific prefetch flush, it can cause the ITLB to enter a need_gpf state, preventing it from receiving previous requests.<span class=tooltip>IF the ITLB is not synchronized during a specific prefetch flush, it can cause the ITLB to enter a need_gpf state, preventing it from receiving previous requests.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/fad7803 target=_blank>2024-12-09</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024120301/openxiangshan-kmh-2e5ebf51-24120301.tar.gz target=_blank>24120301</a></td><td class=reason-column><div class=ellipsis>IF the ITLB is not synchronized during a specific prefetch flush, it can cause the ITLB to enter a need_gpf state, preventing it from receiving previous requests.<span class=tooltip>IF the ITLB is not synchronized during a specific prefetch flush, it can cause the ITLB to enter a need_gpf state, preventing it from receiving previous requests.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/30 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>17</td><td class=id-column>KMH22-1968</td><td class=description-column><div class=ellipsis>An incorrect index was used to select the ECC.<span class=tooltip>An incorrect index was used to select the ECC.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/98d2aaa target=_blank>2024-12-12</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024120901/openxiangshan-kmh-fad7803d-24120901.tar.gz target=_blank>24120901</a></td><td class=reason-column><div class=ellipsis>An incorrect index was used to select the ECC.<span class=tooltip>An incorrect index was used to select the ECC.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/31 target=_blank>Link</a></td><td class=issue-column>-</td></tr><tr><td class=index-column>18</td><td class=id-column>KMH22-1971</td><td class=description-column><div class=ellipsis>The vecExceptionFlag marking position condition is incorrect.<span class=tooltip>The vecExceptionFlag marking position condition is incorrect.</span></div></td><td class=commit-column><a href=https://github.com/OpenXiangShan/XiangShan/commit/99baa88 target=_blank>2025-01-13</a></td><td class=rtl-column><a href=https://github.com/XS-MLVP/UnityChipXiangShanRTLs/releases/download/2024120901/openxiangshan-kmh-fad7803d-24120901.tar.gz target=_blank>24120901</a></td><td class=reason-column><div class=ellipsis>The vecExceptionFlag marking position condition is incorrect.<span class=tooltip>The vecExceptionFlag marking position condition is incorrect.</span></div></td><td class=issue-column><a href=https://github.com/XS-MLVP/UnityChipForXiangShan/issues/32 target=_blank>Link</a></td><td class=issue-column>-</td></tr></tbody></table></div></div></div></div><div class=container><div class="row justify-content-between"><div class=col-sm-4><p class=footer>MLVP Group © 2025</p></div><div class="col-sm-6 d-flex flex-row-reverse"><a class="footer-social px-2" href=# target=_blank><i class="fab fa-weixin"></i></a>
<a class="footer-social px-2" href=# target=_blank><i class="fab fa-weibo"></i></a></div></div></div><script src=/js/bootstrap.min.js></script><script src=/js/jquery.min.js></script><script src=/js/isotope.pkgd.min.js></script><script src=/js/masonry.pkgd.min.js async></script><script src=/js/dark.js></script><script>var savedTheme=localStorage.getItem("dark-mode-storage")||"light";setTheme(savedTheme)</script><script src=/js/isotope.js></script><script src=/js/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,securityLevel:"loose"})</script></body></html>