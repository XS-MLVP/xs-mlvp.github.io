<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z2ZY6ZE84"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4Z2ZY6ZE84")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?6aacb1c7ca0a3ef4e3aa84c1eaa237dd",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Mulish:wght@300;400;600;700;800&family=Frank+Ruhl+Libre:wght@200;300;400;500;600&family=Encode+Sans+Semi+Condensed:wght@400&display=swap" rel=stylesheet><link rel=stylesheet type=text/css href=/css/bootstrap.min.css><link rel=stylesheet type=text/css href=/css/all.min.css><link disabled id=dark-mode-theme rel=stylesheet href=/css/dark.css><link rel=stylesheet type=text/css href=/css/style.css><link rel=stylesheet type=text/css href=/css/my_style.css><title>万众一芯开放验证 | 第五讲·实战案例：果壳 Cache</title>
<meta name=description content></head><body style=width:100%;max-width:100%;margin:0;padding:0><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="d-flex justify-content-between align-items-center" style=width:100%><div class="d-flex align-items-center"><a class="navbar-brand navbar-brand-content" href=https://open-verify.cc/cn><img src=/images/logo.png></a><div class="collapse navbar-collapse" id=navbarNavDropdown><ul class="navbar-nav ms-auto mt-2 mt-lg-0"><li class=nav-item><a class=nav-link href=/registration_portal/>报名入口汇总</a></li><li class=nav-item><a class=nav-link href=/learningresource/>学习资源</a></li><li class=nav-item><a class=nav-link href=/about/>关于我们</a></li></ul></div></div><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarNavDropdown aria-controls=navbarNavDropdown aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" style=flex:1><ul class="navbar-nav ms-auto mt-2 mt-lg-0"><li class=nav-item><a class="btn fas fa-moon" id=dark-mode-toggle></a></li></ul></div></div></nav><div id=content><div class=container><div class="py-5 rounded-3"><div class="container-fluid py-2"><h1 class="display-2 mb-4 text-center">第五讲·实战案例：果壳 Cache</h1><p class="bio fs-4 serif text-center">介绍如何开始一个验证任务、完成 Chisel 到 Verilog 的转换，以及验证果壳 Cache 的要求</p></div></div><div class="row justify-content-between mb-5"><div class=col-6>Created <span style=font-size:small>Jan 2, 2025</span>
- Last updated <span style=font-size:small>Jan 2, 2025</span></div><div class=col-6 style=text-align:right></div><hr class=dropdown-divider></div><div class="container py-2"><div class="serif main-content"><p>新手课程的最后任务是用 Toffee 对果壳 Cache 进行验证，在完成新手教程全部内容的学习之后，需要提交果壳 Cache 的验证代码仓库和验证报告。</p><h1 id=开始新的验证任务>开始新的验证任务</h1><p>使用 toffee，你已经可以搭建出一个完整的验证环境，并且方便地去编写测试用例了。然而在实际的业务中，往往无法理解如何开始上手，并最终完成验证任务。实际编写代码后，会遇到无法正确划分 Bundle，无法正确理解 Agent 的高级语义封装，搭建完环境之后不知道做什么等问题。</p><p>在这一节中，将会介绍如何从头开始完成一个新的验证任务，以及如何更好地使用 toffee 来完成验证任务。</p><ol><li>了解待验证设计</li></ol><p>拿到一个新的设计后，往往面对的是几十或数百个输入输出信号，如果直接看这些信号，很可能一头雾水，感觉无从下手。在这时，你必须坚信，输入输出信号都是设计人员来定义的，只要能够理解设计的功能，就能够理解这些信号的含义。</p><p>如果设计人员提供了设计文档，那么你可以阅读设计文档，了解设计的功能，并一步步地将功能与输入输出信号对应起来，并且要清楚地理解输入输出信号的时序，以及如何使用这些信号来驱动设计。一般来说，你还需要阅读设计的源代码，来找寻更细节的接口时序问题。</p><p>当大致了解了 DUT 的功能，并明白如何驱动起 DUT 接口之后，你就可以开始搭建验证环境了。</p><ul><li>划分 Bundle</li></ul><p>搭建环境的第一件事，就是根据接口的逻辑功能，将其划分为若干个接口集合，我们可以每一个接口集合视作一个 Bundle。划分为的每个 Bundle 都应是独立的，由一个独立的 Agent 来驱动。</p><p>但是，往往实际中的接口是这样的：</p><pre tabindex=0><code class="language-plain text" data-lang="plain text">|---------------------- DUT Bundle -------------------------------|
<p>|&mdash;&mdash;- Bundle 1 &mdash;&mdash;| |&mdash;&mdash; Bundle 2 &mdash;&mdash;| |&ndash; Bundle 3 &ndash;|</p>
<p>|&ndash; B1.1 &ndash;| |&ndash; B1.2 &ndash;| |&ndash; B2.1 &ndash;|
</code></pre><p>那么问题就出现了，例如究竟是应该为 B1.1， B1.2 各自创建一个 Agent，还是应该直接为 Bundle 1 建立一个 Agent 呢？</p></p><p>这还是取决于接口的逻辑功能，如果需要定义一个独立的请求，这个请求需要对 B1.1 和 B1.2 同时进行操作，那么就应该为 Bundle 1 创建一个 Agent，而不是为 B1.1 和 B1.2 分别创建 Agent。</p><p>即便如此，为 B1.1 和 B1.2 定义 1.2 也是可行的，这增添了 Agent 的划分粒度，但牺牲了操作的连续性，上层代码和参考模型的编写都会变得复杂。因此选择合适的划分粒度是需要对具体业务的权衡。最终的划分，所有的 Agent 加起来应该能覆盖 DUT Bundle 的所有接口。</p><p>实践中，为了方便 DUT 的连接，可以定义一个 <code>DUT</code> Bundle，一次性将所有的接口都连接到这个 Bundle 上，由 Env 将其中的子 Bundle 分发给各个 Agent。</p><ul><li>编写 Agent</li></ul><p>当 Bundle 划分完成后，就可以开始编写 Agent 来驱动这些 Bundle 了，你需要为每个 Bundle 编写一个 Agent。</p><p>首先，可以从驱动方法开始写起，驱动方法实际上是对 Bundle 的一种高级语义封装，因此，高级语义信息应该携带了足以驱动 Bundle 的所有信息。如果 Bundle 中存在一个信号需要数字，但参数中并没有提供与这一信号相关的信息，那么这种高级语义封装就是不完整的。应尽量避免在驱动方法中对某个信号值进行假定，如果对这一信号在 Agent 中进行假定，DUT 的输出将会受到这一假定的影响，可能导致参考模型与 DUT 的行为不一致。</p><p>同时，这一高层封装也决定了参考模型的功能层级，参考模型会直接与高层语义信息进行交互，并不会涉及到底层信号。</p><p>如果参考模型需要用函数调用模式编写，那么应该将 DUT 的输出通过函数返回值来返回。如果参考模型需要用独立执行流模式编写，那么应该编写监测方法，将 DUT 的所有输出转换成高层语义信息，通过监测方法输出。</p><ul><li>封装成 Env</li></ul><p>当所有的 Agent 编写完成后，或者挑选之前已有的 Agent，就可以将这些 Agent 封装成 Env 了。</p><p>Env 封装了整个验证环境，并确定了参考模型的编写规范。</p><ul><li>编写参考模型</li></ul><p>参考模型的编写没有必要在 Env 编写完成之后再开始，可以与 Agent 的编写同时进行，并实时编写一些驱动代码，来检验编写的正确性。当然如果 Agent 的编写特别规范，编写完整 Env 后再编写参考模型也是可行的。</p><p>参考模型最重要的是选择合适的编写模式，函数调用模式和独立执行流模式都是可行的，但在不同的场景下，选择不同的模式会更加方便。</p><ul><li>确定功能点及测试点</li></ul><p>编写好 Env 以及参考模型后，并不能直接开始编写测试用例，因为此时并没有测试用例的编写方向，盲目的编写测试用例，没有办法让待测设计验证完全。</p><p>首先需要列出功能点及测试点列表。功能点是待测设计支持的所有功能，例如对于一个算术逻辑单元（ALU）来说，功能点的形式可能是“支持加法”，“支持乘法”等。每个功能点需要对应一个或多个测试点，测试点通过将功能划分为不同的测试场景，来验证功能点是否正确。例如对于“支持加法”这个功能点，可能有“当输入都为正数时，加法正确”等测试点。</p><ul><li>编写测试用例</li></ul><p>当功能点及测试点列表确定后，就可以开始编写测试用例了，一个测试用例需要能够覆盖一个或多个测试点，以验证功能点是否正确。所有的测试用例应该能够覆盖所有的测试点（功能覆盖率 100%），以及覆盖所有的设计行（行覆盖率 100%），这样一来就能保证验证的完备性。</p><p>如何保证验证的正确性呢？如果采用参考模型比对的方式，当比对失败时，toffee 会自动抛出异常，使得测试用例失败。如果采用直接比对的方式，应该在测试用例中使用 <code>assert</code> 来编写比对代码，当比对失败时，测试用例也会失败。最终，当所有的测试用例都通过时，意味着功能已验证为正确。</p><p>编写过程中，你需要使用 <code>Env</code> 中提供的接口来驱动 DUT，如果出现了需要多个驱动方法交互的情况，可以使用 <code>Executor</code> 来封装更高层的函数。也就是说驱动方法级的交互，是在测试用例的编写中完成的。</p><ul><li>编写验证报告</li></ul><p>当行覆盖率和功能覆盖率都达到了 100% 之后，意味着验证已经完成。最终需要编写一个验证报告，来总结验证任务的结果。如果验证出了待测设计的问题，也应在验证报告中详细描述问题的原因。如果行覆盖率或者功能覆盖率没有达到 100%，也应在验证报告中说明原因，报告的格式应该遵循公司内部统一的规范。</p><h1 id=生成果壳-cache-的-dut>生成果壳 Cache 的 DUT</h1><h2 id=果壳-cache>果壳 cache</h2><p>果壳 cache（Nutshell Cache）是果壳处理器中使用的缓存模块。其采用三级流水设计，当第三级流水检出当前请求为 MMIO 或者发生重填（refill）时，会阻塞流水线。同时，果壳 cache 采用可定制的模块化设计，通过改变参数可以生成存储空间大小不同的一级 cache（L1 Cache）或者二级 cache（L2 Cache）。此外，果壳 cache 留有一致性（coherence）接口，可以处理一致性相关的请求。</p><p><img src alt></p><h2 id=chisel-与果壳>Chisel 与果壳</h2><p>准确来说，Chisel 是基于 Scala 语言的高级硬件构造（HCL）语言。传统 HDL 是描述电路，而 HCL 则是生成电路，更加抽象和高级。同时 Chisel 中提供的 Stage 包则可以将 HCL 设计转化成 Verilog、System Verilog 等传统的 HDL 语言设计。配合上 Mill、Sbt 等 Scala 工具则可以实现自动化的开发。</p><p>如果你并不熟悉Chisel语言，可以先浏览<a href=https://mybinder.org/v2/gh/freechipsproject/chisel-bootcamp/master>Chisel Bootcamp</a>的前三章内容，快速熟悉Chisel的语法。</p><p>果壳是使用 Chisel 语言模块化设计的、基于 RISC-V RV64 开放指令集的顺序单发射处理器实现。果壳更详细的介绍请参考链接：<a href=https://oscpu.github.io/NutShell-doc/>https://oscpu.github.io/NutShell-doc/</a></p><h2 id=chisel-转-verilog>Chisel 转 Verilog</h2><p>Chisel 中的<code>stage</code>库可以帮助由 Chisel 代码生成 Verilog、System Verilog 等传统的 HDL 代码。以下将简单介绍如何由基于 Chisel 的 cache 实现转换成对应的 Verilog 电路描述。</p><p>请先保证完成 jdk 环境和 mill 的配置。</p><blockquote><p>⚠️警告：JDK 的版本≥21 会出现编译报错！</p></blockquote><h3 id=初始化果壳环境>初始化果壳环境</h3><p>首先从源仓库下载整个果壳源代码，并进行初始化：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir cache-ut
</span></span><span style=display:flex><span><span style=color:#111>cd</span> cache-ut
</span></span><span style=display:flex><span>git clone https://github.com/OSCPU/NutShell.git
</span></span><span style=display:flex><span><span style=color:#111>cd</span> NutShell <span style=color:#f92672>&amp;&amp;</span> git checkout 97a025d
</span></span><span style=display:flex><span>make init
</span></span></code></pre></div><h3 id=创建-scala-编译配置>创建 scala 编译配置</h3><p>在 cache-ut 目录下创建 build.sc，其中内容如下：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00a8c8>import</span> <span style=color:#111>$file.NutShell.build</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>import</span> <span style=color:#111>mill._</span><span style=color:#f92672>,</span> <span style=color:#111>scalalib</span><span style=color:#f92672>.</span><span style=color:#00a8c8>_</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>import</span> <span style=color:#111>coursier.maven.MavenRepository</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>import</span> <span style=color:#111>mill.scalalib.TestModule._</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 指定Nutshell的依赖
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#00a8c8>object</span> <span style=color:#75af00>difftest</span> <span style=color:#00a8c8>extends</span> <span style=color:#75af00>NutShell</span><span style=color:#f92672>.</span><span style=color:#111>build</span><span style=color:#f92672>.</span><span style=color:#75af00>CommonNS</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#00a8c8>override</span> <span style=color:#00a8c8>def</span> <span style=color:#111>millSourcePath</span> <span style=color:#00a8c8>=</span> <span style=color:#111>os</span><span style=color:#f92672>.</span><span style=color:#111>pwd</span> <span style=color:#f92672>/</span> <span style=color:#d88200>&#34;NutShell&#34;</span> <span style=color:#f92672>/</span> <span style=color:#d88200>&#34;difftest&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Nutshell 配置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#00a8c8>object</span> <span style=color:#75af00>NtShell</span> <span style=color:#00a8c8>extends</span> <span style=color:#75af00>NutShell</span><span style=color:#f92672>.</span><span style=color:#111>build</span><span style=color:#f92672>.</span><span style=color:#75af00>CommonNS</span> <span style=color:#00a8c8>with</span> <span style=color:#75af00>NutShell</span><span style=color:#f92672>.</span><span style=color:#111>build</span><span style=color:#f92672>.</span><span style=color:#75af00>HasChiselTests</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#00a8c8>override</span> <span style=color:#00a8c8>def</span> <span style=color:#111>millSourcePath</span> <span style=color:#00a8c8>=</span> <span style=color:#111>os</span><span style=color:#f92672>.</span><span style=color:#111>pwd</span> <span style=color:#f92672>/</span> <span style=color:#d88200>&#34;NutShell&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#00a8c8>override</span> <span style=color:#00a8c8>def</span> <span style=color:#111>moduleDeps</span> <span style=color:#00a8c8>=</span> <span style=color:#00a8c8>super</span><span style=color:#f92672>.</span><span style=color:#111>moduleDeps</span> <span style=color:#f92672>++</span> <span style=color:#75af00>Seq</span><span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>        <span style=color:#111>difftest</span><span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// UT环境配置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#00a8c8>object</span> <span style=color:#75af00>ut</span> <span style=color:#00a8c8>extends</span> <span style=color:#75af00>NutShell</span><span style=color:#f92672>.</span><span style=color:#111>build</span><span style=color:#f92672>.</span><span style=color:#75af00>CommonNS</span> <span style=color:#00a8c8>with</span> <span style=color:#75af00>ScalaTest</span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>override</span> <span style=color:#00a8c8>def</span> <span style=color:#111>millSourcePath</span> <span style=color:#00a8c8>=</span> <span style=color:#111>os</span><span style=color:#f92672>.</span><span style=color:#111>pwd</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>override</span> <span style=color:#00a8c8>def</span> <span style=color:#111>moduleDeps</span> <span style=color:#00a8c8>=</span> <span style=color:#00a8c8>super</span><span style=color:#f92672>.</span><span style=color:#111>moduleDeps</span> <span style=color:#f92672>++</span> <span style=color:#75af00>Seq</span><span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>        <span style=color:#75af00>NtShell</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=实例化-cache>实例化 cache</h3><p>创建好配置信息后，按照 scala 规范，创建<code>src/main/scala</code>源代码目录。之后，就可以在源码目录中创建<code>nut_cache.scala</code>，利用如下代码实例化 Cache 并转换成 Verilog 代码：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00a8c8>package</span> <span style=color:#111>ut_nutshell</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>import</span> <span style=color:#111>chisel3._</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>import</span> <span style=color:#111>chisel3.util._</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>import</span> <span style=color:#111>nutcore._</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>import</span> <span style=color:#111>top._</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>import</span> <span style=color:#111>chisel3.stage._</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>object</span> <span style=color:#75af00>CacheMain</span> <span style=color:#00a8c8>extends</span> <span style=color:#75af00>App</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>(</span><span style=color:#00a8c8>new</span> <span style=color:#75af00>ChiselStage</span><span style=color:#f92672>).</span><span style=color:#111>execute</span><span style=color:#f92672>(</span><span style=color:#111>args</span><span style=color:#f92672>,</span> <span style=color:#75af00>Seq</span><span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>      <span style=color:#75af00>ChiselGeneratorAnnotation</span><span style=color:#f92672>(()</span> <span style=color:#00a8c8>=&gt;</span> <span style=color:#00a8c8>new</span> <span style=color:#75af00>Cache</span><span style=color:#f92672>()(</span><span style=color:#75af00>CacheConfig</span><span style=color:#f92672>(</span><span style=color:#111>ro</span> <span style=color:#00a8c8>=</span> <span style=color:#00a8c8>false</span><span style=color:#f92672>,</span> <span style=color:#111>name</span> <span style=color:#00a8c8>=</span> <span style=color:#d88200>&#34;tcache&#34;</span><span style=color:#f92672>,</span> <span style=color:#111>userBits</span> <span style=color:#00a8c8>=</span> <span style=color:#ae81ff>16</span><span style=color:#f92672>)))</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>))</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=生成-rtl>生成 RTL</h3><p>完成上述所有文件的创建后（<code>build.sc</code>，<code>src/main/scala/nut_cache.scala</code>），在<code>cache-ut</code>目录下执行如下命令：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir build
</span></span><span style=display:flex><span>mill --no-server -d ut.runMain ut_nutshell.CacheMain --target-dir build --output-file Cache
</span></span></code></pre></div><blockquote><p>注：mill 环境的配置请参考 <a href=https://mill-build.com/mill/Intro_to_Mill.html>https://mill-build.com/mill/Intro_to_Mill.html</a></p></blockquote><p>上述命令成功执行完成后，会在 build 目录下生成 verilog 文件：Cache.v。之后就可以通过 picker 工具进行 Cache.v 到 Python 模块的转换。除去 chisel 外，其他 HCL 语言几乎都能生成对应的 RTL 代码，因此上述基本流程也适用于其他 HCL。</p><h1 id=验证果壳-cache>验证果壳 Cache</h1><p>在学习了前述的知识后，相信你已经对硬件验证的方法有了一定的概念，请进行一次实战吧！请你对果壳 Cache 进行验证，撰写验证代码和测试报告，并在 UnityChipForXiangShan 的<a href=https://github.com/XS-MLVP/UnityChipForXiangShan/discussions/13> github 讨论板块</a>提交验证报告和代码。报告内容应当包含功能梳理、测试点分解、测试用例编写、验证结果分析和验证结论等。</p><p>验证报告的格式可以参考先前的<a href=https://github.com/XS-MLVP/Example-NutShellCache/blob/master/nutshell_cache_report_demo.pdf>果壳 Cache 验证案例</a>完成您的验证。</p><blockquote><p>在开始验证之前，推荐先通读一遍 picker 和 toffee 的文档</p></blockquote></div></div></div><div class="container mb-5"></div><div class=container><div class="row row-cols-1 row-cols-md-2 row-cols-lg-3 row-cols-xl-4 g-4 mb-3" id=blogposts></div></div></div><script src=/js/bootstrap.min.js></script><script src=/js/jquery.min.js></script><script src=/js/isotope.pkgd.min.js></script><script src=/js/masonry.pkgd.min.js async></script><script src=/js/dark.js></script><script>var savedTheme=localStorage.getItem("dark-mode-storage")||"light";setTheme(savedTheme)</script><script src=/js/isotope.js></script><script src=/js/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,securityLevel:"loose"})</script></body></html>