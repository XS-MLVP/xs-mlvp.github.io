<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z2ZY6ZE84"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4Z2ZY6ZE84")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?6aacb1c7ca0a3ef4e3aa84c1eaa237dd",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Mulish:wght@300;400;600;700;800&family=Frank+Ruhl+Libre:wght@200;300;400;500;600&family=Encode+Sans+Semi+Condensed:wght@400&display=swap" rel=stylesheet><link rel=stylesheet type=text/css href=/css/bootstrap.min.css><link rel=stylesheet type=text/css href=/css/all.min.css><link disabled id=dark-mode-theme rel=stylesheet href=/css/dark.css><link rel=stylesheet type=text/css href=/css/style.css><link rel=stylesheet type=text/css href=/css/my_style.css><title>万众一芯开放验证 | 第三讲·Toffee 的安装与使用</title>
<meta name=description content></head><body style=width:100%;max-width:100%;margin:0;padding:0><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="d-flex justify-content-between align-items-center" style=width:100%><div class="d-flex align-items-center"><a class="navbar-brand navbar-brand-content" href=https://open-verify.cc/cn><img src=/images/logo.png></a><div class="collapse navbar-collapse" id=navbarNavDropdown><ul class="navbar-nav ms-auto mt-2 mt-lg-0"><li class=nav-item><a class=nav-link href=/registration_portal/>报名入口汇总</a></li><li class=nav-item><a class=nav-link href=/learningresource/>学习资源</a></li><li class=nav-item><a class=nav-link href=/about/>关于我们</a></li></ul></div></div><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarNavDropdown aria-controls=navbarNavDropdown aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" style=flex:1><ul class="navbar-nav ms-auto mt-2 mt-lg-0"><li class=nav-item><a class="btn fas fa-moon" id=dark-mode-toggle></a></li></ul></div></div></nav><div id=content><div class=container><div class="py-5 rounded-3"><div class="container-fluid py-2"><h1 class="display-2 mb-4 text-center">第三讲·Toffee 的安装与使用</h1><p class="bio fs-4 serif text-center">掌握使用 Toffee 进行芯片验证的基本流程和关键技术，为后续独立完成验证任务打下基础</p></div></div><div class="row justify-content-between mb-5"><div class=col-6>Created <span style=font-size:small>Jul 30, 2025</span>
- Last updated <span style=font-size:small>Jul 30, 2025</span></div><div class=col-6 style=text-align:right></div><hr class=dropdown-divider></div><div class="container py-2"><div class="serif main-content"><div class=toc><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#1-toffee-的安装>1. Toffee 的安装</a></li><li><a href=#2-使用-toffee-test-管理测试用例>2. 使用 toffee-test 管理测试用例</a><ul><li><a href=#21-fixture>2.1 Fixture</a></li><li><a href=#22-测试用例的规范>2.2 测试用例的规范</a></li></ul></li><li><a href=#3-使用异步环境>3. 使用异步环境</a><ul><li><a href=#31-异步函数>3.1 异步函数</a><ul><li><a href=#async关键字><code>async</code>关键字</a></li><li><a href=#await关键字><code>await</code>关键字</a></li></ul></li><li><a href=#32-实现并发>3.2 实现并发</a></li><li><a href=#33-管理-dut-时钟>3.3 管理 DUT 时钟</a></li><li><a href=#34-其他的异步等待方法>3.4 其他的异步等待方法</a></li><li><a href=#练习>练习</a></li></ul></li><li><a href=#4-使用-bundle-封装端口>4. 使用 Bundle 封装端口</a><ul><li><a href=#41-一个简单的-bundle-的定义>4.1 一个简单的 Bundle 的定义</a></li><li><a href=#42-将-dut-绑定到-bundle>4.2 将 DUT 绑定到 Bundle</a></li><li><a href=#43-处理端口名称不匹配的情况>4.3 处理端口名称不匹配的情况</a><ul><li><a href=#通过前缀进行绑定>通过前缀进行绑定</a></li><li><a href=#通过正则表达式进行绑定>通过正则表达式进行绑定</a></li><li><a href=#通过字典进行绑定>通过字典进行绑定</a></li></ul></li><li><a href=#44-创建子-bundle>4.4 创建子 Bundle</a></li><li><a href=#45-bundle-中的实用操作节选>4.5 Bundle 中的实用操作（节选）</a><ul><li><a href=#信号访问与赋值>信号访问与赋值</a></li><li><a href=#消息支持字典操作>消息支持（字典操作）</a></li><li><a href=#异步支持>异步支持</a></li></ul></li><li><a href=#46-小结>4.6 小结</a></li><li><a href=#47-练习>4.7 练习</a></li></ul></li><li><a href=#5-使用-agent-进一步封装>5. 使用 Agent 进一步封装</a><ul><li><a href=#51-初始化-agent>5.1 初始化 Agent</a></li><li><a href=#52-创建驱动方法>5.2 创建驱动方法</a></li><li><a href=#53-创建监测方法>5.3 创建监测方法</a></li><li><a href=#54-获取监测消息>5.4 获取监测消息</a></li><li><a href=#55-agent-中的时序>5.5 Agent 中的时序</a></li><li><a href=#56-完整的-agent-示例>5.6 完整的 Agent 示例</a></li><li><a href=#57-练习>5.7 练习</a></li></ul></li><li><a href=#6-同步-fifo-规范阅读>6. 同步 FIFO 规范阅读</a><ul><li><a href=#本节目标>本节目标</a></li><li><a href=#阅读顺序推荐五步法>阅读顺序推荐：五步法</a><ul><li><a href=#1-理解模块的作用和目的>1. 理解模块的作用和目的</a></li><li><a href=#2-弄清输入输出信号>2. 弄清输入输出信号</a></li><li><a href=#3-理解模块内部逻辑>3. 理解模块内部逻辑</a></li><li><a href=#4-识别极端或边界行为>4. 识别极端或边界行为</a></li><li><a href=#5-整理验证目标建立验证计划>5. 整理验证目标，建立验证计划</a></li></ul></li></ul></li><li><a href=#7-收集功能覆盖率>7. 收集功能覆盖率</a><ul><li><a href=#71-功能覆盖率模型>7.1 功能覆盖率模型</a></li><li><a href=#72-功能覆盖率的组成>7.2 功能覆盖率的组成</a></li><li><a href=#73-构建功能覆盖率模型基本原则>7.3 构建功能覆盖率模型：基本原则</a><ul><li><a href=#1-基于功能需求和验证计划>1. 基于功能需求和验证计划</a></li><li><a href=#2-基于观察数据>2. 基于观察数据</a></li><li><a href=#3-面向分析而设计>3. 面向分析而设计</a></li><li><a href=#4-确定适当的详细程度>4. 确定适当的详细程度</a></li><li><a href=#5-覆盖点和覆盖仓的关键考量>5. 覆盖点和覆盖仓的关键考量</a></li><li><a href=#6-确定正确的参样时机>6. 确定正确的参样时机</a></li><li><a href=#7-确定采样结果是有效的>7. 确定采样结果是有效的</a></li></ul></li><li><a href=#74-在-toffee-中收集功能覆盖率>7.4 在 Toffee 中收集功能覆盖率</a><ul><li><a href=#定义覆盖组-covgroup-和覆盖点-add_watch_point>定义覆盖组 （<code>CovGroup</code>） 和覆盖点 （<code>add_watch_point</code>）</a></li><li><a href=#编写技巧>编写技巧</a></li><li><a href=#覆盖率数据的收集与采样>覆盖率数据的收集与采样</a></li></ul></li><li><a href=#75-小结>7.5 小结</a></li><li><a href=#76-练习x20>7.6 练习</a></li></ul></li><li><a href=#8-打包验证环境>8. 打包验证环境</a><ul><li><a href=#81-创建-env>8.1 创建 Env</a></li><li><a href=#82-绑定参考模型>8.2 绑定参考模型</a></li></ul></li><li><a href=#9-编写参考模型>9. 编写参考模型</a><ul><li><a href=#91-参考模型的实现方式>9.1 参考模型的实现方式</a><ul><li><a href=#如何选择实现模式>如何选择实现模式？</a></li></ul></li><li><a href=#92-使用函数调用模式>9.2 使用函数调用模式</a><ul><li><a href=#驱动函数钩子-driver_hook>驱动函数钩子 （@driver_hook）</a></li><li><a href=#监测钩子函数-monitor_hook>监测钩子函数 （@monitor_hook）</a></li><li><a href=#agent-钩子agent_hook>Agent 钩子（@agent_hook）</a></li><li><a href=#hook-调用顺序>Hook 调用顺序</a></li></ul></li><li><a href=#93-使用独立执行流模式>9.3 使用独立执行流模式</a><ul><li><a href=#定义端口>定义端口</a></li><li><a href=#便捷匹配方式-1>便捷匹配方式</a></li><li><a href=#实现异步执行流>实现异步执行流</a></li><li><a href=#使用-agentport>使用 AgentPort</a></li></ul></li><li><a href=#94-练习>9.4 练习</a></li></ul></li><li><a href=#拓展阅读>拓展阅读</a><ul><li><a href=#协程相关>协程相关</a></li><li><a href=#pytest-相关>Pytest 相关</a></li></ul></li></ul></nav></div><h1 id=简介>简介</h1><p>在上一讲中，我们学习了如何使用 Picker 工具将 RTL 设计转换为可在高级语言（如 Python）中驱动的模块。虽然 Picker 提供了底层的硬件交互能力，但要构建一个结构化、可复用、易于维护的验证环境，还需要更完善的框架和方法学支持。</p><p><strong>Toffee</strong> 正是为此而生。它是一个基于 Python 语言编写的硬件验证框架，构建于 Picker 之上，旨在提供一套更高效、更规范的验证解决方案。</p><p><strong>Toffee 框架的主要功能特点包括：</strong></p><ol><li><p><strong>标准化验证环境结构</strong>：借鉴了 UVM 等验证方法学的思想，提供了 <code>Bundle</code>（接口封装）、<code>Agent</code>（事务级驱动与监测）、<code>Env</code>（环境组织）、<code>Model</code>（参考模型）等核心组件，引导用户构建分层、模块化的验证平台。</p></li><li><p><strong>集成测试用例管理 （<code>toffee-test</code>）</strong>：通过与 <code>pytest</code> 框架集成，<code>toffee-test</code> 插件简化了测试用例的编写、执行、管理和报告生成，支持 <code>fixture</code> 等高级测试特性。</p></li><li><p><strong>内建异步支持</strong>：核心基于 Python 的 <code>asyncio</code> 协程，提供了 <code>async/await</code> 的原生支持和一系列异步等待机制（如 <code>AStep</code>， <code>ACondition</code>），便于处理并发行为和精确的时序控制。</p></li><li><p><strong>功能覆盖率支持</strong>：内建 <code>CovGroup</code>， <code>CovPoint</code>， <code>CovBin</code> 等类，支持方便地定义、收集和报告功能覆盖率，量化验证完备性。</p></li></ol><p><strong>相比直接使用 Picker，采用 Toffee 框架的优势：</strong></p><ul><li><p><strong>更高的抽象层次</strong>：Toffee 将验证逻辑从底层的信号读写提升到事务级操作，使测试用例更关注于“测什么”而不是“怎么驱动信号”。</p></li><li><p><strong>更强的结构化和规范性</strong>：提供了明确的验证环境组件和组织方式，提高了代码的可读性、可维护性和可复用性。</p></li><li><p><strong>简化的测试流程</strong>：<code>toffee-test</code> 自动化了测试用例发现、执行和报告生成，集成了覆盖率收集，简化了整个验证流程的管理。</p></li><li><p><strong>方法学支持</strong>：融入了验证方法学的最佳实践（如驱动与监测分离、事务级建模、覆盖率驱动验证等），有助于新手建立规范的验证思维。</p></li><li><p><strong>易于扩展和协作</strong>：模块化的设计使得验证环境更容易扩展，也更便于团队成员分工协作。</p></li></ul><p>总而言之，Picker 解决了“如何用高级语言与硬件交互”的问题，而 Toffee 则在此基础上，提供了“如何<strong>高效、规范地</strong>用高级语言构建完整验证环境”的解决方案。本讲将详细介绍 Toffee 的安装和核心组件的使用方法。</p><h1 id=1-toffee-的安装>1. Toffee 的安装</h1><p>配置好 Python 环境后，可以通过以下命令安装 Toffee 及其测试工具 <code>toffee-test</code>：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>pip3</span> <span style=color:#111>install</span> <span style=color:#111>pytoffee</span><span style=color:#75af00>@git</span><span style=color:#f92672>+</span><span style=color:#111>https</span><span style=color:#111>:</span><span style=color:#f92672>//</span><span style=color:#111>github</span><span style=color:#f92672>.</span><span style=color:#111>com</span><span style=color:#f92672>/</span><span style=color:#111>XS</span><span style=color:#f92672>-</span><span style=color:#111>MLVP</span><span style=color:#f92672>/</span><span style=color:#111>toffee</span><span style=color:#75af00>@master</span>
</span></span><span style=display:flex><span><span style=color:#111>pip3</span> <span style=color:#111>install</span> <span style=color:#111>toffee</span><span style=color:#f92672>-</span><span style=color:#111>test</span><span style=color:#75af00>@git</span><span style=color:#f92672>+</span><span style=color:#111>https</span><span style=color:#111>:</span><span style=color:#f92672>//</span><span style=color:#111>github</span><span style=color:#f92672>.</span><span style=color:#111>com</span><span style=color:#f92672>/</span><span style=color:#111>XS</span><span style=color:#f92672>-</span><span style=color:#111>MLVP</span><span style=color:#f92672>/</span><span style=color:#111>toffee</span><span style=color:#f92672>-</span><span style=color:#111>test</span><span style=color:#75af00>@master</span>
</span></span></code></pre></div><blockquote><p>❗关于<code>error: externally-managed-environment</code></p><p>由于<a href=https://peps.python.org/pep-0668/> PEP 668 </a>的原因，如果出现该报错，建议使用 venv 创建一个虚拟环境，在虚拟环境中安装并使用 toffee</p></blockquote><p>完成安装之后，我们可以尝试运行一段加法器的样例代码，来验证是否完成安装：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 拉取代码</span>
</span></span><span style=display:flex><span>git clone https://github.com/XS-MLVP/toffee.git --depth<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 进入加法器示例的文件夹</span>
</span></span><span style=display:flex><span><span style=color:#111>cd</span> toffee/example/adder
</span></span><span style=display:flex><span><span style=color:#75715e># 构建dut</span>
</span></span><span style=display:flex><span>make dut
</span></span><span style=display:flex><span><span style=color:#75715e># 运行测试                                 </span>
</span></span><span style=display:flex><span>make run
</span></span></code></pre></div><p>如果配置成功，你会看到：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>test_adder.py::test_random PASSED
</span></span><span style=display:flex><span>test_adder.py::test_boundary PASSED
</span></span></code></pre></div><hr><h1 id=2-使用-toffee-test-管理测试用例>2. 使用 toffee-test 管理测试用例</h1><p>在先前的环境中，我们需要手动管理测试用例。<code>toffee-test</code> 是 toffee 提供的一个 pytest 插件，用于管理 toffee 测试用例。</p><blockquote><p>💡关于 pytest：Pytest 是 Python 中的一个软件测试框架。</p><p>它能够轻松编写简洁易读的测试用例，同时具备强大的扩展能力，足以支持应用程序和库的复杂功能测试需求。</p><p>Pytest 本身有强大的功能和丰富的生态，如果感兴趣的话，可以查阅 <a href=https://docs.pytest.org/en/stable/>pytest 的文档</a>和相关的插件仓库，来帮助你更好地完成验证任务。</p></blockquote><p>在随机数生成器的例子中，仅使用 picker 的验证代码为：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>RandomGenerator</span> <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#111>random</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 定义参考模型</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>LFSR_16</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#111>__init__</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>seed</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>state</span> <span style=color:#f92672>=</span> <span style=color:#111>seed</span> <span style=color:#f92672>&amp;</span> <span style=color:#111>((</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>16</span><span style=color:#111>)</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>Step</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>new_bit</span> <span style=color:#f92672>=</span> <span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>state</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>15</span><span style=color:#111>)</span> <span style=color:#f92672>^</span> <span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>state</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>14</span><span style=color:#111>)</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>state</span> <span style=color:#f92672>=</span> <span style=color:#111>((</span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>state</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span><span style=color:#111>)</span> <span style=color:#f92672>|</span> <span style=color:#111>new_bit</span> <span style=color:#111>)</span> <span style=color:#f92672>&amp;</span> <span style=color:#111>((</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>16</span><span style=color:#111>)</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>if</span> <span style=color:#111>__name__</span> <span style=color:#f92672>==</span> <span style=color:#d88200>&#34;__main__&#34;</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span> <span style=color:#f92672>=</span> <span style=color:#111>DUTRandomGenerator</span><span style=color:#111>()</span>            <span style=color:#75715e># 创建DUT </span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>InitClock</span><span style=color:#111>(</span><span style=color:#d88200>&#34;clk&#34;</span><span style=color:#111>)</span>                  <span style=color:#75715e># 指定时钟引脚，初始化时钟</span>
</span></span><span style=display:flex><span>    <span style=color:#111>seed</span> <span style=color:#f92672>=</span> <span style=color:#111>random</span><span style=color:#f92672>.</span><span style=color:#111>randint</span><span style=color:#111>(</span><span style=color:#ae81ff>0</span><span style=color:#111>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>**</span><span style=color:#ae81ff>16</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#111>)</span>   <span style=color:#75715e># 生成随机种子</span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>seed</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#111>seed</span>                 <span style=color:#75715e># 设置DUT种子</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># reset DUT</span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>reset</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>                   <span style=color:#75715e># reset 信号置1</span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>Step</span><span style=color:#111>()</span>                            <span style=color:#75715e># 推进一个时钟周期</span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>reset</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>                   <span style=color:#75715e># reset 信号置0</span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>Step</span><span style=color:#111>()</span>                            <span style=color:#75715e># 推进一个时钟周期</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#111>ref</span> <span style=color:#f92672>=</span> <span style=color:#111>LFSR_16</span><span style=color:#111>(</span><span style=color:#111>seed</span><span style=color:#111>)</span>                   <span style=color:#75715e># 创建参考模型用于对比</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#ae81ff>65536</span><span style=color:#111>):</span>                <span style=color:#75715e># 循环65536次</span>
</span></span><span style=display:flex><span>        <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>Step</span><span style=color:#111>()</span>                        <span style=color:#75715e># dut 推进一个时钟周期，生成随机数</span>
</span></span><span style=display:flex><span>        <span style=color:#111>ref</span><span style=color:#f92672>.</span><span style=color:#111>Step</span><span style=color:#111>()</span>                        <span style=color:#75715e># ref 推进一个时钟周期，生成随机数</span>
</span></span><span style=display:flex><span>        <span style=color:#111>rand</span> <span style=color:#f92672>=</span> <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>random_number</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>assert</span> <span style=color:#111>rand</span> <span style=color:#f92672>==</span> <span style=color:#111>ref</span><span style=color:#f92672>.</span><span style=color:#111>state</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;Mismatch&#34;</span>  <span style=color:#75715e># 对比DUT和参考模型生成的随机数</span>
</span></span><span style=display:flex><span>        <span style=color:#111>print</span><span style=color:#111>(</span><span style=color:#d88200>f</span><span style=color:#d88200>&#34;Cycle </span><span style=color:#d88200>{</span><span style=color:#111>i</span><span style=color:#d88200>}</span><span style=color:#d88200>, DUT: </span><span style=color:#d88200>{</span><span style=color:#111>rand</span><span style=color:#d88200>:</span><span style=color:#d88200>x</span><span style=color:#d88200>}</span><span style=color:#d88200>, REF: </span><span style=color:#d88200>{</span><span style=color:#111>ref</span><span style=color:#f92672>.</span><span style=color:#111>state</span><span style=color:#d88200>:</span><span style=color:#d88200>x</span><span style=color:#d88200>}</span><span style=color:#d88200>&#34;</span><span style=color:#111>)</span> <span style=color:#75715e># 打印结果</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 完成测试</span>
</span></span><span style=display:flex><span>    <span style=color:#111>print</span><span style=color:#111>(</span><span style=color:#d88200>&#34;Test Passed&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>Finish</span><span style=color:#111>()</span>    <span style=color:#75715e># Finish函数会完成波形、覆盖率等文件的写入</span>
</span></span></code></pre></div><p>那么引入 toffee 和 toffee-test 之后，就可以通过 pytest 自动完成测试用例的运行和结果的收集。例如，在<code>RandomGenerator.v</code>所在的目录下创建 <code>test_with_toffee.py</code>：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># test_with_toffee.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>RandomGenerator</span> <span style=color:#f92672>import</span> <span style=color:#111>DUTRandomGenerator</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#111>random</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#111>toffee_test</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 定义参考模型</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>LFSR_16</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#111>__init__</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>seed</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>state</span> <span style=color:#f92672>=</span> <span style=color:#111>seed</span> <span style=color:#f92672>&amp;</span> <span style=color:#111>((</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>16</span><span style=color:#111>)</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>Step</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>new_bit</span> <span style=color:#f92672>=</span> <span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>state</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>15</span><span style=color:#111>)</span> <span style=color:#f92672>^</span> <span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>state</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>14</span><span style=color:#111>)</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>state</span> <span style=color:#f92672>=</span> <span style=color:#111>((</span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>state</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span><span style=color:#111>)</span> <span style=color:#f92672>|</span> <span style=color:#111>new_bit</span><span style=color:#111>)</span> <span style=color:#f92672>&amp;</span> <span style=color:#111>((</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>16</span><span style=color:#111>)</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75af00>@toffee_test.testcase</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>test_with_ref</span><span style=color:#111>(</span><span style=color:#111>dut</span><span style=color:#111>:</span> <span style=color:#111>DUTRandomGenerator</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#111>seed</span> <span style=color:#f92672>=</span> <span style=color:#111>random</span><span style=color:#f92672>.</span><span style=color:#111>randint</span><span style=color:#111>(</span><span style=color:#ae81ff>0</span><span style=color:#111>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>**</span><span style=color:#ae81ff>16</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#111>)</span>  <span style=color:#75715e># 生成随机种子</span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>seed</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#111>seed</span>                <span style=color:#75715e># 设置DUT种子</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#### 初始化部分 ####</span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>reset</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e># reset 信号置1</span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>Step</span><span style=color:#111>()</span>           <span style=color:#75715e># 推进一个时钟周期</span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>reset</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>  <span style=color:#75715e># reset 信号置0</span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>Step</span><span style=color:#111>()</span>           <span style=color:#75715e># 推进一个时钟周期</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#### 初始化结束 ####</span>
</span></span><span style=display:flex><span>    <span style=color:#111>ref</span> <span style=color:#f92672>=</span> <span style=color:#111>LFSR_16</span><span style=color:#111>(</span><span style=color:#111>seed</span><span style=color:#111>)</span>  <span style=color:#75715e># 创建参考模型用于对比</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#ae81ff>65536</span><span style=color:#111>):</span>  <span style=color:#75715e># 循环65536次</span>
</span></span><span style=display:flex><span>        <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>Step</span><span style=color:#111>()</span>          <span style=color:#75715e># dut 推进一个时钟周期，生成随机数</span>
</span></span><span style=display:flex><span>        <span style=color:#111>ref</span><span style=color:#f92672>.</span><span style=color:#111>Step</span><span style=color:#111>()</span>          <span style=color:#75715e># ref 推进一个时钟周期，生成随机数</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 对比DUT和参考模型生成的随机数</span>
</span></span><span style=display:flex><span>        <span style=color:#111>rand</span> <span style=color:#f92672>=</span> <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>random_number</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>assert</span> <span style=color:#111>rand</span> <span style=color:#f92672>==</span> <span style=color:#111>ref</span><span style=color:#f92672>.</span><span style=color:#111>state</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;Mismatch&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75af00>@toffee_test.fixture</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>dut</span><span style=color:#111>(</span><span style=color:#111>toffee_request</span><span style=color:#111>:</span> <span style=color:#111>toffee_test</span><span style=color:#f92672>.</span><span style=color:#111>ToffeeRequest</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 使用toffee创建DUT并绑定时钟</span>
</span></span><span style=display:flex><span>    <span style=color:#111>rand_dut</span> <span style=color:#f92672>=</span> <span style=color:#111>toffee_request</span><span style=color:#f92672>.</span><span style=color:#111>create_dut</span><span style=color:#111>(</span><span style=color:#111>DUTRandomGenerator</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;clk&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#111>rand_dut</span>
</span></span></code></pre></div><p>随后运行：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>pytest</span> <span style=color:#f92672>.</span> <span style=color:#f92672>-</span><span style=color:#111>sv</span> <span style=color:#75715e># . 代表命令行下当前的目录</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 如果想生成报告，执行</span>
</span></span><span style=display:flex><span><span style=color:#111>pytest</span> <span style=color:#f92672>.</span> <span style=color:#f92672>-</span><span style=color:#111>sv</span> <span style=color:#f92672>--</span><span style=color:#111>toffee</span><span style=color:#f92672>-</span><span style=color:#111>report</span>
</span></span></code></pre></div><p>然后就可以看到 pytest 输出的测试结果，在当前目录下还会创建<code>reports</code>文件夹，里面包含了可视化的测试报告。</p><p>在只使用 picker 的代码中，我们需要把测试用例放在<a href=https://docs.python.org/zh-cn/3.11/library/__main__.html>顶层代码环境</a>中来手动控制运行；而引入 toffee 的代码，只要保证遵循 pytest 的规范，并添加装饰器<code>@toffee_test.testcase</code>，就可以由 pytest 管理并运行；此外，pytest 还有丰富的功能和各种插件，例如可以给测试用例添加 mark，来控制运行哪一类用例等。</p><h2 id=21-fixture>2.1 Fixture</h2><p>在正式执行测试用例之前，pytest 会先执行使用<code>@toffee_test.fixture</code>装饰器的函数。</p><p><code>fixture</code> 是软件测试中的一个常用术语，在 pytest（以及 <code>toffee-test</code>）中，它指的是一种用于<strong>设置测试前置条件</strong>和<strong>管理测试资源</strong>的机制。Fixture 为测试用例提供了一个明确定义、可靠且一致的测试上下文。</p><p>通俗地讲，<code>fixture</code> 就像是测试的“脚手架”或“准备区”，它负责在每个需要它的测试用例运行之前，准备好所需的环境（如创建 DUT 对象、启动时钟、初始化 Agent 等），并在测试结束后进行可能的清理工作（如关闭文件、释放资源）。</p><p><strong>使用 Fixture 的好处：</strong></p><ul><li><p><strong>代码复用</strong>：将通用的设置逻辑（如创建 DUT）抽取到 Fixture 中，避免在每个测试用例中重复编写。</p></li><li><p><strong>关注点分离</strong>：测试用例可以专注于测试逻辑本身，而将环境准备工作交给 Fixture。</p></li><li><p><strong>资源管理</strong>：Fixture 可以确保资源（如 DUT 实例）在测试开始时被正确创建，并在测试结束后（如果需要）被清理。</p></li><li><p><strong>依赖注入</strong>：Fixture 的返回值可以自动“注入”到需要它的测试用例的参数中。</p></li></ul><p>在 <code>toffee-test</code> 中，定义 Fixture 需要遵循特定的规范：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75af00>@toffee_test.fixture</span> <span style=color:#75715e># 1. 固定装饰器</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>dut</span><span style=color:#111>(</span><span style=color:#111>toffee_request</span><span style=color:#111>:</span> <span style=color:#111>toffee_test</span><span style=color:#f92672>.</span><span style=color:#111>ToffeeRequest</span><span style=color:#111>):</span> <span style=color:#75715e># 2. 固定参数 toffee_request</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Fixture 的设置逻辑</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#111>rand_dut</span> <span style=color:#f92672>=</span> <span style=color:#111>toffee_request</span><span style=color:#f92672>.</span><span style=color:#111>create_dut</span><span style=color:#111>(</span><span style=color:#111>DUTRandomGenerator</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;clk&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 返回准备好的资源</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#111>rand_dut</span> <span style=color:#75715e># 3. 返回值将被注入测试用例</span>
</span></span></code></pre></div><p><strong>关键要素：</strong></p><ol><li><p><strong>装饰器</strong>：必须使用 <code>@toffee_test.fixture</code> 来声明这是一个 Toffee 测试的 Fixture。</p></li><li><p><strong>固定参数 <code>toffee_request</code></strong>： Fixture <strong>一定要</strong>包含一个名称为<code>toffee_request</code>（它的类型为 <code>toffee_test.ToffeeRequest</code>） 的参数， 该参数也会提供一些实用的功能（如创建 DUT <code>create_dut</code>、添加覆盖组 <code>add_cov_groups</code>）；<strong>框架会自动传入这个对象</strong>。</p></li><li><p><strong>返回值</strong>：Fixture 函数通过 <code>return</code>来提供准备好的资源。</p></li></ol><p><strong>执行机制与依赖注入：</strong></p><p>当一个测试用例（如 <code>async def test_with_ref(dut: DUTRandomGenerator)</code>）声明了一个与某个 Fixture 函数同名的参数（这里是 <code>dut</code>）时，pytest/toffee-test 会自动执行以下操作：</p><ol><li><p><strong>查找 Fixture</strong>：找到名为 <code>dut</code> 的 Fixture 函数。</p></li><li><p><strong>执行 Fixture</strong>：在运行测试用例之前，先调用 <code>dut()</code> 这个 Fixture 函数。</p></li><li><p><strong>注入结果</strong>：将 <code>dut()</code> Fixture 函数的返回值（即创建并启动了时钟的 <code>DUTRandomGenerator</code> 实例）传递给测试用例 <code>test_with_ref</code> 的 <code>dut</code> 参数。</p></li></ol><blockquote><p>⚠️<strong>重要提示</strong>：默认情况下，每个测试用例<strong>都会</strong>获得由 Fixture <strong>重新执行</strong>并返回的<strong>独立实例</strong>。这意味着 <code>test_with_ref</code> 使用的 <code>dut</code> 实例与另一个测试用例 <code>test_another(dut)</code> 使用的 <code>dut</code> 实例是不同的对象，它们之间状态隔离，确保了测试的独立性。</p></blockquote><p>下图展示了 Fixture 如何为多个测试用例提供独立的 DUT 实例：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>+---------------------------+
</span></span><span style=display:flex><span><span style=color:#111>|</span> fixture: dut<span style=color:#f92672>()</span>            <span style=color:#111>|</span>
</span></span><span style=display:flex><span><span style=color:#111>|</span> <span style=color:#00a8c8>return</span>: DUTRandomGenerator<span style=color:#111>|</span>
</span></span><span style=display:flex><span>+---------------------------+
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>
</span></span><span style=display:flex><span>              <span style=color:#111>|</span> 返回值
</span></span><span style=display:flex><span>              v
</span></span><span style=display:flex><span>        +--------------+
</span></span><span style=display:flex><span>        <span style=color:#111>|</span> DUT instance <span style=color:#111>|</span> 注意：fixture返回的结果并不是测试用例之间共享的，每个用例都会获得独立的实例
</span></span><span style=display:flex><span>        +--------------+
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>     +---------------------------------------------------+
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>     <span style=color:#111>|</span> @toffee_test.testcase                             <span style=color:#111>|</span>
</span></span><span style=display:flex><span>              +----&gt;<span style=color:#111>|</span> async def test_with_ref<span style=color:#f92672>(</span>dut: DUTRandomGenerator<span style=color:#f92672>)</span>: <span style=color:#111>|</span>
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>     <span style=color:#111>|</span>   await dut.generate<span style=color:#f92672>()</span>                            <span style=color:#111>|</span>
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>     <span style=color:#111>|</span>   ...                                             <span style=color:#111>|</span>
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>     +---------------------------------------------------+
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>     +---------------------------------------------------+
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>     <span style=color:#111>|</span> @toffee_test.testcase                             <span style=color:#111>|</span>
</span></span><span style=display:flex><span>              +----&gt;<span style=color:#111>|</span> async def test_another<span style=color:#f92672>(</span>dut: DUTRandomGenerator<span style=color:#f92672>)</span>:  <span style=color:#111>|</span>
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>     <span style=color:#111>|</span>   <span style=color:#111>result</span> <span style=color:#f92672>=</span> await dut.get_random<span style=color:#f92672>()</span>                 <span style=color:#111>|</span>
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>     <span style=color:#111>|</span>   ...                                             <span style=color:#111>|</span>
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>     +---------------------------------------------------+
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>     +---------------------------------------------------+
</span></span><span style=display:flex><span>              <span style=color:#111>|</span>     <span style=color:#111>|</span> @toffee_test.testcase                             <span style=color:#111>|</span>
</span></span><span style=display:flex><span>              +----&gt;<span style=color:#111>|</span> async def test_third<span style=color:#f92672>(</span>dut: DUTRandomGenerator<span style=color:#f92672>)</span>:    <span style=color:#111>|</span>
</span></span><span style=display:flex><span>                    <span style=color:#111>|</span>   await dut.setup<span style=color:#f92672>()</span>                               <span style=color:#111>|</span>
</span></span><span style=display:flex><span>                    <span style=color:#111>|</span>   ...                                             <span style=color:#111>|</span>
</span></span><span style=display:flex><span>                    +---------------------------------------------------+
</span></span></code></pre></div><p>通过使用 Fixture，我们可以有效地组织测试环境的准备工作，让测试用例本身更简洁、更专注于验证逻辑。关于 Fixture 的作用域（如 <code>session</code>、<code>module</code> 级别共享），可以查阅 pytest 和 python 的相关文档。</p><h2 id=22-测试用例的规范>2.2 测试用例的规范</h2><p>一般来说，对于包含测试用例的文件，需要遵循：</p><ol><li><p>定义为异步函数</p></li><li><p>包含测试用例的文件要以<code>test_</code>为前缀或<code>_test</code>为后缀</p></li><li><p>每个测试用例（即函数或方法）的名称，需要以<code>test</code>为前缀，更具体的规则请参考 <a href=https://docs.pytest.org/en/stable/explanation/goodpractices.html#conventions-for-python-test-discovery>pytest 文档</a></p></li><li><p>每个测试用例要有和 fixture 函数同名的参数，这样才能让 pytest 注入结果</p></li></ol><p>随着验证代码量的增加，使用 toffee 和 toffee-test 能显著提升验证效率、优化验证的工作体验。</p><hr><h1 id=3-使用异步环境>3. 使用异步环境</h1><p>在之前 <code>toffee-test</code> 的示例代码中，我们注意到函数定义前都添加了 <code>async</code> 关键字。这是因为 Toffee 框架的核心是基于<strong>协程</strong>的<strong>异步编程模型</strong>协程函数。</p><p>硬件验证天然涉及大量并发活动和精确的时间同步。例如，我们需要同时驱动多个 DUT 接口，监测各种信号，等待特定的时钟边沿或事件发生，与参考模型进行交互等。如果使用传统的同步阻塞式编程（即一个函数调用必须等待其完全返回后才能执行下一步），代码会难以表达这种并发性，或者导致仿真效率低下（因为一个等待操作会阻塞所有其他活动）。虽然可以使用回调函数来处理异步事件，但这往往会导致控制流变得碎片化，容易陷入所谓的“回调地狱”，代码难以阅读和维护。</p><h2 id=31-异步函数>3.1 异步函数</h2><p>我们首先需要了解两个 Python 关键字 <code>async</code> 和 <code>await</code>，它们是使用协程的基础。</p><h3 id=async关键字><code>async</code>关键字</h3><p>当我们在函数定义前加上 <code>async</code> 关键字时，这个函数就变成了一个<strong>协程函数（也称“异步函数”，下文统一使用“异步函数”）：</strong></p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>my_coro</span><span style=color:#111>():</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>但是直接调用异步函数（例如 <code>my_coro()</code>）并不会立即执行其内部的代码。相反，它会<strong>立即返回</strong>一个<strong>协程对象</strong>。这个协程对象本质上像是一个“待执行的任务”或“执行计划”，包含了运行协程所需的信息，但它本身并不会自动运行。</p><h3 id=await关键字><code>await</code>关键字</h3><p><code>await</code> 关键字<strong>只能</strong>在 <code>async def</code> 函数内部使用。它的作用是<strong>执行并等待</strong>一个<strong>协程对象</strong>完成。当我们在异步函数内部使用 <code>await</code> 关键字时，就可以执行一个异步函数，并等待其执行完成并返回结果：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#111>asyncio</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>my_coro</span><span style=color:#111>():</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#d88200>&#34;my_coro&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>my_coro2</span><span style=color:#111>():</span>
</span></span><span style=display:flex><span>    <span style=color:#111>result</span> <span style=color:#f92672>=</span> <span style=color:#00a8c8>await</span> <span style=color:#111>my_coro</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#d88200>    等价于：
</span></span></span><span style=display:flex><span><span style=color:#d88200>    coro_obj = my_coro()
</span></span></span><span style=display:flex><span><span style=color:#d88200>    result = await coro_obj
</span></span></span><span style=display:flex><span><span style=color:#d88200>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#111>print</span><span style=color:#111>(</span><span style=color:#111>result</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#00a8c8>if</span> <span style=color:#111>__name__</span> <span style=color:#f92672>==</span> <span style=color:#d88200>&#34;__main__&#34;</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#111>asyncio</span><span style=color:#f92672>.</span><span style=color:#111>run</span><span style=color:#111>(</span><span style=color:#111>my_coro2</span><span style=color:#111>())</span> <span style=color:#75715e># 执行my_coro2()</span>
</span></span></code></pre></div><p>在<strong>顶层的普通（非 <code>async</code>）代码</strong>中，需要使用像 <code>asyncio.run(coro_object)</code> 这样的机制来启动事件循环并执行协程对象。</p><blockquote><p>注意：在后续使用 <code>@toffee_test.testcase</code> 装饰的测试用例中，测试框架会自动处理事件循环的运行，通常无需手动调用 <code>asyncio.run</code>。</p></blockquote><h2 id=32-实现并发>3.2 实现并发</h2><p>使用 <code>async def</code> 定义函数和 <code>await</code> 调用之所以能实现并发（或异步执行）效果，其核心机制在于<strong>事件循环</strong>和<strong>协程机制</strong>。</p><p>工作流程如下：</p><ol><li><p><strong><code>async def</code> 标记可暂停</strong>：<code>async def</code> 标记的函数是一个协程，表明它内部可能包含耗时或需要等待的操作，并且它有能力在这些点<strong>暂停</strong>执行。</p></li><li><p><strong><code>await</code> 触发暂停与执行权让出：</strong><code>await</code> 关键字标志着协程中<strong>发生暂停</strong>的位置。当 <code>await</code> 一个无法立即完成的异步操作时（例如，后台I/O 操作、睡眠等待一定时间（ <code>sleep</code>）或等待像硬件时钟推进这样的事件（ <code>dut.AStep(1)</code>） ），当前协程会在此处暂停，并将执行权交还给事件循环，以便事件循环可以调度执行其他就绪的任务。需要注意的是，并非所有 <code>await</code> 都会导致立即的执行权切换；执行首先会进入被 <code>await</code> 的目标，只有当其内部遇到需要等待的阻塞操作时，才会发生实际的暂停和切换。</p></li><li><p><strong>事件循环接管调度</strong>：事件循环是后台的核心调度器。它回收执行权后，会检查其他协程任务并把已就绪（未处于等待状态）的任务调度到当前线程上运行。</p></li><li><p><strong>切换到其他任务</strong>：事件循环选择一个就绪的协程并执行它。这个机制是模拟硬件并行行为的关键：在硬件仿真中，只有当“时钟推进”事件发生时，仿真时间才会前进，硬件的内部状态也随之更新。在此之前，所有软件操作都被视为在“零时间”内完成，从而可以在单个仿真时刻，为硬件准备好所有并行的输入。</p></li><li><p><strong>事件完成与恢复</strong>：当某个被 <code>await</code> 的异步操作最终完成时（例如时钟周期走完、信号变化），事件循环会收到通知，并将等待该事件的协程标记为可运行。在合适的时机，事件循环会<strong>恢复</strong>该协程的执行，使其从上次暂停的 <code>await</code> 语句之后继续。</p></li></ol><p><strong>总结来说</strong>：<code>async def</code> 定义了可暂停的单元，<code>await</code> 触发暂停和让出。事件循环利用协程让出的时间片运行其他任务，并在等待结束后唤醒原任务。这种基于等待点的快速任务切换，构成了协程实现并发的基础，使得多个任务能在单个线程上交错执行，看起来像在同时进行。</p><p>下面的示意图可以帮助理解这个切换过程：</p><p><img src=/beginner/course/3-toffee/assets/coroutine.png alt></p><p>这张图展示了两个协程（任务 A 和 B）的执行流。从宏观上看，A 和 B 似乎是并行的。在微观上，当 A 需要等待事件时，它通过 <code>await</code> 让出控制权，事件循环（Event Loop）将执行权交给 B。当 B 也遇到等待时，可能又会切换回 A（若 A 的事件已完成）。这种协作式切换是协程并发的核心。</p><p>这种通过 <code>await</code> 实现的并发主要体现在<strong>单个任务流内部</strong>的等待与切换。对于需要启动多个<strong>独立运行、互不直接等待</strong>的后台任务（例如，同时运行多个独立的监测器或激励发生器），Toffee 还提供了其他机制来实现，我们将在后续内容中遇到（例如 <code>toffee.create_task</code> 或 <code>Executor</code>）。</p><h2 id=33-管理-dut-时钟>3.3 管理 DUT 时钟</h2><p>在传统的 Verilog 仿真或仅使用 Picker 的环境中，我们通过调用 <code>dut.Step()</code> 方法来手动推进时钟周期并更新 DUT 状态。然而，在需要精确控制等待特定时钟周期数或等待特定事件发生的异步验证场景中，仅仅依赖手动 <code>Step()</code> 是不够灵活的。我们需要一种机制来自动、持续地驱动时钟，同时允许我们的测试逻辑通过 <code>await</code> 来等待时间流逝。</p><p>Toffee 提供了 <code>toffee.start_clock(dut)</code> 函数来解决这个问题。当你调用 <code>start_clock(dut)</code> 时（通常在测试环境初始化阶段，如 Fixture 中），Toffee 会在后台启动一个专门负责驱动 <code>dut</code> 时钟信号（需要预先通过 <code>create_dut</code> 或 <code>InitClock</code> 指定时钟引脚）的任务。这个任务会根据仿真时间步进持续地翻转时钟信号，从而驱动整个设计的时序前进。</p><blockquote><p><code>start_clock</code> <strong>关键点</strong></p><ul><li>只能在<strong>异步函数</strong>里调用。</li><li>波形会<strong>额外多一个周期</strong>的结果，这个是为了后文提到的**监测方法（Monitor method）**刻意为之的。</li></ul></blockquote><p>引入 <code>start_clock</code> 管理时钟和异步等待方法后的代码示例如下：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>RandomGenerator</span> <span style=color:#f92672>import</span> <span style=color:#111>DUTRandomGenerator</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#111>random</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#111>toffee</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#111>toffee_test</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>LFSR_16</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#111>__init__</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>seed</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>state</span> <span style=color:#f92672>=</span> <span style=color:#111>seed</span> <span style=color:#f92672>&amp;</span> <span style=color:#111>((</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>16</span><span style=color:#111>)</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>Step</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>new_bit</span> <span style=color:#f92672>=</span> <span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>state</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>15</span><span style=color:#111>)</span> <span style=color:#f92672>^</span> <span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>state</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>14</span><span style=color:#111>)</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>state</span> <span style=color:#f92672>=</span> <span style=color:#111>((</span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>state</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span><span style=color:#111>)</span> <span style=color:#f92672>|</span> <span style=color:#111>new_bit</span><span style=color:#111>)</span> <span style=color:#f92672>&amp;</span> <span style=color:#111>((</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>16</span><span style=color:#111>)</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75af00>@toffee_test.testcase</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>test_with_ref</span><span style=color:#111>(</span><span style=color:#111>dut</span><span style=color:#111>:</span> <span style=color:#111>DUTRandomGenerator</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#111>seed</span> <span style=color:#f92672>=</span> <span style=color:#111>random</span><span style=color:#f92672>.</span><span style=color:#111>randint</span><span style=color:#111>(</span><span style=color:#ae81ff>0</span><span style=color:#111>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>**</span><span style=color:#ae81ff>16</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>seed</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#111>seed</span>
</span></span><span style=display:flex><span>    <span style=color:#111>ref</span> <span style=color:#f92672>=</span> <span style=color:#111>LFSR_16</span><span style=color:#111>(</span><span style=color:#111>seed</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>reset</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>await</span> <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>AStep</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span>  <span style=color:#75715e># 等待时钟经过一个周期</span>
</span></span><span style=display:flex><span>    <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>reset</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>await</span> <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>AStep</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span>  <span style=color:#75715e># 更新DUT状态</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#ae81ff>65536</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>await</span> <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>AStep</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#111>ref</span><span style=color:#f92672>.</span><span style=color:#111>Step</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>assert</span> <span style=color:#111>dut</span><span style=color:#f92672>.</span><span style=color:#111>random_number</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>==</span> <span style=color:#111>ref</span><span style=color:#f92672>.</span><span style=color:#111>state</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;Mismatch&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75af00>@toffee_test.fixture</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>dut</span><span style=color:#111>(</span><span style=color:#111>toffee_request</span><span style=color:#111>:</span> <span style=color:#111>toffee_test</span><span style=color:#f92672>.</span><span style=color:#111>ToffeeRequest</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#111>rand_dut</span> <span style=color:#f92672>=</span> <span style=color:#111>toffee_request</span><span style=color:#f92672>.</span><span style=color:#111>create_dut</span><span style=color:#111>(</span><span style=color:#111>DUTRandomGenerator</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;clk&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#111>toffee</span><span style=color:#f92672>.</span><span style=color:#111>start_clock</span><span style=color:#111>(</span><span style=color:#111>rand_dut</span><span style=color:#111>)</span>  <span style=color:#75715e># 让toffee驱动时钟，只能在异步函数中调用</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#111>rand_dut</span>
</span></span></code></pre></div><p>通过 <code>start_clock</code> 和 <code>await AStep()</code> 的配合，我们实现了测试逻辑与时钟推进的解耦，使得编写基于时间的异步验证序列更加自然和清晰。</p><h2 id=34-其他的异步等待方法>3.4 其他的异步等待方法</h2><p>除了 DUT 类提供的异步等待方法，toffee 也提供了一些实用方法，例如：</p><ul><li><p><code>AllValid</code>：等待传入的所有接口均为高电平</p></li><li><p><code>Change</code>：等待引脚信号发生改变</p></li><li><p><code>Condition</code>：等待条件为真</p></li><li><p><code>Value</code>：等待引脚信号变为指定的值</p></li><li><p>……</p></li></ul><p>完整的内容请查看 API 文档关于<a href=https://pytoffee.readthedocs.io/zh-cn/latest/api/toffee.html#module-toffee.triggers> toffee.triggers.module </a>的内容。</p><h2 id=练习>练习</h2><p>本节的练习已经发布，请查阅<a href=/beginner/task/toffee/>【学习任务2: Toffee 部分】 1. 用 toffee-test 管理测试用例</a>。</p><blockquote><p>⚠️关于练习</p><p>本讲的内容比较多，可以在阅读文字教程的时候，每完成一部分的阅读就上手做一下练习~</p></blockquote><hr><h1 id=4-使用-bundle-封装端口>4. 使用 Bundle 封装端口</h1><blockquote><p>以下内容来自：<a href=https://pytoffee.readthedocs.io/zh-cn/latest/env/bundle.html>如何使用 Bundle</a></p></blockquote><p>在复杂的芯片设计中，DUT 可能包含大量的输入输出端口。为了有效地管理这些端口并与验证环境的其他部分交互，我们需要一种封装机制。</p><p><code>Bundle</code> 在 Toffee 验证环境中扮演着关键角色。它主要用于：</p><ol><li><p><strong>接口封装与抽象：</strong> 将 DUT 的一组相关端口（例如，一个总线接口的所有信号）封装在一起，形成一个逻辑单元。</p></li><li><p><strong>解耦 Agent 与 DUT：</strong> 作为 <code>Agent</code> （下一节将介绍） 与 DUT 交互的中间层，<code>Bundle</code> 使得 <code>Agent</code> 的编写可以独立于 DUT 具体的端口名称和层次结构，提高了验证组件的可重用性。</p></li><li><p><strong>结构化访问：</strong> 对 DUT 接口进行层次化划分，使访问特定端口更加清晰和方便。</p></li></ol><h2 id=41-一个简单的-bundle-的定义>4.1 一个简单的 Bundle 的定义</h2><p>要定义一个 <code>Bundle</code>，需要自定义一个新类，并继承 toffee 中的 <code>Bundle</code> 类。下面是一个简单加法器接口的 <code>Bundle</code> 定义示例：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>toffee</span> <span style=color:#f92672>import</span> <span style=color:#111>Bundle</span><span style=color:#111>,</span> <span style=color:#111>Signals</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>AdderBundle</span><span style=color:#111>(</span><span style=color:#111>Bundle</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Signals(N) 一次性定义 N 个同名信号，常用于定义一组信号</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 这里我们定义了 5 个信号：a, b, sum, cin, cout</span>
</span></span><span style=display:flex><span>    <span style=color:#111>a</span><span style=color:#111>,</span> <span style=color:#111>b</span><span style=color:#111>,</span> <span style=color:#111>sum</span><span style=color:#111>,</span> <span style=color:#111>cin</span><span style=color:#111>,</span> <span style=color:#111>cout</span> <span style=color:#f92672>=</span> <span style=color:#111>Signals</span><span style=color:#111>(</span><span style=color:#ae81ff>5</span><span style=color:#111>)</span>
</span></span></code></pre></div><p>在这个 <code>AdderBundle</code> 类中，我们定义了五个信号：<code>a</code>、<code>b</code>、<code>sum</code>、<code>cin</code> 和 <code>cout</code>。这些信号逻辑上对应加法器的两个输入 （<code>a</code>， <code>b</code>）、和输出 （<code>sum</code>）、进位输入 （<code>cin</code>） 和进位输出 （<code>cout</code>）。</p><p>定义完成后，可以实例化 <code>AdderBundle</code> 并访问其包含的信号：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>bundle.adder_bundle</span> <span style=color:#f92672>import</span> <span style=color:#111>AdderBundle</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 实例化 Bundle</span>
</span></span><span style=display:flex><span><span style=color:#111>adder_bundle</span> <span style=color:#f92672>=</span> <span style=color:#111>AdderBundle</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 通过 &#39;.&#39; 运算符访问并赋值信号的 value 属性</span>
</span></span><span style=display:flex><span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>a</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>b</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>cin</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 等待时钟推进一个周期，更新引脚信号</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>await</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>step</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 读取信号值</span>
</span></span><span style=display:flex><span><span style=color:#111>print</span><span style=color:#111>(</span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>sum</span><span style=color:#f92672>.</span><span style=color:#111>value</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span><span style=color:#111>print</span><span style=color:#111>(</span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>cout</span><span style=color:#f92672>.</span><span style=color:#111>value</span><span style=color:#111>)</span>
</span></span></code></pre></div><blockquote><p>⚠️警告：<font color=red><strong>不推荐</strong>重写 Bundle 的构造方法 </font>，除非你对 Bundle 的代码实现非常熟悉！</p></blockquote><h2 id=42-将-dut-绑定到-bundle>4.2 将 DUT 绑定到 Bundle</h2><p>仅仅创建 <code>Bundle</code> 实例并对其进行操作，还无法影响到实际的硬件设计 （DUT）。我们需要将 <code>Bundle</code> 与 DUT 的端口进行“绑定”，建立连接。</p><p><code>bind</code> 方法用于将 <code>Bundle</code> 实例与一个 DUT 对象进行绑定。假设我们有一个名为 <code>DUTAdder</code> 的加法器 DUT 类实例 <code>adder</code>，其端口名称恰好与 <code>AdderBundle</code> 中定义的信号名称相同：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 假设 DUTAdder 是代表加法器硬件设计的类</span>
</span></span><span style=display:flex><span><span style=color:#75715e># adder = DUTAdder()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#111>adder_bundle</span> <span style=color:#f92672>=</span> <span style=color:#111>AdderBundle</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将 adder_bundle 绑定到 adder 这个 DUT 实例</span>
</span></span><span style=display:flex><span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>bind</span><span style=color:#111>(</span><span style=color:#111>adder</span><span style=color:#111>)</span>
</span></span></code></pre></div><p>执行 <code>bind(adder)</code> 后，Toffee 会自动查找 <code>adder</code> 对象中与 <code>adder_bundle</code> 内定义的信号名称相同的端口，并将它们连接起来。此后，对 <code>adder_bundle.a</code> 的赋值操作就会实际驱动 <code>adder</code> 上的 <code>a</code> 端口。</p><h2 id=43-处理端口名称不匹配的情况>4.3 处理端口名称不匹配的情况</h2><p>在实际项目中，DUT 的端口命名往往与我们在 <code>Bundle</code> 中定义的理想名称不同。例如，DUT 可能遵循特定的命名规范，如添加前缀、后缀或使用不同的命名风格。<code>Bundle</code> 提供了多种灵活的绑定策略来处理这种情况。</p><blockquote><p><strong>注意：</strong> 以下的 <code>from_prefix</code>， <code>from_regex</code>， <code>from_dict</code> 都是 <strong>类方法 （Class Methods）</strong>，它们用于在调用 <code>bind</code> <strong>之前</strong> 创建 <code>Bundle</code> 实例，并配置好该实例后续绑定时应遵循的名称匹配规则</p></blockquote><h3 id=通过前缀进行绑定>通过前缀进行绑定</h3><p>假设 DUT 端口名相比 <code>Bundle</code> 信号名，都增加了一个 <code>io_</code> 前缀：</p><pre tabindex=0><code class="language-plain text" data-lang="plain text">(Bundle -&gt; DUT)
a       -&gt; io_a
b       -&gt; io_b
sum     -&gt; io_sum
cin     -&gt; io_cin
cout    -&gt; io_cout
</code></pre><p>我们可以使用 <code>from_prefix</code> 方法创建 <code>Bundle</code> 实例，并告知它在绑定时需要匹配带有 <code>io_</code> 前缀的 DUT 端口：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 创建 DUT</span>
</span></span><span style=display:flex><span><span style=color:#111>adder</span> <span style=color:#f92672>=</span> <span style=color:#111>DUTAdder</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 创建 Bundle 实例时指定前缀匹配规则</span>
</span></span><span style=display:flex><span><span style=color:#111>adder_bundle</span> <span style=color:#f92672>=</span> <span style=color:#111>AdderBundle</span><span style=color:#f92672>.</span><span style=color:#111>from_prefix</span><span style=color:#111>(</span><span style=color:#d88200>&#39;io_&#39;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 进行绑定，此时会自动寻找 DUT 上 io_a, io_b 等端口</span>
</span></span><span style=display:flex><span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>bind</span><span style=color:#111>(</span><span style=color:#111>adder</span><span style=color:#111>)</span>
</span></span></code></pre></div><h3 id=通过正则表达式进行绑定>通过正则表达式进行绑定</h3><p>有时，名称对应关系更复杂，例如包含方向信息：</p><pre tabindex=0><code class="language-plain text" data-lang="plain text">(Bundle -&gt; DUT)
a       -&gt; io_a_in
b       -&gt; io_b_in
sum     -&gt; io_sum_out
cin     -&gt; io_cin_in
cout    -&gt; io_cout_out
</code></pre><p>这种情况下，可以使用正则表达式来提取 <code>Bundle</code> 中定义的原始名称。通过 <code>from_regex</code> 方法创建 <code>Bundle</code>，并提供一个包含捕获组的正则表达式：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>adder</span> <span style=color:#f92672>=</span> <span style=color:#111>DUTAdder</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 正则表达式 r&#39;io_(.*)_.*&#39; 会捕获下划线之间的部分</span>
</span></span><span style=display:flex><span><span style=color:#111>adder_bundle</span> <span style=color:#f92672>=</span> <span style=color:#111>AdderBundle</span><span style=color:#f92672>.</span><span style=color:#111>from_regex</span><span style=color:#111>(</span><span style=color:#d88200>r</span><span style=color:#d88200>&#39;io_(.*)_.*&#39;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>bind</span><span style=color:#111>(</span><span style=color:#111>adder</span><span style=color:#111>)</span>
</span></span></code></pre></div><p>绑定时，Toffee 会：</p><ol><li><p>尝试用正则表达式 <code>r'io_(.*)_.*'</code> 匹配 DUT 的每个端口名。</p></li><li><p>如果匹配成功（例如 <code>io_a_in</code>），提取正则表达式中所有捕获组的内容（这里是 <code>a</code>）。</p></li><li><p>将捕获到的内容（<code>a</code>）与 <code>Bundle</code> 中定义的信号名进行匹配。</p></li><li><p>如果匹配成功，则将 DUT 端口 <code>io_a_in</code> 绑定到 <code>Bundle</code> 信号 <code>a</code>。</p></li></ol><h3 id=通过字典进行绑定>通过字典进行绑定</h3><p>最直接的方式是提供一个明确的映射字典，指定 <code>Bundle</code> 信号名到 DUT 端口名的精确对应关系：</p><pre tabindex=0><code class="language-plain text" data-lang="plain text">(Bundle -&gt; DUT)
a       -&gt; a_in
b       -&gt; b_in
sum     -&gt; sum_out
cin     -&gt; cin_in
cout    -&gt; cout_out
</code></pre><p>使用 <code>from_dict</code> 方法创建 <code>Bundle</code>，并传入映射字典：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>adder</span> <span style=color:#f92672>=</span> <span style=color:#111>DUTAdder</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span><span style=color:#111>adder_bundle</span> <span style=color:#f92672>=</span> <span style=color:#111>AdderBundle</span><span style=color:#f92672>.</span><span style=color:#111>from_dict</span><span style=color:#111>({</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;a&#39;</span><span style=color:#111>:</span> <span style=color:#d88200>&#39;a_in&#39;</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;b&#39;</span><span style=color:#111>:</span> <span style=color:#d88200>&#39;b_in&#39;</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;sum&#39;</span><span style=color:#111>:</span> <span style=color:#d88200>&#39;sum_out&#39;</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;cin&#39;</span><span style=color:#111>:</span> <span style=color:#d88200>&#39;cin_in&#39;</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;cout&#39;</span><span style=color:#111>:</span> <span style=color:#d88200>&#39;cout_out&#39;</span>
</span></span><span style=display:flex><span><span style=color:#111>})</span>
</span></span><span style=display:flex><span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>bind</span><span style=color:#111>(</span><span style=color:#111>adder</span><span style=color:#111>)</span>
</span></span></code></pre></div><p><code>bind</code> 时将严格按照字典查找对应的 DUT 端口进行绑定。</p><h2 id=44-创建子-bundle>4.4 创建子 Bundle</h2><p>复杂的接口通常可以分解为若干子接口。<code>Bundle</code> 支持嵌套，允许将一个 <code>Bundle</code> 定义为另一个 <code>Bundle</code> 的成员（子 Bundle），从而构建层次化的接口描述。</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>toffee</span> <span style=color:#f92672>import</span> <span style=color:#111>Bundle</span><span style=color:#111>,</span> <span style=color:#111>Signal</span><span style=color:#111>,</span> <span style=color:#111>Signals</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>AdderBundle</span><span style=color:#111>(</span><span style=color:#111>Bundle</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#111>a</span><span style=color:#111>,</span> <span style=color:#111>b</span><span style=color:#111>,</span> <span style=color:#111>sum</span><span style=color:#111>,</span> <span style=color:#111>cin</span><span style=color:#111>,</span> <span style=color:#111>cout</span> <span style=color:#f92672>=</span> <span style=color:#111>Signals</span><span style=color:#111>(</span><span style=color:#ae81ff>5</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>MultiplierBundle</span><span style=color:#111>(</span><span style=color:#111>Bundle</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#111>a</span><span style=color:#111>,</span> <span style=color:#111>b</span><span style=color:#111>,</span> <span style=color:#111>product</span> <span style=color:#f92672>=</span> <span style=color:#111>Signals</span><span style=color:#111>(</span><span style=color:#ae81ff>3</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>ArithmeticBundle</span><span style=color:#111>(</span><span style=color:#111>Bundle</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 自身包含的信号</span>
</span></span><span style=display:flex><span>    <span style=color:#111>selector</span> <span style=color:#f92672>=</span> <span style=color:#111>Signal</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 将 AdderBundle 作为子 Bundle，命名为 adder</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 并指定其绑定时需要匹配以 &#39;add_&#39; 为前缀的 DUT 端口</span>
</span></span><span style=display:flex><span>    <span style=color:#111>adder</span> <span style=color:#f92672>=</span> <span style=color:#111>AdderBundle</span><span style=color:#f92672>.</span><span style=color:#111>from_prefix</span><span style=color:#111>(</span><span style=color:#d88200>&#39;add_&#39;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 将 MultiplierBundle 作为子 Bundle，命名为 multiplier</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 并指定其绑定时需要匹配以 &#39;mul_&#39; 为前缀的 DUT 端口</span>
</span></span><span style=display:flex><span>    <span style=color:#111>multiplier</span> <span style=color:#f92672>=</span> <span style=color:#111>MultiplierBundle</span><span style=color:#f92672>.</span><span style=color:#111>from_prefix</span><span style=color:#111>(</span><span style=color:#d88200>&#39;mul_&#39;</span><span style=color:#111>)</span>
</span></span></code></pre></div><p>在 <code>ArithmeticBundle</code> 中，我们定义了一个选择器信号 <code>selector</code>，并包含了 <code>AdderBundle</code> 和 <code>MultiplierBundle</code> 的实例，分别命名为 <code>adder</code> 和 <code>multiplier</code>。访问子 <code>Bundle</code> 中的信号使用 <code>.</code> 运算符：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>arithmetic_bundle</span> <span style=color:#f92672>=</span> <span style=color:#111>ArithmeticBundle</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#111>arithmetic_bundle</span><span style=color:#f92672>.</span><span style=color:#111>selector</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#111>arithmetic_bundle</span><span style=color:#f92672>.</span><span style=color:#111>adder</span><span style=color:#f92672>.</span><span style=color:#111>a</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>       <span style=color:#75715e># 访问子 Bundle adder 的信号 a</span>
</span></span><span style=display:flex><span><span style=color:#111>arithmetic_bundle</span><span style=color:#f92672>.</span><span style=color:#111>adder</span><span style=color:#f92672>.</span><span style=color:#111>b</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#111>arithmetic_bundle</span><span style=color:#f92672>.</span><span style=color:#111>multiplier</span><span style=color:#f92672>.</span><span style=color:#111>a</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>  <span style=color:#75715e># 访问子 Bundle multiplier 的信号 a</span>
</span></span><span style=display:flex><span><span style=color:#111>arithmetic_bundle</span><span style=color:#f92672>.</span><span style=color:#111>multiplier</span><span style=color:#f92672>.</span><span style=color:#111>b</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</span></span></code></pre></div><p><strong>绑定行为：</strong> 当对顶层 <code>Bundle</code> （<code>ArithmeticBundle</code>） 进行 <code>bind</code> 操作时，其包含的子 <code>Bundle</code> 也会被递归地绑定到 DUT 上。子 <code>Bundle</code> 的名称匹配规则（如 <code>from_prefix('add_')</code>）会作用于经过父 <code>Bundle</code> 匹配规则处理后的名称空间。</p><p>例如，如果 <code>ArithmeticBundle</code> 本身是这样创建的：<code>ArithmeticBundle.from_prefix('io_')</code>，并且 DUT 上有一个端口叫 <code>io_add_a</code>：</p><ol><li><p>顶层 <code>ArithmeticBundle</code> 的 <code>from_prefix('io_')</code> 规则会将 <code>io_add_a</code> 暂时映射为 <code>add_a</code>。</p></li><li><p>然后，子 <code>Bundle</code> <code>adder</code> 的 <code>from_prefix('add_')</code> 规则会作用于 <code>add_a</code>，将其映射为 <code>a</code>。</p></li><li><p>最终，DUT 端口 <code>io_add_a</code> 会被绑定到 <code>arithmetic_bundle.adder.a</code>。</p></li></ol><p>字典和正则表达式匹配方式同样会将它们处理（映射或捕获）后的名称传递给子 Bundle 进行进一步匹配。</p><h2 id=45-bundle-中的实用操作节选>4.5 Bundle 中的实用操作（节选）</h2><h3 id=信号访问与赋值>信号访问与赋值</h3><p><strong>访问信号值</strong></p><p>除了 <code>.</code> 运算符，也可以用 <code>[]</code> 运算符通过字符串名称访问信号：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>adder_bundle</span> <span style=color:#f92672>=</span> <span style=color:#111>AdderBundle</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span><span style=color:#111>adder_bundle</span><span style=color:#111>[</span><span style=color:#d88200>&#39;a&#39;</span><span style=color:#111>]</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p><strong>同时赋值所有信号</strong></p><p>可以通过 <code>set_all</code> 方法同时将所有输入信号更改为某个值。</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>set_all</span><span style=color:#111>(</span><span style=color:#ae81ff>0</span><span style=color:#111>)</span>
</span></span></code></pre></div><p><strong>信号赋值模式更改</strong></p><p>Bundle 中支持通过 <code>set_write_mode</code> 来改变整个 Bundle 的赋值模式。</p><p>同时，Bundle 提供了设置的快捷方法：<code>set_write_mode_as_imme</code>， <code>set_write_mode_as_rise</code> 与 <code>set_write_mode_as_fall</code>，分别用于设置 Bundle 的赋值模式为立即赋值、上升沿赋值与下降沿赋值。</p><p>Bundle 默认的信号赋值模式为<strong>上升沿写模式（Rise）。</strong></p><h3 id=消息支持字典操作>消息支持（字典操作）</h3><p><strong>默认消息类型赋值（</strong><code>assign</code><strong>）</strong></p><p>可以通过 <code>assign</code> 方法用字典快速地为 <code>Bundle</code> 中的多个信号赋值：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>assign</span><span style=color:#111>({</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;a&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>1</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;b&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>2</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;cin&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#111>})</span>
</span></span></code></pre></div><p>使用 <code>'*'</code> 可以为字典中未明确指定的信号设置默认值：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>assign</span><span style=color:#111>({</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;*&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;a&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>1</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span><span style=color:#111>})</span>
</span></span></code></pre></div><p><strong>子 Bundle 的默认消息赋值支持</strong></p><p>当 <code>assign</code> 的 <code>multilevel=True</code> 时，可以使用嵌套字典赋值：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>arithmetic_bundle</span><span style=color:#f92672>.</span><span style=color:#111>assign</span><span style=color:#111>({</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;selector&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>1</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;adder&#39;</span><span style=color:#111>:</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#39;*&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#39;cin&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#111>},</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;multiplier&#39;</span><span style=color:#111>:</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#39;a&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>3</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#39;b&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span><span style=color:#111>},</span> <span style=color:#111>multilevel</span><span style=color:#f92672>=</span><span style=color:#00a8c8>True</span><span style=color:#111>)</span>
</span></span></code></pre></div><p>当 <code>multilevel=False</code> （默认） 时，使用 <code>.</code> 符号指定子 Bundle 信号：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>arithmetic_bundle</span><span style=color:#f92672>.</span><span style=color:#111>assign</span><span style=color:#111>({</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;*&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;selector&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>1</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;adder.cin&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;multiplier.a&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>3</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;multiplier.b&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#111>},</span> <span style=color:#111>multilevel</span><span style=color:#f92672>=</span><span style=color:#00a8c8>False</span><span style=color:#111>)</span>
</span></span></code></pre></div><p><strong>默认消息类型读取</strong></p><p><code>as_dict</code> 方法会将 <code>Bundle</code> 当前的信号值转换为字典。同样支持 <code>multilevel</code> 参数控制输出格式（嵌套字典或扁平字典）：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;</span> <span style=color:#111>arithmetic_bundle</span><span style=color:#f92672>.</span><span style=color:#111>as_dict</span><span style=color:#111>(</span><span style=color:#111>multilevel</span><span style=color:#f92672>=</span><span style=color:#00a8c8>True</span><span style=color:#111>)</span> <span style=color:#75715e># 输出嵌套字典</span>
</span></span><span style=display:flex><span><span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;selector&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>1</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;adder&#39;</span><span style=color:#111>:</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#39;a&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#39;b&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#39;sum&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#39;cin&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#39;cout&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#111>},</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;multiplier&#39;</span><span style=color:#111>:</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#39;a&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#39;b&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#39;product&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#111>}</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;</span> <span style=color:#111>arithmetic_bundle</span><span style=color:#f92672>.</span><span style=color:#111>as_dict</span><span style=color:#111>(</span><span style=color:#111>multilevel</span><span style=color:#f92672>=</span><span style=color:#00a8c8>False</span><span style=color:#111>)</span> <span style=color:#75715e># 输出扁平字</span>
</span></span><span style=display:flex><span><span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;selector&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>1</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;adder.a&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;adder.b&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;adder.sum&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;adder.cin&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;adder.cout&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;multiplier.a&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;multiplier.b&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span><span style=color:#111>,</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#39;multiplier.product&#39;</span><span style=color:#111>:</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><p><strong>自定义消息类型</strong></p><p>如果你有自定义的数据结构 （类） 想用于与 <code>Bundle</code> 交互：</p><ul><li><p><strong>赋值给 Bundle</strong>：</p><ol><li><p>在自定义类中实现 <code>as_dict()</code> 方法，返回一个字典，然后用 <code>bundle.assign(my_message.as_dict())</code></p></li><li><p>在自定义类中实现 <code>bundle_assign(self, bundle)</code> 方法，直接在该方法内完成对 <code>bundle</code> 信号的赋值。然后可以直接调用 <code>bundle.assign(my_message)</code>，Toffee 会自动调用 <code>bundle_assign</code>。</p></li></ol></li></ul><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>MyMessage</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#111>__init__</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>a</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>b</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>cin</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>__bundle_assign__</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>bundle</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>a</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>a</span>
</span></span><span style=display:flex><span>        <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>b</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>b</span>
</span></span><span style=display:flex><span>        <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>cin</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>cin</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#111>my_message</span> <span style=color:#f92672>=</span> <span style=color:#111>MyMessage</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>assign</span><span style=color:#111>(</span><span style=color:#111>my_message</span><span style=color:#111>)</span>
</span></span></code></pre></div><ul><li><strong>从 Bundle 读取值：</strong> 当需要将 Bundle 中的信号值转换为自定义消息结构时，可以在自定义类中实现一个类方法 <code>from_bundle(cls, bundle)</code>，用于从 <code>bundle</code> 读取信号值并创建该类的实例。</li></ul><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>MyMessage</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#111>__init__</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>a</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>b</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>cin</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75af00>@classmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>from_bundle</span><span style=color:#111>(</span><span style=color:#111>cls</span><span style=color:#111>,</span> <span style=color:#111>bundle</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>message</span> <span style=color:#f92672>=</span> <span style=color:#111>cls</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#111>message</span><span style=color:#f92672>.</span><span style=color:#111>a</span> <span style=color:#f92672>=</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>a</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>        <span style=color:#111>message</span><span style=color:#f92672>.</span><span style=color:#111>b</span> <span style=color:#f92672>=</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>b</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>        <span style=color:#111>message</span><span style=color:#f92672>.</span><span style=color:#111>cin</span> <span style=color:#f92672>=</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>cin</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>return</span> <span style=color:#111>message</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#111>my_message</span> <span style=color:#f92672>=</span> <span style=color:#111>MyMessage</span><span style=color:#f92672>.</span><span style=color:#111>from_bundle</span><span style=color:#111>(</span><span style=color:#111>adder_bundle</span><span style=color:#111>)</span>
</span></span></code></pre></div><h3 id=异步支持>异步支持</h3><p>在 Bundle 中，为了方便的接收时钟信息，提供了 <code>step</code> 函数。当 Bundle 连接至 DUT 的任意一个信号时，step 函数会自动同步至 DUT 的时钟信号。</p><p>可以通过 <code>step</code> 函数来完成时钟周期的等待。</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>adder_process</span><span style=color:#111>(</span><span style=color:#111>adder_bundle</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>a</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>b</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>cin</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>await</span> <span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>step</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>    <span style=color:#111>print</span><span style=color:#111>(</span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>sum</span><span style=color:#f92672>.</span><span style=color:#111>value</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>print</span><span style=color:#111>(</span><span style=color:#111>adder_bundle</span><span style=color:#f92672>.</span><span style=color:#111>cout</span><span style=color:#f92672>.</span><span style=color:#111>value</span><span style=color:#111>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>SomeExample</span><span style=color:#111>(</span><span style=color:#111>Bundle</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>operation</span><span style=color:#111>(</span><span style=color:#111>value</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>await</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>step</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span></code></pre></div><h2 id=46-小结>4.6 小结</h2><p><code>Bundle</code> 是 Toffee 中与 DUT 端口交互的基础。它提供了强大的封装、绑定和操作功能。熟练使用 <code>Bundle</code> 是构建健壮验证环境的第一步。更详细的功能请参考 Toffee 官方文档。</p><h2 id=47-练习>4.7 练习</h2><p>本节的练习已经发布，请查阅<a href=/beginner/task/toffee/>【学习任务2: Toffee 部分】 2. 使用 Bundle 封装 DUT</a>。</p><hr><h1 id=5-使用-agent-进一步封装>5. 使用 Agent 进一步封装</h1><p><code>Bundle</code> 解决了与 DUT 端口信号层面的交互问题，但直接在测试用例中操作 <code>Bundle</code> 信号仍然比较底层。<code>Agent</code> 在 Toffee 中提供了一个更高层次的抽象，它通常封装一个或多个 <code>Bundle</code>，并定义与这些接口相关的 <strong>事务级 （Transaction-Level）</strong> 操作。</p><p><code>Agent</code> 的主要目标是：</p><ul><li><p><strong>抽象操作：</strong> 将底层的信号操作（如握手协议）封装成有意义的事务（如 <code>read_transaction</code>， <code>write_data</code>）。</p></li><li><p><strong>驱动与监测分离：</strong> 清晰地划分主动发起操作（驱动）和被动观察行为（监测）的逻辑。</p></li><li><p><strong>简化测试用例：</strong> 使顶层验证代码更关注于测试场景和数据，而不是具体的信号时序。</p></li></ul><p>通过 Agent 封装为函数之后，上层只需关注如何调用函数。</p><p>一个 <code>Agent</code> 通常由两类核心方法组成：</p><ol><li><p><strong>驱动方法 （Driver Method）：</strong>主动向 DUT 发起操作，通过控制 <code>Bundle</code> 信号实现。通常带有参数（输入数据/配置）和返回值（操作结果/读取的数据）。</p></li><li><p><strong>监测方法 （Monitor Method）：</strong>被动地观察 <code>Bundle</code> 信号，当满足特定条件时，捕获接口上的活动或状态，并可能生成表示该活动的事务对象或数据。</p></li></ol><h2 id=51-初始化-agent>5.1 初始化 Agent</h2><p>定义 <code>Agent</code> 需要创建一个继承自 Toffee <code>Agent</code> 基类的新类：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>toffee</span> <span style=color:#f92672>import</span> <span style=color:#111>Agent</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>AdderAgent</span><span style=color:#111>(</span><span style=color:#111>Agent</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>在 <code>AdderAgent</code> 类初始化时，需要外界传入该 Agent 需要驱动的 Bundle，例如：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>adder_agent</span> <span style=color:#f92672>=</span> <span style=color:#111>AdderAgent</span><span style=color:#111>(</span><span style=color:#111>adder_bundle</span><span style=color:#111>)</span>
</span></span></code></pre></div><p>如果一个 <code>Agent</code> 需要操作多个 <code>Bundle</code> （例如 FIFO 的读写接口），可以重写构造函数，接收多个 <code>Bundle</code>，但需要将其中一个传递给 <code>super().__init__</code>中，因为这个 <code>Bundle</code> 主要用于让 <code>Agent</code> 能够使用 <code>step()</code> 方法与仿真时钟同步。</p><p>以先前练习的 SyncFIFO 为例：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>toffee.agent</span> <span style=color:#f92672>import</span> <span style=color:#111>Agent</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>FIFOAgent</span><span style=color:#111>(</span><span style=color:#111>Agent</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#111>__init__</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>read_bundle</span><span style=color:#111>,</span> <span style=color:#111>write_bundle</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 将 read_bundle 传给父类以获取时钟</span>
</span></span><span style=display:flex><span>        <span style=color:#111>super</span><span style=color:#111>()</span><span style=color:#f92672>.</span><span style=color:#111>__init__</span><span style=color:#111>(</span><span style=color:#111>read_bundle</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 保存两个 Bundle 实例</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>read</span> <span style=color:#f92672>=</span> <span style=color:#111>read_bundle</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>write</span> <span style=color:#f92672>=</span> <span style=color:#111>write_bundle</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></div><h2 id=52-创建驱动方法>5.2 创建驱动方法</h2><p>驱动方法是 <code>Agent</code> 中用于主动执行操作的异步函数 （<code>async def</code>）。它负责解析输入参数，按照特定时序操作 <code>Bundle</code> 信号，并可能返回操作结果。</p><ul><li><p>必须使用 <code>@driver_method()</code> 装饰器标记。</p></li><li><p>通过 <code>self.bundle</code> （或保存的其他 Bundle 成员） 访问和操作信号。</p></li><li><p>访问信号、控制时钟等操作使用内部定义的成员变量</p><ul><li><p>访问信号用内部定义的 Bundle。</p></li><li><p>等待时钟周期可以用 <code>await self.bundle.step()</code> （或 <code>await self.monitor_step()</code>）。</p></li></ul></li><li><p>可以通过 <code>return</code> 语句返回操作结果。</p></li></ul><p>下面是 <code>AdderAgent</code> 的一个简单驱动方法示例：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>toffee.agent</span> <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>AdderAgent</span><span style=color:#111>(</span><span style=color:#111>Agent</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#75af00>@driver_method</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>exec_add</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>a</span><span style=color:#111>,</span> <span style=color:#111>b</span><span style=color:#111>,</span> <span style=color:#111>cin</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#34;&#34;&#34;执行一次加法操作&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>a</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#111>a</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>b</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#111>b</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>cin</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#111>cin</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 等待一个时钟周期</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>await</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>monitor_step</span><span style=color:#111>()</span> <span style=color:#75715e># 等价 self.bundle.step()</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 读取并返回结果</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>return</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>sum</span><span style=color:#f92672>.</span><span style=color:#111>value</span><span style=color:#111>,</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>cout</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span></code></pre></div><p>在验证代码中，可以像调用普通异步函数一样调用驱动方法：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>adder_bundle</span> <span style=color:#f92672>=</span> <span style=color:#111>AdderBundle</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span><span style=color:#111>adder_agent</span> <span style=color:#f92672>=</span> <span style=color:#111>AdderAgent</span><span style=color:#111>(</span><span style=color:#111>adder_bundle</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span><span style=color:#111>sum</span><span style=color:#111>,</span> <span style=color:#111>cout</span> <span style=color:#f92672>=</span> <span style=color:#00a8c8>await</span> <span style=color:#111>adder_agent</span><span style=color:#f92672>.</span><span style=color:#111>exec_add</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span> <span style=color:#ae81ff>2</span><span style=color:#111>,</span> <span style=color:#ae81ff>0</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span><span style=color:#111>print</span><span style=color:#111>(</span><span style=color:#111>sum</span><span style=color:#111>,</span> <span style=color:#111>cout</span><span style=color:#111>)</span>
</span></span></code></pre></div><blockquote><p><strong>提示：</strong> 使用 <code>@driver_method</code> 装饰器标记的方法，除了执行我们定义的逻辑外，Toffee 框架还会自动进行一些额外处理，例如与参考模型 （Reference Model） 的交互和结果比对（这部分内容将在后续章节介绍）。</p></blockquote><h2 id=53-创建监测方法>5.3 创建监测方法</h2><p>监测方法用于被动地观察 <code>Bundle</code> 接口上的活动。它们也是异步函数 （<code>async def</code>），并由框架自动、周期性地调用。</p><ul><li><p>必须使用 <code>@monitor_method()</code> 装饰器标记。</p></li><li><p>框架会在每个时钟周期的特定阶段（见后文时序部分）自动调用所有监测方法。</p></li><li><p>监测方法内部逻辑通常是检查 <code>Bundle</code> 信号是否满足特定条件（例如，某个使能信号有效，或者握手完成）。</p></li><li><p><strong>关键：</strong> 如果监测方法在某次调用中认为一次有效的活动/事务被捕获，它应该 <strong>返回</strong> 代表该活动的数据（例如一个字典、一个自定义事务对象等）。如果<strong>返回值不为 <code>None</code></strong>，框架会认为监测到了一个事件，并将返回值存入内部的消息队列。如果返回 <code>None</code>，则表示本周期没有监测到目标事件。</p></li><li><p>如果监测方法的执行逻辑需要跨越多个时钟周期（例如，等待一个完整的传输结束），框架会等待其完成后再进行下一次调用。</p></li></ul><p>下面是一个简单的监测方法示例，用于监测加法器输出 <code>sum</code> 大于 0 的情况：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>toffee.agent</span> <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>AdderAgent</span><span style=color:#111>(</span><span style=color:#111>Agent</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#75af00>@monitor_method</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>monitor_sum</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 检查条件</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>if</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>sum</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 条件满足，返回 Bundle 的当前状态作为监测到的数据</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 使用 as_dict() 获取包含所有信号值的字典</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>return</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>as_dict</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 条件不满足，返回 None (或不返回任何东西)</span>
</span></span></code></pre></div><p>这个 <code>monitor_sum</code> 方法会在<strong>每个周期被框架调用</strong>。如果 <code>sum</code> 大于 0，它会返回一个包含当时所有信号值的字典；否则返回 <code>None</code>。</p><p>如果想在每个周期都无条件地捕获 <code>Bundle</code> 状态，可以这样写：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75af00>@monitor_method</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>monitor_always</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>as_dict</span><span style=color:#111>(</span><span style=color:#111>multilevel</span><span style=color:#f92672>=</span><span style=color:#00a8c8>False</span><span style=color:#111>)</span>
</span></span></code></pre></div><h2 id=54-获取监测消息>5.4 获取监测消息</h2><p>被 <code>@monitor_method</code> 标记的方法自动运行时，其非 <code>None</code> 的返回值会被放入一个与该方法同名的内部消息队列。要在测试用例中获取这些被监测到的数据，需要执行以下步骤：</p><ol><li><strong>启动监测队列：</strong> 在测试开始前（通常在 fixture 中），为需要获取消息的监测方法启动队列，并指定队列大小：</li></ol><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>adder_agent</span><span style=color:#f92672>.</span><span style=color:#111>start_monitor</span><span style=color:#111>(</span><span style=color:#d88200>&#34;monitor_sum&#34;</span><span style=color:#111>,</span> <span style=color:#ae81ff>10</span><span style=color:#111>)</span> <span style=color:#75715e># 指定消息队列的大小, 默认大小为 4</span>
</span></span></code></pre></div><ul><li><strong>检查队列大小（可选操作）：</strong> 可以使用 <code>monitor_size("method_name")</code> 获取当前队列中消息的数量。</li></ul><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>message_count</span> <span style=color:#f92672>=</span> <span style=color:#111>adder_agent</span><span style=color:#f92672>.</span><span style=color:#111>monitor_size</span><span style=color:#111>(</span><span style=color:#d88200>&#34;monitor_sum&#34;</span><span style=color:#111>)</span> <span style=color:#75715e># 获取消息队列中的消息数量</span>
</span></span></code></pre></div><ul><li><strong>获取消息：</strong> 在测试用例中，调用与监测方法同名的 <code>Agent</code> 方法来从队列中获取消息。这是一个异步操作，如果队列为空，它会等待直到有消息进入。</li></ul><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>result</span> <span style=color:#f92672>=</span> <span style=color:#00a8c8>await</span> <span style=color:#111>adder_agent</span><span style=color:#f92672>.</span><span style=color:#111>monitor_sum</span><span style=color:#111>()</span>
</span></span></code></pre></div><p>监测方法同样也与参考模型相关联，框架会自动将监测到的数据与参考模型的预期进行比较（后续章节介绍）。</p><h2 id=55-agent-中的时序>5.5 Agent 中的时序</h2><p><code>Agent</code> 中的驱动方法和监测方法遵循以下基本时序规则：</p><ol><li><p><strong>监测优先：</strong> 在每个时钟周期的开始阶段，框架会首先调用所有的 <strong>监测方法</strong>。只有当所有监测方法（在该周期的调用）都执行完毕后，<strong>驱动方法</strong>（如果在本周期被验证代码调用）才会被执行。</p></li><li><p><strong>启动与结束：</strong> 驱动方法可以在第 0 个时钟周期就被调用。监测方法从第 1 个时钟周期的起始时刻开始被框架自动调用。在整个测试流程结束时，监测方法会被额外调用一次，以确保捕获最后一个周期的状态。</p></li></ol><p>下面的示意图展示了执行 5 次单周期驱动方法 <code>exec_add</code> 的时序：</p><pre tabindex=0><code class="language-plain text" data-lang="plain text">            cycle 0       cycle 1            cycle 2          cycle 3          cycle 4          cycle 5
test start ---------+-----------------+-----------------+-----------------+-----------------+----------------- test end
                    |                 |                 |                 |                 |
            +---------------+ +---------------+ +---------------+ +---------------+ +---------------+
            |    exec_add   | |    exec_add   | |    exec_add   | |    exec_add   | |    exec_add   |
            +---------------+ +---------------+ +---------------+ +---------------+ +---------------+
                    | +-------------+ | +-------------+ | +-------------+ | +-------------+ | +-------------+
                    | | monitor_sum | | | monitor_sum | | | monitor_sum | | | monitor_sum | | | monitor_sum |
                    | +-------------+ | +-------------+ | +-------------+ | +-------------+ | +-------------+
                    |                 |                 |                 |                 |
           ---------+-----------------+-----------------+-----------------+-----------------+-----------------
</code></pre><h2 id=56-完整的-agent-示例>5.6 完整的 Agent 示例</h2><p>结合驱动和监测方法，<code>AdderAgent</code> 的完整代码如下：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 代码位于 https://github.com/XS-MLVP/toffee/blob/master/example/adder/env/agent.py</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>AdderAgent</span><span style=color:#111>(</span><span style=color:#111>Agent</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#75af00>@driver_method</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>exec_add</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>a</span><span style=color:#111>,</span> <span style=color:#111>b</span><span style=color:#111>,</span> <span style=color:#111>cin</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>a</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#111>a</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>b</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#111>b</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>cin</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>=</span> <span style=color:#111>cin</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>await</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>step</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>return</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>sum</span><span style=color:#f92672>.</span><span style=color:#111>value</span><span style=color:#111>,</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>cout</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75af00>@monitor_method</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>monitor_once</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>return</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>as_dict</span><span style=color:#111>()</span>
</span></span></code></pre></div><h2 id=57-练习>5.7 练习</h2><p>本节的练习已经发布，请查阅<a href=/beginner/task/toffee/>【学习任务2: Toffee 部分】 3. 使用 Agent 进一步封装</a>。</p><hr><h1 id=6-同步-fifo-规范阅读>6. 同步 FIFO 规范阅读</h1><p>需要大家去阅读同步 FIFO 的规范，具体看：</p><p><a href=/beginner/task/sync_fifo/>同步FIFO设计规范</a></p><h2 id=本节目标>本节目标</h2><p>本小节旨在<strong>帮助验证新人学习如何快速阅读和理解芯片或硬件设计规范文档</strong>，并从中提炼出验证工作的重点。通过以 <code>SyncFIFO</code> 模块为例，带领大家逐步掌握：</p><ul><li><p>如何识别模块功能和用途</p></li><li><p>如何理解接口和信号含义</p></li><li><p>如何分析模块内部行为</p></li><li><p>如何提炼出关键验证点和边界条件</p></li></ul><h2 id=阅读顺序推荐五步法>阅读顺序推荐：五步法</h2><p>所谓的五步，实际上就是<strong>从五个维度去理解验证文档</strong>，这需要我们在阅读前就带上这五个问题，一个一个去文章中寻找答案。</p><p>这样，你就可以把文档的阅读理解转化成五个题目，以做题的方式去理解文档；当你确保自己能答对这几个题的时候，你对硬件的规范设计就能称得上了然于胸了。</p><h3 id=1-理解模块的作用和目的>1. 理解模块的作用和目的</h3><ul><li><p><strong>模块是什么？它想要实现什么？</strong></p><ul><li>这一步的作用在于，让我们形成对模块的宏观认识。</li></ul></li><li><p>具体怎么做？</p><ol><li><p>规范文档的最前方一般都会有一个总述性的描写，你可以从中了解到待验证模块的故事背景，在同步 FIFO 的案例中，你可以对照到<code>描述</code>这一小节，就描述了这一部分内容，显然，FIFO 是大家所熟知的数据结构，光是听到这个名字，就能让我们一下子建立起一种<strong>熟悉的亲切感。</strong></p></li><li><p>剩余的内容介绍中，你可以了解到它的<strong>大致功能</strong>，<strong>应用场景</strong>，规格，<strong>遵循同步还是异步</strong>操作，这部分内容，可能会进一步加深你对故事背景的认识，但如果反而让你产生陌生的情绪，也不用慌张，在后面的阅读中，你会找到你想要的答案，重要的是，我们至少已经在前一步树立起故事背景的认识。</p></li><li><p><strong>需要注意的是</strong>，不是所有模块都像 FIFO 那样为我们所熟知，不需要做进一步说明。很多情况下，需要通过阅读背景介绍建立宏观的认识。</p></li></ol></li></ul><h3 id=2-弄清输入输出信号>2. 弄清输入输出信号</h3><ul><li><strong>输入输出信号都代表什么？输入输出信号之间的协同关系是什么？</strong><ul><li>接口是模块与外界沟通的唯一方式，理解接口就是理解了模块的行为。</li></ul></li></ul><ul><li><p>具体怎么做？</p><ol><li><p>接口信号主要分为三大类，输入信号，输出信号，控制信号（其实也属于输入信号，但功能特殊，此处专门列出），下面以 FIFO 中的<strong>端口说明</strong>为例，请你自己按照分类，去理解 FIFO 的端口含义：</p><ul><li><p>控制信号：用于控制整个模块</p><ul><li><p>时钟信号：<code>clk</code></p></li><li><p>reset 信号：<code>rst_n</code></p></li></ul></li><li><p>输入信号：</p><ul><li><p>写入信号：</p><ul><li><p>写入数据信号：<code>data_i</code></p></li><li><p>写入控制信号：<code>we_i</code></p></li></ul></li><li><p>读取信号：</p><ul><li>读取控制信号：<code>re_i</code></li></ul></li></ul></li><li><p>输出信号：</p><ul><li><p>读取数据信号：<code>data_o</code></p></li><li><p>输出状态信号：<code>full_o</code>， <code>empty_o</code></p></li></ul></li></ul></li></ol><blockquote><p>💡提示：这种分类方式并不是必须的，你可以按照个人喜好去分，比如读写使能信号可以归类与控制信号中</p></blockquote><ul><li><p>在弄清楚每个输入输出信号的含义之后，接下来，我们还需要搞清楚输入输出信号之间的组合/协同关系：</p><ul><li><p>在上面这个例子中，其实信号之间的协同关系也已经浮出水面了：</p><ul><li><p>输入信号中的写入信号协同进行信号的写入</p></li><li><p>输入信号中的读取控制信号控制输出信号中的读取数据信号的读出</p></li></ul></li></ul></li></ul></li></ul><h3 id=3-理解模块内部逻辑>3. 理解模块内部逻辑</h3><ul><li><p><strong>模块里面是怎么工作的？逻辑是啥？</strong></p><ul><li>上一步，我们了解了信号的外部如何交互，接下来，我们深入内部，了解模块内部到底做了什么？</li></ul></li><li><p>具体怎么做？</p><ul><li><p>从这里开始，我们就要具体地理解模块的内部逻辑了（参照 FIFO 的 <code>功能描述</code> ），我们需要把内部行为提取出来，细化成一个具体的点。对于一个模块而言，其行为逻辑无非就是由<strong>顶层信号的模块控制，模块更新，模块读取</strong>这几部分组成，我们可以从这几个视角去提取：</p><ul><li><p>顶层信号的控制</p><ul><li>复位：根据reset信号，使同步 FIFO中的内部信号<strong>复位</strong></li></ul></li><li><p>模块更新：</p><ul><li><p>内部数据更新：通过<strong>写入操作</strong>向同步 FIFO中存储数据（对应功能描述的<strong>写入操作</strong>部分）</p></li><li><p>内部状态更新：由输入信号（包括控制信号）导致的内部状态信号更新，比如写入操作会导致计数器变更（对应功能描述的<strong>计数器</strong>部分）。读或者写会触发<strong>指针更新</strong>。</p></li></ul></li><li><p>模块读取：</p><ul><li><p>内部数据读取：通过<strong>读取操作</strong>从同步 FIFO中读取存储的数据（对应功能描述的<strong>读取操作</strong>部**）**</p></li><li><p>内部状态读取：通过计数器记录同步 FIFO中存储的数据容量（对应功能描述的<strong>计数器</strong>部**）**</p></li></ul></li></ul></li></ul></li></ul><h3 id=4-识别极端或边界行为>4. 识别极端或边界行为</h3><ul><li><p><strong>极限情况怎么办？模块能不能“撑住”？</strong></p><ul><li>当你完成前面三步时，已经可以比较好的理解模块的大致设计了，现在我们要专门考虑一些极端情况，或者说边界情况</li></ul></li><li><p>具体怎么做？</p><ul><li><p>这部分内容可能需要从功能点自行总结，但在<code>FIFO</code>案例中，我们直接给出了<code>边界条件</code>这一节。</p></li><li><p>常见的边界条件有以下类型：</p><ul><li><p>数据边界：比如写入数据的最大最小值是否有效。</p></li><li><p>控制信号边界：比如 FIFO 满时继续写入，空时读取（这里的控制信号不是指前文提到的顶层控制信号，而是驱动某一个功能执行的控制信号 like:<code>re_i</code> <code>we_i</code>）</p></li><li><p>交互边界：多个信号同时发生作用时，模块是否能正确执行？</p><ol><li><p><code>we_i = 1 & re_i = 1</code> 时模块能否同时处理读写请求？（典型场景：同时读写的 FIFO）</p></li><li><p><code>we_i = 1 & rst_n = 0</code> 时，写请求是否被忽略？</p></li></ol></li></ul></li></ul></li></ul><h3 id=5-整理验证目标建立验证计划>5. 整理验证目标，建立验证计划</h3><ul><li><p><strong>将所理解的一切转化为可执行的验证任务</strong>：之前的四步已足以让你完全理解整个模块了，接下来这一步，要求我们在此基础上，思考怎么建立起一个大致的验证计划了，这就要求我们关注文档中更细节的内容。</p></li><li><p>具体怎么做？</p><ul><li><p>这一步要做的，其实就是在功能点的基础上细分测试点，并给出相应的覆盖点了。<code>FIFO</code>案例中，我们直接给出了<code>功能点和测试点</code> 这一节，很值得参考。</p></li><li><p>关于如何划分测试点，我们在<a href=/beginner/course/2-picker/>第一讲</a>有详细阐述。</p></li></ul></li></ul><p>需要注意的是，使用这五步法阅读规范的时候，<strong>并不一定是顺序执行的，很可能有时候需要并行执行</strong>，比如一开始看端口列表时，不能通过字面上的意思理解端口的含义，而读完功能点时，才能回过头去理解。</p><hr><h1 id=7-收集功能覆盖率>7. 收集功能覆盖率</h1><blockquote><p>“If you can&rsquo;t measure it, you can&rsquo;t improve it.” — Peter Drucker （如果你无法衡量它，你就无法改进它。)</p></blockquote><p>在芯片验证中，仅仅运行测试用例并通过（即没有 <code>assert</code> 失败）是远远不够的。“跑通了测试”并不意味着设计中不存在 Bug。我们需要一种方法来量化验证的进展和完备性。<strong>覆盖率</strong>就是用于此目的的关键指标。</p><p>前面章节已经涉及了<strong>代码覆盖率 </strong>，例如行覆盖率、分支覆盖率、状态机覆盖率等。代码覆盖率衡量的是设计的源代码（RTL 代码）在仿真过程中有多少比例被执行到。它非常有助于发现设计中那些从未被任何测试触达的部分（所谓的“死代码”或测试激励无法到达的区域）。</p><p>然而，100% 的代码覆盖率 <strong>不等于</strong> 100% 的功能验证。想象一个简单的加法器，它的所有代码行都可能在测试中被执行过，但我们可能从未测试过两个负数相加的情况，或者从未触发过加法溢出的场景。这些关键的功能点或边界条件，代码覆盖率是无法直接体现的。</p><p><strong>功能覆盖率</strong>正是弥补了这一不足。它衡量的是<strong>设计规格</strong>中定义的<strong>功能点、操作模式、关键参数组合、状态转换、边界条件</strong>等，是否在验证过程中被实际观察到或经历过。功能覆盖率直接关联<strong>验证计划 </strong>，旨在回答核心问题：“我们计划要验证的所有功能和场景，是否真的都被测试覆盖到了？”</p><h2 id=71-功能覆盖率模型>7.1 功能覆盖率模型</h2><p>在深入了解其构成要素之前，我们先定义什么是<strong>功能覆盖率模型</strong>。</p><p>功能覆盖率模型是实现验证计划中测试点覆盖的<strong>具体代码实现</strong>。它不是一个抽象的概念，而是你在验证环境（例如使用 Toffee 框架）中编写的一组代码结构，其目的是：</p><ol><li><p><strong>定义“感兴趣”的事件：</strong> 明确规定需要监控哪些设计行为、哪些信号值或值的组合、哪些状态转换是重要的，这些都源于设计规格和验证计划。</p></li><li><p><strong>监控仿真活动：</strong> 在仿真运行时，模型会持续观察 DUT 的行为和状态。</p></li><li><p><strong>记录覆盖情况：</strong> 当模型定义的“感兴趣”的事件发生时，模型会记录下来（通常是标记对应的“覆盖区间/仓”被命中）。</p></li><li><p><strong>量化功能的验证进度：</strong> 通过统计有多少预定义的事件被观察到，来衡量验证对<strong>设计功能的覆盖程度</strong>。</p></li></ol><p>简单来说，功能覆盖率模型就像一个在仿真过程中<strong>动态执行的、基于功能需求的检查清单</strong>。这份清单由验证工程师根据设计规格编写，用于确认所有关心的功能场景是否都已在测试中出现。在 Toffee 中，这份“清单”就是由接下来要介绍的 <code>CovGroup</code>、<code>CovPoint</code> 和 <code>CovBin</code> 等元素构建而成的。</p><h2 id=72-功能覆盖率的组成>7.2 功能覆盖率的组成</h2><p>在 Toffee （以及 SystemVerilog 等语言） 中，收集功能覆盖率通常涉及以下核心元素：</p><ol><li><p><strong>覆盖组 （<code>CovGroup</code> ）</strong>： 一个逻辑容器，用于组织一组相关的覆盖项。通常对应验证计划中的一个高层功能点（例如，“FIFO 基本读写操作”）或一个接口。</p></li><li><p><strong>覆盖点 （<code>CovPoint</code>）</strong>： 定义在 <code>CovGroup</code> 内部，用于监视设计的某个特定行为、变量值或一组变量值的组合。它明确了我们要<strong>测量什么</strong>（例如，“FIFO 计数器的值”、“写操作时的状态”）。</p></li><li><p><strong>覆盖区间/仓 （<code>CovBin</code>）</strong>： 定义在 <code>CovPoint</code> 内部，代表了该覆盖点需要覆盖的具体数值、数值范围、状态转换或条件。它明确了覆盖点期望达到的<strong>具体状态</strong>。当某个 Bin 所定义的条件在仿真中被观察到时，该 Bin 就被认为“覆盖”了。</p></li></ol><p><strong>目标：</strong> 功能验证的目标通常是让<strong>功能覆盖率达到 100%</strong>，即所有在覆盖模型中定义的 <code>CovBin</code> 都至少被命中一次。任何未被覆盖的 Bin 都指示了验证的“盲点”，提示我们需要补充新的测试用例或调整现有的激励生成策略来覆盖这些缺失的场景。</p><h2 id=73-构建功能覆盖率模型基本原则>7.3 构建功能覆盖率模型：基本原则</h2><p>开发功能覆盖率模型不是一次性的任务，而是一个需要仔细规划和<strong>迭代完善</strong>的过程。它紧密依赖于对设计规格的理解和验证计划的制定。以下是一些关键原则：</p><h3 id=1-基于功能需求和验证计划>1. 基于功能需求和验证计划</h3><p>功能覆盖率模型必须<strong>源于设计规格和验证计划</strong>。验证计划中列出的每一个需要验证的功能点、特性、状态或场景，都应该在覆盖率模型中有对应的 <code>CovGroup</code> 或 <code>Coverpoint</code> 来衡量其覆盖情况。这确保了验证工作始终聚焦于设计的预期功能。</p><h3 id=2-基于观察数据>2. 基于观察数据</h3><p>验证环境通常可以分为：</p><ul><li><p><strong>激励/控制路径：</strong> 负责产生输入信号，驱动 DUT。</p></li><li><p><strong>响应/分析路径：</strong> 负责观察 DUT 的输出信号，检查其行为，并进行数据分析。</p></li></ul><p>功能覆盖率的收集点<strong>应该</strong>位于<strong>分析路径</strong>。也就是说，覆盖率模型应该采样和记录 DUT <strong>实际表现出的行为和状态</strong>（通常通过监测接口的 <code>Agent</code> 或 <code>Monitor</code> 获取），而不是采样激励端发送给 DUT 的数据。</p><p><strong>原因：</strong> 如果基于激励端采样，当 DUT 或激励本身存在问题时（例如，DUT 没有正确响应激励，或者激励发送了错误的数据），覆盖率数据可能会产生误导，报告某个功能已被“覆盖”，而实际上 DUT 并未按预期执行该功能。基于对 DUT 实际输出的观察来采样，才能确保覆盖率反映的是真实的设计行为。</p><p>所以，在搭建验证环境时，功能覆盖率需通过分析事务的内容来构建。这对验证环境和分析事务的设计提出了以下要求：</p><ol><li><p><strong>观测与激励分离</strong>：覆盖率模型需独立于激励生成逻辑，仅依赖 DUT 的实际输出。</p></li><li><p><strong>分析事务的完整性</strong>：需确保事务数据完整记录 DUT 的响应状态（如信号值、时序等）。</p></li><li><p><strong>覆盖率驱动的验证</strong>：工程师需要通过分析已有的覆盖率数据，指导后续激励生成。</p></li></ol><h3 id=3-面向分析而设计>3. 面向分析而设计</h3><p><strong>功能覆盖率报告是给验证工程师看的</strong>。一个设计良好的覆盖率模型不仅能准确衡量覆盖情况，还应该易于理解和分析。当出现覆盖漏洞时，工程师需要能快速定位到是哪个功能点的哪种具体情况没有被覆盖到。</p><ul><li><p><strong>清晰命名：</strong> 为 <code>CovGroup</code>、<code>Coverpoint</code> 和 <code>Bin</code> 使用描述性强、易于理解的名称。例如，<code>fifo_state_covgroup</code>， <code>counter_value_cp</code>， <code>bin counter_is_zero</code>。</p></li><li><p><strong>合理组织：</strong> 将相关的覆盖点组织在同一个 <code>CovGroup</code> 中。</p></li><li><p><strong>利用语言特性：</strong> 使用 Toffee 提供的功能（如 Bin 的命名等）来提高报告的可读性。</p></li></ul><p>在模型设计阶段投入时间优化其结构和命名，可以在后续分析覆盖率报告时节省大量时间。</p><h3 id=4-确定适当的详细程度>4. 确定适当的详细程度</h3><p>需要权衡覆盖率模型与设计实现的匹配精度以及抽象的程度：</p><ul><li><p><strong>匹配精度：</strong> 模型需要多详细地反映设计的内部状态或接口信号？</p></li><li><p><strong>抽象层级：</strong> 可以在多大程度上对细节进行抽象或简化？</p></li></ul><p>例如，对于一个 32 位的地址总线，为每个可能的地址值创建一个 Bin 是不现实的。更合适的做法是定义一些关键的 Bin，比如说：</p><ul><li><p>边界值：地址 0，地址最大值。</p></li><li><p>特定区域：某个内存区域的起始和结束地址范围。</p></li><li><p>对齐方式：检查奇偶地址访问。</p></li><li><p>一些随机采样值。 这就需要进行抽象，将无限的可能性归纳为有限的、有代表性的覆盖目标。</p></li></ul><p>对于配置寄存器中的几个标志位，可能就需要覆盖它们所有 $2^N$ 种组合。</p><h3 id=5-覆盖点和覆盖仓的关键考量>5. 覆盖点和覆盖仓的关键考量</h3><p>在定义覆盖点和覆盖仓时，需要思考：</p><ul><li><p><strong>哪些值是重要的？</strong></p><ul><li><p>识别出设计规格中要求的、或可能引发特殊行为的关键值、状态或模式。</p></li><li><p>例如：FIFO 的空、满、半满状态；特定的操作码；错误标志位。</p></li></ul></li><li><p><strong>是否存在边界条件？</strong></p><ul><li><p>关注数值范围的边界（最小值、最大值、零值）、状态转换的临界点、协议时序的极限情况。</p></li><li><p>例如：计数器溢出前后；缓冲区刚好满/空；定时器超时。</p></li></ul></li><li><p><strong>数据之间是否存在依赖关系？</strong></p><ul><li><p>如果多个信号或变量的状态组合起来才有意义，或者它们的组合会影响设计行为，就需要定义<strong>交叉覆盖 （Cross Coverage）</strong>。</p></li><li><p>例如：覆盖读操作 （<code>re_i=1</code>） 发生在 FIFO 非空 （<code>empty_o=0</code>） 的情况；覆盖特定的配置位组合。</p></li></ul></li><li><p><strong>是否存在非法或不期望的条件？</strong></p><ul><li><p>可以定义 <code>illegal_bins</code> 来捕获那些根据设计规格不应该发生的状态或组合。如果 <code>illegal_bin</code> 被命中，通常表示存在设计错误或验证环境错误。</p></li><li><p>例如：FIFO 同时报告满 （<code>full_o=1</code>） 和空 （<code>empty_o=1</code>）。</p></li></ul></li><li><p><strong>是否存在需要忽略或不关心的条件？</strong></p><ul><li><p>可以使用 <code>ignore_bins</code> 来排除那些虽然可能发生、但对当前验证目标不重要或无效的条件。</p></li><li><p>例如：在复位期间的信号值；某些交叉覆盖中逻辑上不可能的组合。</p></li></ul></li><li><p><strong>优先级和分阶段目标：</strong></p><ul><li><p>并非所有覆盖点都同等重要。</p></li><li><p>根据验证计划，为覆盖点设定优先级。优先确保 P1 级别的覆盖点达到 100%，再逐步关注 P2、P3。</p></li></ul></li></ul><h3 id=6-确定正确的参样时机>6. 确定正确的参样时机</h3><p>选择正确的采样时刻至关重要，错误的采样可能导致覆盖率数据无效或遗漏。采样点需要满足：</p><ul><li><p><strong>相关检查已通过 （可选但推荐）:</strong> 最好在确认 DUT 的行为是正确的之后再采样覆盖率，以避免记录错误行为下的覆盖。</p></li><li><p><strong>数据有效 （Data Valid）:</strong> 确保在采样时刻，所关心的信号值是稳定且有意义的。例如，在总线协议中，通常在握手信号确认传输完成的那个周期进行采样。</p></li><li><p><strong>数据稳定 （Data Stable）:</strong> 避免在信号正在跳变的时刻采样。</p></li></ul><h3 id=7-确定采样结果是有效的>7. 确定采样结果是有效的</h3><p>需要考虑在哪些情况下，即使满足了采样条件，该次采样也应该被视为无效或应被特殊处理。例如：</p><ul><li><p>DUT 正处于复位状态。</p></li><li><p>刚刚更改了操作模式，需要等待几个周期让状态稳定。</p></li><li><p>正在进行错误注入测试，此时的覆盖率可能需要与正常操作的覆盖率分开统计。</p></li></ul><p>可以通过在采样逻辑中添加额外的判断条件来处理这些情况。</p><h2 id=74-在-toffee-中收集功能覆盖率>7.4 在 Toffee 中收集功能覆盖率</h2><p>Toffee 通过 <code>toffee.funcov</code> 模块提供功能覆盖率相关的类和方法。</p><h3 id=定义覆盖组-covgroup-和覆盖点-add_watch_point>定义覆盖组 （<code>CovGroup</code>） 和覆盖点 （<code>add_watch_point</code>）</h3><ul><li>创建覆盖组：</li></ul><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>toffee.funcov</span> <span style=color:#f92672>import</span> <span style=color:#111>CovGroup</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>agent.fifo_agent</span> <span style=color:#f92672>import</span> <span style=color:#111>FIFOAgent</span> <span style=color:#75715e># 假设已有 FIFOAgent</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>get_cover_group_fifo_state</span><span style=color:#111>(</span><span style=color:#111>agent</span><span style=color:#111>:</span> <span style=color:#111>FIFOAgent</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>CovGroup</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 创建一个名为 &#34;FIFO state&#34; 的覆盖组</span>
</span></span><span style=display:flex><span>    <span style=color:#111>group</span> <span style=color:#f92672>=</span> <span style=color:#111>CovGroup</span><span style=color:#111>(</span><span style=color:#d88200>&#34;FIFO state&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># ... 在这里添加覆盖点 ...</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#111>group</span>
</span></span></code></pre></div><p><strong>添加覆盖点：</strong> 使用 <code>group.add_watch_point()</code> 方法。该方法需要：</p><ol><li><p><strong>监视对象：</strong> 要监视的信号或 <code>Bundle</code> 实例 （例如 <code>agent.internal.counter</code>， <code>agent.write</code>， <code>agent.internal</code>）。</p></li><li><p><strong>Bins 字典：</strong> 一个字典，定义了该覆盖点的所有 Bins。</p><ul><li><p><strong>Key:</strong> Bin 的名称 （字符串）。</p></li><li><p><strong>Value:</strong> 定义该 Bin 命中条件的逻辑。可以是：</p><ul><li><p><strong>比较函数：</strong> 如 <code>CovEq(1)</code>， <code>CovIsInRange(7, 9)</code> 等，用于检查监视对象的值。</p></li><li><p><strong>检查函数：</strong> 一个函数 （普通函数或 lambda），接收监视对象作为参数，返回 <code>True</code> （命中） 或 <code>False</code> （未命中）。</p></li></ul></li></ul></li><li><p><strong><code>name</code> 参数：</strong> 覆盖点的名称，用于报告。</p></li></ol><h3 id=编写技巧>编写技巧</h3><h4 id=检查单个信号的值>检查单个信号的值</h4><p>使用 <code>toffee.funcov</code> 提供的比较函数很方便：<code>CovEq</code>， <code>CovGt</code>， <code>CovLt</code>， <code>CovGe</code>， <code>CovLe</code>， <code>CovNe</code>， <code>CovIn</code>， <code>CovNotIn</code>， <code>CovIsInRange</code>。例如，如果我们想检测同步 FIFO 中<code>counter</code>的取值情况：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>get_cover_group_fifo_state</span><span style=color:#111>(</span><span style=color:#111>agent</span><span style=color:#111>:</span> <span style=color:#111>FIFOAgent</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>CovGroup</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Create coverage group</span>
</span></span><span style=display:flex><span>    <span style=color:#111>group</span> <span style=color:#f92672>=</span> <span style=color:#111>CovGroup</span><span style=color:#111>(</span><span style=color:#d88200>&#34;FIFO state&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Add coverage points</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 检测counter信号</span>
</span></span><span style=display:flex><span>    <span style=color:#111>group</span><span style=color:#f92672>.</span><span style=color:#111>add_watch_point</span><span style=color:#111>(</span><span style=color:#111>agent</span><span style=color:#f92672>.</span><span style=color:#111>internal</span><span style=color:#f92672>.</span><span style=color:#111>counter</span><span style=color:#111>,</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#34;one&#34;</span><span style=color:#111>:</span> <span style=color:#111>CovEq</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>),</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#34;middle&#34;</span><span style=color:#111>:</span> <span style=color:#111>CovIsInRange</span><span style=color:#111>(</span><span style=color:#ae81ff>7</span><span style=color:#111>,</span> <span style=color:#ae81ff>9</span><span style=color:#111>),</span> <span style=color:#75715e># counter的值在 7~9 之间</span>
</span></span><span style=display:flex><span>        <span style=color:#d88200>&#34;near_full&#34;</span><span style=color:#111>:</span> <span style=color:#111>CovIsInRange</span><span style=color:#111>(</span><span style=color:#ae81ff>14</span><span style=color:#111>,</span> <span style=color:#ae81ff>15</span><span style=color:#111>),</span>
</span></span><span style=display:flex><span>    <span style=color:#111>},</span> <span style=color:#111>name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;counter&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#111>group</span>
</span></span><span style=display:flex><span>   
</span></span></code></pre></div><h4 id=检查涉及多个信号的条件>检查涉及多个信号的条件</h4><p>当 Bin 的条件涉及多个信号或更复杂的逻辑时，需要提供一个<strong>检查函数</strong>。</p><h5 id=lambda-表达式x20>Lambda 表达式</h5><p>对于简单的条件，最直接的写法是使用 Lambda 表达式。</p><h5 id=命名函数>命名函数</h5><p>更推荐使用命名函数，不仅会有更好的维护性，而且在编码时还会方便 IDE 提供补全支持：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>toffee.funcov</span> <span style=color:#f92672>import</span> <span style=color:#111>CovGroup</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>agent.fifo_agent</span> <span style=color:#f92672>import</span> <span style=color:#111>FIFOAgent</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>bundle.fifo_bundle</span> <span style=color:#f92672>import</span> <span style=color:#111>WriteBundle</span><span style=color:#111>,</span> <span style=color:#111>ReadBundle</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- 定义检查函数 ---</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>check_write_operation</span><span style=color:#111>(</span><span style=color:#111>bundle</span><span style=color:#111>:</span> <span style=color:#111>WriteBundle</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>bool</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>we_i</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>is_full</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>check_read_operation</span><span style=color:#111>(</span><span style=color:#111>bundle</span><span style=color:#111>:</span> <span style=color:#111>ReadBundle</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>bool</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>re_i</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>is_empty</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>check_none_operation</span><span style=color:#111>(</span><span style=color:#111>agent</span><span style=color:#111>:</span> <span style=color:#111>FIFOAgent</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>bool</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#f92672>not</span> <span style=color:#111>agent</span><span style=color:#f92672>.</span><span style=color:#111>read</span><span style=color:#f92672>.</span><span style=color:#111>re_i</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> <span style=color:#111>agent</span><span style=color:#f92672>.</span><span style=color:#111>write</span><span style=color:#f92672>.</span><span style=color:#111>we_i</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- 创建覆盖组 ---</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>get_cover_group_basic_operations</span><span style=color:#111>(</span><span style=color:#111>agent</span><span style=color:#111>:</span> <span style=color:#111>FIFOAgent</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>CovGroup</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#111>group</span> <span style=color:#f92672>=</span> <span style=color:#111>CovGroup</span><span style=color:#111>(</span><span style=color:#d88200>&#34;Basic operations&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># --- 添加覆盖点，使用命名函数 ---</span>
</span></span><span style=display:flex><span>    <span style=color:#111>group</span><span style=color:#f92672>.</span><span style=color:#111>add_watch_point</span><span style=color:#111>(</span><span style=color:#111>agent</span><span style=color:#f92672>.</span><span style=color:#111>write</span><span style=color:#111>,</span> <span style=color:#111>{</span><span style=color:#d88200>&#34;write_occurs&#34;</span><span style=color:#111>:</span> <span style=color:#111>check_write_operation</span><span style=color:#111>},</span> <span style=color:#111>name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;Write operation&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>group</span><span style=color:#f92672>.</span><span style=color:#111>add_watch_point</span><span style=color:#111>(</span><span style=color:#111>agent</span><span style=color:#f92672>.</span><span style=color:#111>read</span><span style=color:#111>,</span> <span style=color:#111>{</span><span style=color:#d88200>&#34;read_occurs&#34;</span><span style=color:#111>:</span> <span style=color:#111>check_read_operation</span><span style=color:#111>},</span> <span style=color:#111>name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;Read operation&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>group</span><span style=color:#f92672>.</span><span style=color:#111>add_watch_point</span><span style=color:#111>(</span><span style=color:#111>agent</span><span style=color:#111>,</span> <span style=color:#111>{</span><span style=color:#d88200>&#34;no_operation&#34;</span><span style=color:#111>:</span> <span style=color:#111>check_none_operation</span><span style=color:#111>},</span> <span style=color:#111>name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;No operation&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#111>group</span>
</span></span></code></pre></div><h5 id=处理规律性强的条件-工厂函数>处理规律性强的条件 （工厂函数）</h5><p>当多个 Bins 的检查逻辑相似，只有少量参数不同，可以使用“工厂函数”模式来生成检查函数。例如，读写指针只有三种比较关系：等于、大于、小于，检查函数可以定义为：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>wptr_compare_rptr</span><span style=color:#111>(</span><span style=color:#111>compare_type</span><span style=color:#111>:</span> <span style=color:#111>int</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>compare</span><span style=color:#111>(</span><span style=color:#111>bundle</span><span style=color:#111>:</span> <span style=color:#111>InternalBundle</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>bool</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>if</span> <span style=color:#111>compare_type</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>return</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>wptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>==</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>rptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>elif</span> <span style=color:#111>compare_type</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>return</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>wptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>&gt;</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>rptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>else</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>return</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>wptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>rptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#111>compare</span>
</span></span></code></pre></div><p>创建检查函数的时候，传入<code>wptr_compare_rptr(0)</code>、<code>wptr_compare_rptr(1)</code>、<code>wptr_compare_rptr(2)</code>就得到了三种情况的<strong>函数对象</strong><code>compare</code>，我们就可以通过一个字典表达式完成对三种指针情况收集的编码：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>get_cover_group_pointer_compare</span><span style=color:#111>(</span><span style=color:#111>agent</span><span style=color:#111>:</span> <span style=color:#111>FIFOAgent</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>CovGroup</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Define coverage conditions</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>wptr_compare_rptr</span><span style=color:#111>(</span><span style=color:#111>compare_type</span><span style=color:#111>:</span> <span style=color:#111>int</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>def</span> <span style=color:#75af00>compare</span><span style=color:#111>(</span><span style=color:#111>bundle</span><span style=color:#111>:</span> <span style=color:#111>InternalBundle</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>bool</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>if</span> <span style=color:#111>compare_type</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>                <span style=color:#00a8c8>return</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>wptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>==</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>rptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>elif</span> <span style=color:#111>compare_type</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>                <span style=color:#00a8c8>return</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>wptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>&gt;</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>rptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>else</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>                <span style=color:#00a8c8>return</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>wptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>rptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>return</span> <span style=color:#111>compare</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Create coverage group</span>
</span></span><span style=display:flex><span>    <span style=color:#111>group</span> <span style=color:#f92672>=</span> <span style=color:#111>CovGroup</span><span style=color:#111>(</span><span style=color:#d88200>&#34;Pointer compare&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Add coverage points</span>
</span></span><span style=display:flex><span>    <span style=color:#111>names</span> <span style=color:#f92672>=</span> <span style=color:#111>[</span><span style=color:#d88200>&#34;equal&#34;</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;greater&#34;</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;less&#34;</span><span style=color:#111>]</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#d88200>    下面的代码等价于:
</span></span></span><span style=display:flex><span><span style=color:#d88200>    group.add_watch_point(agent.internal, {
</span></span></span><span style=display:flex><span><span style=color:#d88200>        &#34;equal&#34;: wptr_compare_rptr(0),
</span></span></span><span style=display:flex><span><span style=color:#d88200>        &#34;greater&#34;: wptr_compare_rptr(1),
</span></span></span><span style=display:flex><span><span style=color:#d88200>        &#34;less&#34;: wptr_compare_rptr(2),
</span></span></span><span style=display:flex><span><span style=color:#d88200>    }, name=&#34;Compare wptr with rptr&#34;)
</span></span></span><span style=display:flex><span><span style=color:#d88200>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#111>group</span><span style=color:#f92672>.</span><span style=color:#111>add_watch_point</span><span style=color:#111>(</span><span style=color:#111>agent</span><span style=color:#f92672>.</span><span style=color:#111>internal</span><span style=color:#111>,</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#111>names</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>]:</span> <span style=color:#111>wptr_compare_rptr</span><span style=color:#111>(</span><span style=color:#111>i</span><span style=color:#111>)</span> <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#ae81ff>3</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>},</span> <span style=color:#111>name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;Compare wptr with rptr&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#111>group</span>
</span></span></code></pre></div><p>后续还想进一步扩充情况，不仅要维护<code>wptr_compare_rptr</code>，还要维护<code>names</code>中每种情况对应的名字，可以考虑引入 Python 中的枚举类 <code>Enum</code>：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Enum需要导入</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>enum</span> <span style=color:#f92672>import</span> <span style=color:#111>Enum</span><span style=color:#111>,</span> <span style=color:#111>auto</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>Compare</span><span style=color:#111>(</span><span style=color:#111>Enum</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#111>Equal</span> <span style=color:#f92672>=</span> <span style=color:#111>auto</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>    <span style=color:#111>WptrAhead</span> <span style=color:#f92672>=</span> <span style=color:#111>auto</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>    <span style=color:#111>RptrAhead</span> <span style=color:#f92672>=</span> <span style=color:#111>auto</span><span style=color:#111>()</span>
</span></span></code></pre></div><p>我们就可以通过<code>Compare</code>类的<code>__members__.items()</code>方法，得到每种情况的名字和对应的值：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>for</span> <span style=color:#111>name</span><span style=color:#111>,</span> <span style=color:#111>value</span> <span style=color:#f92672>in</span> <span style=color:#111>Compare</span><span style=color:#f92672>.</span><span style=color:#111>__members__</span><span style=color:#f92672>.</span><span style=color:#111>items</span><span style=color:#111>():</span>
</span></span><span style=display:flex><span>    <span style=color:#111>print</span><span style=color:#111>(</span><span style=color:#111>name</span><span style=color:#111>,</span> <span style=color:#111>value</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 输出</span>
</span></span><span style=display:flex><span><span style=color:#111>Equal</span> <span style=color:#111>Compare</span><span style=color:#f92672>.</span><span style=color:#111>Equal</span>
</span></span><span style=display:flex><span><span style=color:#111>WptrAhead</span> <span style=color:#111>Compare</span><span style=color:#f92672>.</span><span style=color:#111>WptrAhead</span>
</span></span><span style=display:flex><span><span style=color:#111>RptrAhead</span> <span style=color:#111>Compare</span><span style=color:#f92672>.</span><span style=color:#111>RptrAhead</span>
</span></span></code></pre></div><p>完整的代码就变成：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>get_cover_group_pointer_comparefuck</span><span style=color:#111>(</span><span style=color:#111>agent</span><span style=color:#111>:</span> <span style=color:#111>FIFOAgent</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>CovGroup</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>class</span> <span style=color:#75af00>Compare</span><span style=color:#111>(</span><span style=color:#111>Enum</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>Equal</span> <span style=color:#f92672>=</span> <span style=color:#111>auto</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#111>WptrAhead</span> <span style=color:#f92672>=</span> <span style=color:#111>auto</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#111>RptrAhead</span> <span style=color:#f92672>=</span> <span style=color:#111>auto</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Define coverage conditions</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>wptr_compare_rptr</span><span style=color:#111>(</span><span style=color:#111>compare_type</span><span style=color:#111>:</span> <span style=color:#111>Compare</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>def</span> <span style=color:#75af00>compare</span><span style=color:#111>(</span><span style=color:#111>bundle</span><span style=color:#111>:</span> <span style=color:#111>InternalBundle</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>bool</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>if</span> <span style=color:#111>compare_type</span> <span style=color:#f92672>is</span> <span style=color:#111>Compare</span><span style=color:#f92672>.</span><span style=color:#111>Equal</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>                <span style=color:#00a8c8>return</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>wptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>==</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>rptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>elif</span> <span style=color:#111>compare_type</span> <span style=color:#f92672>is</span> <span style=color:#111>Compare</span><span style=color:#f92672>.</span><span style=color:#111>WptrAhead</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>                <span style=color:#00a8c8>return</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>wptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>&gt;</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>rptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>else</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>                <span style=color:#00a8c8>return</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>wptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>rptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>return</span> <span style=color:#111>compare</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Create coverage group</span>
</span></span><span style=display:flex><span>    <span style=color:#111>group</span> <span style=color:#f92672>=</span> <span style=color:#111>CovGroup</span><span style=color:#111>(</span><span style=color:#d88200>&#34;Pointer compare&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Add coverage points</span>
</span></span><span style=display:flex><span>    <span style=color:#111>group</span><span style=color:#f92672>.</span><span style=color:#111>add_watch_point</span><span style=color:#111>(</span><span style=color:#111>agent</span><span style=color:#f92672>.</span><span style=color:#111>internal</span><span style=color:#111>,</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#111>name</span><span style=color:#111>:</span> <span style=color:#111>wptr_compare_rptr</span><span style=color:#111>(</span><span style=color:#111>compare</span><span style=color:#111>)</span> <span style=color:#00a8c8>for</span> <span style=color:#111>name</span><span style=color:#111>,</span> <span style=color:#111>compare</span> <span style=color:#f92672>in</span> <span style=color:#111>Compare</span><span style=color:#f92672>.</span><span style=color:#111>__members__</span><span style=color:#f92672>.</span><span style=color:#111>items</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>    <span style=color:#111>},</span> <span style=color:#111>name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;Compare wptr with rptr&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#111>group</span>
</span></span></code></pre></div><p>如果你使用的 Python 版本≥ 3.11，还可以使用<code>match... case</code>语句来编写<code>wptr_compare_rptr</code>，抛弃繁琐的<code>if... elif... else...</code>结构：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Version of python &gt;= 3.11</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>wptr_compare_rptr</span><span style=color:#111>(</span><span style=color:#111>compare_type</span><span style=color:#111>:</span> <span style=color:#111>Compare</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>compare</span><span style=color:#111>(</span><span style=color:#111>bundle</span><span style=color:#111>:</span> <span style=color:#111>InternalBundle</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>bool</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>match</span> <span style=color:#111>compare_type</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>case</span> <span style=color:#111>Compare</span><span style=color:#f92672>.</span><span style=color:#111>Equal</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>                <span style=color:#00a8c8>return</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>wptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>==</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>rptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>case</span> <span style=color:#111>Compare</span><span style=color:#f92672>.</span><span style=color:#111>WptrAhead</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>                <span style=color:#00a8c8>return</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>wptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>&gt;</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>rptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>case</span> <span style=color:#111>Compare</span><span style=color:#f92672>.</span><span style=color:#111>RptrAhead</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>                <span style=color:#00a8c8>return</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>wptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>rptr</span><span style=color:#f92672>.</span><span style=color:#111>value</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>case</span> <span style=color:#111>_</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>                <span style=color:#00a8c8>return</span> <span style=color:#00a8c8>False</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#111>compare</span>
</span></span></code></pre></div><h3 id=覆盖率数据的收集与采样>覆盖率数据的收集与采样</h3><p>定义好 <code>CovGroup</code> 之后，需要在仿真过程中适时地调用其 <code>sample()</code> 方法来采集数据，判断哪些 Bins 被命中。</p><h4 id=时钟上升沿采样>时钟上升沿采样</h4><p>最常见的方式是在每个时钟周期的固定上升沿，对所有需要周期性检查的覆盖组进行采样。toffee-test 提供了便捷的机制来实现这一点：</p><ul><li><p>在测试的 fixture （例如 <code>agent</code> fixture） 中，实例化所有需要周期性采样的 <code>CovGroup</code> 对象。</p></li><li><p>将这些 <code>CovGroup</code> 对象放入一个列表。</p></li><li><p>调用 <code>toffee_request.add_cov_groups(your_group_list)</code>。</p></li></ul><p><code>add_cov_groups</code> 会自动完成以下工作：</p><ol><li><p>注册列表中的每个 <code>CovGroup</code>，使其 <code>sample()</code> 方法在每个时钟上升沿被自动调用。</p></li><li><p>在测试结束时，自动将这些 <code>CovGroup</code> 的覆盖率统计结果导出到报告中。</p></li></ol><p>以下面代码为例，每个测试函数传入的是一个 agent 对象：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75af00>@toffee_test.fixture</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>agent</span><span style=color:#111>(</span><span style=color:#111>toffee_request</span><span style=color:#111>:</span> <span style=color:#111>toffee_test</span><span style=color:#f92672>.</span><span style=color:#111>ToffeeRequest</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Creat DUT</span>
</span></span><span style=display:flex><span>    <span style=color:#111>fifo_dut</span><span style=color:#111>:</span> <span style=color:#111>DUTSyncFIFO</span> <span style=color:#f92672>=</span> <span style=color:#111>toffee_request</span><span style=color:#f92672>.</span><span style=color:#111>create_dut</span><span style=color:#111>(</span><span style=color:#111>DUTSyncFIFO</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;clk&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Start clock</span>
</span></span><span style=display:flex><span>    <span style=color:#111>start_clock</span><span style=color:#111>(</span><span style=color:#111>fifo_dut</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Create bundles</span>
</span></span><span style=display:flex><span>    <span style=color:#111>read</span> <span style=color:#f92672>=</span> <span style=color:#111>ReadBundle</span><span style=color:#111>()</span><span style=color:#f92672>.</span><span style=color:#111>bind</span><span style=color:#111>(</span><span style=color:#111>fifo_dut</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>write</span> <span style=color:#f92672>=</span> <span style=color:#111>WriteBundle</span><span style=color:#111>()</span><span style=color:#f92672>.</span><span style=color:#111>bind</span><span style=color:#111>(</span><span style=color:#111>fifo_dut</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>internal</span> <span style=color:#f92672>=</span> <span style=color:#111>InternalBundle</span><span style=color:#111>()</span><span style=color:#f92672>.</span><span style=color:#111>from_prefix</span><span style=color:#111>(</span><span style=color:#d88200>&#34;SyncFIFO_&#34;</span><span style=color:#111>)</span><span style=color:#f92672>.</span><span style=color:#111>bind</span><span style=color:#111>(</span><span style=color:#111>fifo_dut</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Create agent</span>
</span></span><span style=display:flex><span>    <span style=color:#111>fifo_agent</span> <span style=color:#f92672>=</span> <span style=color:#111>FIFOAgent</span><span style=color:#111>(</span><span style=color:#111>fifo_dut</span><span style=color:#f92672>.</span><span style=color:#111>rst_n</span><span style=color:#111>,</span> <span style=color:#111>read</span><span style=color:#111>,</span> <span style=color:#111>write</span><span style=color:#111>,</span> <span style=color:#111>internal</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 自动在时钟上升沿注册、收集覆盖率信息</span>
</span></span><span style=display:flex><span>    <span style=color:#111>toffee_request</span><span style=color:#f92672>.</span><span style=color:#111>add_cov_groups</span><span style=color:#111>([</span>
</span></span><span style=display:flex><span>        <span style=color:#111>get_cover_group_basic_operations</span><span style=color:#111>(</span><span style=color:#111>fifo_agent</span><span style=color:#111>),</span>
</span></span><span style=display:flex><span>        <span style=color:#111>get_cover_group_fifo_state</span><span style=color:#111>(</span><span style=color:#111>fifo_agent</span><span style=color:#111>),</span>
</span></span><span style=display:flex><span>        <span style=color:#111>get_cover_group_boundary_operations</span><span style=color:#111>(</span><span style=color:#111>fifo_agent</span><span style=color:#111>),</span>
</span></span><span style=display:flex><span>        <span style=color:#111>get_cover_group_pointer_compare</span><span style=color:#111>(</span><span style=color:#111>fifo_agent</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>])</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#111>fifo_agent</span>
</span></span></code></pre></div><h4 id=基于特定时序或条件的采样>基于特定时序或条件的采样</h4><p>有些覆盖点需要在满足特定<strong>时序序列</strong>或<strong>复杂条件</strong>后才进行采样，而不是每个时钟周期都采样。例如，FIFO 指针回绕 （<code>wraparound</code>） 的覆盖，需要在指针先达到最大值 <code>0xf</code>，<strong>然后</strong>变为 <code>0</code> 的那一刻才采样。</p><p>对于这种情况，不能使用 <code>add_cov_groups</code> 的自动采样。需要：</p><ol><li><p><strong>手动实例化</strong> <code>CovGroup</code>，但不添加到 <code>add_cov_groups</code> 的列表中。</p></li><li><p><strong>编写异步任务</strong> （<code>async def</code> 函数），该任务负责监测触发采样的序列或条件。</p></li><li><p>在异步任务内部，当序列或条件满足时，<strong>手动调用</strong> <code>your_group.sample()</code>。</p></li><li><p><strong>启动异步任务：</strong>使用 <code>toffee.create_task()</code>来启动这个监测任务，让它在后台独立运行。</p></li><li><p><strong>确保覆盖率结果被导出：</strong> 由于该 <code>CovGroup</code> 未通过 <code>add_cov_groups</code> 注册，测试框架默认不会导出其结果。需要在 fixture 的 <code>yield</code> 之后 （即测试函数执行完毕后），手动将这个 <code>CovGroup</code> 对象添加到 <code>toffee_request.cov_groups</code> 列表中。</p></li></ol><p><strong><code>yield</code> 在 fixture 中的作用</strong></p><p>当 fixture 使用 <code>yield</code> 而不是 <code>return</code> 来提供对象时：</p><ul><li><p><code>yield</code> 之前的代码在测试函数开始前执行。</p></li><li><p><code>yield</code> 提供的值（例如 <code>fifo_agent</code>）被传递给测试函数。</p></li><li><p>测试函数执行。</p></li><li><p>测试函数执行完毕后，程序流程<strong>返回</strong>到 fixture 函数中，从 <code>yield</code> 语句之后继续执行。这提供了一个执行“后处理”代码的机会。</p></li></ul><p>以同步 FIFO 为例，读指针<code>rptr</code>和写指针<code>wptr</code>在达到最大值 15 之后，再次增加后值会变为 0。如果要对相关的覆盖组进行采样，可以让覆盖点的条件选为指针值为 0，与之相关的覆盖组定义为：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>get_cover_group_pointer_wraparound</span><span style=color:#111>(</span><span style=color:#111>is_wptr</span><span style=color:#111>:</span> <span style=color:#111>int</span><span style=color:#111>,</span> <span style=color:#111>agent</span><span style=color:#111>:</span> <span style=color:#111>FIFOAgent</span><span style=color:#111>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#111>CovGroup</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Define coverage conditions</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>wraparound_ptr</span><span style=color:#111>(</span><span style=color:#111>bundle</span><span style=color:#111>:</span> <span style=color:#111>InternalBundle</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>return</span> <span style=color:#111>(</span><span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>wptr</span> <span style=color:#00a8c8>if</span> <span style=color:#111>is_wptr</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#00a8c8>else</span> <span style=color:#111>bundle</span><span style=color:#f92672>.</span><span style=color:#111>rptr</span><span style=color:#111>)</span><span style=color:#f92672>.</span><span style=color:#111>value</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Create coverage group</span>
</span></span><span style=display:flex><span>    <span style=color:#111>group</span> <span style=color:#f92672>=</span> <span style=color:#111>CovGroup</span><span style=color:#111>(</span><span style=color:#d88200>&#34;Pointer wraparound&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Add coverage points</span>
</span></span><span style=display:flex><span>    <span style=color:#111>name</span> <span style=color:#f92672>=</span> <span style=color:#d88200>&#34;Write ptr&#34;</span> <span style=color:#00a8c8>if</span> <span style=color:#111>is_wptr</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#00a8c8>else</span> <span style=color:#d88200>&#34;Read ptr&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#111>group</span><span style=color:#f92672>.</span><span style=color:#111>add_watch_point</span><span style=color:#111>(</span><span style=color:#111>agent</span><span style=color:#f92672>.</span><span style=color:#111>internal</span><span style=color:#111>,</span> <span style=color:#111>{</span><span style=color:#d88200>&#34;event&#34;</span><span style=color:#111>:</span> <span style=color:#111>wraparound_ptr</span><span style=color:#111>},</span> <span style=color:#111>name</span><span style=color:#f92672>=</span><span style=color:#d88200>f</span><span style=color:#d88200>&#34;</span><span style=color:#d88200>{</span><span style=color:#111>name</span><span style=color:#d88200>}</span><span style=color:#d88200> wraparound&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>return</span> <span style=color:#111>group</span>
</span></span></code></pre></div><p>在上面的代码中，我们可以通过控制<code>is_wptr</code>来实例化具有相同名字的覆盖组，但是里面的覆盖点分别对读、写指针进行采样。这两个点的结果最后都会合并到覆盖组<code>Pointer wraparound</code>中。</p><blockquote><p>多个同名的<code>CovGroup</code>对象的采样结果会在报告中合并，但其中同名覆盖点的 Bins 结构必须保持一致！</p></blockquote><p>为了监测时序关系，我们可以定义一个异步函数<code>wraparound_sequence</code>，在一个无限循环中不断监测指针的值，当值达到 15 之后，再等待指针的结果变为 0 后进行采样，fixture 部分的完整代码为：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#111>toffee_test</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>toffee</span> <span style=color:#f92672>import</span> <span style=color:#111>create_task</span><span style=color:#111>,</span> <span style=color:#111>Value</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75af00>@toffee_test.fixture</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>agent</span><span style=color:#111>(</span><span style=color:#111>toffee_request</span><span style=color:#111>:</span> <span style=color:#111>toffee_test</span><span style=color:#f92672>.</span><span style=color:#111>ToffeeRequest</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#111>fifo_dut</span><span style=color:#111>:</span> <span style=color:#111>DUTSyncFIFO</span> <span style=color:#f92672>=</span> <span style=color:#111>toffee_request</span><span style=color:#f92672>.</span><span style=color:#111>create_dut</span><span style=color:#111>(</span><span style=color:#111>DUTSyncFIFO</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;clk&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>start_clock</span><span style=color:#111>(</span><span style=color:#111>fifo_dut</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>read</span> <span style=color:#f92672>=</span> <span style=color:#111>ReadBundle</span><span style=color:#111>()</span><span style=color:#f92672>.</span><span style=color:#111>bind</span><span style=color:#111>(</span><span style=color:#111>fifo_dut</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>write</span> <span style=color:#f92672>=</span> <span style=color:#111>WriteBundle</span><span style=color:#111>()</span><span style=color:#f92672>.</span><span style=color:#111>bind</span><span style=color:#111>(</span><span style=color:#111>fifo_dut</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>internal</span> <span style=color:#f92672>=</span> <span style=color:#111>InternalBundle</span><span style=color:#111>()</span><span style=color:#f92672>.</span><span style=color:#111>from_prefix</span><span style=color:#111>(</span><span style=color:#d88200>&#34;SyncFIFO_&#34;</span><span style=color:#111>)</span><span style=color:#f92672>.</span><span style=color:#111>bind</span><span style=color:#111>(</span><span style=color:#111>fifo_dut</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>fifo_agent</span> <span style=color:#f92672>=</span> <span style=color:#111>FIFOAgent</span><span style=color:#111>(</span><span style=color:#111>fifo_dut</span><span style=color:#f92672>.</span><span style=color:#111>rst_n</span><span style=color:#111>,</span> <span style=color:#111>read</span><span style=color:#111>,</span> <span style=color:#111>write</span><span style=color:#111>,</span> <span style=color:#111>internal</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>toffee_request</span><span style=color:#f92672>.</span><span style=color:#111>add_cov_groups</span><span style=color:#111>([</span>
</span></span><span style=display:flex><span>        <span style=color:#111>get_cover_group_basic_operations</span><span style=color:#111>(</span><span style=color:#111>fifo_agent</span><span style=color:#111>),</span>
</span></span><span style=display:flex><span>        <span style=color:#111>get_cover_group_fifo_state</span><span style=color:#111>(</span><span style=color:#111>fifo_agent</span><span style=color:#111>),</span>
</span></span><span style=display:flex><span>        <span style=color:#111>get_cover_group_boundary_operations</span><span style=color:#111>(</span><span style=color:#111>fifo_agent</span><span style=color:#111>),</span>
</span></span><span style=display:flex><span>        <span style=color:#111>get_cover_group_pointer_compare</span><span style=color:#111>(</span><span style=color:#111>fifo_agent</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#111>])</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Custom sample group</span>
</span></span><span style=display:flex><span>    <span style=color:#111>cover_pointer_wraparound</span> <span style=color:#f92672>=</span> <span style=color:#111>[</span><span style=color:#111>get_cover_group_pointer_wraparound</span><span style=color:#111>(</span><span style=color:#111>x</span><span style=color:#111>,</span> <span style=color:#111>fifo_agent</span><span style=color:#111>)</span> <span style=color:#00a8c8>for</span> <span style=color:#111>x</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#ae81ff>2</span><span style=color:#111>)]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Time sequences</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>wraparound_sequence</span><span style=color:#111>(</span><span style=color:#111>is_wptr</span><span style=color:#111>:</span> <span style=color:#111>bool</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>ptr</span> <span style=color:#f92672>=</span> <span style=color:#111>fifo_agent</span><span style=color:#f92672>.</span><span style=color:#111>internal</span><span style=color:#f92672>.</span><span style=color:#111>wptr</span> <span style=color:#00a8c8>if</span> <span style=color:#111>is_wptr</span> <span style=color:#00a8c8>else</span> <span style=color:#111>fifo_agent</span><span style=color:#f92672>.</span><span style=color:#111>internal</span><span style=color:#f92672>.</span><span style=color:#111>rptr</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>while</span> <span style=color:#00a8c8>True</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>await</span> <span style=color:#111>Value</span><span style=color:#111>(</span><span style=color:#111>ptr</span><span style=color:#111>,</span> <span style=color:#ae81ff>0xf</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>await</span> <span style=color:#111>Value</span><span style=color:#111>(</span><span style=color:#111>ptr</span><span style=color:#111>,</span> <span style=color:#ae81ff>0</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>            <span style=color:#111>cover_pointer_wraparound</span><span style=color:#111>[</span><span style=color:#111>is_wptr</span><span style=color:#111>]</span><span style=color:#f92672>.</span><span style=color:#111>sample</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Detecting sequence</span>
</span></span><span style=display:flex><span>    <span style=color:#111>create_task</span><span style=color:#111>(</span><span style=color:#111>wraparound_sequence</span><span style=color:#111>(</span><span style=color:#00a8c8>False</span><span style=color:#111>))</span>
</span></span><span style=display:flex><span>    <span style=color:#111>create_task</span><span style=color:#111>(</span><span style=color:#111>wraparound_sequence</span><span style=color:#111>(</span><span style=color:#00a8c8>True</span><span style=color:#111>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>yield</span> <span style=color:#111>fifo_agent</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 把 cover_pointer_wraparound 中的元素合并到 cov_groups 中</span>
</span></span><span style=display:flex><span>    <span style=color:#111>toffee_request</span><span style=color:#f92672>.</span><span style=color:#111>cov_groups</span><span style=color:#f92672>.</span><span style=color:#111>extend</span><span style=color:#111>(</span><span style=color:#111>cover_pointer_wraparound</span><span style=color:#111>)</span>
</span></span></code></pre></div><p><strong>关于 <code>create_task</code></strong>：</p><p>在上面的代码中，我们使用了 <code>create_task(coroutine)</code>。这是一个关键的异步编程工具，它的作用是：</p><ul><li><p>接收一个协程对象（如 <code>wraparound_sequence(True)</code> 的调用结果）。</p></li><li><p>将这个协程<strong>安排到事件循环中</strong>，使其尽快开始执行，成为一个<strong>独立的后台任务</strong>。</p></li><li><p><code>create_task</code> 本身<strong>立即返回</strong>一个 <code>Task</code> 对象（可以用于后续管理，如取消任务、后续用<code>await</code>等待完成），而<strong>不会直接等待</strong>它所启动的协程执行完成。</p></li></ul><p>这与 <code>await coroutine</code> 不同，<code>await</code> 会暂停当前流程直到被等待的协程完成。而 <code>create_task</code> 允许我们“发射”一个任务让它在后台运行，同时当前代码流可以继续执行其他事情。</p><p>通过 <code>create_task</code>，我们可以让多个验证逻辑片段真正地并发运行，互相协作，共同完成验证任务。</p><h2 id=75-小结>7.5 小结</h2><p>功能覆盖率是衡量验证完备性的核心指标，它关注设计功能是否按预期被测试到。通过在 Toffee 中使用 <code>CovGroup</code> 和 <code>add_watch_point</code> 定义覆盖模型，结合周期性自动采样和基于特定序列的手动采样，我们可以有效地收集覆盖率数据，发现验证漏洞，并最终提高验证质量。</p><h2 id=76-练习x20>7.6 练习</h2><p>本节的练习已经发布，请查阅<a href=/beginner/task/toffee/>【学习任务2: Toffee 部分】 4. 收集功能覆盖率</a>。</p><hr><h1 id=8-打包验证环境>8. 打包验证环境</h1><p>随着验证环境变得复杂，我们需要一个更高层次的容器来管理它们。<code>Env</code>在 Toffee 中就扮演了这个角色。</p><p>它的主要职责包括：</p><ul><li><p><strong>实例化组件</strong>：在 <code>Env</code> 内部实例化验证环境中所需的所有 <code>Agent</code> 组件。</p></li><li><p><strong>管理接口连接</strong>：负责确保每个 <code>Agent</code> 都获得了正确的 <code>Bundle</code> 接口实例，<code>Bundle</code> 通常代表了与待验证设计（DUT）交互的物理或逻辑接口。</p></li><li><p><strong>定义参考模型规范</strong>：<code>Env</code> 的结构（即其包含的 <code>Agent</code> 及其方法）隐式地定义了参考模型（Reference Model）需要遵循的接口规范。</p></li><li><p><strong>集成与同步参考模型</strong>：对于遵循规范编写的参考模型，<code>Env</code> 提供了附加（attach）机制，并负责在运行时自动将测试激励和监测数据同步给这些模型。</p></li></ul><h2 id=81-创建-env>8.1 创建 Env</h2><p>要定义一个具体的验证环境，你需要创建一个新的 Python 类，并让它继承自 Toffee 提供的 <code>toffee.env.Env</code> 基类。在你的自定义 <code>Env</code> 类中，通常会在其初始化方法 （<code>__init__</code>） 中完成 <code>Agent</code> 的实例化。</p><p>以下是一个简单的 <code>Env</code> 定义示例：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>toffee.env</span> <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>DualPortStackEnv</span><span style=color:#111>(</span><span style=color:#111>Env</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#d88200>&#34;&#34;&#34;一个包含两个栈接口 Agent 的验证环境示例&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#111>__init__</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>port1_bundle</span><span style=color:#111>:</span> <span style=color:#111>StackPortBundle</span><span style=color:#111>,</span> <span style=color:#111>port2_bundle</span><span style=color:#111>:</span> <span style=color:#111>StackPortBundle</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 调用父类的初始化方法</span>
</span></span><span style=display:flex><span>        <span style=color:#111>super</span><span style=color:#111>()</span><span style=color:#f92672>.</span><span style=color:#111>__init__</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 在 Env 内部实例化所需的 Agent，并将 Bundle 传递给它们</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Agent 实例通常作为 Env 的属性，方便后续访问</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>port1_agent</span> <span style=color:#f92672>=</span> <span style=color:#111>StackAgent</span><span style=color:#111>(</span><span style=color:#111>port1_bundle</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>port2_agent</span> <span style=color:#f92672>=</span> <span style=color:#111>StackAgent</span><span style=color:#111>(</span><span style=color:#111>port2_bundle</span><span style=color:#111>)</span>
</span></span></code></pre></div><p>在这个例子中：</p><ul><li><p>我们定义了 <code>DualPortStackEnv</code> 类，继承自 <code>Env</code>。</p></li><li><p><code>__init__</code> 方法接收两个 <code>Bundle</code> 对象作为参数。</p></li><li><p>在 <code>__init__</code> 内部，我们实例化了两个 <code>StackAgent</code>，分别命名为 <code>port1_agent</code> 和 <code>port2_agent</code>，并将对应的 <code>Bundle</code> 对象传递给了它们。这两个 <code>Agent</code> 现在成为了 <code>DualPortStackEnv</code> 实例的属性。</p></li></ul><p><code>Bundle</code> 的连接可以在 <code>Env</code> 外部完成，也可以在 <code>Env</code> 内部实现。关键在于确保每个 <code>Agent</code> 都接收到了正确的 <code>Bundle</code> 实例。</p><p>如果当前验证场景不需要编写参考模型进行行为比对，那么至此，验证环境的核心结构已经搭建完毕。可以直接编写测试用例，并在用例中使用 <code>Env</code> 实例及其包含的 <code>Agent</code> 提供的接口与待验证设计（DUT）进行交互，例如：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 假设 StackPortBundle 和 DualPortStackEnv 已定义</span>
</span></span><span style=display:flex><span><span style=color:#111>port1_bundle</span> <span style=color:#f92672>=</span> <span style=color:#111>StackPortBundle</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span><span style=color:#111>port2_bundle</span> <span style=color:#f92672>=</span> <span style=color:#111>StackPortBundle</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span><span style=color:#111>env</span> <span style=color:#f92672>=</span> <span style=color:#111>DualPortStackEnv</span><span style=color:#111>(</span><span style=color:#111>port1_bundle</span><span style=color:#111>,</span> <span style=color:#111>port2_bundle</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 通过 Env 访问 Agent 的方法来驱动 DUT 或获取数据</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>await</span> <span style=color:#111>env</span><span style=color:#f92672>.</span><span style=color:#111>port1_agent</span><span style=color:#f92672>.</span><span style=color:#111>push</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>await</span> <span style=color:#111>env</span><span style=color:#f92672>.</span><span style=color:#111>port2_agent</span><span style=color:#f92672>.</span><span style=color:#111>push</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span><span style=color:#111>print</span><span style=color:#111>(</span><span style=color:#00a8c8>await</span> <span style=color:#111>env</span><span style=color:#f92672>.</span><span style=color:#111>port1_agent</span><span style=color:#f92672>.</span><span style=color:#111>pop</span><span style=color:#111>())</span>
</span></span><span style=display:flex><span><span style=color:#111>print</span><span style=color:#111>(</span><span style=color:#00a8c8>await</span> <span style=color:#111>env</span><span style=color:#f92672>.</span><span style=color:#111>port2_agent</span><span style=color:#f92672>.</span><span style=color:#111>pop</span><span style=color:#111>())</span>
</span></span></code></pre></div><h2 id=82-绑定参考模型>8.2 绑定参考模型</h2><p>如前所述，<code>Env</code> 的结构定义了其包含的所有 <code>Agent</code> 及其方法（包括驱动方法和监测方法），这构成了验证环境的外部接口。例如，对于上述 <code>DualPortStackEnv</code>，其接口结构可以表示为：</p><pre tabindex=0><code class="language-plain text" data-lang="plain text">DualPortStackEnv
  - port1_agent (类型: StackAgent)
    - @driver_method push(data)
    - @driver_method pop() -&gt; value
    - @monitor_method some_monitor() -&gt; value
  - port2_agent (类型: StackAgent)
    - @driver_method push(data)
    - @driver_method pop() -&gt; value
    - @monitor_method some_monitor() -&gt; value
</code></pre><p>参考模型（Reference Model）的编写需要遵循这个由 <code>Env</code> 定义的接口规范。符合规范的参考模型可以使用 <code>attach</code> 方法附加到 <code>Env</code> 实例上。<code>Env</code> 负责将测试用例对 <code>Agent</code> 驱动方法的调用以及 <code>Agent</code> 监测方法获取的数据，自动同步给所有附加的参考模型。附加操作示例如下：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>env</span> <span style=color:#f92672>=</span> <span style=color:#111>DualPortStackEnv</span><span style=color:#111>(</span><span style=color:#111>port1_bundle</span><span style=color:#111>,</span> <span style=color:#111>port2_bundle</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span><span style=color:#111>env</span><span style=color:#f92672>.</span><span style=color:#111>attach</span><span style=color:#111>(</span><span style=color:#111>StackRefModel</span><span style=color:#111>())</span>
</span></span></code></pre></div><p>一个 <code>Env</code> 实例可以附加多个参考模型。所有附加的参考模型都会被 <code>Env</code> 自动管理和同步。参考模型的具体编写方法将在下一节详细介绍。</p><hr><h1 id=9-编写参考模型>9. 编写参考模型</h1><p><strong>参考模型</strong>（Reference Model）在芯片验证中扮演着关键角色，它通常用于模拟待验证设计（DUT）的预期行为。在验证过程中，通过比较参考模型的输出与 DUT 的实际输出，可以判断 DUT 的功能是否正确</p><blockquote><p>参考模型还有其他称呼，例如黄金模型（Golden model），预测器（Predictor）等。</p></blockquote><p>在 Toffee 验证环境中，参考模型需要遵循其所附加的 <code>Env</code> 定义的接口规范。这样，<code>Env</code> 才能够自动地将驱动操作和监测数据同步给参考模型，实现自动化验证。</p><h2 id=91-参考模型的实现方式>9.1 参考模型的实现方式</h2><p>Toffee 框架为参考模型的实现提供了两种主要模式。开发者可以根据参考模型的复杂度、状态管理需求以及与 DUT 交互的时序特性来选择最合适的模式。这两种模式编写的模型均可通过 <code>Env</code> 的 <code>attach</code> 方法进行集成和自动同步。</p><ol><li><p><strong>函数调用模式</strong>：参考模型的行为由一系列响应特定事件（方法调用）的<strong>钩子函数</strong>来定义。框架在检测到匹配的事件时，自动调用这些钩子函数。</p></li><li><p><strong>独立执行流模式</strong>：参考模型的行为被封装在一个或多个独立的、通常是异步的执行流程中（如 <code>async def main</code>）。模型在此流程中<strong>主动</strong>通过<strong>端口</strong> 等待并获取数据，控制自己的执行逻辑。</p></li></ol><h3 id=如何选择实现模式>如何选择实现模式？</h3><ul><li><p><strong>函数调用模式</strong>：</p><ul><li><p><strong>优点</strong>：实现相对简单直接，尤其适用于无状态或状态逻辑简单的模型。框架自动处理驱动方法返回值的比较，减少了样板代码。</p></li><li><p><strong>缺点</strong>：对于具有复杂状态、需要精细控制内部时序或处理多接口间复杂依赖关系的模型，可能会变得难以管理。模型是被动响应事件的。</p></li><li><p><strong>适用场景</strong>：简单的协议检查器、无状态的行为模型、主要关注点分离的多个小型模型等。</p></li></ul></li><li><p><strong>独立执行流模式</strong>：</p><ul><li><p><strong>优点</strong>：对模型内部状态和执行流程有完全的控制权，更适合模拟复杂的时序行为和状态机。模型可以主动管理数据流，处理接口间的复杂依赖。</p></li><li><p><strong>缺点</strong>：需要编写更多的控制流和比对逻辑代码。需要理解异步编程（<code>async/await</code>）。</p></li><li><p><strong>适用场景</strong>：复杂的总线功能模型（BFM）、需要模拟内部流水线或状态机的模型、需要精细控制事务处理流程的模型等。</p></li></ul></li></ul><p><strong>差异总结：</strong></p><p>接下来，我们将详细介绍如何编写这两种模式的参考模型。</p><h2 id=92-使用函数调用模式>9.2 使用函数调用模式</h2><p>此模式的核心是定义<strong>钩子函数 （Hook Functions）</strong> 并使用 Toffee 提供的装饰器（<code>@driver_hook</code>， <code>@monitor_hook</code>， <code>@agent_hook</code>）将其与 <code>Env</code> 中 <code>Agent</code> 的特定方法关联起来。</p><p>假设 <code>Env</code> 接口如下：</p><pre tabindex=0><code class="language-plain text" data-lang="plain text">StackEnv
  - port_agent
    - @driver_method push(data)
    - @driver_method pop() -&gt; value
    - @monitor_method monitor_pop_data() -&gt; item
</code></pre><h3 id=驱动函数钩子-driver_hook>驱动函数钩子 （@driver_hook）</h3><p>该装饰器用于响应 <code>Agent</code> 的驱动方法 （<code>@driver_method</code> 标记的方法） 调用。</p><h4 id=基本用法>基本用法</h4><p>使用 <code>@driver_hook</code> 装饰模型中的方法，需要通过 <code>agent_name</code> 和 <code>driver_name</code> 参数指定要匹配的 <code>Agent</code> 实例名和驱动方法名。</p><p>钩子函数的参数列表（除 <code>self</code> 外）必须与对应的驱动方法的参数列表一致。框架会自动比较钩子函数的返回值与驱动方法的实际返回值（如果驱动方法有返回值）。</p><p>下面为示例代码：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>toffee.model</span> <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>StackRefModel</span><span style=color:#111>(</span><span style=color:#111>Model</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#111>__init__</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>super</span><span style=color:#111>()</span><span style=color:#f92672>.</span><span style=color:#111>__init__</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 匹配 port_agent.push(data)</span>
</span></span><span style=display:flex><span>    <span style=color:#75af00>@driver_hook</span><span style=color:#111>(</span><span style=color:#111>agent_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;port_agent&#34;</span><span style=color:#111>,</span> <span style=color:#111>driver_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;push&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>handle_push</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>data</span><span style=color:#111>):</span> <span style=color:#75715e># 钩子函数名可自定义</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 匹配 port_agent.pop()</span>
</span></span><span style=display:flex><span>    <span style=color:#75af00>@driver_hook</span><span style=color:#111>(</span><span style=color:#111>agent_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;port_agent&#34;</span><span style=color:#111>,</span> <span style=color:#111>driver_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;pop&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>handle_pop</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>):</span> <span style=color:#75715e># 钩子函数名可自定义</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>pass</span>
</span></span></code></pre></div><h4 id=便捷匹配方式>便捷匹配方式</h4><p>Toffee 提供了几种简化匹配声明的方式：</p><ul><li><p><strong>路径指定</strong>：使用点号 <code>.</code> 连接 <code>agent_name</code> 和 <code>driver_name</code> 作为第一个参数。</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75af00>@driver_hook</span><span style=color:#111>(</span><span style=color:#d88200>&#34;port_agent.push&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>handle_push</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>data</span><span style=color:#111>):</span> 
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></div></li><li><p><strong>函数名匹配驱动名</strong>：如果钩子函数的名称与驱动方法的名称相同，可以省略 <code>driver_name</code> 参数。</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75af00>@driver_hook</span><span style=color:#111>(</span><span style=color:#111>agent_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;port_agent&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>push</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>data</span><span style=color:#111>):</span> <span style=color:#75715e># 函数名 &#39;push&#39; 匹配 driver_name=&#39;push&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span> 
</span></span></code></pre></div></li><li><p><strong>函数名同时匹配 Agent 与驱动名</strong>：函数名使用双下划线 <code>__</code> 分隔 <code>agent_name</code> 和 <code>driver_name</code>，此时 <code>@driver_hook()</code> 无需参数。</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75af00>@driver_hook</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>port_agent__push</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>data</span><span style=color:#111>):</span> <span style=color:#75715e># 函数名匹配 agent_name=&#39;port_agent&#39;, driver_name=&#39;push&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span> 
</span></span></code></pre></div></li></ul><h3 id=监测钩子函数-monitor_hook>监测钩子函数 （@monitor_hook）</h3><p>该装饰器用于接收并处理 <code>Agent</code> 的监测方法 （<code>@monitor_method</code> 标记的方法） 返回的数据。</p><h4 id=基本用法-1>基本用法</h4><p>使用 <code>@monitor_hook</code> 装饰模型中的方法，需要通过 <code>agent_name</code> 和 <code>monitor_name</code> 参数指定目标。</p><p>监测钩子函数除了 <code>self</code> 外，<strong>必须</strong>额外接收一个参数（通常命名为 <code>item</code> 或 <code>value</code>），该参数用于接收监测方法的返回值。<strong>开发者需要在此钩子函数体内实现对接收到的数据 （<code>item</code>） 的检查逻辑</strong>。</p><p>下面为示例代码：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>StackRefModel</span><span style=color:#111>(</span><span style=color:#111>Model</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 匹配 port_agent.monitor_pop_data()</span>
</span></span><span style=display:flex><span>    <span style=color:#75af00>@monitor_hook</span><span style=color:#111>(</span><span style=color:#111>agent_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;port_agent&#34;</span><span style=color:#111>,</span> <span style=color:#111>monitor_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;monitor_pop_data&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>monitor_pop_data</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>item</span><span style=color:#111>):</span> <span style=color:#75715e># item 是 monitor_pop_data 的返回值</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>pass</span>
</span></span></code></pre></div><h4 id=便捷匹配方法>便捷匹配方法</h4><p><code>@monitor_hook</code> 支持与 <code>@driver_hook</code> 相同的所有便捷匹配方式（路径、函数名匹配 <code>monitor_name</code>、<code>__</code> 约定）。</p><h3 id=agent-钩子agent_hook>Agent 钩子（@agent_hook）</h3><p>该装饰器提供一种机制，让一个钩子函数能够处理某个 <code>Agent</code> 下的所有（或指定的多个）驱动和监测方法的调用/数据。</p><h4 id=基本用法-2>基本用法</h4><p>使用 <code>@agent_hook</code> 装饰模型方法，需要通过 <code>agent_name</code> 参数指定目标 <code>Agent</code>。</p><p>钩子函数通常需要接收 <code>self</code>、 <code>name</code> （被调用的方法名） 和 <code>item</code> （对驱动方法是参数字典或元组，对监测方法是返回值） 这三个参数。</p><p>下面为示例代码：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>StackRefModel</span><span style=color:#111>(</span><span style=color:#111>Model</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75af00>@agent_hook</span><span style=color:#111>(</span><span style=color:#d88200>&#34;port_agent&#34;</span><span style=color:#111>)</span> <span style=color:#75715e># 匹配 port_agent 下的所有方法</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>port_agent</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>name</span><span style=color:#111>,</span> <span style=color:#111>item</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>print</span><span style=color:#111>(</span><span style=color:#d88200>f</span><span style=color:#d88200>&#34;Model: Agent &#39;port_agent&#39; method &#39;</span><span style=color:#d88200>{</span><span style=color:#111>name</span><span style=color:#d88200>}</span><span style=color:#d88200>&#39; called/monitored.&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>pass</span>
</span></span></code></pre></div><h4 id=便捷匹配与高级选项>便捷匹配与高级选项</h4><ul><li><p><strong>省略 <code>agent_name</code></strong>：当钩子函数名与 <code>Agent</code> 名称相同时，<code>@agent_hook()</code> 无需参数。</p></li><li><p><strong><code>agents</code> 参数</strong>：使用列表匹配多个 Agent （<code>agents=["agent1", "agent2"]</code>）。</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>StackRefModel</span><span style=color:#111>(</span><span style=color:#111>Model</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#75af00>@agent_hook</span><span style=color:#111>(</span><span style=color:#111>agents</span><span style=color:#f92672>=</span><span style=color:#111>[</span><span style=color:#d88200>&#34;port_agent&#34;</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;port_agent2&#34;</span><span style=color:#111>])</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>port_agent</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>driver_name</span><span style=color:#111>,</span> <span style=color:#111>args</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>pass</span>
</span></span></code></pre></div></li><li><p><strong><code>methods</code> 参数</strong>：使用列表仅匹配指定的方法 （<code>methods=["port_agent.push", "port_agent.pop", ...]</code>），方法名需包含 Agent 路径。</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>StackRefModel</span><span style=color:#111>(</span><span style=color:#111>Model</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#75af00>@agent_hook</span><span style=color:#111>(</span><span style=color:#111>methods</span><span style=color:#f92672>=</span><span style=color:#111>[</span><span style=color:#d88200>&#34;port_agent.push&#34;</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;port_agent.pop&#34;</span><span style=color:#111>,</span> <span style=color:#d88200>&#34;port_agent2.monitor_pop_data&#34;</span><span style=color:#111>])</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#75af00>port_agent</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>driver_name</span><span style=color:#111>,</span> <span style=color:#111>args</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>pass</span>
</span></span></code></pre></div></li></ul><h3 id=hook-调用顺序>Hook 调用顺序</h3><p>在同一个仿真时间点或事件触发点，如果多个 Hook 匹配了同一个事件，可以通过参数配置它们的执行顺序。</p><ul><li><p><strong><code>priority</code> 参数</strong>：用于所有类型的 Hook （<code>@driver_hook</code>， <code>@monitor_hook</code>， <code>@agent_hook</code>）。数值越小，优先级越高（越先执行）。默认情况下，<code>@monitor_hook</code> 的优先级通常较高。</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75af00>@driver_hook</span><span style=color:#111>(</span><span style=color:#d88200>&#34;port_agent.push&#34;</span><span style=color:#111>,</span> <span style=color:#111>priority</span><span style=color:#f92672>=</span><span style=color:#ae81ff>10</span><span style=color:#111>)</span> <span style=color:#75715e># 优先级较低</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>push</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>data</span><span style=color:#111>):</span> <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75af00>@monitor_hook</span><span style=color:#111>(</span><span style=color:#d88200>&#34;port_agent.monitor_pop_data&#34;</span><span style=color:#111>,</span> <span style=color:#111>priority</span><span style=color:#f92672>=</span><span style=color:#ae81ff>5</span><span style=color:#111>)</span> <span style=color:#75715e># 优先级较高</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>monitor_pop_data</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>item</span><span style=color:#111>):</span> <span style=color:#f92672>...</span>
</span></span></code></pre></div></li><li><p><strong><code>sche_order</code> 参数</strong>：仅用于 <code>@driver_hook</code> 以及 <code>@agent_hook</code> 处理驱动方法时。它决定了 Hook 函数相对于 <code>Env</code> 中实际 <code>Agent</code> 驱动方法 （<code>@driver_method</code>） 的执行顺序。</p><ul><li><p><code>sche_order="model_first"</code> （默认值）: Hook 函数在驱动方法之前执行。</p></li><li><p><code>sche_order="dut_first"</code>： Hook 函数在驱动方法执行之后（通常是其完成后）执行。</p></li></ul><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75af00>@driver_hook</span><span style=color:#111>(</span><span style=color:#d88200>&#34;port_agent.push&#34;</span><span style=color:#111>,</span> <span style=color:#111>sche_order</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;dut_first&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>def</span> <span style=color:#75af00>push</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>,</span> <span style=color:#111>data</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 这个 hook 会在 env.port_agent.push() 实际驱动 DUT *之后* 执行</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>pass</span>
</span></span></code></pre></div></li></ul><h2 id=93-使用独立执行流模式>9.3 使用独立执行流模式</h2><p>此模式的核心是使用 Toffee 提供的 <strong>端口类</strong>（<code>DriverPort</code>， <code>MonitorPort</code>， <code>AgentPort</code>）在模型内部建立与 <code>Env</code> 接口的连接点，并通过一个或多个异步方法（通常是 <code>async def main</code>）来<strong>主动</strong>获取数据和执行模型逻辑。</p><h3 id=定义端口>定义端口</h3><p>首先，需要在模型的 <code>init</code> 方法中，实例化所需的端口类，并将它们与 <code>Env</code> 中 <code>Agent</code> 的目标方法进行匹配。端口是模型与外部（即 <code>Env</code> 同步过来的驱动调用和监测数据）交互的接口。</p><p><strong>基本用法</strong>：</p><ul><li><p><code>DriverPort(agent_name, driver_name)</code>：用于匹配 <code>Env</code> 中的驱动方法 （<code>@driver_method</code>）。模型通过从此端口获取数据来得知驱动方法何时被调用及其参数。</p></li><li><p><code>MonitorPort(agent_name, monitor_name)</code>：用于匹配 <code>Env</code> 中的监测方法 （<code>@monitor_method</code>）。模型通过从此端口获取数据来得知监测方法的返回值。</p></li><li><p><code>AgentPort(agent_name)</code>：一个端口匹配指定 <code>Agent</code> 下的所有驱动和监测方法。</p></li></ul><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>toffee.model</span> <span style=color:#f92672>import</span> <span style=color:#111>Model</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> <span style=color:#111>toffee.model_port</span> <span style=color:#f92672>import</span> <span style=color:#111>DriverPort</span><span style=color:#111>,</span> <span style=color:#111>MonitorPort</span><span style=color:#111>,</span> <span style=color:#111>AgentPort</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>StackRefModel</span><span style=color:#111>(</span><span style=color:#111>Model</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#111>__init__</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>super</span><span style=color:#111>()</span><span style=color:#f92672>.</span><span style=color:#111>__init__</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 示例：使用基本匹配方式定义端口</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>push_port</span> <span style=color:#f92672>=</span> <span style=color:#111>DriverPort</span><span style=color:#111>(</span><span style=color:#111>agent_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;port_agent&#34;</span><span style=color:#111>,</span> <span style=color:#111>driver_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;push&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>pop_port</span> <span style=color:#f92672>=</span> <span style=color:#111>DriverPort</span><span style=color:#111>(</span><span style=color:#111>agent_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;port_agent&#34;</span><span style=color:#111>,</span> <span style=color:#111>driver_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;pop&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>monitor_pop_data_port</span> <span style=color:#f92672>=</span> <span style=color:#111>MonitorPort</span><span style=color:#111>(</span><span style=color:#111>agent_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;port_agent&#34;</span><span style=color:#111>,</span> <span style=color:#111>monitor_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;monitor_pop_data&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 或者，可以只用一个 AgentPort 来处理该 agent 的所有交互</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># self.port_agent = AgentPort(agent_name=&#34;port_agent&#34;)</span>
</span></span></code></pre></div><h3 id=便捷匹配方式-1>便捷匹配方式</h3><p>端口实例化同样支持便捷匹配规则，这些规则应用于<strong>实例变量名</strong>和构造函数参数：</p><ul><li><strong>路径指定</strong>：将方法的完整路径 （<code>agent_name.method_name</code>） 作为第一个参数。</li></ul><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>push_port</span> <span style=color:#f92672>=</span> <span style=color:#111>DriverPort</span><span style=color:#111>(</span><span style=color:#d88200>&#34;port_agent.push&#34;</span><span style=color:#111>)</span>
</span></span></code></pre></div><ul><li><strong>变量名匹配方法名</strong>：如果实例变量名与方法名（驱动或监测）相同，可省略 <code>driver_name</code> 或 <code>monitor_name</code> 参数。</li></ul><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>push</span> <span style=color:#f92672>=</span> <span style=color:#111>DriverPort</span><span style=color:#111>(</span><span style=color:#111>agent_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;port_agent&#34;</span><span style=color:#111>)</span> <span style=color:#75715e># 变量名 &#39;push&#39; 匹配 driver_name</span>
</span></span><span style=display:flex><span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>monitor_pop_data</span> <span style=color:#f92672>=</span> <span style=color:#111>MonitorPort</span><span style=color:#111>(</span><span style=color:#111>agent_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;port_agent&#34;</span><span style=color:#111>)</span> <span style=color:#75715e># 变量名匹配 monitor_name</span>
</span></span></code></pre></div><ul><li><strong>变量名同时匹配 Agent 与方法名</strong>：变量名使用双下划线 <code>__</code> 分隔 <code>agent_name</code> 和方法名，此时端口类构造函数无需参数。</li></ul><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>port_agent__push</span> <span style=color:#f92672>=</span> <span style=color:#111>DriverPort</span><span style=color:#111>()</span> <span style=color:#75715e># 变量名匹配 agent_name 和 driver_name</span>
</span></span><span style=display:flex><span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>port_agent__monitor_pop_data</span> <span style=color:#f92672>=</span> <span style=color:#111>MonitorPort</span><span style=color:#111>()</span> <span style=color:#75715e># 变量名匹配 agent_name 和 monitor_name</span>
</span></span></code></pre></div><ul><li><strong>AgentPort 省略 <code>agent_name</code></strong>：如果实例变量名与 Agent 名称相同。</li></ul><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>port_agent</span> <span style=color:#f92672>=</span> <span style=color:#111>AgentPort</span><span style=color:#111>()</span> <span style=color:#75715e># 变量名 &#39;port_agent&#39; 匹配 agent_name</span>
</span></span></code></pre></div><h3 id=实现异步执行流>实现异步执行流</h3><p>我们需要在模型中定义核心异步方法： <code>async def main(self):</code>。Toffee 框架会在模型被附加到 <code>Env</code> 后自动启动并运行这个 <code>main</code> 方法。</p><p>在 <code>main</code> 方法中，使用 <code>await port_instance()</code> 语法来<strong>等待</strong>并从端口获取数据。这个 <code>await</code> 操作会暂停当前执行流，直到对应的端口接收到数据为止。获取数据后，模型执行其内部逻辑，这通常包括更新内部状态和执行必要的验证比对。</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>StackRefModel</span><span style=color:#111>(</span><span style=color:#111>Model</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>async</span> <span style=color:#00a8c8>def</span> <span style=color:#75af00>main</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>print</span><span style=color:#111>(</span><span style=color:#d88200>&#34;Model (Independent Flow): Starting main execution loop.&#34;</span><span style=color:#111>)</span>
</span></span><span style=display:flex><span>        <span style=color:#00a8c8>while</span> <span style=color:#00a8c8>True</span><span style=color:#111>:</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 1. 主动等待 push 操作的驱动数据</span>
</span></span><span style=display:flex><span>            <span style=color:#111>push_args</span> <span style=color:#f92672>=</span> <span style=color:#00a8c8>await</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>push_port</span><span style=color:#111>()</span> <span style=color:#75715e># push_args 是参数字典或元组</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 2. 主动等待 pop 操作被调用 (通常不关心 pop 的参数)</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 注意: await pop_port() 只是同步了 pop 调用发生的时间点</span>
</span></span><span style=display:flex><span>            <span style=color:#00a8c8>await</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>pop_port</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 3. 主动等待 pop 操作对应的监测数据</span>
</span></span><span style=display:flex><span>            <span style=color:#111>monitored_item</span> <span style=color:#f92672>=</span> <span style=color:#00a8c8>await</span> <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>monitor_pop_data_port</span><span style=color:#111>()</span> <span style=color:#75715e># 这是实际的 DUT 输出</span>
</span></span></code></pre></div><h3 id=使用-agentport>使用 AgentPort</h3><p>如果选择使用 <code>AgentPort</code> 来统一处理一个 Agent 的所有交互，那么 <code>await</code> 操作会返回一个元组，其中包含被调用的方法路径（字符串）和相关数据 （<code>item</code>）。你需要在执行流中根据方法路径来分发处理逻辑。</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a8c8>class</span> <span style=color:#75af00>StackRefModelWithAgentPort</span><span style=color:#111>(</span><span style=color:#111>Model</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>def</span> <span style=color:#111>__init__</span><span style=color:#111>(</span><span style=color:#111>self</span><span style=color:#111>):</span>
</span></span><span style=display:flex><span>        <span style=color:#111>super</span><span style=color:#111>()</span><span style=color:#f92672>.</span><span style=color:#111>__init__</span><span style=color:#111>()</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 使用 AgentPort，假设变量名 &#39;port_agent&#39; 匹配 agent_name</span>
</span></span><span style=display:flex><span>        <span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>port_agent</span> <span style=color:#f92672>=</span> <span style=color:#111>AgentPort</span><span style=color:#111>(</span><span style=color:#111>agent_name</span><span style=color:#f92672>=</span><span style=color:#d88200>&#34;port_agent&#34;</span><span style=color:#111>)</span>
</span></span></code></pre></div><p>类似的，当变量名称与 Agent 名称相同时，可以省略 <code>agent_name</code> 参数：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#111>self</span><span style=color:#f92672>.</span><span style=color:#111>port_agent</span> <span style=color:#f92672>=</span> <span style=color:#111>AgentPort</span><span style=color:#111>()</span>
</span></span></code></pre></div><p>同时，也可以使用 <code>agents</code> 参数来匹配多个 Agent，或使用 <code>methods</code> 参数来匹配多个驱动函数或监测函数。</p><p>使用了 <code>AgentPort</code> 之后，参考模型可以通过 <code>await</code> 关键字来等待 Env 中的驱动函数或监测函数的调用，其返回数据将会是包含了函数路径以及相关参数的元组。</p><h2 id=94-练习>9.4 练习</h2><p>本节的练习已经发布，请查阅<a href=/beginner/task/toffee/>【学习任务2: Toffee 部分】 5. 编写参考模型并打包验证环境</a>。</p><h1 id=拓展阅读>拓展阅读</h1><h2 id=协程相关>协程相关</h2><ul><li><p>Python 文档中关于协程的部分：https://docs.python.org/zh-cn/3.11/library/asyncio-task.html</p></li><li><p>Python 异步编程 - 搞明白 async， await （继续解释 yield）： <a href=https://www.bilibili.com/video/BV1zJ7mzdEc8>https://www.bilibili.com/video/BV1zJ7mzdEc8</a></p></li></ul><h2 id=pytest-相关>Pytest 相关</h2><blockquote><p>💡Pytest 本身的功能和生态非常强大，推荐阅读下面的内容：</p></blockquote><ul><li><p><a href=https://docs.pytest.org/en/stable/index.html>pytest 文档</a></p></li><li><p><a href=https://docs.pytest.org/en/stable/how-to/usage.html>如何调用 pytest</a></p></li><li><p>pytest 中 <a href=https://docs.pytest.org/en/stable/how-to/fixtures.html>fixture 的用法</a></p></li><li><p>pytest 中标记功能 <a href=https://docs.pytest.org/en/stable/how-to/mark.html>mark 的用法</a></p></li><li><p>pytest 实现<a href=https://docs.pytest.org/en/stable/how-to/parametrize.html>测试函数的参数化</a></p></li><li><p>利用多核并行，加快测试用例运行速度：<a href=https://pytest-xdist.readthedocs.io/en/stable/>pytest-xdist</a></p><ul><li><blockquote><p>⚠️警告：开启多核并行运行测试用例后，如果对比顺序运行测试用例的结果，发现覆盖率下降，说明顺序运行的一部分覆盖率是靠 DUT 初始状态的随机值给刷上去的，并非依赖输入激励的影响</p></blockquote></li></ul></li></ul></div></div></div><div class="container mb-5"></div><div class=container><div class="row row-cols-1 row-cols-md-2 row-cols-lg-3 row-cols-xl-4 g-4 mb-3"></div></div></div><script src=/js/bootstrap.min.js></script><script src=/js/jquery.min.js></script><script src=/js/isotope.pkgd.min.js></script><script src=/js/masonry.pkgd.min.js async></script><script src=/js/dark.js></script><script>var savedTheme=localStorage.getItem("dark-mode-storage")||"light";setTheme(savedTheme)</script><script src=/js/isotope.js></script><script src=/js/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,securityLevel:"loose"})</script></body></html>