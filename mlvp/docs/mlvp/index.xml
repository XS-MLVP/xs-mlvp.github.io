<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开放验证平台学习资源 – 验证框架</title>
    <link>https://xs-mlvp.github.io/mlvp/docs/mlvp/</link>
    <description>Recent content in 验证框架 on 开放验证平台学习资源</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	  <atom:link href="https://xs-mlvp.github.io/mlvp/docs/mlvp/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: 快速开始</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/mlvp/quick-start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/mlvp/quick-start/</guid>
      <description>
        
        
        &lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;h3 id=&#34;toffee&#34;&gt;toffee&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/XS-MLVP/toffee&#34;&gt;Toffee&lt;/a&gt; 是一款基于 Python 的硬件验证框架，旨在帮助用户更加便捷、规范地使用 Python 构建硬件验证环境。它依托于多语言转换工具 &lt;a href=&#34;https://github.com/XS-MLVP/picker&#34;&gt;picker&lt;/a&gt;，该工具能够将硬件设计的 Verilog 代码转换为 Python Package，使得用户可以使用 Python 来驱动并验证硬件设计。&lt;/p&gt;
&lt;p&gt;Toffee 需要的依赖有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python 3.6.8+&lt;/li&gt;
&lt;li&gt;Picker 0.9.0+&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当安装好上述依赖后,可通过pip安装toffee：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pip install pytoffee
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或通过以下命令安装最新版本的toffee：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pip install pytoffee@git+https://github.com/XS-MLVP/toffee@master
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或通过以下方式进行本地安装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone https://github.com/XS-MLVP/toffee.git
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; toffee
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pip install .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;toffee-test&#34;&gt;toffee-test&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/XS-MLVP/toffee-test/tree/master&#34;&gt;Toffee-test&lt;/a&gt; 是一个用于为 Toffee 框架提供测试支持的 Pytest 插件，他为 toffee 框架提供了以下测试功能，以便于用户编写测试用例。&lt;/p&gt;
&lt;p&gt;通过 pip 安装 toffee-test&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pip install toffee-test
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或安装开发版本&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pip install toffee-test@git+https://github.com/XS-MLVP/toffee-test@master
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或通过源码安装&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone https://github.com/XS-MLVP/toffee-test.git
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; toffee-test
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pip install .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;搭建简单的验证环境&#34;&gt;搭建简单的验证环境&lt;/h2&gt;
&lt;p&gt;我们使用一个简单的加法器示例来演示 toffee 的使用方法，该示例位于 &lt;code&gt;example/adder&lt;/code&gt; 目录下。&lt;/p&gt;
&lt;p&gt;加法器的设计如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Adder&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;#(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;parameter&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;WIDTH&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;input&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;WIDTH&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;io_a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;input&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;WIDTH&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;io_b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;input&lt;/span&gt;              &lt;span style=&#34;color:#000&#34;&gt;io_cin&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;output&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;WIDTH&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;io_sum&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;output&lt;/span&gt;             &lt;span style=&#34;color:#000&#34;&gt;io_cout&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;assign&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;io_cout&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;io_sum&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;  &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;io_a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;io_b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;io_cin&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;endmodule&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先使用 picker 将其转换为 Python Package，再使用 toffee 来为其建立验证环境。安装好依赖后，可以直接在 &lt;code&gt;example/adder&lt;/code&gt; 目录下运行以下命令来完成转换：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make dut
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了验证加法器的功能，我们使用 toffee 提供的方法来建立验证环境。&lt;/p&gt;
&lt;p&gt;首先需要为其创建加法器接口的驱动方法，这里用到了 &lt;code&gt;Bundle&lt;/code&gt; 来描述需要驱动的某类接口，&lt;code&gt;Agent&lt;/code&gt; 用于编写对该接口的驱动方法。如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;AdderBundle&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Bundle&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;sum&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cout&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Signals&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;AdderAgent&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Agent&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#5c35cc;font-weight:bold&#34;&gt;@driver_method&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;exec_add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#3465a4&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#3465a4&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;bundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#3465a4&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;bundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#3465a4&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;bundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#3465a4&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;bundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;step&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#3465a4&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;bundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#3465a4&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;bundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cout&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;value&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们使用了 &lt;code&gt;driver_method&lt;/code&gt; 装饰器来标记 &lt;code&gt;Agent&lt;/code&gt; 中用于驱动的方法 &lt;code&gt;exec_add&lt;/code&gt;，该方法完成了对加法器的一次驱动操作，每当该方法被调用，其会将输入信号 &lt;code&gt;a&lt;/code&gt;、&lt;code&gt;b&lt;/code&gt;、&lt;code&gt;cin&lt;/code&gt; 的值分别赋给加法器的输入端口，并在下一个时钟周期后读取加法器的输出信号 &lt;code&gt;sum&lt;/code&gt; 和 &lt;code&gt;cout&lt;/code&gt; 的值并返回。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Bundle&lt;/code&gt; 是该 &lt;code&gt;Agent&lt;/code&gt; 需要驱动的接口的描述。在 &lt;code&gt;Bundle&lt;/code&gt; 中提供了一系列的连接方法来连接到 DUT 的输入输出端口。这样一来，我们可以通过此 &lt;code&gt;Agent&lt;/code&gt; 完成所有拥有相同接口的 DUT 的驱动操作。&lt;/p&gt;
&lt;p&gt;为了验证加法器的功能，我们还需要为其创建一个参考模型，用于验证加法器的输出是否正确。在 toffee 中，我们使用 &lt;code&gt;Model&lt;/code&gt; 来定义参考模型。如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;AdderModel&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Model&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#5c35cc;font-weight:bold&#34;&gt;@driver_hook&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;agent_name&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;add_agent&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;exec_add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#3465a4&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#204a87&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;64&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000&#34;&gt;cout&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;sum&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cout&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在参考模型中，我们同样定义了一个 &lt;code&gt;exec_add&lt;/code&gt; 方法，该方法与 &lt;code&gt;Agent&lt;/code&gt; 中的 &lt;code&gt;exec_add&lt;/code&gt; 方法含有相同的输入参数，我们用程序代码计算出了加法器的标准返回值。我们使用了 &lt;code&gt;driver_hook&lt;/code&gt; 装饰器来标记该方法，以便该方法可以与 &lt;code&gt;Agent&lt;/code&gt; 中的 &lt;code&gt;exec_add&lt;/code&gt; 方法进行关联。&lt;/p&gt;
&lt;p&gt;接下来，我们需要创建一个顶层的测试环境，将上述的驱动方法与参考模型相关联，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;AdderEnv&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Env&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;__init__&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#3465a4&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;adder_bundle&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#204a87&#34;&gt;super&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;__init__&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#3465a4&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;add_agent&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;AdderAgent&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;adder_bundle&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#3465a4&#34;&gt;self&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;attach&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;AdderModel&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时，验证环境已经搭建完成，toffee 会自动驱动参考模型并收集结果，并将结果与加法器的输出进行比对。&lt;/p&gt;
&lt;p&gt;之后，需要编写测试用例来验证加法器的功能，通过 toffee-test，可以使用如下方式编写测试用例。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5c35cc;font-weight:bold&#34;&gt;@toffee_test.testcase&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;test_random&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;adder_env&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;range&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1000&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;random&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;randint&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;64&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;random&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;randint&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;64&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;random&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;randint&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;adder_env&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;add_agent&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;exec_add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5c35cc;font-weight:bold&#34;&gt;@toffee_test.testcase&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;test_boundary&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;adder_env&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;64&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;64&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;adder_env&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;add_agent&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;exec_add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以直接在 &lt;code&gt;example/adder&lt;/code&gt; 目录下运行以下命令来运行该示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make run
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行结束后报告将自动在&lt;code&gt;reports&lt;/code&gt;目录下生成。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 编写规范的验证环境</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/mlvp/canonical_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/mlvp/canonical_env/</guid>
      <description>
        
        
        &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;一个验证任务编写代码的主体工作可以大致分为两部分，&lt;strong&gt;验证环境的搭建&lt;/strong&gt; 和 &lt;strong&gt;测试用例的编写&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;验证环境的搭建&lt;/strong&gt; 旨在完成对待测设计（DUT）的封装，使得验证人员在驱动DUT时，不必面临繁杂的接口信号，而是可以直接使用验证环境中提供的高级接口。如果需要编写参考模型，则参考模型也应是验证环境的一部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试用例的编写&lt;/strong&gt; 则是测试人员使用验证环境提供的接口，编写一个个测试用例，对DUT进行功能验证。&lt;/p&gt;
&lt;p&gt;搭建验证环境是一件相当有挑战的事情，当 DUT 极度复杂，特别是在接口信号繁多的情况下，搭建验证环境的难度会更大。此时，若没有一个统一的规范，验证环境的搭建将会变得混乱不堪，一个人编写的验证环境很难被其他人维护。并且当出现新的验证任务与原有验证任务有交集时，因为原有的验证环境缺乏规范，很难将原有的验证环境复用。&lt;/p&gt;
&lt;p&gt;本节将会介绍一个规范的验证环境所应该具备的特性，这将有助于理解 mlvp 验证环境的搭建流程。&lt;/p&gt;
&lt;h2 id=&#34;无法复用的验证代码&#34;&gt;无法复用的验证代码&lt;/h2&gt;
&lt;p&gt;以一个简单的加法器为例，该加法器拥有两个输入端口 &lt;code&gt;io_a&lt;/code&gt; 和 &lt;code&gt;io_b&lt;/code&gt;，一个输出端口 &lt;code&gt;io_sum&lt;/code&gt;。 在没有意识到验证代码可能会被用于其他验证任务的情况下，我们可能会编写出这样的驱动代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;exec_add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dut&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;dut&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;io_a&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;dut&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;io_b&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;dut&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Step&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;dut&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;io_sum&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;value&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码中，我们编写了一个 &lt;code&gt;exec_add&lt;/code&gt; 方法，该方法本质上是对加法器加法操作的一次高层封装。拥有 &lt;code&gt;exec_add&lt;/code&gt; 方法以后，我们无需再关心如何对加法器的接口信号进行赋值，也无需关心怎样驱动加法器并获取其输出，只需要调用 &lt;code&gt;exec_add&lt;/code&gt; 方法即可驱动加法器完成一次加法操作。&lt;/p&gt;
&lt;p&gt;然而，这个驱动函数却有一个很大的弊端，它直接使用了 DUT 的接口信号来与 DUT 进行交互，这也就意味着，这个驱动函数只能用于这个加法器。&lt;/p&gt;
&lt;p&gt;与软件测试不同，在硬件验证中我们每时每刻都能碰到接口结构相同的情况。假设我们拥有另一个具有相同功能的加法器，但其接口信号名称分别是 &lt;code&gt;io_a_0&lt;/code&gt;、&lt;code&gt;io_b_0&lt;/code&gt; 和 &lt;code&gt;io_sum_0&lt;/code&gt;，那么这个驱动函数对这个加法器则直接失效，无法复用。要想驱动，只能重新编写一个新的驱动函数。&lt;/p&gt;
&lt;p&gt;一个加法器尚且如此，倘若我们拿到了一个拥有繁杂接口的 DUT，费尽心思为其编写了驱动代码。当后续发现驱动代码需要迁移至另一个相似结构的接口上时，我们将会面临巨大的工作量。例如出现接口名称改变、部分接口缺少但驱动代码中却有引用，部分接口新增等等一系列的问题。&lt;/p&gt;
&lt;p&gt;出现这种问题的根本原因在于，我们在验证代码中直接对 DUT 的接口信号进行操作，如下图所示，这种做法是不可取的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;+-----------+   +-----------+
|           |--&amp;gt;|           |
| Test Code |   |    DUT    |
|           |&amp;lt;--|           |
+-----------+   +-----------+
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;将验证代码与dut进行解耦&#34;&gt;将验证代码与DUT进行解耦&lt;/h2&gt;
&lt;p&gt;为了解决上述问题，我们需要将验证代码与 DUT 进行解耦，使得验证代码不再直接操作 DUT 的接口信号，而是通过一个中间层来与 DUT 进行交互。这个中间层是人为定义的一个接口结构，在 mlvp 中，我们将这个中间层定义为 &lt;code&gt;Bundle&lt;/code&gt;，下文也将会使用 &lt;code&gt;Bundle&lt;/code&gt; 来代指这个中间层。&lt;/p&gt;
&lt;p&gt;以上述加法器为例，我们可以定义一个 Bundle 结构，其中包含 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;sum&lt;/code&gt; 三个信号，并让测试代码与这个 Bundle 进行直接交互。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;exec_add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;bundle&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;bundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;bundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;bundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Step&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;bundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;value&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时，在 &lt;code&gt;exec_add&lt;/code&gt; 中并没有直接操作 DUT 的接口信号，甚至不知道 DUT 中的接口信号名称是什么，其直接与我们在 Bundle 中定义的接口信号进行交互。&lt;/p&gt;
&lt;p&gt;那如何让 Bundle 中的信号与 DUT 的引脚进行关联呢？只需要添加一个连接操作即可，最简单的连接方法是，我们直接指定 Bundle 中的每一个信号具体与 DUT 的哪一个引脚相连，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bundle.a   &amp;lt;-&amp;gt; dut.io_a
bundle.b   &amp;lt;-&amp;gt; dut.io_b
bundle.sum &amp;lt;-&amp;gt; dut.io_sum
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果 DUT 的接口信号名称发生了变化，我们只需要修改这个连接过程，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bundle.a   &amp;lt;-&amp;gt; dut.io_a_0
bundle.b   &amp;lt;-&amp;gt; dut.io_b_0
bundle.sum &amp;lt;-&amp;gt; dut.io_sum_0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样一来，无论 DUT 的接口如何变化，只要其拥有相同的结构，都可以通过原有的驱动代码来驱动，需要修改的仅仅是连接过程。此时的验证代码与 DUT 的关系如下图所示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;+-----------+  +--------+             +-----------+
|           |-&amp;gt;|        |             |           |
| Test Code |  | Bundle |-- connect --|    DUT    |
|           |&amp;lt;-|        |             |           |
+-----------+  +--------+             +-----------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 mlvp 中，我们为 &lt;code&gt;Bundle&lt;/code&gt; 提供了简洁的定义过程以及大量的连接方法，可极大方便中间层的定义与连接，除此之外，&lt;code&gt;Bundle&lt;/code&gt; 还提供了大量的实用功能来帮助验证人员更好的与接口信号进行交互。&lt;/p&gt;
&lt;h2 id=&#34;将-dut-接口进行分类驱动&#34;&gt;将 DUT 接口进行分类驱动&lt;/h2&gt;
&lt;p&gt;我们已经知道，需要定义一个 &lt;code&gt;Bundle&lt;/code&gt; 来完成测试代码与 DUT 之间的解耦，但是如果 DUT 的接口信号过于复杂，我们将会面临一个新的问题————可能只有这一个 DUT 能与这个 &lt;code&gt;Bundle&lt;/code&gt; 进行连接。因为我们会定义一个含有众多信号的中间层，将整个 DUT 的引脚全部涵盖在内，这样一来，只有与整个 DUT 结构相同的 DUT 才能与这个 &lt;code&gt;Bundle&lt;/code&gt; 进行连接，这个条件是极为苛刻的。&lt;/p&gt;
&lt;p&gt;这样一来，中间层的设置也就失去意义了。但我们观察到，每个 DUT 的接口结构往往是有规律的，他们通常由若干个具有独立功能的接口组成。例如 &lt;a href=&#34;https://open-verify.cc/mlvp/docs/quick-start/eg-stack-callback/&#34;&gt;这里&lt;/a&gt; 提到的双端口栈，它的接口则由两个结构完全相同的子接口构成。因此，相比于将整个双端口栈的接口信号全部涵盖在一个 &lt;code&gt;Bundle&lt;/code&gt; 中，我们可以将其拆分为两个 &lt;code&gt;Bundle&lt;/code&gt;，每个 &lt;code&gt;Bundle&lt;/code&gt; 分别对应一个子接口。&lt;/p&gt;
&lt;p&gt;并且，对于双端口栈来说，两个子接口的结构是完全相同的，因此我们可以使用同一个 &lt;code&gt;Bundle&lt;/code&gt; 来描述这两个子接口，无需重复定义。既然他们拥有同样的 Bundle，那么我们针对这个 Bundle 编写的驱动代码也是完全可以复用的！这就是验证环境可复用性的魅力。&lt;/p&gt;
&lt;p&gt;总结一下，对于所有的 DUT 来说，我们应该将其接口信号划分成若干个独立的子接口，每个子接口拥有独立的功能，然后为每个子接口定义一个 &lt;code&gt;Bundle&lt;/code&gt;，并编写与这个 &lt;code&gt;Bundle&lt;/code&gt; 相关的驱动代码。&lt;/p&gt;
&lt;p&gt;此时，我们的验证代码与 DUT 的关系如下图所示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;+-----------+  +--------+             +-----------+
|           |-&amp;gt;|        |             |           |
| Test Code |  | Bundle |-- connect --|           |
|           |&amp;lt;-|        |             |           |
+-----------+  +--------+             |           |
                                      |           |
     ...           ...                |    DUT    |
                                      |           |
+-----------+  +--------+             |           |
|           |-&amp;gt;|        |             |           |
| Test Code |  | Bundle |-- connect --|           |
|           |&amp;lt;-|        |             |           |
+-----------+  +--------+             +-----------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同时，我们搭建验证环境的思路也变得清晰起来，只需要为分别每个独立的子接口编写高层封装的操作即可。&lt;/p&gt;
&lt;h2 id=&#34;驱动独立接口的结构&#34;&gt;驱动独立接口的结构&lt;/h2&gt;
&lt;p&gt;我们为每个 Bundle 都编写了高层封装的操作，这些代码之间相互独立，拥有极高的可复用性。如果我们把不同 Bundle 高层封装之间的交互逻辑都划分出去，放到测试用例中来完成，那么多个 &lt;code&gt;Test Code + Bundle&lt;/code&gt; 的组合将会完成对整个 DUT 的驱动环境的搭建。&lt;/p&gt;
&lt;p&gt;我们不妨对单个 &lt;code&gt;Test Code + Bundle&lt;/code&gt; 的组合起一个名字，在 mlvp 中，该结构被称之为 &lt;code&gt;Agent&lt;/code&gt;。&lt;code&gt;Agent&lt;/code&gt; 独立于 DUT，负责完成对一类接口的所有交互操作。&lt;/p&gt;
&lt;p&gt;此时，我们的验证代码与 DUT 的关系如下图所示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;+---------+    +-----------+
|         |    |           |
|  Agent  |----|           |
|         |    |           |
+---------+    |           |
               |           |
    ...        |    DUT    |
               |           |
+---------+    |           |
|         |    |           |
|  Agent  |----|           |
|         |    |           |
+---------+    +-----------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此编写驱动环境的过程，就是编写一个个 &lt;code&gt;Agent&lt;/code&gt; 的过程。但至此，我们还没有讨论过编写 &lt;code&gt;Agent&lt;/code&gt; 的具体规范，如果每个人编写的 &lt;code&gt;Agent&lt;/code&gt; 都各不相同，那么验证环境依然会变得较为混乱。&lt;/p&gt;
&lt;h2 id=&#34;编写规范的-agent&#34;&gt;编写规范的 “Agent”&lt;/h2&gt;
&lt;p&gt;为了探寻如何编写一个规范的 &lt;code&gt;Agent&lt;/code&gt;，我们首先要明白 &lt;code&gt;Agent&lt;/code&gt; 主要完成怎样的功能。如上文所述，&lt;code&gt;Agent&lt;/code&gt; 中实现了对一类接口的所有交互操作，并提供高层封装。&lt;/p&gt;
&lt;p&gt;我们首先来探讨，验证代码究竟会与接口产生怎样的交互，假设验证代码具备读取输入端口的能力，我们可以按照验证代码是否主动发起交互，与接口的方向性来划分为以下几类交互。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;验证代码主动发起&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;验证代码主动读取输入/输出端口的值&lt;/li&gt;
&lt;li&gt;验证代码主动给输入端口赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;验证代码被动接收&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;验证代码被动接收输出/输出端口的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两类操作涵盖了验证代码侧与接口之间的的所有操作，因此 &lt;code&gt;Agent&lt;/code&gt; 也必须具备这两类操作的能力。&lt;/p&gt;
&lt;h3 id=&#34;验证代码主动发起的交互&#34;&gt;验证代码主动发起的交互&lt;/h3&gt;
&lt;p&gt;我们首先考虑验证代码主动发起的两类交互，对这两类交互完成高层封装，就要求 &lt;code&gt;Agent&lt;/code&gt; 必须具备两种能力：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;驱动发起者能够将上层语义信息转换为对接口信号的赋值操作&lt;/li&gt;
&lt;li&gt;能够将接口信号转换为上层语义信息并返回给发起者&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;能够完成这两类交互的形式有很多。但由于 mlvp 是一个基于软件测试语言的验证框架，且我们希望验证代码的编写形式尽量简洁，mlvp 中规范了使用 &lt;strong&gt;函数&lt;/strong&gt; 为载体来完成这两类交互。&lt;/p&gt;
&lt;p&gt;因为函数是编程语言中最基本的抽象单元，输入参数可直接作为上层语义信息并传递给函数体，函数体中通过赋值和读取操作完成上层语义信息与接口信号的转换，最后通过返回值将接口信号转换为上层语义信息并返回给发起者。&lt;/p&gt;
&lt;p&gt;mlvp 此类用于验证代码主动发起交互的函数称之为&lt;strong&gt;驱动方法&lt;/strong&gt;，在 mlvp 中，我们使用 &lt;code&gt;driver_method&lt;/code&gt; 装饰器来标记此类函数。&lt;/p&gt;
&lt;h3 id=&#34;验证代码被动接收的交互&#34;&gt;验证代码被动接收的交互&lt;/h3&gt;
&lt;p&gt;接下来我们考虑验证代码被动接收的交互，并对此类交互完成高层封装。这类交互的呈现形式为，验证代码并不去主动发起对接口的输入输出，而是当满足特定的条件时，接口会将输出信号传递给验证代码。&lt;/p&gt;
&lt;p&gt;例如，验证代码想要在 DUT 完成一次操作后，被动获取 DUT 的输出信号并转换为上层语义信息。再如，验证代码想在每一周期都被动获取 DUT 的输出信号并转换为上层语义信息。&lt;/p&gt;
&lt;p&gt;与 &lt;code&gt;driver_method&lt;/code&gt; 类似，mlvp 中同样规范了使用 &lt;strong&gt;函数&lt;/strong&gt; 为载体来完成这类交互，只不过这个函数没有输入参数，并且不受验证代码的主动控制。当特定条件满足时，该函数会被调用，完成对接口信号的读取操作，并转换为上层语义信息。该信息会被保存，等待验证代码的使用。&lt;/p&gt;
&lt;p&gt;类似的，mlvp 将此类用于验证代码被动接收交互的函数称之为&lt;strong&gt;监测方法&lt;/strong&gt;，在 mlvp 中，我们使用 &lt;code&gt;monitor_method&lt;/code&gt; 装饰器来标记此类函数。&lt;/p&gt;
&lt;h3 id=&#34;一个规范的-agent-结构&#34;&gt;一个规范的 “Agent” 结构&lt;/h3&gt;
&lt;p&gt;综上所述，我们使用 &lt;strong&gt;函数&lt;/strong&gt; 作为载体来完成验证代码与接口的所有交互，并将其分为两类：&lt;strong&gt;驱动方法&lt;/strong&gt; 和 &lt;strong&gt;监测方法&lt;/strong&gt;。这两类方法分别完成验证代码主动发起的交互和被动接收的交互。&lt;/p&gt;
&lt;p&gt;因此，编写 &lt;code&gt;Agent&lt;/code&gt;，其实就是编写一系列的驱动方法和检测方法。一个 Agent 编写好之后，也只需要提供其内部驱动方法和检测方法的列表，便能描述整个 &lt;code&gt;Agent&lt;/code&gt; 的功能。&lt;/p&gt;
&lt;p&gt;一个 &lt;code&gt;Agent&lt;/code&gt; 的结构可以使用下图来描述：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;+--------------------+
| Agent              |
|                    |
|   @driver_method   |
|   @driver_method   |
|   ...              |
|                    |
|   @monitor_method  |
|   @monitor_method  |
|   ...              |
|                    |
+--------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;验证-dut-的功能正确性&#34;&gt;验证 DUT 的功能正确性&lt;/h2&gt;
&lt;p&gt;目前为止，我们完成了对 DUT 高层操作的封装，并使用函数完成了验证代码与 DUT 之间的交互。此时，为了验证 DUT 的功能是否正确，我们会编写测试用例，通过我们封装好的&lt;strong&gt;驱动方法&lt;/strong&gt;来驱动起 DUT 完成特定的执行过程。与此同时，&lt;strong&gt;监测方法&lt;/strong&gt; 在自动地被调用并监测收集 DUT 的相关信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而如何去验证 DUT 的功能是否正确呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在测试用例中对 DUT 进行驱动后，能够得到 DUT 输出的信息包含两种，一种是通过驱动方法主动获取的信息，另一种是通过检测方法收集到的信息。因此，验证 DUT 的功能是否正确，实际上就是验证这两种信息是否符合预期。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那如何判断这两种信息是否符合预期呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一种情况是，我们本来就知道 DUT 的输出应该是什么，或是满足什么样的条件。这时我们在测试用例中拿到这两种信息后，直接对这两种信息（或是其中一种，取决于验证用例的需求）进行检查即可。&lt;/p&gt;
&lt;p&gt;另一种情况是，我们并不知道 DUT 的输出应该是什么。此时我们只能编写一个与 DUT 功能相同的 &lt;strong&gt;参考模型(RM, Reference Model)&lt;/strong&gt;，当主动发送给 DUT 任何信息时，同时将这些信息主动发送给参考模型。&lt;/p&gt;
&lt;p&gt;为了对验证两类信息是否符合预期。当主动获取 DUT 的输出信息是时，同时主动去获取参考模型中的输出信息，并将两者进行比对；当监测方法监测到 DUT 的输出信息时，同时参考模型也应主动提供输出信息，并将两者进行比对。&lt;/p&gt;
&lt;p&gt;这便是验证 DUT 功能正确性的两类方法：&lt;strong&gt;直接比对&lt;/strong&gt; 和 &lt;strong&gt;参考模型比对&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;如何添加参考模型&#34;&gt;如何添加参考模型&lt;/h2&gt;
&lt;p&gt;对于直接比对的验证方法，我们直接在测试用例中编写比对逻辑即可。而如果我们使用参考模型的比对方式，测试用例可能会面临一些比较繁琐的步骤：驱动接口的同时，需要将信息同时发送给模型；收集接口信息的同时，需要同时收集模型的信息；对于被动监测的接口信息，还要额外编写逻辑来完成与参考模型的比对。这样一来，测试用例的代码会混乱，与参考模型的交互逻辑会混杂在测试用例中，不利于代码的维护。&lt;/p&gt;
&lt;p&gt;我们注意到，对于驱动函数的每一次调用，代表着对 DUT 的每一次操作，这些操作都需要转发给参考模型。而参考模型的编写无需考虑 DUT 接口是怎样驱动的，它只需要分析高层语义信息，并且完成自身状态更新即可，因此参考模型中只需要获取上层发来的高层语义信息（即驱动函数的输入参数）。&lt;/p&gt;
&lt;p&gt;所以在参考模型中只需要实现当驱动函数被调用时，如何做出反应即可。对于将调用信息传递给参考模型的操作完全可以交由框架来完成。与此同时，每一次操作的返回值、监测方法的检测值比较，也可以通过框架来自动完成。&lt;/p&gt;
&lt;p&gt;这样一来，测试用例中只需要编写驱动 DUT 的逻辑，参考模型的同步与比对工作将会被框架自动完成。&lt;/p&gt;
&lt;p&gt;为了实现参考模型的同步，mlvp 中定义了一套参考模型的匹配规范，只需要按照此规范编写参考模型调用接口，便可实现参考模型的自动转发与比较。同时为了方便参考模型与整个验证环境相关联，mlvp 中提供了 &lt;code&gt;Env&lt;/code&gt; 的概念来打包整个验证环境，写好参考模型后，只需要将其与 &lt;code&gt;Env&lt;/code&gt; 相关联，便可实现参考模型的自动同步。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;这样一来，我们的验证环境变成了如下的结构：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;+--------------------------------+
| Env                            |
|                  +-----------+ |  +-----------+
|   +---------+    |           | |  |           |
|   |  Agent  |----|           | |-&amp;gt;| Reference |
|   +---------+    |    DUT    | |  |   Model   |
|   +---------+    |           | |&amp;lt;-|           |
|   |  Agent  |----|           | |  |           |
|   +---------+    |           | |  +-----------+
|       ...        +-----------+ |
+--------------------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时，整个验证环境的搭建变得清晰而规范，需要复用时，只需挑选合适的 &lt;code&gt;Agent&lt;/code&gt;，连接至 DUT，并打包到 &lt;code&gt;Env&lt;/code&gt; 中。需要编写参考模型时，只需要根据 Env 中调用接口规范，实现参考模型的逻辑即可。&lt;/p&gt;
&lt;p&gt;测试用例的编写与验证环境是分开的，当测试环境搭建完毕后，测试环境的接口就是每个 Agent 中的调用接口。测试用例可以清晰地使用这些接口来完成驱动逻辑的编写。参考模型的同步及对比工作也将由框架自动完成。&lt;/p&gt;
&lt;p&gt;这是 mlvp 中验证环境的搭建思想，mlvp 中提供了大量的功能，来帮助你建立起这样一个规范的验证环境。同时，它提供了测试用例的管理方法，使得测试用例更易于编写和管理。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 搭建验证环境</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/mlvp/env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/mlvp/env/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;mlvp&lt;/strong&gt; 提供了搭建验证环境全流程所需要的方法和工具，本章中将详细介绍如何使用 &lt;strong&gt;mlvp&lt;/strong&gt; 搭建一个完整的验证环境。&lt;/p&gt;
&lt;p&gt;在阅读前请确保您已经阅读了 &lt;a href=&#34;https://xs-mlvp.github.io/mlvp/mlvp/docs/mlvp/canonical_env/&#34;&gt;如何编写规范的验证环境&lt;/a&gt;，并了解了 mlvp 规范验证环境的基本结构。&lt;/p&gt;
&lt;p&gt;对于一次全新的验证工作来说，按照环境搭建步骤的开始顺序，搭建验证环境可以分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按照逻辑功能划分 DUT 接口，并定义 Bundle&lt;/li&gt;
&lt;li&gt;为每个 Bundle 编写 Agent，完成对 Bundle 的高层封装&lt;/li&gt;
&lt;li&gt;将多个 Agent 封装成 Env，完成对整个 DUT 的高层封装&lt;/li&gt;
&lt;li&gt;按照 Env 的接口规范编写参考模型，并将其与 Env 进行绑定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章将会分别介绍每个步骤中如何使用 mlvp 中的工具来完成环境搭建需求。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 编写测试用例</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/mlvp/cases/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/mlvp/cases/</guid>
      <description>
        
        
        &lt;p&gt;编写测试用例需要使用验证环境中定义好的接口来实现，但在用例中，往往会遇到同时驱动多个接口的情况，并且对于参考模拟的同步往往也有不同的需求，这一部分将详细介绍如何更好地使用验证环境中的接口来编写测试用例。&lt;/p&gt;
&lt;p&gt;当验证环境搭建完成后，编写测试用例用于验证设计的功能是否符合预期。对于硬件验证中的验证，两个重要的导向是：&lt;strong&gt;功能覆盖率&lt;/strong&gt;和&lt;strong&gt;行覆盖率&lt;/strong&gt;，功能覆盖率意味着测试用例是否覆盖了设计的所有功能，行覆盖率意味着测试用例是否触发了设计的所有代码行。在 mlvp 中，不仅提供了对这两种覆盖率的支持，还会再每次运行过后，自动计算出这两种覆盖率的结果，并生成一个验证报告。mlvp 使用 pytest 来管理测试用例，使其拥有强大的测试用例管理能力。&lt;/p&gt;
&lt;p&gt;在本节中，会在以下几个方面来讲述如何编写测试用例，以使用 mlvp 提供的强大功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何使用测试环境接口进行驱动&lt;/li&gt;
&lt;li&gt;如何使用 pytest 管理测试用例&lt;/li&gt;
&lt;li&gt;如何添加功能测试点&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 开始新的验证任务</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/mlvp/verification/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/mlvp/verification/</guid>
      <description>
        
        
        &lt;p&gt;使用 mlvp，你已经可以搭建出一个完整的验证环境，并且方便地去编写测试用例了。然而在实际的业务中，往往无法理解如何开始上手，并最终完成验证任务。实际编写代码后，会遇到无法正确划分 Bundle，无法正确理解 Agent 的高级语义封装，搭建完环境之后不知道做什么等问题。&lt;/p&gt;
&lt;p&gt;在这一节中，将会介绍如何从头开始完成一个新的验证任务，以及如何更好地使用 mlvp 来完成验证任务。&lt;/p&gt;
&lt;h2 id=&#34;1-了解待验证设计&#34;&gt;1. 了解待验证设计&lt;/h2&gt;
&lt;p&gt;拿到一个新的设计后，往往面对的是几十或数百个输入输出信号，如果直接看这些信号，很可能一头雾水，感觉无从下手。在这时，你必须坚信，输入输出信号都是设计人员来定义的，只要能够理解设计的功能，就能够理解这些信号的含义。&lt;/p&gt;
&lt;p&gt;如果设计人员提供了设计文档，那么你可以阅读设计文档，了解设计的功能，并一步步地将功能与输入输出信号对应起来，并且要清楚地理解输入输出信号的时序，以及如何使用这些信号来驱动设计。一般来说，你还需要阅读设计的源代码，来找寻更细节的接口时序问题。&lt;/p&gt;
&lt;p&gt;当大致了解了 DUT 的功能，并明白如何驱动起 DUT 接口之后，你就可以开始搭建验证环境了。&lt;/p&gt;
&lt;h2 id=&#34;2-划分-bundle&#34;&gt;2. 划分 Bundle&lt;/h2&gt;
&lt;p&gt;搭建环境的第一件事，就是根据接口的逻辑功能，将其划分为若干个接口集合，我们可以每一个接口集合视作一个 Bundle。划分为的每个 Bundle 都应是独立的，由一个独立的 Agent 来驱动。&lt;/p&gt;
&lt;p&gt;但是，往往实际中的接口是这样的：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;|---------------------- DUT Bundle -------------------------------|

|------- Bundle 1 ------| |------ Bundle 2 ------| |-- Bundle 3 --|

|-- B1.1 --| |-- B1.2 --| |-- B2.1 --|
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么问题就出现了，例如究竟是应该为 B1.1， B1.2 各自创建一个 Agent，还是应该直接为 Bundle 1 建立一个 Agent 呢？&lt;/p&gt;
&lt;p&gt;这还是取决于接口的逻辑功能，如果需要定义一个独立的请求，这个请求需要对 B1.1 和 B1.2 同时进行操作，那么就应该为 Bundle 1 创建一个 Agent，而不是为 B1.1 和 B1.2 分别创建 Agent。&lt;/p&gt;
&lt;p&gt;即便如此，为 B1.1 和 B1.2 定义 1.2 也是可行的，这增添了 Agent 的划分粒度，但牺牲了操作的连续性，上层代码和参考模型的编写都会变得复杂。因此选择合适的划分粒度是需要对具体业务的权衡。最终的划分，所有的 Agent 加起来应该能覆盖 DUT Bundle 的所有接口。&lt;/p&gt;
&lt;p&gt;实践中，为了方便 DUT 的连接，可以定义一个 &lt;code&gt;DUT&lt;/code&gt; Bundle，一次性将所有的接口都连接到这个 Bundle 上，由 Env 将其中的子 Bundle 分发给各个 Agent。&lt;/p&gt;
&lt;h2 id=&#34;3-编写-agent&#34;&gt;3. 编写 Agent&lt;/h2&gt;
&lt;p&gt;当 Bundle 划分完成后，就可以开始编写 Agent 来驱动这些 Bundle 了，你需要为每个 Bundle 编写一个 Agent。&lt;/p&gt;
&lt;p&gt;首先，可以从驱动方法开始写起，驱动方法实际上是对 Bundle 的一种高级语义封装，因此，高级语义信息应该携带了足以驱动 Bundle 的所有信息。如果 Bundle 中存在一个信号需要数字，但参数中并没有提供与这一信号相关的信息，那么这种高级语义封装就是不完整的。应尽量避免在驱动方法中对某个信号值进行假定，如果对这一信号在 Agent 中进行假定，DUT 的输出将会受到这一假定的影响，可能导致参考模型与 DUT 的行为不一致。&lt;/p&gt;
&lt;p&gt;同时，这一高层封装也决定了参考模型的功能层级，参考模型会直接与高层语义信息进行交互，并不会涉及到底层信号。&lt;/p&gt;
&lt;p&gt;如果参考模型需要用函数调用模式编写，那么应该将 DUT 的输出通过函数返回值来返回。如果参考模型需要用独立执行流模式编写，那么应该编写监测方法，将 DUT 的所有输出转换成高层语义信息，通过监测方法输出。&lt;/p&gt;
&lt;h2 id=&#34;4-封装成-env&#34;&gt;4. 封装成 Env&lt;/h2&gt;
&lt;p&gt;当所有的 Agent 编写完成后，或者挑选之前已有的Agent，就可以将这些 Agent 封装成 Env 了。&lt;/p&gt;
&lt;p&gt;Env 封装了整个验证环境，并确定了参考模型的编写规范。&lt;/p&gt;
&lt;h2 id=&#34;5-编写参考模型&#34;&gt;5. 编写参考模型&lt;/h2&gt;
&lt;p&gt;参考模型的编写没有必要在 Env 编写完成之后再开始，可以与 Agent 的编写同时进行，并实时编写一些驱动代码，来检验编写的正确性。当然如果 Agent 的编写特别规范，编写完整 Env 后再编写参考模型也是可行的。&lt;/p&gt;
&lt;p&gt;参考模型最重要的是选择合适的编写模式，函数调用模式和独立执行流模式都是可行的，但在不同的场景下，选择不同的模式会更加方便。&lt;/p&gt;
&lt;h2 id=&#34;6-确定功能点及测试点&#34;&gt;6. 确定功能点及测试点&lt;/h2&gt;
&lt;p&gt;编写好 Env 以及参考模型后，并不能直接开始编写测试用例，因为此时并没有测试用例的编写方向，盲目的编写测试用例，没有办法让待测设计验证完全。&lt;/p&gt;
&lt;p&gt;首先需要列出功能点及测试点列表。功能点是待测设计支持的所有功能，例如对于一个算术逻辑单元（ALU）来说，功能点的形式可能是“支持加法”，“支持乘法”等。每个功能点需要对应一个或多个测试点，测试点通过将功能划分为不同的测试场景，来验证功能点是否正确。例如对于“支持加法”这个功能点，可能有“当输入都为正数时，加法正确”等测试点。&lt;/p&gt;
&lt;h2 id=&#34;7-编写测试用例&#34;&gt;7. 编写测试用例&lt;/h2&gt;
&lt;p&gt;当功能点及测试点列表确定后，就可以开始编写测试用例了，一个测试用例需要能够覆盖一个或多个测试点，以验证功能点是否正确。所有的测试用例应该能够覆盖所有的测试点（功能覆盖率100%），以及覆盖所有的设计行（行覆盖率100%），这样一来就能保证验证的完备性。&lt;/p&gt;
&lt;p&gt;如何保证验证的正确性呢？如果采用参考模型比对的方式，当比对失败时，mlvp 会自动抛出异常，使得测试用例失败。如果采用直接比对的方式，应该在测试用例中使用 &lt;code&gt;assert&lt;/code&gt; 来编写比对代码，当比对失败时，测试用例也会失败。最终，当所有的测试用例都通过时，意味着功能已验证为正确。&lt;/p&gt;
&lt;p&gt;编写过程中，你需要使用 &lt;code&gt;Env&lt;/code&gt; 中提供的接口来驱动 DUT，如果出现了需要多个驱动方法交互的情况，可以使用 &lt;code&gt;Executor&lt;/code&gt; 来封装更高层的函数。也就是说驱动方法级的交互，是在测试用例的编写中完成的。&lt;/p&gt;
&lt;h2 id=&#34;8-编写验证报告&#34;&gt;8. 编写验证报告&lt;/h2&gt;
&lt;p&gt;当行覆盖率和功能覆盖率都达到了 100% 之后，意味着验证已经完成。最终需要编写一个验证报告，来总结验证任务的结果。如果验证出了待测设计的问题，也应在验证报告中详细描述问题的原因。如果行覆盖率或者功能覆盖率没有达到 100%，也应在验证报告中说明原因，报告的格式应该遵循公司内部统一的规范。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: API 文档</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/mlvp/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/mlvp/api/</guid>
      <description>
        
        
        
      </description>
    </item>
    
  </channel>
</rss>
