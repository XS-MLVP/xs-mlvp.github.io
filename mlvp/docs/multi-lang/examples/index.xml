<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>验证案例 on 开放验证平台学习资源</title>
    <link>https://open-verify.cc/mlvp/docs/multi-lang/examples/</link>
    <description>Recent content in 验证案例 on 开放验证平台学习资源</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/mlvp/docs/multi-lang/examples/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>加法器</title>
      <link>https://open-verify.cc/mlvp/docs/multi-lang/examples/adder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/docs/multi-lang/examples/adder/</guid>
      <description>&lt;p&gt;以Adder为例，各语言的验证代码和注释如下：&lt;/p&gt;&#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&#xA;    &#xA;    &lt;div style=&#34;background-color: #f0f0f0; display: flex; justify-content: flex-end; gap: 5px; padding-right: 5px&#34;&gt;&#xA;        &#xA;            &lt;a name=&#34;multi-lang-toggle&#34; style=&#34;font-size: 12px;&#34; lang=&#39;cpp&#39; href=&#34;javascript://&#34;&gt;Cpp&lt;/a&gt;&#xA;        &#xA;            &lt;a name=&#34;multi-lang-toggle&#34; style=&#34;font-size: 12px;&#34; lang=&#39;java&#39; href=&#34;javascript://&#34;&gt;Java&lt;/a&gt;&#xA;        &#xA;            &lt;a name=&#34;multi-lang-toggle&#34; style=&#34;font-size: 12px;&#34; lang=&#39;scala&#39; href=&#34;javascript://&#34;&gt;Scala&lt;/a&gt;&#xA;        &#xA;            &lt;a name=&#34;multi-lang-toggle&#34; style=&#34;font-size: 12px;&#34; lang=&#39;python&#39; href=&#34;javascript://&#34;&gt;Python&lt;/a&gt;&#xA;        &#xA;            &lt;a name=&#34;multi-lang-toggle&#34; style=&#34;font-size: 12px;&#34; lang=&#39;go&#39; href=&#34;javascript://&#34;&gt;Go&lt;/a&gt;&#xA;        &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;&#xA;&#xA;&lt;pre name=&#34;group-lang-code-cpp&#34; class=&#34;language-cpp line-numbers&#34; style=&#34;display:true;&#34;&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;UT_Adder.hpp&#34;&#xA;&#xA;int64_t random_int64()&#xA;{&#xA;    static std::random_device rd;&#xA;    static std::mt19937_64 generator(rd());&#xA;    static std::uniform_int_distribution&lt;int64_t&gt; distribution(INT64_MIN,&#xA;                                                               INT64_MAX);&#xA;    return distribution(generator);&#xA;}&#xA;&#xA;int main()&#xA;{&#xA;    UTAdder *dut = new UTAdder();&#xA;    dut-&gt;Step(1);&#xA;    printf(&#34;Initialized UTAdder\n&#34;);&#xA;&#xA;    struct input_t {&#xA;        uint64_t a;&#xA;        uint64_t b;&#xA;        uint64_t cin;&#xA;    };&#xA;&#xA;    struct output_t {&#xA;        uint64_t sum;&#xA;        uint64_t cout;&#xA;    };&#xA;&#xA;    for (int c = 0; c &lt; 114514; c++) {&#xA;        input_t i;&#xA;        output_t o_dut, o_ref;&#xA;&#xA;        i.a   = random_int64();&#xA;        i.b   = random_int64();&#xA;        i.cin = random_int64() &amp; 1;&#xA;&#xA;        auto dut_cal = [&amp;]() {&#xA;            dut-&gt;a   = i.a;&#xA;            dut-&gt;b   = i.b;&#xA;            dut-&gt;cin = i.cin;&#xA;            dut-&gt;Step(1);&#xA;            o_dut.sum  = (uint64_t)dut-&gt;sum;&#xA;            o_dut.cout = (uint64_t)dut-&gt;cout;&#xA;        };&#xA;&#xA;        auto ref_cal = [&amp;]() {&#xA;            uint64_t sum = i.a + i.b;&#xA;            bool carry   = sum &lt; i.a;&#xA;&#xA;            sum += i.cin;&#xA;            carry = carry || sum &lt; i.cin;&#xA;&#xA;            o_ref.sum  = sum;&#xA;            o_ref.cout = carry ;&#xA;        };&#xA;&#xA;        dut_cal();&#xA;        ref_cal();&#xA;        printf(&#34;[cycle %lu] a=0x%lx, b=0x%lx, cin=0x%lx\n&#34;, dut-&gt;xclock.clk, i.a,&#xA;               i.b, i.cin);&#xA;        printf(&#34;DUT: sum=0x%lx, cout=0x%lx\n&#34;, o_dut.sum, o_dut.cout);&#xA;        printf(&#34;REF: sum=0x%lx, cout=0x%lx\n&#34;, o_ref.sum, o_ref.cout);&#xA;        Assert(o_dut.sum == o_ref.sum, &#34;sum mismatch&#34;);&#xA;    }&#xA;&#xA;    dut-&gt;Finish();&#xA;    printf(&#34;Test Passed, destory UTAdder\n&#34;);&#xA;    return 0;&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;&#xA;&#xA;&lt;pre name=&#34;group-lang-code-java&#34; class=&#34;language-java line-numbers&#34; style=&#34;display:none;&#34;&gt;&lt;code class=&#34;language-java&#34;&gt;package com.ut;&#xA;&#xA;import java.math.BigInteger;&#xA;&#xA;// import the generated UT class&#xA;import com.ut.UT_Adder;&#xA;&#xA;public class example {&#xA;    static public void main(String[] args){&#xA;        UT_Adder adder = new UT_Adder();&#xA;        for(int i=0; i&lt;10000; i++){&#xA;            int N = 1000000;&#xA;            long a = (long) (Math.random() * N);&#xA;            long b = (long) (Math.random() * N);&#xA;            long c = (long) (Math.random() * N) &gt; 50 ? 1 : 0;&#xA;            // set inputs&#xA;            adder.a.Set(a);&#xA;            adder.b.Set(b);&#xA;            adder.cin.Set(c);&#xA;            // step&#xA;            adder.Step();&#xA;            // reference model&#xA;            long sum = a + b;&#xA;            boolean carry = sum &lt; a ? true : false;&#xA;            sum += c;&#xA;            carry = carry || sum &lt; c;&#xA;            // assert&#xA;            assert adder.sum.U().longValue() == sum : &#34;sum mismatch: &#34; + adder.sum.U() + &#34; != &#34; + sum;&#xA;            assert adder.cout.U().intValue() == (carry ? 1 : 0) : &#34;carry mismatch: &#34; + adder.cout.U() + &#34; != &#34; + carry;&#xA;        }&#xA;        System.out.println(&#34;Java tests passed&#34;);&#xA;        adder.Finish();&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;&#xA;&#xA;&lt;pre name=&#34;group-lang-code-scala&#34; class=&#34;language-scala line-numbers&#34; style=&#34;display:none;&#34;&gt;&lt;code class=&#34;language-scala&#34;&gt;package com.ut&#xA;&#xA;import java.lang.Math&#xA;import com.ut.UT_Adder&#xA;&#xA;object example {&#xA;    def main(args: Array[String]): Unit = {&#xA;      val adder = new UT_Adder()&#xA;      for (i &lt;- 0 until 10000) {&#xA;        val N = 1000000&#xA;        val a = (Math.random() * N).toLong&#xA;        val b = (Math.random() * N).toLong&#xA;        val c = if ((Math.random() * N).toLong &gt; 50) 1 else 0&#xA;&#xA;        // set inputs&#xA;        adder.a.Set(a)&#xA;        adder.b.Set(b)&#xA;        adder.cin.Set(c)&#xA;&#xA;        // step&#xA;        adder.Step()&#xA;&#xA;        // reference model&#xA;        var sum = a + b&#xA;        var carry = if (sum &lt; a) true else false&#xA;        sum += c&#xA;        carry = carry || (sum &lt; c)&#xA;&#xA;        // assert&#xA;        assert(adder.sum.U().longValue() == sum, s&#34;sum mismatch: ${adder.sum.U()} != $sum&#34;)&#xA;        assert(adder.cout.U().intValue() == (if (carry) 1 else 0), s&#34;carry mismatch: ${adder.cout.U()} != $carry&#34;)&#xA;        println(s&#34;[cycle ${adder.xclock.getClk().intValue()}] a=${adder.a.U64()}, b=${adder.b.U64()}, cin=${adder.cin.U64()}&#34;)&#xA;      }&#xA;      println(&#34;Scala tests passed&#34;)&#xA;      adder.Finish()&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;&#xA;&#xA;&lt;pre name=&#34;group-lang-code-python&#34; class=&#34;language-python line-numbers&#34; style=&#34;display:none;&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;from Adder import *&#xA;&#xA;import random&#xA;&#xA;class input_t:&#xA;    def __init__(self, a, b, cin):&#xA;        self.a = a&#xA;        self.b = b&#xA;        self.cin = cin&#xA;&#xA;class output_t:&#xA;    def __init__(self):&#xA;        self.sum = 0&#xA;        self.cout = 0&#xA;&#xA;def random_int():&#xA;    return random.randint(-(2**127), 2**127 - 1) &amp; ((1 &lt;&lt; 128) - 1)&#xA;&#xA;def as_uint(x, nbits):&#xA;    return x &amp; ((1 &lt;&lt; nbits) - 1)&#xA;&#xA;def main():&#xA;    dut = DUTAdder()  # Assuming USE_VERILATOR&#xA;&#xA;    print(&#34;Initialized UTAdder&#34;)&#xA;&#xA;    for c in range(11451):&#xA;        i = input_t(random_int(), random_int(), random_int() &amp; 1)&#xA;        o_dut, o_ref = output_t(), output_t()&#xA;&#xA;        def dut_cal():&#xA;            dut.a.value, dut.b.value, dut.cin.value = i.a, i.b, i.cin&#xA;            dut.Step(1)&#xA;            o_dut.sum = dut.sum.value&#xA;            o_dut.cout = dut.cout.value&#xA;&#xA;        def ref_cal():&#xA;            sum = as_uint( i.a + i.b + i.cin, 128+1)&#xA;            o_ref.sum = as_uint(sum, 128)&#xA;            o_ref.cout = as_uint(sum &gt;&gt; 128, 1)&#xA;&#xA;        dut_cal()&#xA;        ref_cal()&#xA;&#xA;        print(f&#34;[cycle {dut.xclock.clk}] a=0x{i.a:x}, b=0x{i.b:x}, cin=0x{i.cin:x}&#34;)&#xA;        print(f&#34;DUT: sum=0x{o_dut.sum:x}, cout=0x{o_dut.cout:x}&#34;)&#xA;        print(f&#34;REF: sum=0x{o_ref.sum:x}, cout=0x{o_ref.cout:x}&#34;)&#xA;&#xA;        assert o_dut.sum == o_ref.sum, &#34;sum mismatch&#34;&#xA;&#xA;    dut.Finish()&#xA;&#xA;    print(&#34;Test Passed, destroy UTAdder&#34;)&#xA;&#xA;if __name__ == &#34;__main__&#34;:&#xA;    main()&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;&#xA;&#xA;&lt;pre name=&#34;group-lang-code-go&#34; class=&#34;language-go line-numbers&#34; style=&#34;display:none;&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;    &#34;time&#34;&#xA;    &#34;math/rand&#34;&#xA;    ut &#34;UT_Adder&#34;&#xA;)&#xA;&#xA;func assert(cond bool, msg string) {&#xA;    if !cond {&#xA;        panic(msg)&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;    adder := ut.NewUT_Adder()&#xA;    rand.Seed(time.Now().UnixNano())&#xA;    for i := 0; i &lt; 10000; i++ {&#xA;        N := 1000000&#xA;        a := rand.Int63n(int64(N))&#xA;        b := rand.Int63n(int64(N))&#xA;        var c int64&#xA;        if rand.Int63n(int64(N)) &gt; 50 {&#xA;            c = 1&#xA;        } else {&#xA;            c = 0&#xA;        }&#xA;&#xA;        adder.A.Set(a)&#xA;        adder.B.Set(b)&#xA;        adder.Cin.Set(c)&#xA;&#xA;        adder.Step()&#xA;&#xA;        // reflerence model&#xA;        sum := a + b&#xA;        carry := sum &lt; a&#xA;        sum += c&#xA;        carry = carry || sum &lt; c&#xA;&#xA;        // assert&#xA;        assert(adder.Sum.U64() == uint64(sum), fmt.Sprintf(&#34;sum mismatch: %d != %d\n&#34;, adder.Sum.U64(), uint64(sum)))&#xA;&#xA;        var carry_bool uint64&#xA;        if carry {&#xA;            carry_bool = 1&#xA;        } else {&#xA;            carry_bool = 0&#xA;        }&#xA;        assert(adder.Cout.U64() == carry_bool, fmt.Sprintf(&#34;carry mismatch: %d != %t\n&#34;, adder.Cout.U().Int64(), carry))&#xA;    }&#xA;    adder.Finish();&#xA;    fmt.Println(&#34;Golang tests passed&#34;)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>CoupledL2</title>
      <link>https://open-verify.cc/mlvp/docs/multi-lang/examples/coupledl2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/docs/multi-lang/examples/coupledl2/</guid>
      <description>&lt;p&gt;&lt;code&gt;CoupledL2&lt;/code&gt;是一个非阻塞的&lt;a href=&#34;https://github.com/OpenXiangShan/CoupledL2&#34;&gt;L2 Cache&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;下面的代码会对&lt;code&gt;CoupledL2&lt;/code&gt;进行简单的验证，并使用数组作为参考模型，验证过程如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;生成随机的地址&lt;code&gt;addr&lt;/code&gt;、执行&lt;code&gt;AcquireBlock&lt;/code&gt;，请求读取&lt;code&gt;addr&lt;/code&gt;的数据。&lt;/li&gt;&#xA;&lt;li&gt;执行&lt;code&gt;GrantData&lt;/code&gt;，接收&lt;code&gt;DUT&lt;/code&gt;响应的数据。&lt;/li&gt;&#xA;&lt;li&gt;把接收到的数据和参考模型的内容进行比较，验证行为是否一致。&lt;/li&gt;&#xA;&lt;li&gt;执行&lt;code&gt;GrantAck&lt;/code&gt;，响应&lt;code&gt;DUT&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;执行&lt;code&gt;ReleaseData&lt;/code&gt;，向&lt;code&gt;DUT&lt;/code&gt;请求在&lt;code&gt;addr&lt;/code&gt;写入随机数据&lt;code&gt;data&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;同步参考模型，把&lt;code&gt;addr&lt;/code&gt;的数据更新为&lt;code&gt;data&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;执行&lt;code&gt;ReleaseAck&lt;/code&gt;，接收&lt;code&gt;DUT&lt;/code&gt;的写入响应。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;上述步骤会重复4000次。&lt;/p&gt;&#xA;&lt;p&gt;验证代码：&lt;/p&gt;&#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&#xA;    &#xA;    &lt;div style=&#34;background-color: #f0f0f0; display: flex; justify-content: flex-end; gap: 5px; padding-right: 5px&#34;&gt;&#xA;        &#xA;            &lt;a name=&#34;multi-lang-toggle&#34; style=&#34;font-size: 12px;&#34; lang=&#39;cpp&#39; href=&#34;javascript://&#34;&gt;Cpp&lt;/a&gt;&#xA;        &#xA;            &lt;a name=&#34;multi-lang-toggle&#34; style=&#34;font-size: 12px;&#34; lang=&#39;java&#39; href=&#34;javascript://&#34;&gt;Java&lt;/a&gt;&#xA;        &#xA;            &lt;a name=&#34;multi-lang-toggle&#34; style=&#34;font-size: 12px;&#34; lang=&#39;python&#39; href=&#34;javascript://&#34;&gt;Python&lt;/a&gt;&#xA;        &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;&#xA;&#xA;&lt;pre name=&#34;group-lang-code-cpp&#34; class=&#34;language-cpp line-numbers&#34; style=&#34;display:true;&#34;&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;UT_CoupledL2.hpp&#34;&#xA;using TLDataArray = std::array&lt;uint64_t, 2&gt;;&#xA;&#xA;enum class OpcodeA : uint32_t {&#xA;  PutFullData = 0x0,&#xA;  PutPartialData = 0x1,&#xA;  ArithmeticData = 0x2,&#xA;  LogicalData = 0x3,&#xA;  Get = 0x4,&#xA;  Hint = 0x5,&#xA;  AcquireBlock = 0x6,&#xA;  AcquirePerm = 0x7,&#xA;};&#xA;&#xA;enum class OpcodeB : uint32_t { ProbeBlock = 0x6, ProbePerm = 0x7 };&#xA;&#xA;enum class OpcodeC : uint32_t { ProbeAck = 0x4, ProbeAckData = 0x5, Release = 0x6, ReleaseData = 0x7 };&#xA;&#xA;enum class OpcodeD : uint32_t { AccessAck, AccessAckData, HintAck, Grant = 0x4, GrantData = 0x5, ReleaseAck = 0x6 };&#xA;&#xA;enum class OpcodeE : uint32_t { GrantAck = 0x4 };&#xA;&#xA;constexpr std::initializer_list&lt;const char *&gt; ARGS = {&#34;+verilator+rand+reset+0&#34;};&#xA;auto dut = UTCoupledL2(ARGS);&#xA;auto &amp;clk = dut.xclock;&#xA;&#xA;void sendA(OpcodeA opcode, uint32_t size, uint32_t address) {&#xA;  const auto &amp;valid = dut.master_port_0_0_a_valid;&#xA;  const auto &amp;ready = dut.master_port_0_0_a_ready;&#xA;  while (ready.value == 0x0) clk.Step();&#xA;  valid.value = 1;&#xA;  dut.master_port_0_0_a_bits_opcode.value = opcode;&#xA;  dut.master_port_0_0_a_bits_size.value = size;&#xA;  dut.master_port_0_0_a_bits_address.value = address;&#xA;  clk.Step();&#xA;  valid.value = 0;&#xA;}&#xA;&#xA;void getB() {&#xA;  assert(false);&#xA;  const auto &amp;valid = dut.master_port_0_0_b_valid;&#xA;  const auto &amp;ready = dut.master_port_0_0_b_ready;&#xA;  ready.value = 1;&#xA;  while (valid.value == 0)&#xA;    clk.Step();&#xA;  dut.master_port_0_0_b_bits_opcode = 0x0;&#xA;  dut.master_port_0_0_b_bits_param = 0x0;&#xA;  dut.master_port_0_0_b_bits_size = 0x0;&#xA;  dut.master_port_0_0_b_bits_source = 0x0;&#xA;  dut.master_port_0_0_b_bits_address = 0x0;&#xA;  dut.master_port_0_0_b_bits_mask = 0x0;&#xA;  dut.master_port_0_0_b_bits_data = 0x0;&#xA;  dut.master_port_0_0_b_bits_corrupt = 0x0;&#xA;  clk.Step();&#xA;  ready.value = 0;&#xA;}&#xA;&#xA;void sendC(OpcodeC opcode, uint32_t size, uint32_t address, uint64_t data) {&#xA;  const auto &amp;valid = dut.master_port_0_0_c_valid;&#xA;  const auto &amp;ready = dut.master_port_0_0_c_ready;&#xA;&#xA;  while (ready.value == 0) clk.Step();&#xA;  valid.value = 1;&#xA;  dut.master_port_0_0_c_bits_opcode.value = opcode;&#xA;  dut.master_port_0_0_c_bits_size.value = size;&#xA;  dut.master_port_0_0_c_bits_address.value = address;&#xA;  dut.master_port_0_0_c_bits_data.value = data;&#xA;  clk.Step();&#xA;  valid.value = 0;&#xA;}&#xA;&#xA;void getD() {&#xA;  const auto &amp;valid = dut.master_port_0_0_d_valid;&#xA;  const auto &amp;ready = dut.master_port_0_0_d_ready;&#xA;  ready.value = 1;&#xA;  clk.Step();&#xA;  while (valid.value == 0) clk.Step();&#xA;  ready.value = 0;&#xA;}&#xA;&#xA;void sendE(uint32_t sink) {&#xA;  const auto &amp;valid = dut.master_port_0_0_e_valid;&#xA;  const auto &amp;ready = dut.master_port_0_0_e_ready;&#xA;  while (ready.value == 0) clk.Step();&#xA;  valid.value = 1;&#xA;  dut.master_port_0_0_e_bits_sink.value = sink;&#xA;  clk.Step();&#xA;  valid.value = 0;&#xA;}&#xA;&#xA;void AcquireBlock(uint32_t address) { sendA(OpcodeA::AcquireBlock, 0x6, address); }&#xA;&#xA;void GrantData(TLDataArray &amp;r_data) {&#xA;  const auto &amp;opcode = dut.master_port_0_0_d_bits_opcode;&#xA;  const auto &amp;data = dut.master_port_0_0_d_bits_data;&#xA;&#xA;  for (int i = 0; i &lt; 2; i++) {&#xA;    do { getD(); } while (opcode.value != OpcodeD::GrantData);&#xA;    r_data[i] = data.value;&#xA;  }&#xA;}&#xA;&#xA;void GrantAck(uint32_t sink) { sendE(sink); }&#xA;&#xA;void ReleaseData(uint32_t address, const TLDataArray &amp;data) {&#xA;  for (int i = 0; i &lt; 2; i++)&#xA;    sendC(OpcodeC::ReleaseData, 0x6, address, data[i]);&#xA;}&#xA;&#xA;void ReleaseAck() {&#xA;  const auto &amp;opcode = dut.master_port_0_0_d_bits_opcode;&#xA;  do { getD(); } while (opcode.value != OpcodeD::ReleaseAck);&#xA;}&#xA;&#xA;int main() {&#xA;  TLDataArray ref_data[16] = {};&#xA;  /* Random generator */&#xA;  std::random_device rd;&#xA;  std::mt19937_64 gen_rand(rd());&#xA;  std::uniform_int_distribution&lt;uint32_t&gt; distrib(0, 0xf - 1);&#xA;&#xA;  /* DUT init */&#xA;  dut.InitClock(&#34;clock&#34;);&#xA;  dut.reset.SetWriteMode(xspcomm::WriteMode::Imme);&#xA;  dut.reset.value = 1;&#xA;  clk.Step();&#xA;  dut.reset.value = 0;&#xA;  for (int i = 0; i &lt; 100; i++) clk.Step();&#xA;&#xA;  /* Test loop */&#xA;  for (int test_loop = 0; test_loop &lt; 4000; test_loop++) {&#xA;    uint32_t d_sink;&#xA;    TLDataArray data{}, r_data{};&#xA;    /* Generate random */&#xA;    const auto address = distrib(gen_rand) &lt;&lt; 6;&#xA;    for (auto &amp;i : data)&#xA;      i = gen_rand();&#xA;&#xA;    printf(&#34;[CoupledL2 Test\t%d]: At address(0x%03x), &#34;, test_loop + 1, address);&#xA;    /* Read */&#xA;    AcquireBlock(address);&#xA;    GrantData(r_data);&#xA;&#xA;    // Print read result&#xA;    printf(&#34;Read: &#34;);&#xA;    for (const auto &amp;x : r_data)&#xA;      printf(&#34;%08lx&#34;, x);&#xA;&#xA;    d_sink = dut.master_port_0_0_d_bits_sink.value;&#xA;    assert ((r_data == ref_data[address &gt;&gt; 6]) &amp;&amp; &#34;Read Failed&#34;);&#xA;    GrantAck(d_sink);&#xA;&#xA;    /* Write */&#xA;    ReleaseData(address, data);&#xA;    ref_data[address &gt;&gt; 6] = data;&#xA;    ReleaseAck();&#xA;&#xA;    // Print write data&#xA;    printf(&#34;, Write: &#34;);&#xA;    for (const auto &amp;x : data)&#xA;      printf(&#34;%08lx&#34;, x);&#xA;    printf(&#34;.\n&#34;);&#xA;  }&#xA;&#xA;  return 0;&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;&#xA;&#xA;&lt;pre name=&#34;group-lang-code-java&#34; class=&#34;language-java line-numbers&#34; style=&#34;display:none;&#34;&gt;&lt;code class=&#34;language-java&#34;&gt;import com.ut.UT_CoupledL2;&#xA;import com.xspcomm.WriteMode;&#xA;&#xA;import java.io.BufferedWriter;&#xA;import java.io.IOException;&#xA;import java.io.OutputStreamWriter;&#xA;import java.io.PrintWriter;&#xA;import java.math.BigInteger;&#xA;import java.util.Arrays;&#xA;import java.util.Random;&#xA;import java.util.random.RandomGenerator;&#xA;&#xA;class Opcode {&#xA;    public enum A {&#xA;        PutFullData(0x0),&#xA;        PutPartialData(0x1),&#xA;        ArithmeticData(0x2),&#xA;        LogicalData(0x3),&#xA;        Get(0x4),&#xA;        Hint(0x5),&#xA;        AcquireBlock(0x6),&#xA;        AcquirePerm(0x7);&#xA;&#xA;        private final int value;&#xA;&#xA;        A(int value) {&#xA;            this.value = value;&#xA;        }&#xA;&#xA;        public int getValue() {&#xA;            return value;&#xA;        }&#xA;    }&#xA;&#xA;    public enum B {&#xA;        ProbeBlock(0x6), ProbePerm(0x7);&#xA;&#xA;        private final int value;&#xA;&#xA;        B(int value) {&#xA;            this.value = value;&#xA;        }&#xA;&#xA;        public int getValue() {&#xA;            return value;&#xA;        }&#xA;    }&#xA;&#xA;    public enum C {&#xA;        ProbeAck(0x4), ProbeAckData(0x5), Release(0x6), ReleaseData(0x7);&#xA;&#xA;        private final int value;&#xA;&#xA;        C(int value) {&#xA;            this.value = value;&#xA;        }&#xA;&#xA;        public int getValue() {&#xA;            return value;&#xA;        }&#xA;    }&#xA;&#xA;    public enum D {&#xA;        AccessAck(0x0), AccessAckData(0x1), HintAck(0x2), Grant(0x4), GrantData(0x5), ReleaseAck(0x6);&#xA;&#xA;        private final int value;&#xA;&#xA;        D(int value) {&#xA;            this.value = value;&#xA;        }&#xA;&#xA;        public int getValue() {&#xA;            return value;&#xA;        }&#xA;    }&#xA;&#xA;    public enum E {&#xA;        GrantAck(0x4);&#xA;&#xA;        private final int value;&#xA;&#xA;        E(int value) {&#xA;            this.value = value;&#xA;        }&#xA;&#xA;        public int getValue() {&#xA;            return value;&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;public class TestCoupledL2 {&#xA;    static PrintWriter pwOut = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));&#xA;    static UT_CoupledL2 dut;&#xA;&#xA;    static void sendA(int opcode, int size, int address) {&#xA;        var valid = dut.master_port_0_0_a_valid;&#xA;        var ready = dut.master_port_0_0_a_ready;&#xA;        while (!ready.B()) dut.xclock.Step();&#xA;        valid.Set(1);&#xA;        dut.master_port_0_0_a_bits_opcode.Set(opcode);&#xA;        dut.master_port_0_0_a_bits_size.Set(size);&#xA;        dut.master_port_0_0_a_bits_address.Set(address);&#xA;        dut.xclock.Step();&#xA;        valid.Set(0);&#xA;    }&#xA;&#xA;    static void getB() {&#xA;        var valid = dut.master_port_0_0_b_valid;&#xA;        var ready = dut.master_port_0_0_b_ready;&#xA;        ready.Set(1);&#xA;        while (!valid.B()) dut.xclock.Step();&#xA;        ready.Set(0);&#xA;    }&#xA;&#xA;    static void sendC(int opcode, int size, int address, long data) {&#xA;        var valid = dut.master_port_0_0_c_valid;&#xA;        var ready = dut.master_port_0_0_c_ready;&#xA;&#xA;        while (!ready.B()) dut.xclock.Step();&#xA;        valid.Set(1);&#xA;        dut.master_port_0_0_c_bits_opcode.Set(opcode);&#xA;        dut.master_port_0_0_c_bits_size.Set(size);&#xA;        dut.master_port_0_0_c_bits_address.Set(address);&#xA;        dut.master_port_0_0_c_bits_data.Set(data);&#xA;        dut.xclock.Step();&#xA;        valid.Set(0);&#xA;    }&#xA;&#xA;    static void getD() {&#xA;        var valid = dut.master_port_0_0_d_valid;&#xA;        var ready = dut.master_port_0_0_d_ready;&#xA;        ready.Set(1);&#xA;        dut.xclock.Step();&#xA;        while (!valid.B()) dut.xclock.Step();&#xA;        ready.Set(0);&#xA;    }&#xA;&#xA;    static void sendE(int sink) {&#xA;        var valid = dut.master_port_0_0_e_valid;&#xA;        var ready = dut.master_port_0_0_e_ready;&#xA;        while (!ready.B()) dut.xclock.Step();&#xA;        valid.Set(1);&#xA;        dut.master_port_0_0_e_bits_sink.Set(sink);&#xA;        dut.xclock.Step();&#xA;        valid.Set(0);&#xA;    }&#xA;&#xA;    static void AcquireBlock(int address) {&#xA;        sendA(Opcode.A.AcquireBlock.getValue(), 0x6, address);&#xA;    }&#xA;&#xA;    static BigInteger GrantData() {&#xA;        var opcode = dut.master_port_0_0_d_bits_opcode;&#xA;        var data = dut.master_port_0_0_d_bits_data;&#xA;&#xA;        do {&#xA;            getD();&#xA;        } while (opcode.Get().intValue() != Opcode.D.GrantData.getValue());&#xA;        var r_data = data.U64().shiftLeft(64);&#xA;        do {&#xA;            getD();&#xA;        } while (opcode.Get().intValue() != Opcode.D.GrantData.getValue());&#xA;        return r_data.or(data.U64());&#xA;    }&#xA;&#xA;    static void GrantAck(int sink) {&#xA;        sendE(sink);&#xA;    }&#xA;&#xA;    static void ReleaseData(int address, BigInteger data) {&#xA;        sendC(Opcode.C.ReleaseData.getValue(), 0x6, address, data.longValue());&#xA;        sendC(Opcode.C.ReleaseData.getValue(), 0x6, address, data.shiftRight(64).longValue());&#xA;    }&#xA;&#xA;    static void ReleaseAck() {&#xA;        var opcode = dut.master_port_0_0_d_bits_opcode;&#xA;        do {&#xA;            getD();&#xA;        } while (opcode.Get().intValue() != Opcode.D.ReleaseAck.getValue());&#xA;    }&#xA;&#xA;    public static void main(String[] args) throws IOException {&#xA;        /* Random Generator */&#xA;        var gen_rand = RandomGenerator.getDefault();&#xA;        /* DUT init */&#xA;        final String[] ARGS = {&#34;+verilator+rand+reset+0&#34;};&#xA;        dut = new UT_CoupledL2(ARGS);&#xA;        dut.InitClock(&#34;clock&#34;);&#xA;        dut.reset.SetWriteMode(WriteMode.Imme);&#xA;        dut.reset.Set(1);&#xA;        dut.xclock.Step();&#xA;        dut.reset.Set(0);&#xA;        for (int i = 0; i &lt; 100; i++) dut.xclock.Step();&#xA;        dut.xclock.Step();&#xA;&#xA;        /* Ref */&#xA;        BigInteger[] ref_data = new BigInteger[16];&#xA;        Arrays.fill(ref_data, BigInteger.ZERO);&#xA;&#xA;        /* Test loop */&#xA;        for (int test_loop = 0; test_loop &lt; 4000; test_loop++) {&#xA;            var address = gen_rand.nextInt(0xf) &lt;&lt; 6;&#xA;            var data = new BigInteger(128, Random.from(gen_rand));&#xA;&#xA;            pwOut.print(&#34;[CoupledL2 Test%d]: At address(%#03x), &#34;.formatted(test_loop + 1, address));&#xA;            /* Read */&#xA;            AcquireBlock(address);&#xA;            var r_data = GrantData();&#xA;            assert (r_data.equals(ref_data[address &gt;&gt; 6]));&#xA;&#xA;            var sink = dut.master_port_0_0_d_bits_sink.Get().intValue();&#xA;            GrantAck(sink);&#xA;&#xA;&#xA;            /* Write */&#xA;            ReleaseData(address, data);&#xA;            ref_data[address &gt;&gt; 6] = data;&#xA;            ReleaseAck();&#xA;&#xA;            pwOut.println(&#34;Read: %s, Write: %s&#34;.formatted(r_data.toString(), data.toString()));&#xA;            pwOut.flush();&#xA;        }&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;&#xA;&#xA;&lt;pre name=&#34;group-lang-code-python&#34; class=&#34;language-python line-numbers&#34; style=&#34;display:none;&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;################ bundle.py ################&#xA;from toffee import Bundle, Signals, Signal&#xA;&#xA;class DecoupledBundle(Bundle):&#xA;    ready, valid = Signals(2)&#xA;&#xA;class TileLinkBundleA(DecoupledBundle):&#xA;    opcode, param, size, source, address, user_alias, mask, data, corrupt = Signals(9)&#xA;&#xA;class TileLinkBundleB(DecoupledBundle):&#xA;    opcode, param, size, source, address, mask, data, corrupt = Signals(8)&#xA;&#xA;class TileLinkBundleC(DecoupledBundle):&#xA;    opcode, param, size, source, address, user_alias, data, corrupt = Signals(8)&#xA;&#xA;class TileLinkBundleD(DecoupledBundle):&#xA;    opcode, param, size, source, sink, denied, data, corrupt = Signals(8)&#xA;&#xA;class TileLinkBundleE(DecoupledBundle):&#xA;    sink = Signal()&#xA;&#xA;class TileLinkBundle(Bundle):&#xA;    a = TileLinkBundleA.from_regex(r&#34;a_(?:(valid|ready)|bits_(.*))&#34;)&#xA;    b = TileLinkBundleB.from_regex(r&#34;b_(?:(valid|ready)|bits_(.*))&#34;)&#xA;    c = TileLinkBundleC.from_regex(r&#34;c_(?:(valid|ready)|bits_(.*))&#34;)&#xA;    d = TileLinkBundleD.from_regex(r&#34;d_(?:(valid|ready)|bits_(.*))&#34;)&#xA;    e = TileLinkBundleE.from_regex(r&#34;e_(?:(valid|ready)|bits_(.*))&#34;)&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;&#xA;&#xA;&lt;pre name=&#34;group-lang-code-python&#34; class=&#34;language-python line-numbers&#34; style=&#34;display:none;&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;################ agent.py ################&#xA;from toffee import Agent, driver_method&#xA;from toffee.triggers import Value&#xA;from bundle import TileLinkBundle&#xA;&#xA;&#xA;class TilelinkOPCodes:&#xA;    class A:&#xA;        PutFullData = 0x0&#xA;        PutPartialData = 0x1&#xA;        ArithmeticData = 0x2&#xA;        LogicalData = 0x3&#xA;        Get = 0x4&#xA;        Hint = 0x5&#xA;        AcquireBlock = 0x6&#xA;        AcquirePerm = 0x7&#xA;&#xA;    class B:&#xA;        Probe = 0x8&#xA;&#xA;    class C:&#xA;        ProbeAck = 0x4&#xA;        ProbeAckData = 0x5&#xA;        Release = 0x6&#xA;        ReleaseData = 0x7&#xA;&#xA;    class D:&#xA;        AccessAck = 0x0&#xA;        AccessAckData = 0x1&#xA;        HintAck = 0x2&#xA;        Grant = 0x4&#xA;        GrantData = 0x5&#xA;        ReleaseAck = 0x6&#xA;&#xA;    class E:&#xA;        GrantAck = 0x4&#xA;&#xA;&#xA;class TileLinkAgent(Agent):&#xA;    def __init__(self, tlbundle: TileLinkBundle):&#xA;        super().__init__(tlbundle.step)&#xA;&#xA;        self.tlbundle = tlbundle&#xA;&#xA;    @driver_method()&#xA;    async def put_a(self, dict):&#xA;        dict[&#34;valid&#34;] = 1&#xA;        self.tlbundle.a.assign(dict)&#xA;        await Value(self.tlbundle.a.ready, 1)&#xA;        self.tlbundle.a.valid.value = 0&#xA;&#xA;    @driver_method()&#xA;    async def get_d(self):&#xA;        self.tlbundle.d.ready.value = 1&#xA;        await Value(self.tlbundle.d.valid, 1)&#xA;        result = self.tlbundle.d.as_dict()&#xA;        self.tlbundle.d.ready.value = 0&#xA;        return result&#xA;&#xA;    @driver_method()&#xA;    async def get_b(self):&#xA;        self.tlbundle.b.ready.value = 1&#xA;        await Value(self.tlbundle.b.valid, 1)&#xA;        result = self.tlbundle.b.as_dict()&#xA;        self.tlbundle.b.ready.value = 0&#xA;        return result&#xA;&#xA;    @driver_method()&#xA;    async def put_c(self, dict):&#xA;        dict[&#34;valid&#34;] = 1&#xA;        self.tlbundle.c.assign(dict)&#xA;        await Value(self.tlbundle.c.ready, 1)&#xA;        self.tlbundle.c.valid.value = 0&#xA;&#xA;    @driver_method()&#xA;    async def put_e(self, dict):&#xA;        dict[&#34;valid&#34;] = 1&#xA;        self.tlbundle.e.assign(dict)&#xA;        await Value(self.tlbundle.e.ready, 1)&#xA;        self.tlbundle.e.valid.value = 0&#xA;&#xA;    ################################&#xA;&#xA;    async def aquire_block(self, address):&#xA;        await self.put_a(&#xA;            {&#xA;                &#34;*&#34;: 0,&#xA;                &#34;size&#34;: 0x6,&#xA;                &#34;opcode&#34;: TilelinkOPCodes.A.AcquireBlock,&#xA;                &#34;address&#34;: address,&#xA;            }&#xA;        )&#xA;&#xA;        data = 0x0&#xA;        for i in range(2):&#xA;            ret = await self.get_d()&#xA;            while ret[&#34;opcode&#34;] != TilelinkOPCodes.D.GrantData:&#xA;                ret = await self.get_d()&#xA;            data = (ret[&#34;data&#34;] &lt;&lt; (256 * i)) | data&#xA;&#xA;        await self.put_e({&#34;sink&#34;: ret[&#34;sink&#34;]})&#xA;&#xA;        return data&#xA;&#xA;    async def release_data(self, address, data):&#xA;        for _ in range(2):&#xA;            await self.put_c(&#xA;                {&#xA;                    &#34;*&#34;: 0,&#xA;                    &#34;size&#34;: 0x6,&#xA;                    &#34;opcode&#34;: TilelinkOPCodes.C.ReleaseData,&#xA;                    &#34;address&#34;: address,&#xA;                    &#34;data&#34;: data % (2**256),&#xA;                }&#xA;            )&#xA;            data = data &gt;&gt; 256&#xA;&#xA;        x = await self.get_d()&#xA;        while x[&#34;opcode&#34;] != TilelinkOPCodes.D.ReleaseAck:&#xA;            x = await self.get_d()&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&#xA;  &#xA;  &#xA;&#xA;&#xA;&lt;pre name=&#34;group-lang-code-python&#34; class=&#34;language-python line-numbers&#34; style=&#34;display:none;&#34;&gt;&lt;code class=&#34;language-python&#34;&gt;################ test.py ################&#xA;import toffee&#xA;import random&#xA;from toffee.triggers import ClockCycles&#xA;from CoupledL2 import DUTCoupledL2&#xA;from bundle import TileLinkBundle&#xA;from agent import TileLinkAgent&#xA;&#xA;&#xA;async def test_top(dut: DUTCoupledL2):&#xA;    toffee.start_clock(dut)&#xA;&#xA;    dut.reset.value = 1&#xA;    await ClockCycles(dut, 100)&#xA;    dut.reset.value = 0&#xA;&#xA;    tlbundle = TileLinkBundle.from_prefix(&#34;master_port_0_0_&#34;).bind(dut)&#xA;    tlbundle.set_all(0)&#xA;    tlagent = TileLinkAgent(tlbundle)&#xA;&#xA;    await ClockCycles(dut, 20)&#xA;    ref_data = [0] * 0x10&#xA;&#xA;    for _ in range(4000):&#xA;        # Read&#xA;        address = random.randint(0, 0xF) &lt;&lt; 6&#xA;        r_data = await tlagent.aquire_block(address)&#xA;        print(f&#34;Read {address} = {hex(r_data)}&#34;)&#xA;        assert r_data == ref_data[address &gt;&gt; 6]&#xA;&#xA;        # Write&#xA;        send_data = random.randint(0, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)&#xA;        await tlagent.release_data(address, send_data)&#xA;        ref_data[address &gt;&gt; 6] = send_data&#xA;        print(f&#34;Write {address} = {hex(send_data)}&#34;)&#xA;&#xA;&#xA;if __name__ == &#34;__main__&#34;:&#xA;    toffee.setup_logging(toffee.INFO)&#xA;    dut = DUTCoupledL2([&#34;+verilator+rand+reset+0&#34;])&#xA;    dut.InitClock(&#34;clock&#34;)&#xA;    dut.reset.AsImmWrite()&#xA;&#xA;    toffee.run(test_top(dut))&#xA;&#xA;    dut.Finish()&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
