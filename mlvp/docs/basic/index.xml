<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开放验证平台学习资源 – 基础知识</title>
    <link>https://xs-mlvp.github.io/mlvp/docs/basic/</link>
    <description>Recent content in 基础知识 on 开放验证平台学习资源</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	  <atom:link href="https://xs-mlvp.github.io/mlvp/docs/basic/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: 芯片验证</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/basic/ic_verify/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/basic/ic_verify/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;本页简单介绍什么是芯片验证，以及示例里面用到的概念，如 DUT (Design Under Test) 和 RM (Reference Model) 。&lt;/p&gt;
&lt;p&gt;芯片验证过程需要和企业、团队的实际情况契合，没有符合所有要求，必须参考的绝对标准。&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id=&#34;什么是芯片验证&#34;&gt;什么是芯片验证&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;芯片从设计到成品的过程主要包括芯片设计、芯片制造、芯片封测试三大阶段。在芯片设计中，又分前端设计和后端设计，前端设计也称之为逻辑设计，目标是让电路逻辑达到预期功能要求。后端设计也称为物理设计，主要工作是优化布局布线，减小芯片面积，降低功耗，提高频率等。芯片验证（Chip Verification）是芯片设计流程中的一个重要环节。它的目标是确保设计的芯片在功能、性能和功耗等方面都满足预定的规格。验证过程通常包括功能验证、时序验证和功耗验证等多个步骤，使用的方法和工具包括仿真、形式验证、硬件加速和原型制作等。&lt;strong&gt;针对本文，芯片验证仅包含对芯片前端设计的验证，验证设计的电路逻辑是否满足既定需求（&amp;ldquo;Does this proposed design do what is intended?&amp;quot;），通常也称为功能验证（Functional verification），不包含功耗、频率等后端设计&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;
对于芯片产品，一旦设计错误被制造出来修改成本将会非常高昂，因为可能需要召回产品，并重新制造芯片，无论是经济成本还是时间成本都十分昂贵。经典由于芯片验证不足导致失败的典型案例如下：
&lt;p&gt;&lt;strong&gt;Intel Pentium FDIV Bug&lt;/strong&gt;：在1994年，Intel的Pentium处理器被发现存在一个严重的除法错误，这个错误被称为FDIV bug。这个错误是由于在芯片的浮点单元中，一个查找表中的几个条目错误导致的。这个错误在大多数应用中不会出现，但在一些特定的计算中会导致结果错误。由于这个错误，Intel不得不召回了大量的处理器，造成了巨大的经济损失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ariane 5 Rocket Failure&lt;/strong&gt;：虽然这不是一个芯片的例子，但它展示了硬件验证的重要性。在1996年，欧洲空间局的Ariane 5火箭在发射后不久就爆炸了。原因是火箭的导航系统中的一个64位浮点数被转换为16位整数时溢出，导致系统崩溃。这个错误在设计阶段没有被发现，导致了火箭的失败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AMD Barcelona Bug&lt;/strong&gt;：在2007年，AMD的Barcelona处理器被发现存在一个严重的转译查找缓冲（TLB）错误。这个错误会导致系统崩溃或者重启。AMD不得不通过降低处理器的频率和发布BIOS更新来解决这个问题，这对AMD的声誉和财务状况造成了重大影响。&lt;/p&gt;
&lt;p&gt;这些案例都强调了芯片验证的重要性。如果在设计阶段就能发现并修复这些错误，那么就可以避免这些昂贵的失败。验证不足的案例不仅发生在过去，也发生在现在，例如某新入局 ASIC 芯片市场的互联网企业打造一款 55 纳米芯片，极力追求面积缩减并跳过验证环节，最终导致算法失败，三次流片皆未通过测试，平均每次流片失败导致企业损失约 50 万美元。&lt;/p&gt;
&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;芯片验证流程&#34;&gt;芯片验证流程&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img alt=&#34;验证在芯片设计中的位置&#34; src=&#34;ic-verify.drawio.svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;芯片设计和验证的耦合关系如上图所示，设计和验证有同样的输入，即规范文档（specification）。参考规范，设计与验证人员双方按照各自的理解，以及各自的需求进行独立编码实现。设计方需要满足的前提是编码的RTL代码“可综合”，需要考虑电路特性，而验证方一般只要考虑功能是否满足要求，编码限制少。双方完成模块开发后，需要进行健全性对比测试（Sanity Test），判定功能是否表现一致，若不一致需要进行协同排查，确定问题所在并进行修复，再进行对比测试，直到所有功能点都满足预期。由于芯片设计和芯片验证耦合度很高，因此有些企业在研发队伍上也进行了直接耦合，为每个子模块的设计团队都配置了对应的验证团队（DV）。上图中的设计与验证的耦合流程为粗粒度的关系，具体到具体芯片（例如Soc、DDR）、具体企业等都有其适合自身的合作模式。&lt;/p&gt;
&lt;p&gt;在上述对比测试中，设计方的产出的模块通常称为DUT（Design Under Test），验证方开发的模型通常称为RM（Reference Model）。针对图中的验证工作，按照流程可以有：编写验证计划、创建验证平台、整理功能点、构建测试用例、运行调试、收集Bug/覆盖率、回归测试、编写测试报告等多个阶段。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;
&lt;p&gt;&lt;strong&gt;验证计划：&lt;/strong&gt; 验证计划描述了如何进行验证，以及如何保证验证质量，达到功能验证要求。在文档结构上通常包含验证目标，验证策略、验证环境、验证项、验证过程、风险防范、资源及时间表、结果和报告等部分。验证目标明确需要验证的功能或性能指标，这些目标应该直接从芯片的规范文档中提取。验证策略描述如何进行验证，包括可能使用的验证方法，例如仿真、形式化、FPGA加速等，以及如何组织验证任务。验证环境用于描述具体的测试环境，例如验证工具类型，版本号等。验证项库俄超关羽需要验证的具体项以及预期结果。验证计划可以有总计划，也可以针对具体验证的子任务进行编写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平台搭建：&lt;/strong&gt; 验证平台是具体验证任务的执行环境，同一类验证任务可以使用相同的验证平台。验证平台的搭建是验证流程中的关键步骤、具体包含验证工具选择（例如是采用软件仿真，还是采用形式化验证，或者硬件加速）、环境配置（例如配置服务器环境，FPGA环境）、创建测试环境、基本测试案例等。创建好基本测试平台，跑通基本测试案例，也通常称为“冒烟测试”。后继具体的测试代码，都将基于该测试平台进行，因此测试平台需要具有可重用性。验证平台通过包含测试框架和被测试代码，以及对应的基本信号激励。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能点整理：&lt;/strong&gt; 功能点整理，即需要根据规范手册（spec）列出DUT的基本功能，并对其进行明确的描述，以及如何对该功能点进行测试。功能点整理过程中，需要根据重要性、风险、复杂性等因数对其进行优先级排序。功能点整理还需要对各个功能点进行追踪和状态，如果发现原始功能点有更新需要及时进行对应计划的同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试用例：&lt;/strong&gt; 测试用例是指一组条件或变量，用于确定DUT是否满足特定需求并能正确运行。每个测试用例通常包含测试条件，输入数据，预期结果，实际结果和测试结果。通过运行测试用例并比较预期结果和实际结果，可以确定系统或应用是否正确实现了特定的功能或需求。在芯片验证中，测试用例是用来验证芯片设计是否满足规格要求的重要工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码实现：&lt;/strong&gt; 编码实现即对测试用例的具体执行过程，包括测试数据生成、测试框架选择、编程语言选择、参考模型编写等。编码实现是对功能点和测试用例充分理解后工作，如果理解不到位，可能导致DUT无法驱动，不能发现潜在bug等问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;收集bug/覆盖率：&lt;/strong&gt; 验证的目标就是提前发现设计中存在的bug，因此需要对发现的bug进行收集和管理。没发现一个新缺陷，需要给定唯一标号，并同设计工程师进行bug定级，然后进行状态追踪。能发现bug最好，但在实际验证中不是每次测试都能发现bug，因此需要另外一个指标评价验证是否到位。该指标通常采用覆盖率，当覆盖率超过一点阈值（例如代码覆盖率大于90%）后方可任务进行了充分验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回归测试：&lt;/strong&gt; 验证和设计是一个相互迭代的过程，因此当验证出bug后，需要设计进行修正，且需要保证修正后的DUT仍然能正常工作。这种测试的目的是捕获可能由于修改而引入的新错误，或者重新激活旧错误。回归测试可以是全面的，也就是说，它涵盖了所有的功能，或者可以是选择性的，只针对某些特定的功能或系统部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试报告：&lt;/strong&gt; 测试报告是对整个验证过程的总结，它提供了关于测试活动的全面视图，包括测试的目标、执行的测试用例、发现的问题和缺陷、测试覆盖率和测试效率等。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/p&gt;
&lt;h2 id=&#34;芯片验证层次&#34;&gt;芯片验证层次&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;按照验证对象的大小，芯片验证通常包含UT、BT、IT、ST四个层次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单元测试（Unit Testing， UT）：&lt;/strong&gt; 这是最低的验证层次，主要针对单个模块或组件进行。目标是验证每个模块或组件的功能是否正确。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;块测试（Block Testing，BT）：&lt;/strong&gt; 很多时候，单个模块和其他模块存在紧耦合，如果进行单独UT测试，可能存在信号处理复杂，功能验证不准确等问题，这时候可以把多个有耦合关系的模块合并成一个DUT块进行测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集成测试（Integration Testing）：&lt;/strong&gt; 在单元测试的基础上，将多个模块或组件组合在一起，验证它们能否正确地协同工作，通常用于测试子系统功能是否正常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统测试（System Testing）：&lt;/strong&gt; ST通常也称为Top验证，在集成测试的基础上，将所有的模块或组件组合在一起，形成一个完整的系统，验证系统的功能是否正确，以及系统的性能是否满足要求。&lt;/p&gt;
&lt;p&gt;理论上，这些层次的验证通常按照从低到高的顺序进行，每个层次的验证都建立在前一个层次的验证的基础上。但实际验证活动中，需要根据企业验证人员的规模、熟练度，功能需求等进行选择，不一定所有层次的验证都需要涉及。在每个层次，都需要编写相应的测试用例，运行测试，收集和分析结果，以确保芯片设计的正确性和质量。&lt;/p&gt;
&lt;h2 id=&#34;芯片验证指标&#34;&gt;芯片验证指标&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;芯片验证的指标，通常包含功能正确性、测试覆盖率、缺陷密度、验证效率、验证成本等多个方面。功能正确性是最基本的验证指标，即芯片是否能够正确地执行其设计的功能。这通常通过运行一系列的功能测试用例来验证，包括正常情况下的功能测试，以及异常情况下的鲁棒性测试。测试覆盖率是指测试用例覆盖了多少设计的功能点，以及覆盖的程度如何。高的测试覆盖率通常意味着更高的验证质量。测试覆盖率可以进一步细分为代码覆盖率、功能覆盖率、条件覆盖率等。缺陷密度是指在一定的设计规模或代码量中，发现的缺陷的数量。低的缺陷密度通常意味着更高的设计质量。验证效率是指在一定的时间和资源下，能够完成的验证工作量。高的验证效率通常意味着更高的验证生产力。验证成本是指进行验证所需要的总体资源，包括人力、设备、时间等。低的验证成本通常意味着更高的验证经济性。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;
&lt;p&gt;功能正确性是验证的绝对指标，但在实践中，很多时候无法确定测试方案是否完备，所有测试空间是否全部测试到位，因此需要一个可量化的指标来指导验证是否足够充分，是否可以结束验证。该指标通常采用“测试覆盖率”。测试覆盖率通常有代码覆盖率（行，函数，分支）、功能覆盖率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码行覆盖率：&lt;/strong&gt; 即在测试过程中，DUT的设计代码中有多少行被执行；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数覆盖率：&lt;/strong&gt; 即在测试过程中，DUT的设计代码中有多少函数被执行；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分支覆盖率：&lt;/strong&gt; 即在测试过程中，DUT的设计代码中有多少分支被执行（if else）；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能覆盖率：&lt;/strong&gt; 即在测试过程中，有多少预定义功能被触发。&lt;/p&gt;
&lt;p&gt;高的代码覆盖率可以提高验证的质量和可靠性，但并不能保证验证的完全正确性，因为它不能覆盖所有的输入和状态组合。因此，除了追求高的代码覆盖率，还需要结合其他测试方法和指标，如功能测试、性能测试、缺陷密度等。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/p&gt;
&lt;h2 id=&#34;芯片验证管理&#34;&gt;芯片验证管理&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;芯片验证管理是一个涵盖了芯片验证过程中所有活动的&lt;strong&gt;管理过程&lt;/strong&gt;，包括之前提到的验证策略的制定、验证环境的搭建、测试用例的编写和执行、结果的收集和分析、以及问题和缺陷的跟踪和修复等。芯片验证管理的目标是确保芯片设计满足所有的功能和性能要求，以及规格和标准。&lt;/p&gt;
&lt;p&gt;在芯片验证管理中，首先需要制定一个详细的验证策略，包括验证的目标、范围、方法、时间表等。然后，需要搭建一个适合的验证环境，包括硬件设备、软件工具、测试数据等。接下来，需要编写一系列的测试用例，覆盖所有的功能和性能点，然后执行这些测试用例，收集和分析结果，找出问题和缺陷。最后，需要跟踪和修复这些问题和缺陷，直到所有的测试用例都能通过。&lt;/p&gt;
&lt;p&gt;芯片验证管理是一个复杂的过程，需要多种技能和知识，包括芯片设计、测试方法、项目管理等。它需要与芯片设计、生产、销售等其他活动紧密协作，以确保芯片的质量和性能。芯片验证管理的效果直接影响到芯片的成功和公司的竞争力。因此，芯片验证管理是芯片开发过程中的一个重要环节。&lt;/p&gt;
&lt;p&gt;芯片验证管理过程可以基于“项目管理平台”和“bug管理平台”进行，基于平台的管理效率通常情况下明显高于基于人工的管理模式。&lt;/p&gt;
&lt;h2 id=&#34;芯片验证现状&#34;&gt;芯片验证现状&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;当前，芯片验证通常是在芯片设计公司内部完成的，这一过程不仅技术上复杂，而且具有巨大的成本。从验收与设计的紧密关系来看，芯片验证不可避免地涉及芯片设计的源代码。然而，芯片设计公司通常将芯片设计源代码视为商业机密，这使得必须由公司内部人员来执行芯片验证，难以将验证工作外包。&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;time_of_verification.png&#34;
         alt=&#34;验证工作量占比&#34; width=&#34;700px&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;芯片验证的重要性在于确保设计的芯片在各种条件下能够可靠运行。验证工作不仅仅是为了满足技术规格，还需要应对不断增长的复杂性和新兴技术的要求。随着半导体行业的发展，芯片验证的工作量不断增加，尤其是对于复杂的芯片而言，验证工作已经超过了设计工作，占比超过70%。这使得在工程师人员配比上，验证工程师人数通常是设计工程师人数的2倍或以上（例如zeku的三千人规模团队中，大约有一千人的设计工程师，两千人的验证工程师。其他大型芯片设计公司的验证人员占比类似或更高）。&lt;/p&gt;
&lt;p&gt;由于验证工作的特殊性，需要对芯片设计源代码进行访问，这在很大程度上限制了芯片验证的外包可能性。芯片设计源代码被视为公司的核心商业机密，涉及到技术细节和创新，因此在安全和法律层面上不太可能与外部方共享。这也导致了公司内部人员必须承担验证工作的重任，增加了公司内部的工作负担和成本。&lt;/p&gt;
&lt;p&gt;在当前情况下，芯片验证工程师的需求持续增加。他们需要具备深厚的技术背景，熟悉各种验证工具和方法，并且对新兴技术有敏锐的洞察力。由于验证工作的复杂性，验证团队通常需要庞大的规模，这与设计团队规模形成鲜明对比。&lt;/p&gt;
&lt;p&gt;为了应对这一挑战，行业可能需要不断探索创新的验证方法和工具，以提高验证效率，降低成本。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;
小结：复杂芯片验证成本昂贵，表现在如下几个方面
&lt;p&gt;&lt;strong&gt;验证工作量大：&lt;/strong&gt; 对于复杂芯片，验证工作在整个芯片设计工作中，占比超过 70%。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人力成本高：&lt;/strong&gt; 验证工程师人数是设计工程师人数的2倍，对于复杂业务，工程师数量在千人以上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内部验证：&lt;/strong&gt; 芯片设计公司为了保证商业秘密（芯片设计代码）不被泄露，只能选择招聘大量验证工程师，在公司内部进行验证工作。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/p&gt;
&lt;h2 id=&#34;芯片验证众包&#34;&gt;芯片验证众包&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;相比与硬件，软件领域为了减少软件测试成本，测试外包（分包）已经成为常态，该领域的分包业务非常成熟，市场规模已经是千亿人民币级别，并朝万亿级别规模进发。从工作内容上看，软件测试和硬件验证，有非常大的共同特征（系统的目的不同的对象），如果以软件的方式对硬件验证进行分包是否可行？&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;软件外包市场&#34; src=&#34;maket_of_soft_test.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;
把芯片验证工作进行外包（分包）面临诸多挑战，例如：
&lt;p&gt;&lt;strong&gt;从业人员基数少：&lt;/strong&gt; 相比软件领域，硬件开发者数量少了几个数量级。例如在github的统计上（https://madnight.github.io/githut/#/pull_requests/2023/2），传统软件编程语言占（Python、Java、C++，Go）比接近 50%， 而硬件描述语言，verilog占比仅 0.076%，这能从侧面反应出各自领域的开发者数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;验证工具商业化：&lt;/strong&gt; 企业中使用的验证工具（仿真器、形式化、数据分析）几乎都是商业工具，这类工具对于普通人来说几乎不可见，自学难度高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开放学习资料少：&lt;/strong&gt; 芯片验证涉及到访问芯片设计的源代码，而这些源代码通常被视为公司的商业机密和专有技术。芯片设计公司可能不愿意公开详细的验证过程和技术，限制了学习材料的可用性。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/p&gt;
&lt;h4 id=&#34;可行性分析&#34;&gt;可行性分析&lt;/h4&gt;
&lt;p&gt;虽然芯片验证领域一直以来相对封闭，但从技术角度而言，采用分包的方式进行验证是一种可行的选择。这主要得益于以下几个因素：&lt;/p&gt;
&lt;p&gt;首先，随着开源芯片项目的逐渐增多，验证过程中所涉及的源代码已经变得更加开放和透明。这些开源项目在设计和验证过程中没有商业机密的顾虑，为学习和研究提供了更多的可能性。即使某些项目涉及商业机密，也可以通过采用加密等方式来隐藏设计代码，从而在一定程度上解决了商业机密的问题，使验证更容易实现。&lt;/p&gt;
&lt;p&gt;其次，芯片验证领域已经涌现出大量的基础验证工具，如verilator和systemc等。这些工具为验证工程师提供了强大的支持，帮助他们更高效地进行验证工作。通过这些工具，验证过程的复杂性和难度得到了一定程度的缓解，为采用分包的验证方法提供了更为可行的技术基础。&lt;/p&gt;
&lt;p&gt;在开源软件领域，已经有一些成功的案例可供参考。例如，Linux内核的验证过程采用了分包的方式，不同的开发者和团队分别负责不同的模块验证，最终形成一个整体完备的系统。类似地，机器学习领域的ImageNet项目也采用了分包标注的策略，通过众包的方式完成大规模的图像标注任务。这些案例为芯片验证领域提供了成功的经验，证明了分包验证在提高效率、降低成本方面的潜力。&lt;/p&gt;
&lt;p&gt;因此，尽管芯片验证领域相对于其他技术领域而言仍显得封闭，但技术的进步和开源项目的增多为采用分包验证提供了新的可能性。通过借鉴其他领域的成功经验和利用现有的验证工具，我们有望在芯片验证中推动更加开放、高效的验证方法的应用，进一步促进行业的发展。这种技术的开放性和灵活性将为验证工程师提供更多的选择，推动芯片验证领域迎来更为创新和多样化的发展。&lt;/p&gt;
&lt;h4 id=&#34;技术路线&#34;&gt;技术路线&lt;/h4&gt;
&lt;blockquote&gt;&lt;p&gt;
&lt;p&gt;为了克服挑战，让更多的人参与到芯片验证，本项目从如下几个技术方向进行持续尝试&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提供多语言验证工具：&lt;/strong&gt; 传统芯片验证是基于System Verilog编程语言进行，但是该语言用户基数少，为了让其他软件开发/测试的技术人员参与到芯片验证，本项目提供多语言验证转换工具Picker（http://xxx），它可以让验证者使用自己熟悉的编程语言（例如C++/Python/Java/Go）基于开源验证工具参与验证工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提供验证学习材料：&lt;/strong&gt; 芯片验证学习材料少，主要原因由于商业公司几乎不可能公开其内部资料，为此本项目会持续更新学习材料，让验证人员可在线，免费学习所需要的技能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提供真实芯片验证案例：&lt;/strong&gt; 为了让学习材料更具使用性，本项目以“香山昆明湖（工业级高性能risc-v处理器）IP核”作为基础，从中摘取模块持续更新验证案例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组织芯片设计分包验证：&lt;/strong&gt; 学以致用是每个人学习的期望目标，为此本项目定期组织芯片设计的验证分包，让所有人（无论你是大学生、验证专家、软件开发测试者、还是中学生）都可以参与到真实芯片的设计工作中去。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/p&gt;
&lt;p&gt;本项目的目标是达到如下愿景，“打开传统验证模式的黑盒，让所有感兴趣的人可以随时随地的，用自己擅长的编程语言参与芯片验证”。&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;landscape.png&#34;
         alt=&#34;愿景&#34; width=&#34;700px&#34;/&gt; 
&lt;/figure&gt;


      </description>
    </item>
    
    <item>
      <title>Docs: 数字电路</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/basic/ic_base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/basic/ic_base/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;本页将介绍数字电路的基础知识。数字电路是利用数字信号的电子电路。近年来，绝大多数的计算机都是基于数字电路实现的。&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id=&#34;什么是数字电路&#34;&gt;什么是数字电路&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;数字电路是一种利用两种不连续的电位来表示信息的电子电路。在数字电路中，通常使用两个电源电压，分别表示高电平（H）和低电平（L），分别代表数字1和0。这样的表示方式通过离散的电信号，以二进制形式传递和处理信息。&lt;/p&gt;
&lt;p&gt;大多数数字电路的实现基于场效应管，其中最常用的是 MOSFET（Metal-Oxide-Semiconductor Field-Effect Transistor，金属氧化物半导体场效应管）。MOSFET 是一种半导体器件，可以在电场的控制下调控电流流动，从而实现数字信号的处理。&lt;/p&gt;
&lt;p&gt;在数字电路中，MOSFET 被组合成各种逻辑电路，如与门、或门、非门等。这些逻辑门通过不同的组合方式，构建了数字电路中的各种功能和操作。以下是一些数字电路的基本特征：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;
&lt;p&gt;&lt;strong&gt;(1) 电位表示信息：&lt;/strong&gt; 数字电路使用两种电位，即高电平和低电平，来表示数字信息。通常，高电平代表数字1，低电平代表数字0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) MOSFET 实现：&lt;/strong&gt; MOSFET 是数字电路中最常用的元件之一。通过控制 MOSFET 的导通和截止状态，可以实现数字信号的处理和逻辑运算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3) 逻辑门的组合：&lt;/strong&gt; 逻辑门是数字电路的基本构建块，由 MOSFET 组成。通过组合不同的逻辑门，可以构建复杂的数字电路，实现各种逻辑功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(4) 二进制表达：&lt;/strong&gt; 数字电路中的信息通常使用二进制系统进行表示。每个数字都可以由一串二进制位组成，这些位可以在数字电路中被处理和操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(5) 电平转换和信号处理：&lt;/strong&gt; 数字电路通过电平的变化和逻辑操作，实现信号的转换和处理。这种离散的处理方式使得数字电路非常适用于计算和信息处理任务。&lt;/p&gt;
&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;为什么要学习数字电路&#34;&gt;为什么要学习数字电路&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;学习数字电路是芯片验证过程中的基础和必要前提，主要体现在以下多个方面：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;
&lt;p&gt;&lt;strong&gt;(1) 理解设计原理：&lt;/strong&gt; 数字电路是芯片设计的基础，了解数字电路的基本原理和设计方法是理解芯片结构和功能的关键。芯片验证的目的是确保设计的数字电路在实际硬件中按照规格正常工作，而理解数字电路原理是理解设计的关键。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) 设计规范：&lt;/strong&gt; 芯片验证通常涉及验证设计是否符合特定的规范和功能要求。学习数字电路可以帮助理解这些规范，从而更好地构建测试用例和验证流程，确保验证的全面性和准确性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3) 时序和时钟：&lt;/strong&gt; 时序问题是数字电路设计和验证中的常见挑战。学习数字电路可以帮助理解时序和时钟的概念，以确保验证过程中能够正确处理时序问题，避免电路中的时序迟滞和冲突。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(4) 逻辑分析：&lt;/strong&gt; 芯片验证通常涉及对逻辑的分析，确保电路的逻辑正确性。学习数字电路可以培养对逻辑的深刻理解，从而更好地进行逻辑分析和故障排查。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(5) 测试用例编写：&lt;/strong&gt; 在芯片验证中，需要编写各种测试用例来确保设计的正确性。对数字电路的理解可以帮助设计更全面、有针对性的测试用例，涵盖电路的各个方面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(6) 信号完整性：&lt;/strong&gt; 学习数字电路有助于理解信号在电路中的传播和完整性问题。在芯片验证中，确保信号在不同条件下的正常传递是至关重要的，特别是在高速设计中。&lt;/p&gt;
&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;整体而言，学习数字电路为芯片验证提供了基础知识和工具，使验证工程师能够更好地理解设计，编写有效的测试用例，分析验证结果，并解决可能出现的问题。数字电路的理论和实践经验对于芯片验证工程师来说都是不可或缺的。&lt;/p&gt;
&lt;h2 id=&#34;数字电路基础知识&#34;&gt;数字电路基础知识&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;&lt;p&gt;
&lt;p&gt;&lt;strong&gt;三极管BJT：&lt;/strong&gt; 三极管又称为双极型晶体管（Bipolar Junction Transistor，BJT），是一种常见的半导体器件，用于电子电路中的放大、开关和调节等功能。它由三个掺杂不同类型的半导体材料层组成，分为发射极（Emitter）、基极（Base）和集电极（Collector）。三极管通过控制基极电流来控制集电极之间的电流，从而实现放大或开关的功能。&lt;/p&gt;
&lt;p&gt;三极管BJT在验证中的作用：&lt;/p&gt;
&lt;p&gt;（1）芯片设计中的应用： 三极管BJT是电子电路中常用的元件之一，广泛应用于各种集成电路中。了解三极管的工作原理和特性，对于理解芯片的设计和功能至关重要。&lt;/p&gt;
&lt;p&gt;（2）模拟电路验证： 芯片验证不仅涉及数字电路的验证，还包括模拟电路的验证。三极管BJT在模拟电路中常用于放大器、振荡器、滤波器等电路中，学习它有助于理解模拟电路的工作原理和验证方法。&lt;/p&gt;
&lt;p&gt;（2）混合信号芯片验证： 许多芯片都是混合信号芯片，同时包含数字和模拟电路。学习三极管BJT的知识可以帮助验证工程师理解芯片中模拟部分的设计和验证过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MOSFET：&lt;/strong&gt; 金属氧化物半导体场效应晶体管（Metal-Oxide-Semiconductor Field-Effect Transistor，MOSFET）是一种常见的场效应晶体管，也是现代集成电路中最常用的晶体管之一。MOSFET由栅极（Gate）、漏极（Source）和源极（Drain）组成，通过栅极电压控制漏极与源极之间的电流。&lt;/p&gt;
&lt;p&gt;MOSFET在芯片验证中的作用：&lt;/p&gt;
&lt;p&gt;（1）数字电路验证： MOSFET常用于数字电路中的开关、逻辑门和存储器等功能单元。理解MOSFET的工作原理和特性有助于设计和验证数字电路，包括静态和动态特性的分析。&lt;/p&gt;
&lt;p&gt;（2）模拟电路验证： 在模拟电路中，MOSFET常用于放大器、滤波器、振荡器等电路中。学习MOSFET有助于理解模拟电路的设计和验证方法，包括小信号模型、大信号模型等。&lt;/p&gt;
&lt;p&gt;（3）混合信号芯片验证： 许多芯片是混合信号芯片，同时包含数字和模拟电路。掌握MOSFET的知识可以帮助验证工程师理解芯片中模拟部分的设计和验证过程，从而提高整个芯片的验证效率和准确性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁存器和触发器：&lt;/strong&gt; 锁存器（Latch）和触发器（Flip-Flop）都是数字电路中用于存储数据的元件，它们在芯片设计和验证中起着重要的作用。&lt;/p&gt;
&lt;p&gt;锁存器（Latch）： 锁存器是一种组合逻辑电路，用于存储少量的数据。它通常由逻辑门构成，具有两种状态：保持状态和透传状态。锁存器在使能信号为高电平时可以将输入数据存储在内部，并在使能信号为低电平时保持存储的数据输出。锁存器通常用于存储数据、控制信号和状态信息等。&lt;/p&gt;
&lt;p&gt;触发器（Flip-Flop）： 触发器是一种时序逻辑电路，用于存储大量的数据和状态。它是由多个门级电路组成的，包括异或门、与门和反相器等。触发器可以实现数据的稳态存储和时序控制功能，是数字电路中最常用的存储器件之一。常见的触发器类型包括RS触发器、D触发器、JK触发器和T触发器等。&lt;/p&gt;
&lt;p&gt;锁存器和触发器在芯片验证中的作用：&lt;/p&gt;
&lt;p&gt;（1）状态存储和控制： 锁存器和触发器在芯片中广泛应用于状态存储和控制功能。理解它们的工作原理和特性有助于验证工程师正确地设计和验证芯片中的状态机和控制逻辑。&lt;/p&gt;
&lt;p&gt;（2）时序分析和验证： 触发器是时序逻辑电路的基本组成单元，掌握触发器的工作原理和时序特性对于芯片的时序分析和验证至关重要。验证工程师需要确保芯片的时序操作符合设计要求，并能够正确地响应各种时序信号。&lt;/p&gt;
&lt;p&gt;（3）时序控制和时钟域： 芯片设计中常涉及多个时钟域和时序控制信号。了解锁存器和触发器在时序控制和时钟域切换中的应用有助于验证工程师设计和验证复杂的时序电路和跨时钟域逻辑。&lt;/p&gt;
&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;硬件描述语言chisel&#34;&gt;硬件描述语言Chisel&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;&lt;p&gt;
&lt;p&gt;&lt;strong&gt;硬件描述语言：&lt;/strong&gt; 硬件描述语言（Hardware Description Language，简称 HDL）是一种用于描述数字电路、系统和硬件的语言。它允许工程师通过编写文本文件来描述硬件的结构、功能和行为，从而实现对硬件设计的抽象和建模。&lt;/p&gt;
&lt;p&gt;HDL 通常被用于设计和仿真数字电路，如处理器、存储器、控制器等。它提供了一种形式化的方法来描述硬件电路的行为和结构，使得设计工程师可以更方便地进行硬件设计、验证和仿真。&lt;/p&gt;
&lt;p&gt;常见的硬件描述语言包括：&lt;/p&gt;
&lt;p&gt;Verilog：Verilog 是最常用的 HDL 之一，它是一种基于事件驱动的硬件描述语言，广泛应用于数字电路设计、验证和仿真。&lt;/p&gt;
&lt;p&gt;VHDL：VHDL 是另一种常用的 HDL，它是一种面向对象的硬件描述语言，提供了更丰富的抽象和模块化的设计方法。&lt;/p&gt;
&lt;p&gt;SystemVerilog：SystemVerilog 是 Verilog 的扩展，它引入了一些高级特性，如对象导向编程、随机化测试等，使得 Verilog 更适用于复杂系统的设计和验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Chisel：&lt;/strong&gt; Chisel 是一种现代化高级的硬件描述语言，与传统的 Verilog 和 VHDL 不同，它是基于 Scala 编程语言的硬件构建语言。Chisel 提供了一种更加现代化和灵活的方法来描述硬件，通过利用 Scala 的特性，可以轻松地实现参数化、抽象化和复用，同时保持硬件级别的效率和性能。&lt;/p&gt;
&lt;p&gt;Chisel 的特点包括：&lt;/p&gt;
&lt;p&gt;现代化的语法：Chisel 的语法更加接近软件编程语言，如 Scala，使得硬件描述更加直观和简洁。&lt;/p&gt;
&lt;p&gt;参数化和抽象化：Chisel 支持参数化和抽象化，可以轻松地创建可配置和可重用的硬件模块。&lt;/p&gt;
&lt;p&gt;类型安全：Chisel 是基于 Scala 的，因此具有类型安全的特性，可以在编译时检测到许多错误。&lt;/p&gt;
&lt;p&gt;生成性能优化的硬件：Chisel 代码可以被转换成 Verilog，然后由标准的 EDA 工具链进行综合、布局布线和仿真，生成性能优化的硬件。&lt;/p&gt;
&lt;p&gt;强大的仿真支持：Chisel 提供了与 ScalaTest 和 Firrtl 集成的仿真支持，使得对硬件进行仿真和验证更加方便和灵活。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Chisel版的全加法器实例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;电路设计如下图所示：&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;fulladder.png&#34;
         alt=&#34;全加器电路&#34; width=&#34;700px&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;完整的Chisel代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;examples&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;chisel3&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;_&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;FullAdder&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Module&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Define IO ports
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;io&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;IO&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Bundle&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Input&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;W&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Input port &amp;#39;a&amp;#39; of width 1 bit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Input&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;W&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Input port &amp;#39;b&amp;#39; of width 1 bit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Input&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;W&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;  &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Input port &amp;#39;cin&amp;#39; (carry-in) of width 1 bit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Output&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;W&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Output port &amp;#39;sum&amp;#39; of width 1 bit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cout&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Output&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;W&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Output port &amp;#39;cout&amp;#39; (carry-out) of width 1 bit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Calculate sum bit (sum of a, b, and cin)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s1&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;io&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;^&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;io&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;               &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// XOR operation between &amp;#39;a&amp;#39; and &amp;#39;b&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;io&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s1&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;^&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;io&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt;              &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// XOR operation between &amp;#39;s1&amp;#39; and &amp;#39;cin&amp;#39;, result assigned to &amp;#39;sum&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Calculate carry-out bit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;io&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;io&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;               &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// AND operation between &amp;#39;a&amp;#39; and &amp;#39;b&amp;#39;, result assigned to &amp;#39;s3&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s1&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;io&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt;               &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// AND operation between &amp;#39;s1&amp;#39; and &amp;#39;cin&amp;#39;, result assigned to &amp;#39;s2&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;io&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cout&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3&lt;/span&gt;                 &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// OR operation between &amp;#39;s2&amp;#39; and &amp;#39;s3&amp;#39;, result assigned to &amp;#39;cout&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;请结合电路图和代码阅读以下解释内容：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;package examples: 这段代码位于名为 examples 的包中。&lt;/p&gt;
&lt;p&gt;import chisel3._: 导入了 Chisel3 库，这是 Chisel 3 的标准导入语句，使我们能够使用 Chisel 的功能。&lt;/p&gt;
&lt;p&gt;class FullAdder extends Module { &amp;hellip; }: 定义了一个名为 FullAdder 的 Chisel 模块。extends Module 表示 FullAdder 是一个继承自 Chisel Module 类的模块。&lt;/p&gt;
&lt;p&gt;val io = IO(new Bundle { &amp;hellip; }): 声明了一个名为 io 的输入输出端口。IO 方法创建了一个新的 Bundle 对象，其中包含了 a、b、cin、sum 和 cout 五个信号。Input 表示这些信号是输入端口，Output 表示这些信号是输出端口，UInt(1.W) 表示这些信号的数据类型为无符号整数，宽度为 1 位。&lt;/p&gt;
&lt;p&gt;val s1 = io.a ^ io.b: 计算了输入端口 a 和 b 的异或结果，并将结果赋给 s1。&lt;/p&gt;
&lt;p&gt;io.sum := s1 ^ io.cin: 计算了 s1 和输入端口 cin 的异或结果，并将结果赋给输出端口 sum。&lt;/p&gt;
&lt;p&gt;val s3 = io.a &amp;amp; io.b: 计算了输入端口 a 和 b 的与操作结果，并将结果赋给 s3。&lt;/p&gt;
&lt;p&gt;val s2 = s1 &amp;amp; io.cin: 计算了 s1 和输入端口 cin 的与操作结果，并将结果赋给 s2。&lt;/p&gt;
&lt;p&gt;io.cout := s2 | s3: 计算了 s2 和 s3 的或操作结果，并将结果赋给输出端口 cout。&lt;/p&gt;
&lt;p&gt;这段代码实现了一个完整的加法器（Full Adder）模块，用于将两个输入端口的数相加，并输出和结果和进位。具体实现原理如下：&lt;/p&gt;
&lt;p&gt;异或操作 ^：异或操作可以实现单位相加，即两个位相加，不考虑进位的情况。例如，0 ^ 0 = 0，0 ^ 1 = 1，1 ^ 0 = 1，1 ^ 1 = 0。&lt;/p&gt;
&lt;p&gt;与操作 &amp;amp;：与操作可以实现进位的生成。只有当两个输入位都为 1 时，与操作的结果才为 1，表示需要进位。例如，1 &amp;amp; 1 = 1，其他情况都为 0。&lt;/p&gt;
&lt;p&gt;或操作 |：或操作可以实现进位的传递。如果有任意一个位为 1，或操作的结果就为 1，表示需要进位。例如，1 | 0 = 1，0 | 1 = 1，1 | 1 = 1，0 | 0 = 0。&lt;/p&gt;
&lt;/p&gt;&lt;/blockquote&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: 创建DUT</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/basic/create_dut/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/basic/create_dut/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;本节主要介绍如何基于Picker创建DUT。&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;创建DUT（Design Under Test）是指在芯片验证过程中，设计并实现被测对象的电路或系统。DUT是验证的主体，是需要验证的电路设计。在创建DUT时，通常需要考虑被测对象的功能、性能要求和验证目标，然后使用硬件描述语言（HDL）如Verilog或VHDL编写相应的电路描述代码，或通过图形化设计工具生成电路设计。创建DUT是验证过程中的第一步，其质量和准确性直接影响着后续的验证工作。&lt;/p&gt;
&lt;p&gt;以&lt;a href=&#34;%22/zh-cn/docs/quick-start/%22&#34;&gt;加法器DUT的创建：&lt;/a&gt;为例，进行解释：&lt;/p&gt;
&lt;p&gt;创建一个名为 Adder 的文件夹，并在其中创建一个名为 Adder.v 的文件。这个文件将包含加法器的 Verilog 代码。下面是一个示例的加法器 Verilog 代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Adder&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;#(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;parameter&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;WIDTH&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;input&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;WIDTH&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;input&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;WIDTH&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;input&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;output&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;WIDTH&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;output&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cout&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;assign&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cout&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;  &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;endmodule&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;UDT解释：&lt;/p&gt;
&lt;p&gt;module Adder &amp;hellip; endmodule: 定义了一个名为 Adder 的模块，该模块实现了加法器的功能。&lt;/p&gt;
&lt;p&gt;parameter WIDTH = 64: 使用 parameter 关键字定义了一个名为 WIDTH 的参数，默认值为 64。这个参数可以控制加法器的输入和输出的位宽。&lt;/p&gt;
&lt;p&gt;input [WIDTH-1:0] a, input [WIDTH-1:0] b: 定义了两个输入端口 a 和 b，它们的宽度为 WIDTH。这里使用了一个向量（vector）来表示输入端口的多个位。&lt;/p&gt;
&lt;p&gt;input cin: 定义了一个输入端口 cin，表示加法器的进位输入。&lt;/p&gt;
&lt;p&gt;output [WIDTH-1:0] sum, output cout: 定义了两个输出端口 sum 和 cout，分别表示加法器的和输出和进位输出。&lt;/p&gt;
&lt;p&gt;assign: 该关键字用于将一个表达式的值赋给一个信号。&lt;/p&gt;
&lt;p&gt;{cout, sum}: 这是一个连续赋值语句，表示将右边表达式的值分别赋给左边的两个信号 cout 和 sum。&lt;/p&gt;
&lt;p&gt;a + b + cin: 这是一个表达式，表示将输入端口 a、b 和 cin 的值相加。由于 a、b 和 sum 都是位宽为 WIDTH 的向量，因此这里进行的是位宽为 WIDTH 的加法运算。&lt;/p&gt;
&lt;p&gt;通过连续赋值语句，将加法器的输出 sum 和 cout 分别赋值为表达式 a + b + cin 的结果的低 WIDTH 位和高 WIDTH 位。&lt;/p&gt;
&lt;p&gt;endmodule: 表示模块定义结束。&lt;/p&gt;
&lt;p&gt;这段 Verilog 代码定义了一个参数化的加法器模块，能够根据参数 WIDTH 控制输入输出的位宽。加法器的输入包括两个 WIDTH 位的数 a 和 b，以及一个单独的进位信号 cin。输出包括一个 WIDTH 位的和 sum 和一个单独的进位输出 cout。加法器的实现通过简单的连续赋值语句，将输入的两个数和进位相加，得到输出的和与进位。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: DUT编译</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/basic/compile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/basic/compile/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;本节主要介绍如何基于Picker编译DUT。&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;编译DUT是指将被测设计（Design Under Test，即DUT）的硬件描述语言（HDL）代码转换为可供仿真和验证使用的逻辑网表的过程。这个过程通常包括综合、优化、映射和布线等步骤，其主要目的是将抽象的HDL代码转换为实际的电路网表，以便进行后续的仿真和验证工作。&lt;/p&gt;
&lt;p&gt;以&lt;a href=&#34;%22/content/zh-cn/docs/quick-start/%22&#34;&gt;加法器DUT的编译：&lt;/a&gt;为例进行解释：&lt;/p&gt;
&lt;p&gt;在 Adder 文件夹中，执行以下命令将 Verilog 文件编译为 C++ Class：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;picker&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Adder&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Adder&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;fst&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;S&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Adder&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;picker_out_adder&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;l&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cpp&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;sim&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;verilator&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个命令会将 Adder.v 文件作为 Top 文件，并将其编译为 C++ Class，使用 verilator 仿真器。编译过程会生成一系列中间文件，其中包括 Verilog 文件、C++ 源代码等。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: DUT验证</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/basic/test_dut/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/basic/test_dut/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;本节主要介绍如何基于Picker验证DUT。&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;DUT测试是芯片验证过程中的关键步骤之一，指的是对被测设计（Design Under Test，即DUT）进行验证和测试的过程。在DUT测试中，验证工程师会通过各种测试方法和技术，对DUT的功能、性能和时序等方面进行全面的评估，以确保DUT能够按照设计要求正常工作，并且满足用户的需求和期望。&lt;/p&gt;
&lt;p&gt;以&lt;a href=&#34;%22/content/zh-cn/docs/quick-start/%22&#34;&gt;加法器DUT的测试：&lt;/a&gt;为例进行解释：&lt;/p&gt;
&lt;p&gt;在测试过程中，我们将创建一个示例项目，并编写测试代码来验证加法器的功能。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;UT_Adder.hpp&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;UTAdder&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dut&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;UTAdder&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;libDPIAdder.so&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// 进行测试...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;delete&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;dut&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这段代码中，我们创建了一个 UTAdder 类的实例，然后进行测试。&lt;/p&gt;
&lt;p&gt;接着，编译测试代码。在 Adder 文件夹中，执行 make 命令，编译测试代码并生成可执行文件。&lt;/p&gt;
&lt;p&gt;最后，运行测试。执行生成的可执行文件，即可运行测试，并观察输出结果。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 验证报告</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/basic/report/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/basic/report/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;在我们完成DUT验证后，编写验证报告是至关重要的一环。本节将从整体角度概述验证报告的结构以及报告所需覆盖的内容。&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id=&#34;1-验证的范围&#34;&gt;1. 验证的范围&lt;/h2&gt;
&lt;p&gt;1.1 什么是验证范围&lt;/p&gt;
&lt;p&gt;在芯片验证过程中，验证范围是指需要进行验证的范围或内容的总体描述。它确定了验证活动所需覆盖的功能、性能、边界条件、接口以及其他关键方面。&lt;/p&gt;
&lt;p&gt;1.2 举例说明&lt;/p&gt;
&lt;p&gt;以加法器功能验证为例，本块内容应该至少描述清楚以下内容：&lt;/p&gt;
&lt;p&gt;（1）基本功能验证：&lt;/p&gt;
&lt;p&gt;确认加法器能够正确执行加法运算，包括对两个输入数进行相加并产生正确的结果。
测试加法器对不同数据宽度（例如8位、16位、32位）的支持，并验证其在不同数据宽度下的加法功能是否正常工作。
边界条件验证：&lt;/p&gt;
&lt;p&gt;验证加法器在最小值、最大值以及边界情况下的加法运算是否正确，例如边界值加法、最大值加法和最小值加法。
测试加法器对于特殊情况（如进位、溢出）的处理是否符合设计要求。&lt;/p&gt;
&lt;p&gt;（2）异常输入验证：&lt;/p&gt;
&lt;p&gt;检查加法器对于不合法输入的处理能力，如无效输入、非数字字符或格式错误输入的情况。
验证加法器在面对不符合规范的输入时能够产生正确的错误提示或异常处理。&lt;/p&gt;
&lt;p&gt;（3）多输入/多操作模式验证：&lt;/p&gt;
&lt;p&gt;确认加法器能够处理多组输入，并正确执行相加操作。
验证加法器在连续多次相加操作下是否能够保持正确的累加结果。&lt;/p&gt;
&lt;h2 id=&#34;2-验证环境说明&#34;&gt;2. 验证环境说明&lt;/h2&gt;
&lt;p&gt;2.1 什么是验证环境&lt;/p&gt;
&lt;p&gt;验证环境是用于运行芯片顶层功能验证的各个组件（component）的集合。它主要包含以下几个部分：&lt;/p&gt;
&lt;p&gt;（1）被测设计（DUT）：&lt;/p&gt;
&lt;p&gt;DUT是待验证的设计单元，即加法器。它是验证的主体，通过验证环境中的测试向量和输入数据进行功能验证。&lt;/p&gt;
&lt;p&gt;（2）CPU子环境（MPI Agent）：&lt;/p&gt;
&lt;p&gt;MPI（Message Passing Interface）Agent是与外部处理器（CPU）通信的组件。它负责处理来自CPU的验证指令，并将验证结果返回给CPU。MPI Agent与CPU之间通过消息传递机制进行通信，以启动验证过程并提供验证结果。&lt;/p&gt;
&lt;p&gt;（3）PTU/PRU子环境（SPT Agent）：&lt;/p&gt;
&lt;p&gt;SPT（System Port Test）Agent是与外部测试单元（PTU/PRU）通信的组件。它负责与PTU/PRU进行数据交换和配置寄存器访问，以验证加法器的功能和性能。SPT Agent通过与PTU/PRU之间的接口通信，控制测试流程并收集验证数据。&lt;/p&gt;
&lt;p&gt;（4）参考模块（RM）：&lt;/p&gt;
&lt;p&gt;参考模块（Reference Model）是验证过程中的参照标准。它包含了预期的加法器功能和性能规格。验证结果将与参考模块的预期结果进行比对，以确认验证的正确性。参考模块通常由设计规格或功能规范定义，并在验证环境中用于验证结果的验证。&lt;/p&gt;
&lt;p&gt;（5）检查器（Checker）：&lt;/p&gt;
&lt;p&gt;检查器是验证环境中的组件，用于检查仿真结果与参考模块预期结果之间的一致性。它负责比对仿真输出和参考模块的预期输出，并生成验证报告。检查器确保验证结果与设计规格的一致性，以确认验证的准确性和完整性。&lt;/p&gt;
&lt;p&gt;（6）脚本（Makefile）：&lt;/p&gt;
&lt;p&gt;Makefile是验证环境的自动化脚本，用于管理验证流程的各个步骤。它包括编译、运行仿真、分析结果等操作，并提供了一种方便的方式来执行验证任务。通过脚本的自动化处理，可以提高验证效率并减少人工错误的可能性。&lt;/p&gt;
&lt;p&gt;2.2 举例说明&lt;/p&gt;
&lt;p&gt;以加法器功能验证为例，本块内容应该至少描述清楚以下内容：&lt;/p&gt;
&lt;p&gt;（1）DUT版本信息：&lt;/p&gt;
&lt;p&gt;DUT名称： 加法器
版本信息： v1.0
设计语言： Verilog HDL
设计工具： Synopsys Design Compiler&lt;/p&gt;
&lt;p&gt;（2）验证平台说明：&lt;/p&gt;
&lt;p&gt;平台名称： FPGA Verification Platform
FPGA型号： Xilinx Virtex UltraScale+ VU9P
仿真工具： Cadence Xcelium Simulator
编译工具： Xilinx Vivado&lt;/p&gt;
&lt;p&gt;（2.1）验证环境架构：&lt;/p&gt;
&lt;p&gt;MPI Agent： 负责与CPU子环境通信，接收和发送验证指令。
SPT Agent： 与PTU/PRU子环境通信，负责与芯片接口进行数据交换和配置寄存器访问。
参考模块（RM）： 包含了预期的加法器功能和性能规格，作为验证结果的参照。
检查器（Checker）： 检查仿真结果与参考模块预期结果之间的一致性，以确认验证的正确性。
脚本（Makefile）： 包含了验证流程的自动化脚本，用于编译、运行仿真以及结果分析。&lt;/p&gt;
&lt;p&gt;（2.2）目录结构：&lt;/p&gt;
&lt;p&gt;列出工作目录下所有文件及文件的概要。&lt;/p&gt;
&lt;p&gt;（2.3）主要文件说明：&lt;/p&gt;
&lt;p&gt;对工作目录中重要文件进行补充说明。&lt;/p&gt;
&lt;h2 id=&#34;3-覆盖率分析&#34;&gt;3. 覆盖率分析&lt;/h2&gt;
&lt;p&gt;3.1 什么是覆盖率分析&lt;/p&gt;
&lt;p&gt;覆盖率分析是软件开发和测试过程中的一种质量评估技术，用于衡量测试对软件代码或功能的覆盖程度。它主要分为两个方面：代码覆盖率分析和功能覆盖率分析。&lt;/p&gt;
&lt;p&gt;（1）代码覆盖率分析：&lt;/p&gt;
&lt;p&gt;代码覆盖率分析关注的是测试用例对软件代码的覆盖程度。它衡量了测试用例执行过程中究竟有多少代码被执行到，以及这些代码中的哪些部分被执行。代码覆盖率分析通常包括语句覆盖率（Statement Coverage）、分支覆盖率（Branch Coverage）、条件覆盖率（Condition Coverage）和路径覆盖率（Path Coverage）等指标。&lt;/p&gt;
&lt;p&gt;（2）功能覆盖率分析：&lt;/p&gt;
&lt;p&gt;功能覆盖率分析关注的是测试用例对软件功能的覆盖程度。它衡量了测试用例是否覆盖了软件规格中定义的各项功能需求。功能覆盖率分析通常包括输入空间覆盖率（Input Space Coverage）、功能操作覆盖率（Functional Operation Coverage）、错误处理覆盖率（Error Handling Coverage）等指标。
覆盖率分析通过分析测试用例的执行情况，可以帮助评估测试的全面性和有效性。较高的覆盖率通常意味着测试用例对软件的覆盖程度更高，从而提高了软件的质量和可靠性。覆盖率分析结果也可以指导测试用例的设计和调整，以进一步提高测试的效率和完整性。&lt;/p&gt;
&lt;p&gt;3.2 举例说明&lt;/p&gt;
&lt;p&gt;以加法器功能验证为例，本块内容应该至少描述清楚以下内容：&lt;/p&gt;
&lt;p&gt;（1）代码覆盖率分析：&lt;/p&gt;
&lt;p&gt;代码覆盖率分析用于评估测试是否覆盖了设计代码中的各个部分和逻辑路径。对于加法器的验证，代码覆盖率分析可以通过以下方式进行：&lt;/p&gt;
&lt;p&gt;语句覆盖率： 确保测试覆盖了加法器设计代码中的所有语句和指令，以验证代码的执行路径。
分支覆盖率： 确保测试覆盖了加法器设计代码中的所有条件分支和控制流程，以验证不同条件下的执行路径。
条件覆盖率： 确保测试覆盖了加法器设计代码中的所有条件表达式的各种可能取值，以验证条件判断的正确性。
路径覆盖率： 确保测试覆盖了加法器设计代码中的所有可能执行路径，以验证代码的完整性和正确性。&lt;/p&gt;
&lt;p&gt;（2）功能覆盖率分析：&lt;/p&gt;
&lt;p&gt;功能覆盖率分析旨在评估测试是否涵盖了设计规格中定义的各项功能要求。对于加法器的验证，功能覆盖率可以通过以下方式进行分析和优化：&lt;/p&gt;
&lt;p&gt;输入空间覆盖率： 确保测试覆盖了所有可能的输入组合，包括边界情况和特殊情况（如进位、溢出）。
功能操作覆盖率： 确保测试覆盖了加法器所有可能的操作模式和功能特性，如单次加法、多次连续加法、不同数据宽度下的加法等。
错误处理覆盖率： 确保测试覆盖了加法器对异常情况的处理，如无效输入、非法操作等，以验证其错误处理能力和容错性。&lt;/p&gt;
&lt;h2 id=&#34;4-未解决bug列表或待改进方案&#34;&gt;4. 未解决Bug列表或待改进方案&lt;/h2&gt;
&lt;p&gt;4.1 什么是未解决Bug列表或待改进方案&lt;/p&gt;
&lt;p&gt;在芯片验证过程中，未解决Bug列表或待改进方案是一个关键的文档，用于跟踪和记录在验证过程中发现的问题和改进点。该列表通常由验证团队维护，并在整个验证过程中进行更新和追踪。&lt;/p&gt;
&lt;p&gt;内容包括但不限于以下方面：&lt;/p&gt;
&lt;p&gt;（1）Bug描述： 每个Bug或待改进方案应该清晰地描述问题的性质、出现的条件、预期行为和实际行为之间的差异。&lt;/p&gt;
&lt;p&gt;（2）Bug优先级： 每个Bug应该根据其对验证工作的影响和紧迫程度确定优先级，以帮助团队优先处理关键问题。&lt;/p&gt;
&lt;p&gt;（3）Bug状态： 每个Bug应该有一个明确定义的状态，如“已确认”、“正在修复”、“待验证”、“已关闭”等，以跟踪Bug的处理进度。&lt;/p&gt;
&lt;p&gt;（4）Bug责任人： 每个Bug应指定一个责任人负责跟进和解决，确保问题得到及时处理。&lt;/p&gt;
&lt;p&gt;（5）Bug跟踪编号： 每个Bug应有一个唯一的标识符，便于跟踪和引用，通常使用Bug跟踪系统中提供的编号。&lt;/p&gt;
&lt;p&gt;4.2 举例说明&lt;/p&gt;
&lt;p&gt;Bug编号	    Bug描述	                                优先级	    状态	     责任人
BUG-001	    加法器对于带有进位的加法操作结果错误	     高	      待修复	    小明
BUG-002	    加法器在32位输入时出现性能下降              中	      正在修复      小红
BUG-003	    加法器在处理负数输入时产生异常结果	         低	      已确认	    小刚
BUG-004	    加法器在高速时钟下出现时序问题	             高	      待验证	    小亮&lt;/p&gt;
&lt;h2 id=&#34;7-验证结论&#34;&gt;7. 验证结论&lt;/h2&gt;
&lt;p&gt;验证结论是在完成芯片验证过程后得出的最终结论，用于总结验证工作的结果并对验证对象的状态进行评估和描述。此处需要明确覆盖率具体指标等内容。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
