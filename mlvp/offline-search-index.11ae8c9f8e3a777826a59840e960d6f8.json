[{"body":"源码安装Picker工具 依赖安装 cmake ( \u003e=3.11 ) gcc ( 支持c++20,至少为10, 最好为11及以上 ) python3 ( \u003e=3.8 ) verilator ( ==4.218 ) verible-verilog-format ( \u003e=0.0-3428-gcfcbb82b ) swig ( \u003e=4.2.0, 目前为master分支， 仅在需要python支持时使用 ) 请注意，请确保verible-verilog-format等工具的路径已经添加到环境变量$PATH中，可以直接命令行调用。\n下载源码 git clone https://github.com/XS-MLVP/picker.git cd picker make init 构建并安装 cd picker export BUILD_XSPCOMM_SWIG=python # 仅在需要python支持时使用 make sudo -E make install 默认的安装的目标路径是 /usr/local， 二进制文件被置于 /usr/local/bin，模板文件被置于 /usr/local/share/picker。\n安装时会自动安装 xspcomm 基础库，该基础库是用于封装 RTL 模块的基础类型，位于 /usr/local/lib/libxspcomm.so。 可能需要手动设置编译时的链接目录参数(-L) 同时如果开启了python支持，还会安装 xspcomm 的python包，位于 /usr/local/share/picker/python/xspcomm/。\n安装测试 执行命令并检查输出：\n➜ picker git:(master) picker XDut Generate. Convert DUT(*.v/*.sv) to C++ DUT libs. Notice that [file] option allow only one file. Usage: XDut Gen [file] [OPTION...] -f, --filelist arg DUT .v/.sv source files, contain the top module, split by comma. Or use '*.txt' file with one RTL file path per line to specify the file list (default: \"\") --sim arg vcs or verilator as simulator, default is verilator (default: verilator) -l, --language arg Build example project, default is cpp, choose cpp or python (default: cpp) -s, --source_dir arg Template Files Dir, default is ${picker_install_path}/../picker/template (default: /usr/local/share/picker/template) -t, --target_dir arg Render files to target dir, default is ./picker_out (default: ./picker_out) -S, --source_module_name arg Pick the module in DUT .v file, default is the last module in the -f marked file (default: \"\") -T, --target_module_name arg Set the module name and file name of target DUT, default is the same as source. For example, -T top, will generate UTtop.cpp and UTtop.hpp with UTtop class (default: \"\") --internal arg Exported internal signal config file, default is empty, means no internal pin (default: \"\") -F, --frequency arg Set the frequency of the **only VCS** DUT, default is 100MHz, use Hz, KHz, MHz, GHz as unit (default: 100MHz) -w, --wave_file_name arg Wave file name, emtpy mean don't dump wave (default: \"\") -c, --coverage Enable coverage, default is not selected as OFF -V, --vflag arg User defined simulator compile args, passthrough. Eg: '-v -x-assign=fast -Wall --trace' || '-C vcs -cc -f filelist.f' (default: \"\") -C, --cflag arg User defined gcc/clang compile command, passthrough. Eg:'-O3 -std=c++17 -I./include' (default: \"\") -v, --verbose Verbose mode -e, --example Build example project, default is OFF -h, --help Print usage 参数解释 [file]: 必需。DUT 的 Verilog 或 SystemVerilog 源文件，包含顶层模块 --filelist, -f: 可选。DUT 的 Verilog 或 SystemVerilog 源文件，逗号分隔。也可以使用 *.txt 文件，每行指定一个 RTL 文件路径，来指定文件列表。 --sim: 可选。模拟器类型，可以是 vcs 或 verilator，默认是 verilator。 --language, -l: 可选。构建示例项目的语言，可以是 cpp 或 python，默认是 cpp。 --source_dir, -s: 可选。模板文件目录，默认是 ${mcv_install_path}/../mcv/template。 --target_dir, -t: 可选。渲染文件的目标目录，默认是 ./mcv_out。 --source_module_name, -S: 可选。在 DUT 的 Verilog 文件中选择模块，默认是 标记的文件中的最后一个模块。 --target_module_name, -T: 可选。设置目标 DUT 的模块名和文件名，默认与源相同。例如，-T top 将生成 UTtop.cpp 和 UTtop.hpp，并包含 UTtop 类。 --internal: 可选。导出的内部信号配置文件，默认为空，表示没有内部引脚。 --frequency, -F: 可选。设置 仅 VCS DUT 的频率，默认是 100MHz，可以使用 Hz、KHz、MHz、GHz 作为单位。 --wave_file_name, -w: 可选。波形文件名，为空表示不导出波形。 --vflag, -V: 可选。用户定义的模拟器编译参数，透传。例如：’-v -x-assign=fast -Wall –trace’ 或 ‘-f filelist.f’。 --cflag, -C: 可选。用户定义的 gcc/clang 编译参数，透传。例如：’-O3 -std=c++17 -I./include’。 --verbose, -v: 可选。详细模式，保留生成的中间文件。 --example, -e: 可选。构建示例项目，默认是 OFF。 --help, -h: 可选。打印使用帮助。 功能测试 项目提供完整的加法器和随机数生成器测试项目，可以用一行命令测试 Picker 功能是否正常。\n加法器测试 cd picker # 进入项目根目录，即git clone的目录 ./example/Adder/release-verilator.sh -l cpp -e 程序应当输出类似的内容：\n... [cycle 114515] a=0xa9c430d2942bd554, b=0xe26feda874dac8b7, cin=0x0 DUT: sum=0x8c341e7b09069e0b, cout=0x1 REF: sum=0x8c341e7b09069e0b, cout=0x1 Test Passed, destory UTAdder ... 随机数生成器测试 cd picker ./example/RandomGenerator/release-verilator.sh -l cpp -e 程序应当输出类似的内容：\n... [cycle 114521] DUT: cout=0x9a4c , REF: cout=0x9a4c [cycle 114522] DUT: cout=0x3499 , REF: cout=0x3499 [cycle 114523] DUT: cout=0x6932 , REF: cout=0x6932 [cycle 114524] DUT: cout=0xd265 , REF: cout=0xd265 [cycle 114525] DUT: cout=0xa4ca , REF: cout=0xa4ca [cycle 114526] DUT: cout=0x4995 , REF: cout=0x4995 Test Passed, destory UTRandomGenerator ... 至此，可以确定picker工具安装完成。\n","categories":["教程"],"description":"安装相关依赖，**下载、构建并安装**对应的工具。","excerpt":"安装相关依赖，**下载、构建并安装**对应的工具。","ref":"/mlvp/docs/quick-start/installer/","tags":["docs"],"title":"搭建验证环境"},{"body":"施工中… https://github.com/yzcccccccccc/XS-MLVP-NutShellCache\n","categories":["示例项目","教程"],"description":"XXX。","excerpt":"XXX。","ref":"/mlvp/docs/advance_case/nutshell_cache/","tags":["examples","docs"],"title":"果壳 Cache"},{"body":"1. 回调 1.1. 概述 回调是一种常见的编程模式，用于异步或事件驱动编程。回调函数是一种特殊的函数，它可以在异步操作完成后调用一个预定义的函数来处理结果。回调函数通常用于处理事件、执行异步操作或响应用户输入等场景。\n回调函数是一个函数或过程，不过它是一个由调用方自己实现，供被调用方使用的特殊函数，一般使用方法如下\n在a()方法中调用了b()方法 在b方法执行完毕主动调用提供的callback()方法 这个下面的例子中，实现了一个简单的callback 示例，我们定一个了一个打印结果的方法 print_result，一个两数相加的方法add (), 当完成add 后，调用 print_result（）方法将结果打印出来\ndef add(x, y, callback): result = x + y # 在执行时，这里的callback相当于print_result() callback(result) def print_result(result): print(result) # 在调用add 时，将 print_result 作为参传递给add 里的callback add(2, 3, callback=print_result) 1.2. 回调函数的使用场景包括 事件处理：回调函数可以用于处理各种事件，例如鼠标点击、键盘输入、网络请求等。 异步操作：回调函数可以用于异步操作，例如读取文件、发送邮件、下载文件等。 数据处理：回调函数可以用于处理数据，例如对数组进行排序、过滤、映射等。 插件开发：回调函数可以用于开发插件，例如 WordPress 插件、jQuery 插件等。 1.3. 回调函数的优缺点 优点\n回调函数的作用是将代码逻辑分离出来，使得代码更加模块化和可维护。使用回调函数可以避免阻塞程序的运行，提高程序的性能和效率。另外，回调函数还可以实现代码的复用，因为它们可以被多个地方调用。 提高代码的复用性和灵活性：回调函数可以将一个函数作为参数传递给另一个函数，从而实现模块化编程，提高代码的复用性和灵活性。 解耦合：回调函数可以将不同模块之间的关系解耦，使得代码更易于维护和扩展。 可以异步执行：回调函数可以在异步操作完成后被执行，这样避免了阻塞线程，提高应用程序的效率。 缺点： 回调函数嵌套过多会导致代码难以维护：如果回调函数嵌套层数过多，代码会变得非常复杂，难以维护。 回调函数容易造成竞态条件：如果回调函数中有共享资源访问，容易出现竞态条件，导致程序出错。 代码可读性差：回调函数的使用可能会破坏代码的结构和可读性，尤其是在处理大量数据时 2. Eventloop 2.1. 概述 **Event Loop：事件循环机制是一种计算机编程模型，其目的是使程序能够在一种非阻塞方式下等待事件(如输入、计时器、定时器、网络等)的发生，并在发生事件时被通知及时处理事件，用于等待和分配消息和事件，单线程运行时不会阻塞的一种机制，也就是实现异步的原理。作为一种单线程语言\n事件循环机制的核心是事件循环，即程序会轮询事件队列中是否有待处理事件，如果有，就执行相应的回调函数来处理该事件。然后继续等待下一个事件。事件可以是来自外部资源（如网络套接字、文件、定时器等）的输入、用户输入、系统通知等。由此，程序就可以实现异步、非阻塞的编程方式，提高程序的响应速度和运行效率.\n2.2. 基本原理 事件循环的工作流程通常如下：\n启动程序，执行同步代码直到遇到异步代码， 将异步代码的回调函数放入事件队列中，以便在事件发生时执行。 当所有同步代码执行完毕，开始事件循环，不断检查是否有事件发生。 如果有事件队列不为空，则执行与之关联的回调函数。 回到步骤 4，继续循环处理事件。 2.3. 宏任务与微任务 事件队列是事件循环机制的核心部分之一，它是一个保存事件以及对应的回调函数的队列，在事件队列中的内容可以分为宏任务和微任务两种类型\n宏任务包括：\n宏任务是指在事件循环中排队等待执行的较大的任务单元。 宏任务的执行顺序是按照它们被添加到队列中的顺序来执行的，每个宏任务在执行完成后，事件循环会检查微任务队列是否有任务需要执行，如果有则立即执行微任务，然后再继续下一个宏任务。\n定时器任务（setTimeout、setInterval等） UI 渲染任务 网络请求任务 文件 I/O 任务 setImmediate（Node 环境）等 微任务包括：\n微任务是指在事件循环中排队等待执行的较小的任务单元 微任务会在宏任务执行完毕后立即执行，因此它们的执行优先级要高于宏任务。当一个宏任务执行完毕后，事件循环会立即执行微任务队列中的所有任务，直到微任务队列为空\nPromise 中的回调函数（then、catch等） async/await 中的异步操作等 2.4. Eventloop 的优点 总之，事件循环机制的基本原理就是不断循环遍历事件队列，每次取出队列中最先进入队列的事件并执行对应的回调函数，直到事件队列为空。\n能够有效地处理大量的并发事件，而不会阻塞程序的执行。这种非阻塞的特性使得它特别适用于构建高性能、响应式的应用程序，如 Web 服务器、桌面应用程序、游戏等。 事件循环的实现可以是单线程的，也可以是多线程的。在单线程的情况下，事件循环会依次处理每个事件，而在多线程的情况下，不同的线程可以并行处理不同的事件，从而提高处理效率。 一些流行的编程语言和框架，如JavaScript 中的 Node.js、Python 中的 asyncio、C# 中的 .NET 等，都提供了事件循环机制，使得开发者可以更轻松地构建异步、非阻塞的应用程序。 ","categories":["示例项目","教程"],"description":"XXXX。","excerpt":"XXXX。","ref":"/mlvp/docs/advance_func/callback/","tags":["examples","docs"],"title":"回调与Eventloop"},{"body":" 在开始前本页会 简单的介绍什么是验证，以及示例里面用到的概念，如 DUT (Design Under Test) 和 RM (Reference Model) 。\n芯片验证 芯片验证是确保芯片设计正确性和可靠性的重要环节，主要包括功能验证、形式验证和物理验证等形式，本学习材料仅仅包含对功能验证的介绍，且侧重于基于仿真器的芯片功能验证。芯片功能验证的流程和方法与软件测试有比较大的共同点，例如都有单元测试、系统测试、黑盒测试、白盒测试等。在验证指标上也有共同特点，例如功能覆盖率、代码覆盖率等等。从某种形式上说，除了使用的工具和编程语言不一样外，他们的目标和流程几乎相同。因此，在不考虑工具和编程语言的情况下，会软件测试的工程师应当就会芯片验证。 但在实际工作中，软件测试和芯片验证属于两个完全不相交的行业，其主要原因是验证工具和验证语言的不同，导致软件测试工程师很难实现跨界。在芯片验证领域，通常使用硬件描述语言进行验证（例如 Verilog 或者 System Verilog），使用专业商业工具进行电路仿真。硬件描述语言不同于C++/Python等高级软件编程语言，具有独特的“时钟”特性，对于软件领域的工程师不友好，学习成本高。\n为了打通芯片验证与传统软件测试之间的壁垒，让更多的人参与到芯片验证，本项目提供如下内容：\n多语言验证工具（Picker），让用户可以使用自己擅长的编程语言进行芯片验证 验证框架（MLVP），如何在不关心时钟的情况下进行功能验证\n介绍基本电路、验证知识，方便软件背景爱好者更能容易的理解电路特征\n提供基本学习材料，学习基本验证知识\n提供真实高性能芯片验证案例，让爱好者可以远程参与验证工作\n基本术语 DUT： DUT（Design Under Test）指待测试设计，通常指设计好的RTL代码。\nRM： Reference Model （RM）指代待测试单元对应的参考模型，参考模型通常被认为是标准的，没有错误的。\nRTL： 指寄存器传输级（Register Transfer Level），通常指代芯片设计对应的 verilog 或者 vhdl 代码。\n覆盖率： 测试覆盖率是指测试范围与整个需求范围的百分比。在芯片验证领域，通常有代码行覆盖率、函数覆盖率、功能覆盖率等。\nDV： DV中的D通常指设计（Desgin），V指验证（Verification）。何在一起指设计与验证协同工作。\n差分测试（difftest）： 选取两个（或以上）功能相同的被测对象，选取符合被测对象要求的同一测试用例分别提交被测对象进行执行，以观测执行结果是否存在差异的过程。\n工具介绍 本学习材料用到的核心工具为 picker （url：），它的作用是将RTL编写的设计模块转换成高级软件编程语言（Python/C++/Java/Golang）第三方库的工具。基于该工具，软件开发（测试）背景的验证人员可以不用去学习 Verilog/VHDL 等硬件描述语言。\n系统需求 操作系统建议： Linux 系统\n","categories":["示例项目","教程"],"description":"如何使用开放验证平台的环境参与到硬件验证中来。","excerpt":"如何使用开放验证平台的环境参与到硬件验证中来。","ref":"/mlvp/docs/quick-start/","tags":["examples","docs"],"title":"快速开始"},{"body":" 本页简单介绍什么是芯片验证，以及示例里面用到的概念，如 DUT (Design Under Test) 和 RM (Reference Model) 。\n芯片验证过程需要和企业、团队的实际情况契合，没有符合所有要求，必须参考的绝对标准。\n什么是芯片验证 芯片从设计到成品的过程主要包括芯片设计、芯片制造、芯片封测试三大阶段。在芯片设计中，又分前端设计和后端设计，前端设计也称之为逻辑设计，目标是让电路逻辑达到预期功能要求。后端设计也称为物理设计，主要工作是优化布局布线，减小芯片面积，降低功耗，提高频率等。芯片验证（Chip Verification）是芯片设计流程中的一个重要环节。它的目标是确保设计的芯片在功能、性能和功耗等方面都满足预定的规格。验证过程通常包括功能验证、时序验证和功耗验证等多个步骤，使用的方法和工具包括仿真、形式验证、硬件加速和原型制作等。针对本文，芯片验证仅包含对芯片前端设计的验证，验证设计的电路逻辑是否满足既定需求（“Does this proposed design do what is intended?\"），通常也称为功能验证（Functional verification），不包含功耗、频率等后端设计。\n对于芯片产品，一旦设计错误被制造出来修改成本将会非常高昂，因为可能需要召回产品，并重新制造芯片，无论是经济成本还是时间成本都十分昂贵。经典由于芯片验证不足导致失败的典型案例如下： Intel Pentium FDIV Bug：在1994年，Intel的Pentium处理器被发现存在一个严重的除法错误，这个错误被称为FDIV bug。这个错误是由于在芯片的浮点单元中，一个查找表中的几个条目错误导致的。这个错误在大多数应用中不会出现，但在一些特定的计算中会导致结果错误。由于这个错误，Intel不得不召回了大量的处理器，造成了巨大的经济损失。\nAriane 5 Rocket Failure：虽然这不是一个芯片的例子，但它展示了硬件验证的重要性。在1996年，欧洲空间局的Ariane 5火箭在发射后不久就爆炸了。原因是火箭的导航系统中的一个64位浮点数被转换为16位整数时溢出，导致系统崩溃。这个错误在设计阶段没有被发现，导致了火箭的失败。\nAMD Barcelona Bug：在2007年，AMD的Barcelona处理器被发现存在一个严重的转译查找缓冲（TLB）错误。这个错误会导致系统崩溃或者重启。AMD不得不通过降低处理器的频率和发布BIOS更新来解决这个问题，这对AMD的声誉和财务状况造成了重大影响。\n这些案例都强调了芯片验证的重要性。如果在设计阶段就能发现并修复这些错误，那么就可以避免这些昂贵的失败。验证不足的案例不仅发生在过去，也发生在现在，例如某新入局 ASIC 芯片市场的互联网企业打造一款 55 纳米芯片，极力追求面积缩减并跳过验证环节，最终导致算法失败，三次流片皆未通过测试，平均每次流片失败导致企业损失约 50 万美元。\n芯片验证流程 芯片设计和验证的耦合关系如上图所示，设计和验证有同样的输入，即规范文档（specification）。参考规范，设计与验证人员双方按照各自的理解，以及各自的需求进行独立编码实现。设计方需要满足的前提是编码的RTL代码“可综合”，需要考虑电路特性，而验证方一般只要考虑功能是否满足要求，编码限制少。双方完成模块开发后，需要进行健全性对比测试（Sanity Test），判定功能是否表现一致，若不一致需要进行协同排查，确定问题所在并进行修复，再进行对比测试，直到所有功能点都满足预期。由于芯片设计和芯片验证耦合度很高，因此有些企业在研发队伍上也进行了直接耦合，为每个子模块的设计团队都配置了对应的验证团队（DV）。上图中的设计与验证的耦合流程为粗粒度的关系，具体到具体芯片（例如Soc、DDR）、具体企业等都有其适合自身的合作模式。\n在上述对比测试中，设计方的产出的模块通常称为DUT（Design Under Test），验证方开发的模型通常称为RM（Reference Model）。针对图中的验证工作，按照流程可以有：编写验证计划、创建验证平台、整理功能点、构建测试用例、运行调试、收集Bug/覆盖率、回归测试、编写测试报告等多个阶段。\n验证计划： 验证计划描述了如何进行验证，以及如何保证验证质量，达到功能验证要求。在文档结构上通常包含验证目标，验证策略、验证环境、验证项、验证过程、风险防范、资源及时间表、结果和报告等部分。验证目标明确需要验证的功能或性能指标，这些目标应该直接从芯片的规范文档中提取。验证策略描述如何进行验证，包括可能使用的验证方法，例如仿真、形式化、FPGA加速等，以及如何组织验证任务。验证环境用于描述具体的测试环境，例如验证工具类型，版本号等。验证项库俄超关羽需要验证的具体项以及预期结果。验证计划可以有总计划，也可以针对具体验证的子任务进行编写。\n平台搭建： 验证平台是具体验证任务的执行环境，同一类验证任务可以使用相同的验证平台。验证平台的搭建是验证流程中的关键步骤、具体包含验证工具选择（例如是采用软件仿真，还是采用形式化验证，或者硬件加速）、环境配置（例如配置服务器环境，FPGA环境）、创建测试环境、基本测试案例等。创建好基本测试平台，跑通基本测试案例，也通常称为“冒烟测试”。后继具体的测试代码，都将基于该测试平台进行，因此测试平台需要具有可重用性。验证平台通过包含测试框架和被测试代码，以及对应的基本信号激励。\n功能点整理： 功能点整理，即需要根据规范手册（spec）列出DUT的基本功能，并对其进行明确的描述，以及如何对该功能点进行测试。功能点整理过程中，需要根据重要性、风险、复杂性等因数对其进行优先级排序。功能点整理还需要对各个功能点进行追踪和状态，如果发现原始功能点有更新需要及时进行对应计划的同步。\n测试用例： 测试用例是指一组条件或变量，用于确定DUT是否满足特定需求并能正确运行。每个测试用例通常包含测试条件，输入数据，预期结果，实际结果和测试结果。通过运行测试用例并比较预期结果和实际结果，可以确定系统或应用是否正确实现了特定的功能或需求。在芯片验证中，测试用例是用来验证芯片设计是否满足规格要求的重要工具。\n编码实现： 编码实现即对测试用例的具体执行过程，包括测试数据生成、测试框架选择、编程语言选择、参考模型编写等。编码实现是对功能点和测试用例充分理解后工作，如果理解不到位，可能导致DUT无法驱动，不能发现潜在bug等问题。\n收集bug/覆盖率： 验证的目标就是提前发现设计中存在的bug，因此需要对发现的bug进行收集和管理。没发现一个新缺陷，需要给定唯一标号，并同设计工程师进行bug定级，然后进行状态追踪。能发现bug最好，但在实际验证中不是每次测试都能发现bug，因此需要另外一个指标评价验证是否到位。该指标通常采用覆盖率，当覆盖率超过一点阈值（例如代码覆盖率大于90%）后方可任务进行了充分验证。\n回归测试： 验证和设计是一个相互迭代的过程，因此当验证出bug后，需要设计进行修正，且需要保证修正后的DUT仍然能正常工作。这种测试的目的是捕获可能由于修改而引入的新错误，或者重新激活旧错误。回归测试可以是全面的，也就是说，它涵盖了所有的功能，或者可以是选择性的，只针对某些特定的功能或系统部分。\n测试报告： 测试报告是对整个验证过程的总结，它提供了关于测试活动的全面视图，包括测试的目标、执行的测试用例、发现的问题和缺陷、测试覆盖率和测试效率等。\n芯片验证层次 按照验证对象的大小，芯片验证通常包含UT、BT、IT、ST四个层次。\n单元测试（Unit Testing， UT）： 这是最低的验证层次，主要针对单个模块或组件进行。目标是验证每个模块或组件的功能是否正确。\n块测试（Block Testing，BT）： 很多时候，单个模块和其他模块存在紧耦合，如果进行单独UT测试，可能存在信号处理复杂，功能验证不准确等问题，这时候可以把多个有耦合关系的模块合并成一个DUT块进行测试。\n集成测试（Integration Testing）： 在单元测试的基础上，将多个模块或组件组合在一起，验证它们能否正确地协同工作，通常用于测试子系统功能是否正常。\n系统测试（System Testing）： ST通常也称为Top验证，在集成测试的基础上，将所有的模块或组件组合在一起，形成一个完整的系统，验证系统的功能是否正确，以及系统的性能是否满足要求。\n理论上，这些层次的验证通常按照从低到高的顺序进行，每个层次的验证都建立在前一个层次的验证的基础上。但实际验证活动中，需要根据企业验证人员的规模、熟练度，功能需求等进行选择，不一定所有层次的验证都需要涉及。在每个层次，都需要编写相应的测试用例，运行测试，收集和分析结果，以确保芯片设计的正确性和质量。\n芯片验证指标 芯片验证的指标，通常包含功能正确性、测试覆盖率、缺陷密度、验证效率、验证成本等多个方面。功能正确性是最基本的验证指标，即芯片是否能够正确地执行其设计的功能。这通常通过运行一系列的功能测试用例来验证，包括正常情况下的功能测试，以及异常情况下的鲁棒性测试。测试覆盖率是指测试用例覆盖了多少设计的功能点，以及覆盖的程度如何。高的测试覆盖率通常意味着更高的验证质量。测试覆盖率可以进一步细分为代码覆盖率、功能覆盖率、条件覆盖率等。缺陷密度是指在一定的设计规模或代码量中，发现的缺陷的数量。低的缺陷密度通常意味着更高的设计质量。验证效率是指在一定的时间和资源下，能够完成的验证工作量。高的验证效率通常意味着更高的验证生产力。验证成本是指进行验证所需要的总体资源，包括人力、设备、时间等。低的验证成本通常意味着更高的验证经济性。\n功能正确性是验证的绝对指标，但在实践中，很多时候无法确定测试方案是否完备，所有测试空间是否全部测试到位，因此需要一个可量化的指标来指导验证是否足够充分，是否可以结束验证。该指标通常采用“测试覆盖率”。测试覆盖率通常有代码覆盖率（行，函数，分支）、功能覆盖率。\n代码行覆盖率： 即在测试过程中，DUT的设计代码中有多少行被执行；\n函数覆盖率： 即在测试过程中，DUT的设计代码中有多少函数被执行；\n分支覆盖率： 即在测试过程中，DUT的设计代码中有多少分支被执行（if else）；\n功能覆盖率： 即在测试过程中，有多少预定义功能被触发。\n高的代码覆盖率可以提高验证的质量和可靠性，但并不能保证验证的完全正确性，因为它不能覆盖所有的输入和状态组合。因此，除了追求高的代码覆盖率，还需要结合其他测试方法和指标，如功能测试、性能测试、缺陷密度等。\n芯片验证管理 芯片验证管理是一个涵盖了芯片验证过程中所有活动的管理过程，包括之前提到的验证策略的制定、验证环境的搭建、测试用例的编写和执行、结果的收集和分析、以及问题和缺陷的跟踪和修复等。芯片验证管理的目标是确保芯片设计满足所有的功能和性能要求，以及规格和标准。\n在芯片验证管理中，首先需要制定一个详细的验证策略，包括验证的目标、范围、方法、时间表等。然后，需要搭建一个适合的验证环境，包括硬件设备、软件工具、测试数据等。接下来，需要编写一系列的测试用例，覆盖所有的功能和性能点，然后执行这些测试用例，收集和分析结果，找出问题和缺陷。最后，需要跟踪和修复这些问题和缺陷，直到所有的测试用例都能通过。\n芯片验证管理是一个复杂的过程，需要多种技能和知识，包括芯片设计、测试方法、项目管理等。它需要与芯片设计、生产、销售等其他活动紧密协作，以确保芯片的质量和性能。芯片验证管理的效果直接影响到芯片的成功和公司的竞争力。因此，芯片验证管理是芯片开发过程中的一个重要环节。\n芯片验证管理过程可以基于“项目管理平台”和“bug管理平台”进行，基于平台的管理效率通常情况下明显高于基于人工的管理模式。\n芯片验证现状 当前，芯片验证通常是在芯片设计公司内部完成的，这一过程不仅技术上复杂，而且具有巨大的成本。从验收与设计的紧密关系来看，芯片验证不可避免地涉及芯片设计的源代码。然而，芯片设计公司通常将芯片设计源代码视为商业机密，这使得必须由公司内部人员来执行芯片验证，难以将验证工作外包。\n芯片验证的重要性在于确保设计的芯片在各种条件下能够可靠运行。验证工作不仅仅是为了满足技术规格，还需要应对不断增长的复杂性和新兴技术的要求。随着半导体行业的发展，芯片验证的工作量不断增加，尤其是对于复杂的芯片而言，验证工作已经超过了设计工作，占比超过70%。这使得在工程师人员配比上，验证工程师人数通常是设计工程师人数的2倍或以上（例如zeku的三千人规模团队中，大约有一千人的设计工程师，两千人的验证工程师。其他大型芯片设计公司的验证人员占比类似或更高）。\n由于验证工作的特殊性，需要对芯片设计源代码进行访问，这在很大程度上限制了芯片验证的外包可能性。芯片设计源代码被视为公司的核心商业机密，涉及到技术细节和创新，因此在安全和法律层面上不太可能与外部方共享。这也导致了公司内部人员必须承担验证工作的重任，增加了公司内部的工作负担和成本。\n在当前情况下，芯片验证工程师的需求持续增加。他们需要具备深厚的技术背景，熟悉各种验证工具和方法，并且对新兴技术有敏锐的洞察力。由于验证工作的复杂性，验证团队通常需要庞大的规模，这与设计团队规模形成鲜明对比。\n为了应对这一挑战，行业可能需要不断探索创新的验证方法和工具，以提高验证效率，降低成本。\n小结：复杂芯片验证成本昂贵，表现在如下几个方面 验证工作量大： 对于复杂芯片，验证工作在整个芯片设计工作中，占比超过 70%。\n人力成本高： 验证工程师人数是设计工程师人数的2倍，对于复杂业务，工程师数量在千人以上。\n内部验证： 芯片设计公司为了保证商业秘密（芯片设计代码）不被泄露，只能选择招聘大量验证工程师，在公司内部进行验证工作。\n芯片验证众包 相比与硬件，软件领域为了减少软件测试成本，测试外包（分包）已经成为常态，该领域的分包业务非常成熟，市场规模已经是千亿人民币级别，并朝万亿级别规模进发。从工作内容上看，软件测试和硬件验证，有非常大的共同特征（系统的目的不同的对象），如果以软件的方式对硬件验证进行分包是否可行？\n把芯片验证工作进行外包（分包）面临诸多挑战，例如： 从业人员基数少： 相比软件领域，硬件开发者数量少了几个数量级。例如在github的统计上（https://madnight.github.io/githut/#/pull_requests/2023/2），传统软件编程语言占（Python、Java、C++，Go）比接近 50%， 而硬件描述语言，verilog占比仅 0.076%，这能从侧面反应出各自领域的开发者数量。\n验证工具商业化： 企业中使用的验证工具（仿真器、形式化、数据分析）几乎都是商业工具，这类工具对于普通人来说几乎不可见，自学难度高。\n开放学习资料少： 芯片验证涉及到访问芯片设计的源代码，而这些源代码通常被视为公司的商业机密和专有技术。芯片设计公司可能不愿意公开详细的验证过程和技术，限制了学习材料的可用性。\n可行性分析 虽然芯片验证领域一直以来相对封闭，但从技术角度而言，采用分包的方式进行验证是一种可行的选择。这主要得益于以下几个因素：\n首先，随着开源芯片项目的逐渐增多，验证过程中所涉及的源代码已经变得更加开放和透明。这些开源项目在设计和验证过程中没有商业机密的顾虑，为学习和研究提供了更多的可能性。即使某些项目涉及商业机密，也可以通过采用加密等方式来隐藏设计代码，从而在一定程度上解决了商业机密的问题，使验证更容易实现。\n其次，芯片验证领域已经涌现出大量的基础验证工具，如verilator和systemc等。这些工具为验证工程师提供了强大的支持，帮助他们更高效地进行验证工作。通过这些工具，验证过程的复杂性和难度得到了一定程度的缓解，为采用分包的验证方法提供了更为可行的技术基础。\n在开源软件领域，已经有一些成功的案例可供参考。例如，Linux内核的验证过程采用了分包的方式，不同的开发者和团队分别负责不同的模块验证，最终形成一个整体完备的系统。类似地，机器学习领域的ImageNet项目也采用了分包标注的策略，通过众包的方式完成大规模的图像标注任务。这些案例为芯片验证领域提供了成功的经验，证明了分包验证在提高效率、降低成本方面的潜力。\n因此，尽管芯片验证领域相对于其他技术领域而言仍显得封闭，但技术的进步和开源项目的增多为采用分包验证提供了新的可能性。通过借鉴其他领域的成功经验和利用现有的验证工具，我们有望在芯片验证中推动更加开放、高效的验证方法的应用，进一步促进行业的发展。这种技术的开放性和灵活性将为验证工程师提供更多的选择，推动芯片验证领域迎来更为创新和多样化的发展。\n技术路线 为了克服挑战，让更多的人参与到芯片验证，本项目从如下几个技术方向进行持续尝试\n提供多语言验证工具： 传统芯片验证是基于System Verilog编程语言进行，但是该语言用户基数少，为了让其他软件开发/测试的技术人员参与到芯片验证，本项目提供多语言验证转换工具Picker（http://xxx），它可以让验证者使用自己熟悉的编程语言（例如C++/Python/Java/Go）基于开源验证工具参与验证工作。\n提供验证学习材料： 芯片验证学习材料少，主要原因由于商业公司几乎不可能公开其内部资料，为此本项目会持续更新学习材料，让验证人员可在线，免费学习所需要的技能。\n提供真实芯片验证案例： 为了让学习材料更具使用性，本项目以“香山昆明湖（工业级高性能risc-v处理器）IP核”作为基础，从中摘取模块持续更新验证案例。\n组织芯片设计分包验证： 学以致用是每个人学习的期望目标，为此本项目定期组织芯片设计的验证分包，让所有人（无论你是大学生、验证专家、软件开发测试者、还是中学生）都可以参与到真实芯片的设计工作中去。\n本项目的目标是达到如下愿景，“打开传统验证模式的黑盒，让所有感兴趣的人可以随时随地的，用自己擅长的编程语言参与芯片验证”。\n","categories":"","description":"关于芯片验证的基本概念\n","excerpt":"关于芯片验证的基本概念\n","ref":"/mlvp/docs/basic/ic_verify/","tags":"","title":"芯片验证"},{"body":"RTL源码 在本案例中，我们驱动一个 64 位的加法器，其源码如下：\n// A verilog 64-bit full adder with carry in and carry out module Adder #( parameter WIDTH = 64 ) ( input [WIDTH-1:0] a, input [WIDTH-1:0] b, input cin, output [WIDTH-1:0] sum, output cout ); assign {cout, sum} = a + b + cin; endmodule 该加法器包含一个 64 位的加法器，其输入为两个 64 位的数和一个进位信号，输出为一个 64 位的和和一个进位信号。\n测试过程 在测试过程中，我们将创建一个名为 Adder 的文件夹，其中包含一个 Adder.v 文件。该文件内容即为上述的 RTL 源码。\n将RTL构建为C++ Class 进入 Adder 文件夹，执行如下命令：\npicker Adder.v -w Adder.fst -S Adder -t picker_out_adder -l cpp -e -v --sim verilator 该命令的含义是：\n将Adder.v作为 Top 文件，并将Adder作为 Top Module，利用verilator仿真器将其编译为Cpp Class 启用波形输出，目标波形文件为Adder.fst 输出示例项目(-e) 并保留生成时产生的中间文件(-v) 最终的文件输出路径是 picker_out_adder 在使用该命令时，还有部分命令行参数没有使用，这些命令将在后续的章节中介绍。\n输出的目录结构如下，请注意这部分均为中间文件：\npicker_out_adder |-- Adder.v # 原始的RTL源码 |-- Adder_top.sv # 生成的Adder_top顶层封装，使用DPI驱动Adder模块的inputs和outputs |-- Adder_top.v # 生成的Adder_top顶层封装，因为Verdi不支持导入SV源码使用，因此需要生成一个Verilog版本 |-- CMakeLists.txt # 用于调用仿真器编译基本的cpp class并将其打包成有裸DPI函数二进制动态库(libDPIAdder.so) |-- Makefile # 生成的Makefile，用于调用CMakeLists.txt，并让用户可以通过make命令编译出libAdder.so，并手动调整Makefile的配置参数。或者编译示例项目 |-- cmake # 生成的cmake文件夹，用于调用不同仿真器编译RTL代码 | |-- vcs.cmake | `-- verilator.cmake |-- cpp # CPP example目录，包含示例代码 | |-- CMakeLists.txt # 用于将libDPIAdder.so使用基础数据类型封装为一个可直接操作的类（libUTAdder.so），而非裸DPI函数。 | |-- Makefile | |-- cmake | | |-- vcs.cmake | | `-- verilator.cmake | |-- dut.cpp # 生成的cpp UT封装，包含了对libDPIAdder.so的调用，及UTAdder类的声明及实现 | |-- dut.hpp # 头文件 | `-- example.cpp # 调用UTAdder类的示例代码 |-- dut_base.cpp # 用于调用与驱动不同仿真器编译结果的基类，通过继承封装为统一的类，用于隐藏所有仿真器相关的代码细节。 |-- dut_base.hpp |-- filelist.f # 多文件项目使用的其他文件列表，请查看 -f 参数的介绍。本案例中为空 |-- mk | |-- cpp.mk # 用于控制以cpp为目标语言时的Makefile，包含控制编译示例项目（-e，example）的逻辑 | `-- python.mk # 同上，目标语言是python `-- python |-- CMakeLists.txt |-- Makefile |-- cmake | |-- vcs.cmake | `-- verilator.cmake |-- dut.i # SWIG配置文件，用于将libDPIAdder.so的基类与函数声明，依据规则用swig导出到python，提供python调用的能力 `-- dut.py # 生成的python UT封装，包含了对libDPIAdder.so的调用，及UTAdder类的声明及实现，等价于 libUTAdder.so 编译C++ Class为动态库 在生成的 picker_out_adder 目录下，替换 cpp/example.cpp 后执行命令 make 即可编译出 libUTAdder.so 动态库及其依赖文件和测试驱动程序。\n由 Makefile 定义的自动编译过程流如下：\n通过 cmake/*.cmake 定义的仿真器调用脚本，编译 Adder_top.sv 及相关文件为 libDPIAdder.so 动态库。 通过 CMakelists.txt 定义的编译脚本，将 libDPIAdder.so 通过 dut_base.cpp 封装为 libUTAdder.so 动态库。并将1、2步产物拷贝到 UT_Adder 目录下。 如果有 -e 参数，则拷贝 cpp 目录下的所有文件到 UT_Adder 目录下，并编译 example.cpp 为 example 可执行文件。 上一步过程由 mk/cpp.mk 定义，可以通过修改 mk/cpp.mk 中的 example 目标，来修改编译过程。 在编译 example 可执行二进制文件的过程中，不同仿真器需要不同cmake文件编译参数，因为需要链接不同的仿真器的依赖库。 配置测试代码 注意只有替换 cpp/example.cpp 中的内容，才能保证 example 示例项目按预期运行。\n#include \"UT_Adder.hpp\" int64_t random_int64() { static std::random_device rd; static std::mt19937_64 generator(rd()); static std::uniform_int_distribution\u003cint64_t\u003e distribution(INT64_MIN, INT64_MAX); return distribution(generator); } int main() { #if defined(USE_VCS) UTAdder *dut = new UTAdder(\"libDPIAdder.so\"); #elif defined(USE_VERILATOR) UTAdder *dut = new UTAdder(); #endif // dut-\u003einitClock(dut-\u003eclock); dut-\u003exclk.Step(1); printf(\"Initialized UTAdder\\n\"); struct input_t { uint64_t a; uint64_t b; uint64_t cin; }; struct output_t { uint64_t sum; uint64_t cout; }; for (int c = 0; c \u003c 114514; c++) { input_t i; output_t o_dut, o_ref; i.a = random_int64(); i.b = random_int64(); i.cin = random_int64() \u0026 1; auto dut_cal = [\u0026]() { dut-\u003ea = i.a; dut-\u003eb = i.b; dut-\u003ecin = i.cin; dut-\u003exclk.Step(1); o_dut.sum = (uint64_t)dut-\u003esum; o_dut.cout = (uint64_t)dut-\u003ecout; }; auto ref_cal = [\u0026]() { uint64_t sum = i.a + i.b; bool carry = sum \u003c i.a; sum += i.cin; carry = carry || sum \u003c i.cin; o_ref.sum = sum; o_ref.cout = carry ; }; dut_cal(); ref_cal(); printf(\"[cycle %llu] a=0x%lx, b=0x%lx, cin=0x%lx\\n\", dut-\u003exclk.clk, i.a, i.b, i.cin); printf(\"DUT: sum=0x%lx, cout=0x%lx\\n\", o_dut.sum, o_dut.cout); printf(\"REF: sum=0x%lx, cout=0x%lx\\n\", o_ref.sum, o_ref.cout); Assert(o_dut.sum == o_ref.sum, \"sum mismatch\"); } delete dut; printf(\"Test Passed, destory UTAdder\\n\"); return 0; } 运行测试 成功编译并运行后，我们即可看到 example 示例项目的输出，作为Release内容的输出结果均在 picker_out_adder/UT_Adder 目录下。\n[...] [cycle 114515] a=0xa312f444394e8372, b=0x599aa4228a8b09ff, cin=0x1 DUT: sum=0xfcad9866c3d98d72, cout=0x0 REF: sum=0xfcad9866c3d98d72, cout=0x0 [...] 此时目录结构如下图\n~/picker_out_adder$ tree UT_Adder UT_Adder |-- Adder.cmake # 原 picker_out_adder/cpp/cmake/verilator.cmake |-- Adder.v # 原 picker_out_adder/Adder.v |-- Adder_top.sv |-- Adder_top.v |-- CMakeLists.txt # 原 picker_out_adder/cpp/CMakeLists.txt |-- Makefile # 原 picker_out_adder/cpp/Makefile |-- UTAdder_example # 测试程序 |-- UT_Adder.cpp # 原 picker_out_adder/cpp/dut.cpp，经过模板渲染，已经被编译到libUTAdder.so中 |-- UT_Adder.hpp # 原 picker_out_adder/cpp/dut.hpp，经过模板渲染 |-- UT_Adder_dpi.hpp # 仿真器生成的DPI函数声明，用于链接时使用 |-- dut_base.hpp # 原 picker_out_adder/dut_base.hpp，基类头文件声明，用于链接时使用 |-- example.cpp # 测试程序代码 |-- libDPIAdder.a # 仿真器生成的静态(verilator)/动态库(vcs)，用于链接时使用 `-- libUTAdder.so # 经过封装的动态库，UT_Adder.cpp的实现已经包含在其中。 可以发现核心文件包含\nlibUTAdder.so 动态库，包含了 UT_Adder.cpp 的实现 libDPIAdder.so 动态库，包含了编译为C++的RTL模块实现，及DPI函数导出。 UT_Adder.hpp, UT_Adder_dpi.hpp, dut_base.hpp 三个头文件，用于链接时使用。 辅助文件包含\nAdder.cmake，用于控制编译二进制文件时的链接参数 ","categories":["示例项目","教程"],"description":"通过一个简单的加法器验证示例辅助学习，此过程只有组合逻辑，没有时序逻辑与寄存器的概念。\n","excerpt":"通过一个简单的加法器验证示例辅助学习，此过程只有组合逻辑，没有时序逻辑与寄存器的概念。\n","ref":"/mlvp/docs/quick-start/eg-adder/","tags":["examples","docs"],"title":"验证加法器"},{"body":"","categories":["示例项目","教程"],"description":"XXX。","excerpt":"XXX。","ref":"/mlvp/docs/advance_case/tilelink/","tags":["examples","docs"],"title":"TileLink 协议"},{"body":" ","categories":["示例项目","教程"],"description":"参与开放验证平台工作所需要的基础知识。","excerpt":"参与开放验证平台工作所需要的基础知识。","ref":"/mlvp/docs/basic/","tags":["examples","docs"],"title":"基础知识"},{"body":" 本页将介绍数字电路的基础知识。数字电路是利用数字信号的电子电路。近年来，绝大多数的计算机都是基于数字电路实现的。\n什么是数字电路 数字电路是一种利用两种不连续的电位来表示信息的电子电路。在数字电路中，通常使用两个电源电压，分别表示高电平（H）和低电平（L），分别代表数字1和0。这样的表示方式通过离散的电信号，以二进制形式传递和处理信息。\n大多数数字电路的实现基于场效应管，其中最常用的是 MOSFET（Metal-Oxide-Semiconductor Field-Effect Transistor，金属氧化物半导体场效应管）。MOSFET 是一种半导体器件，可以在电场的控制下调控电流流动，从而实现数字信号的处理。\n在数字电路中，MOSFET 被组合成各种逻辑电路，如与门、或门、非门等。这些逻辑门通过不同的组合方式，构建了数字电路中的各种功能和操作。以下是一些数字电路的基本特征：\n(1) 电位表示信息： 数字电路使用两种电位，即高电平和低电平，来表示数字信息。通常，高电平代表数字1，低电平代表数字0。\n(2) MOSFET 实现： MOSFET 是数字电路中最常用的元件之一。通过控制 MOSFET 的导通和截止状态，可以实现数字信号的处理和逻辑运算。\n(3) 逻辑门的组合： 逻辑门是数字电路的基本构建块，由 MOSFET 组成。通过组合不同的逻辑门，可以构建复杂的数字电路，实现各种逻辑功能。\n(4) 二进制表达： 数字电路中的信息通常使用二进制系统进行表示。每个数字都可以由一串二进制位组成，这些位可以在数字电路中被处理和操作。\n(5) 电平转换和信号处理： 数字电路通过电平的变化和逻辑操作，实现信号的转换和处理。这种离散的处理方式使得数字电路非常适用于计算和信息处理任务。\n为什么要学习数字电路 学习数字电路是芯片验证过程中的基础和必要前提，主要体现在以下多个方面：\n(1) 理解设计原理： 数字电路是芯片设计的基础，了解数字电路的基本原理和设计方法是理解芯片结构和功能的关键。芯片验证的目的是确保设计的数字电路在实际硬件中按照规格正常工作，而理解数字电路原理是理解设计的关键。\n(2) 设计规范： 芯片验证通常涉及验证设计是否符合特定的规范和功能要求。学习数字电路可以帮助理解这些规范，从而更好地构建测试用例和验证流程，确保验证的全面性和准确性。\n(3) 时序和时钟： 时序问题是数字电路设计和验证中的常见挑战。学习数字电路可以帮助理解时序和时钟的概念，以确保验证过程中能够正确处理时序问题，避免电路中的时序迟滞和冲突。\n(4) 逻辑分析： 芯片验证通常涉及对逻辑的分析，确保电路的逻辑正确性。学习数字电路可以培养对逻辑的深刻理解，从而更好地进行逻辑分析和故障排查。\n(5) 测试用例编写： 在芯片验证中，需要编写各种测试用例来确保设计的正确性。对数字电路的理解可以帮助设计更全面、有针对性的测试用例，涵盖电路的各个方面。\n(6) 信号完整性： 学习数字电路有助于理解信号在电路中的传播和完整性问题。在芯片验证中，确保信号在不同条件下的正常传递是至关重要的，特别是在高速设计中。\n整体而言，学习数字电路为芯片验证提供了基础知识和工具，使验证工程师能够更好地理解设计，编写有效的测试用例，分析验证结果，并解决可能出现的问题。数字电路的理论和实践经验对于芯片验证工程师来说都是不可或缺的。\n数字电路基础知识 三极管BJT： 三极管又称为双极型晶体管（Bipolar Junction Transistor，BJT），是一种常见的半导体器件，用于电子电路中的放大、开关和调节等功能。它由三个掺杂不同类型的半导体材料层组成，分为发射极（Emitter）、基极（Base）和集电极（Collector）。三极管通过控制基极电流来控制集电极之间的电流，从而实现放大或开关的功能。\n三极管BJT在验证中的作用：\n（1）芯片设计中的应用： 三极管BJT是电子电路中常用的元件之一，广泛应用于各种集成电路中。了解三极管的工作原理和特性，对于理解芯片的设计和功能至关重要。\n（2）模拟电路验证： 芯片验证不仅涉及数字电路的验证，还包括模拟电路的验证。三极管BJT在模拟电路中常用于放大器、振荡器、滤波器等电路中，学习它有助于理解模拟电路的工作原理和验证方法。\n（2）混合信号芯片验证： 许多芯片都是混合信号芯片，同时包含数字和模拟电路。学习三极管BJT的知识可以帮助验证工程师理解芯片中模拟部分的设计和验证过程。\nMOSFET： 金属氧化物半导体场效应晶体管（Metal-Oxide-Semiconductor Field-Effect Transistor，MOSFET）是一种常见的场效应晶体管，也是现代集成电路中最常用的晶体管之一。MOSFET由栅极（Gate）、漏极（Source）和源极（Drain）组成，通过栅极电压控制漏极与源极之间的电流。\nMOSFET在芯片验证中的作用：\n（1）数字电路验证： MOSFET常用于数字电路中的开关、逻辑门和存储器等功能单元。理解MOSFET的工作原理和特性有助于设计和验证数字电路，包括静态和动态特性的分析。\n（2）模拟电路验证： 在模拟电路中，MOSFET常用于放大器、滤波器、振荡器等电路中。学习MOSFET有助于理解模拟电路的设计和验证方法，包括小信号模型、大信号模型等。\n（3）混合信号芯片验证： 许多芯片是混合信号芯片，同时包含数字和模拟电路。掌握MOSFET的知识可以帮助验证工程师理解芯片中模拟部分的设计和验证过程，从而提高整个芯片的验证效率和准确性。\n锁存器和触发器： 锁存器（Latch）和触发器（Flip-Flop）都是数字电路中用于存储数据的元件，它们在芯片设计和验证中起着重要的作用。\n锁存器（Latch）： 锁存器是一种组合逻辑电路，用于存储少量的数据。它通常由逻辑门构成，具有两种状态：保持状态和透传状态。锁存器在使能信号为高电平时可以将输入数据存储在内部，并在使能信号为低电平时保持存储的数据输出。锁存器通常用于存储数据、控制信号和状态信息等。\n触发器（Flip-Flop）： 触发器是一种时序逻辑电路，用于存储大量的数据和状态。它是由多个门级电路组成的，包括异或门、与门和反相器等。触发器可以实现数据的稳态存储和时序控制功能，是数字电路中最常用的存储器件之一。常见的触发器类型包括RS触发器、D触发器、JK触发器和T触发器等。\n锁存器和触发器在芯片验证中的作用：\n（1）状态存储和控制： 锁存器和触发器在芯片中广泛应用于状态存储和控制功能。理解它们的工作原理和特性有助于验证工程师正确地设计和验证芯片中的状态机和控制逻辑。\n（2）时序分析和验证： 触发器是时序逻辑电路的基本组成单元，掌握触发器的工作原理和时序特性对于芯片的时序分析和验证至关重要。验证工程师需要确保芯片的时序操作符合设计要求，并能够正确地响应各种时序信号。\n（3）时序控制和时钟域： 芯片设计中常涉及多个时钟域和时序控制信号。了解锁存器和触发器在时序控制和时钟域切换中的应用有助于验证工程师设计和验证复杂的时序电路和跨时钟域逻辑。\n硬件描述语言Chisel 硬件描述语言： 硬件描述语言（Hardware Description Language，简称 HDL）是一种用于描述数字电路、系统和硬件的语言。它允许工程师通过编写文本文件来描述硬件的结构、功能和行为，从而实现对硬件设计的抽象和建模。\nHDL 通常被用于设计和仿真数字电路，如处理器、存储器、控制器等。它提供了一种形式化的方法来描述硬件电路的行为和结构，使得设计工程师可以更方便地进行硬件设计、验证和仿真。\n常见的硬件描述语言包括：\nVerilog：Verilog 是最常用的 HDL 之一，它是一种基于事件驱动的硬件描述语言，广泛应用于数字电路设计、验证和仿真。\nVHDL：VHDL 是另一种常用的 HDL，它是一种面向对象的硬件描述语言，提供了更丰富的抽象和模块化的设计方法。\nSystemVerilog：SystemVerilog 是 Verilog 的扩展，它引入了一些高级特性，如对象导向编程、随机化测试等，使得 Verilog 更适用于复杂系统的设计和验证。\nChisel： Chisel 是一种现代化高级的硬件描述语言，与传统的 Verilog 和 VHDL 不同，它是基于 Scala 编程语言的硬件构建语言。Chisel 提供了一种更加现代化和灵活的方法来描述硬件，通过利用 Scala 的特性，可以轻松地实现参数化、抽象化和复用，同时保持硬件级别的效率和性能。\nChisel 的特点包括：\n现代化的语法：Chisel 的语法更加接近软件编程语言，如 Scala，使得硬件描述更加直观和简洁。\n参数化和抽象化：Chisel 支持参数化和抽象化，可以轻松地创建可配置和可重用的硬件模块。\n类型安全：Chisel 是基于 Scala 的，因此具有类型安全的特性，可以在编译时检测到许多错误。\n生成性能优化的硬件：Chisel 代码可以被转换成 Verilog，然后由标准的 EDA 工具链进行综合、布局布线和仿真，生成性能优化的硬件。\n强大的仿真支持：Chisel 提供了与 ScalaTest 和 Firrtl 集成的仿真支持，使得对硬件进行仿真和验证更加方便和灵活。\nChisel版的全加法器实例：\n电路设计如下图所示：\n完整的Chisel代码如下：\npackage examples import chisel3._ class FullAdder extends Module { // Define IO ports val io = IO(new Bundle { val a = Input(UInt(1.W)) // Input port 'a' of width 1 bit val b = Input(UInt(1.W)) // Input port 'b' of width 1 bit val cin = Input(UInt(1.W)) // Input port 'cin' (carry-in) of width 1 bit val sum = Output(UInt(1.W)) // Output port 'sum' of width 1 bit val cout = Output(UInt(1.W))// Output port 'cout' (carry-out) of width 1 bit }) // Calculate sum bit (sum of a, b, and cin) val s1 = io.a ^ io.b // XOR operation between 'a' and 'b' io.sum := s1 ^ io.cin // XOR operation between 's1' and 'cin', result assigned to 'sum' // Calculate carry-out bit val s3 = io.a \u0026 io.b // AND operation between 'a' and 'b', result assigned to 's3' val s2 = s1 \u0026 io.cin // AND operation between 's1' and 'cin', result assigned to 's2' io.cout := s2 | s3 // OR operation between 's2' and 's3', result assigned to 'cout' } 请结合电路图和代码阅读以下解释内容：\npackage examples: 这段代码位于名为 examples 的包中。\nimport chisel3._: 导入了 Chisel3 库，这是 Chisel 3 的标准导入语句，使我们能够使用 Chisel 的功能。\nclass FullAdder extends Module { … }: 定义了一个名为 FullAdder 的 Chisel 模块。extends Module 表示 FullAdder 是一个继承自 Chisel Module 类的模块。\nval io = IO(new Bundle { … }): 声明了一个名为 io 的输入输出端口。IO 方法创建了一个新的 Bundle 对象，其中包含了 a、b、cin、sum 和 cout 五个信号。Input 表示这些信号是输入端口，Output 表示这些信号是输出端口，UInt(1.W) 表示这些信号的数据类型为无符号整数，宽度为 1 位。\nval s1 = io.a ^ io.b: 计算了输入端口 a 和 b 的异或结果，并将结果赋给 s1。\nio.sum := s1 ^ io.cin: 计算了 s1 和输入端口 cin 的异或结果，并将结果赋给输出端口 sum。\nval s3 = io.a \u0026 io.b: 计算了输入端口 a 和 b 的与操作结果，并将结果赋给 s3。\nval s2 = s1 \u0026 io.cin: 计算了 s1 和输入端口 cin 的与操作结果，并将结果赋给 s2。\nio.cout := s2 | s3: 计算了 s2 和 s3 的或操作结果，并将结果赋给输出端口 cout。\n这段代码实现了一个完整的加法器（Full Adder）模块，用于将两个输入端口的数相加，并输出和结果和进位。具体实现原理如下：\n异或操作 ^：异或操作可以实现单位相加，即两个位相加，不考虑进位的情况。例如，0 ^ 0 = 0，0 ^ 1 = 1，1 ^ 0 = 1，1 ^ 1 = 0。\n与操作 \u0026：与操作可以实现进位的生成。只有当两个输入位都为 1 时，与操作的结果才为 1，表示需要进位。例如，1 \u0026 1 = 1，其他情况都为 0。\n或操作 |：或操作可以实现进位的传递。如果有任意一个位为 1，或操作的结果就为 1，表示需要进位。例如，1 | 0 = 1，0 | 1 = 1，1 | 1 = 1，0 | 0 = 0。\n","categories":"","description":"关于数字电路的基本概念\n","excerpt":"关于数字电路的基本概念\n","ref":"/mlvp/docs/basic/ic_base/","tags":"","title":"数字电路"},{"body":"异步编程 1.1. 概述 异步编程通过将某些任务异步执行，程序可以在等待结果时继续执行其他任务，从而减少了阻塞和等待的时间。 传统的同步编程方式中，代码会按照顺序依次执行，直到前一个任务完成后才能执行下一个任务，异步编程通过将任务分解为更小的子任务，并且不需要等待前一个任务完成，从而实现并行执行多个任务的效果。\n1.2. 实现原理 异步编程的实现基于以下两个核心概念，我们会在下一小节进行更详细的介绍\n回调函数（Callback） 回调函数是异步编程的基础。当一个任务完成时，系统会调用预先注册的回调函数来处理任务的结果。通过回调函数的方式，程序可以在等待任务完成的同时继续执行其他任务，提高了程序的并发性。 事件循环（Event Loop） 事件循环是异步编程的核心机制之一。它负责监听各种事件（如用户输入、I/O 操作等），当事件发生时，触发相应的回调函数进行处理。事件循环通过不断地轮询事件队列，实现了非阻塞式的任务处理。 1.3. 常见的异步编程框架和工具 为了方便开发者进行异步编程，有许多优秀的框架和工具可供选择。以下是一些常见的异步编程框架和工具：\nAsyncio Asyncio 是 Python 的一个强大的异步编程框架，提供了高效的协程（Coroutine）支持。它可以用于编写并发性能优秀的网络应用、爬虫程序等。 Node. Js Node. Js 是基于 Chrome V 8 引擎构建的 JavaScript 运行时环境，天生支持非阻塞 I/O 操作。它在 Web 开发领域广泛应用，尤其擅长处理高并发的实时应用。 RxJava RxJava 是一个基于观察者模式和迭代器模式的异步编程库。它为 Java 开发者提供了丰富的操作符和组合方式，简化了异步编程的复杂性。 1.4. 异步编程的优势 异步编程具有以下几个显著的优势：\n提高响应速度 通过异步编程，程序能够在等待某个任务完成时继续执行其他任务，避免了任务阻塞带来的延迟。这样能够大幅度提高程序的响应速度，提升用户体验。 提升并发性能 异步编程允许程序同时处理多个任务，充分利用计算资源，提升了系统的并发能力。特别是在处理大量 I/O 密集型任务时，异步编程能够更好地发挥优势，降低资源消耗。 简化编程逻辑 异步编程可以避免编写复杂的多线程代码，降低了程序的复杂性和出错的概率。通过简化编程逻辑，开发者能够更专注于业务逻辑的实现。 因此异步编程广泛应用于以下几个领域：\nWeb 开发 在 Web 开发中，异步编程常用于处理网络请求、数据库操作等耗时任务。通过异步方式处理这些任务，可以避免阻塞主线程，保证 Web 服务器的并发性能。 并行计算 异步编程可以帮助实现并行计算，将一个大任务拆分成多个小任务并发执行，提高计算效率。这在科学计算、数据处理等领域非常常见。 消息队列 消息队列是异步编程的经典应用之一。异步消息队列可以实现不同系统之间的解耦和异步通信，提高系统的可扩展性和稳定性。 ","categories":["示例项目","教程"],"description":"XXXX。","excerpt":"XXXX。","ref":"/mlvp/docs/advance_func/async/","tags":["examples","docs"],"title":"异步编程"},{"body":" 本节主要介绍如何基于Picker创建DUT。\n创建DUT（Design Under Test）是指在芯片验证过程中，设计并实现被测对象的电路或系统。DUT是验证的主体，是需要验证的电路设计。在创建DUT时，通常需要考虑被测对象的功能、性能要求和验证目标，然后使用硬件描述语言（HDL）如Verilog或VHDL编写相应的电路描述代码，或通过图形化设计工具生成电路设计。创建DUT是验证过程中的第一步，其质量和准确性直接影响着后续的验证工作。\n以加法器DUT的创建：为例，进行解释：\n创建一个名为 Adder 的文件夹，并在其中创建一个名为 Adder.v 的文件。这个文件将包含加法器的 Verilog 代码。下面是一个示例的加法器 Verilog 代码：\nmodule Adder #( parameter WIDTH = 64 ) ( input [WIDTH-1:0] a, input [WIDTH-1:0] b, input cin, output [WIDTH-1:0] sum, output cout ); assign {cout, sum} = a + b + cin; endmodule UDT解释：\nmodule Adder … endmodule: 定义了一个名为 Adder 的模块，该模块实现了加法器的功能。\nparameter WIDTH = 64: 使用 parameter 关键字定义了一个名为 WIDTH 的参数，默认值为 64。这个参数可以控制加法器的输入和输出的位宽。\ninput [WIDTH-1:0] a, input [WIDTH-1:0] b: 定义了两个输入端口 a 和 b，它们的宽度为 WIDTH。这里使用了一个向量（vector）来表示输入端口的多个位。\ninput cin: 定义了一个输入端口 cin，表示加法器的进位输入。\noutput [WIDTH-1:0] sum, output cout: 定义了两个输出端口 sum 和 cout，分别表示加法器的和输出和进位输出。\nassign: 该关键字用于将一个表达式的值赋给一个信号。\n{cout, sum}: 这是一个连续赋值语句，表示将右边表达式的值分别赋给左边的两个信号 cout 和 sum。\na + b + cin: 这是一个表达式，表示将输入端口 a、b 和 cin 的值相加。由于 a、b 和 sum 都是位宽为 WIDTH 的向量，因此这里进行的是位宽为 WIDTH 的加法运算。\n通过连续赋值语句，将加法器的输出 sum 和 cout 分别赋值为表达式 a + b + cin 的结果的低 WIDTH 位和高 WIDTH 位。\nendmodule: 表示模块定义结束。\n这段 Verilog 代码定义了一个参数化的加法器模块，能够根据参数 WIDTH 控制输入输出的位宽。加法器的输入包括两个 WIDTH 位的数 a 和 b，以及一个单独的进位信号 cin。输出包括一个 WIDTH 位的和 sum 和一个单独的进位输出 cout。加法器的实现通过简单的连续赋值语句，将输入的两个数和进位相加，得到输出的和与进位。\n","categories":["示例项目","学习材料"],"description":"开放验证平台DUT创建的相关知识。","excerpt":"开放验证平台DUT创建的相关知识。","ref":"/mlvp/docs/basic/create_dut/","tags":["examples","docs"],"title":"创建DUT"},{"body":"","categories":["示例项目","教程"],"description":"开放验证平台工具链的高级特性教程。","excerpt":"开放验证平台工具链的高级特性教程。","ref":"/mlvp/docs/advance_func/","tags":["examples","docs"],"title":"高级教程"},{"body":"","categories":["示例项目","教程"],"description":"XXXX。","excerpt":"XXXX。","ref":"/mlvp/docs/advance_func/message/","tags":["examples","docs"],"title":"消息驱动"},{"body":"RTL源码 在本案例中，我们驱动一个随机数生成器，其源码如下：\nmodule RandomGenerator ( input wire clk, input wire reset, input [15:0] seed, output [15:0] random_number ); reg [15:0] lfsr; always @(posedge clk or posedge reset) begin if (reset) begin lfsr \u003c= seed; end else begin lfsr \u003c= {lfsr[14:0], lfsr[15] ^ lfsr[14]}; end end assign random_number = lfsr; endmodule 该随机数生成器包含一个 16 位的 LFSR，其输入为一个 16 位的种子数，输出为一个 16 位的随机数。 LFSR 的更新规则为：将当前的 LFSR 的最高位与次高位异或，然后将结果放在 LFSR 的最低位，溢出的位被丢弃。\n测试过程 在测试过程中，我们将创建一个名为 RandomGenerator 的文件夹，其中包含一个 RandomGenerator.v 文件。该文件内容即为上述的 RTL 源码。\n将RTL构建为C++ Class 进入 RandomGenerator 文件夹，执行如下命令：\npicker RandomGenerator.v -w RandomGenerator.fst -S RandomGenerator -t picker_out_random_generator -l cpp -e -v --sim verilator 该命令的含义是：\n将RandomGenerator.v作为 Top 文件，并将RandomGenerator作为 Top Module，利用verilator仿真器将其编译为Cpp Class 启用波形输出，目标波形文件为RandomGenerator.fst 输出示例项目(-e) 并保留生成时产生的中间文件(-v) 最终的文件输出路径是 picker_out_random_generator 输出的目录类似加法器验证-目录结构，这里不再赘述。\n编译C++ Class为动态库 在生成的 picker_out_random_generator 目录下，替换 cpp/example.cpp 后执行命令 make 即可编译出 libUTRandomGenerator.so 动态库及其依赖文件和测试驱动程序。\n备注：其编译过程类似于 加法器验证-编译流程，这里不再赘述。\n配置测试驱动程序 注意只有替换 cpp/example.cpp 中的内容，才能保证 example 示例项目按预期运行。\n#include \"UT_RandomGenerator.hpp\" int64_t random_int64() { static std::random_device rd; static std::mt19937_64 generator(rd()); static std::uniform_int_distribution\u003cint64_t\u003e distribution(INT64_MIN, INT64_MAX); return distribution(generator); } int main() { #if defined(USE_VCS) UTRandomGenerator *dut = new UTRandomGenerator(\"libDPIAdder.so\"); #elif defined(USE_VERILATOR) UTRandomGenerator *dut = new UTRandomGenerator(); #endif unsigned short seed = random_int64() \u0026 0xffff; printf(\"seed = 0x%x\\n\", seed); dut-\u003einitClock(dut-\u003eclk); dut-\u003exclk.Step(10); dut-\u003ereset = 1; dut-\u003eseed = seed; dut-\u003exclk.Step(1); dut-\u003ereset = 0; dut-\u003exclk.Step(1); printf(\"Initialized UTRandomGenerator\\n\"); struct output_t { uint64_t cout; }; for (int c = 0; c \u003c 114514; c++) { output_t o_dut, o_ref; auto dut_cal = [\u0026]() { dut-\u003exclk.Step(1); o_dut.cout = (unsigned short)dut-\u003erandom_number; }; // as lfsr auto ref_cal = [\u0026]() { seed = (seed \u003c\u003c 1) | ((seed \u003e\u003e 15) ^ (seed \u003e\u003e 14) \u0026 1); o_ref.cout = seed; }; dut_cal(); ref_cal(); printf(\"[cycle %llu] \", dut-\u003exclk.clk); printf(\"DUT: cout=0x%x , \", o_dut.cout); printf(\"REF: cout=0x%x\\n\", o_ref.cout); Assert(o_dut.cout == o_ref.cout, \"sum mismatch\"); } delete dut; printf(\"Test Passed, destory UTRandomGenerator\\n\"); return 0; } 运行测试程序 在 picker_out_random_generator 目录下执行 ./example 即可运行测试程序。\n输出示例为：\n... [cycle 114510] DUT: cout=0x7e8d , REF: cout=0x7e8d [cycle 114511] DUT: cout=0xfd1b , REF: cout=0xfd1b [cycle 114512] DUT: cout=0xfa36 , REF: cout=0xfa36 [cycle 114513] DUT: cout=0xf46c , REF: cout=0xf46c [cycle 114514] DUT: cout=0xe8d8 , REF: cout=0xe8d8 [cycle 114515] DUT: cout=0xd1b0 , REF: cout=0xd1b0 [cycle 114516] DUT: cout=0xa360 , REF: cout=0xa360 [cycle 114517] DUT: cout=0x46c1 , REF: cout=0x46c1 [cycle 114518] DUT: cout=0x8d83 , REF: cout=0x8d83 [cycle 114519] DUT: cout=0x1b07 , REF: cout=0x1b07 [cycle 114520] DUT: cout=0x360e , REF: cout=0x360e [cycle 114521] DUT: cout=0x6c1c , REF: cout=0x6c1c [cycle 114522] DUT: cout=0xd839 , REF: cout=0xd839 [cycle 114523] DUT: cout=0xb072 , REF: cout=0xb072 [cycle 114524] DUT: cout=0x60e5 , REF: cout=0x60e5 [cycle 114525] DUT: cout=0xc1cb , REF: cout=0xc1cb [cycle 114526] DUT: cout=0x8396 , REF: cout=0x8396 Test Passed, destory UTRandomGenerator ... 此时目录结构及核心文件也和加法器验证-运行测试类似，这里不再赘述。\n","categories":["示例项目","教程"],"description":"以LFSR随机数生成器作为案例，引入时序逻辑与寄存器的概念。","excerpt":"以LFSR随机数生成器作为案例，引入时序逻辑与寄存器的概念。","ref":"/mlvp/docs/quick-start/eg-rmg/","tags":["examples","docs"],"title":"验证随机数"},{"body":" 本节主要介绍如何基于Picker编译DUT。\n编译DUT是指将被测设计（Design Under Test，即DUT）的硬件描述语言（HDL）代码转换为可供仿真和验证使用的逻辑网表的过程。这个过程通常包括综合、优化、映射和布线等步骤，其主要目的是将抽象的HDL代码转换为实际的电路网表，以便进行后续的仿真和验证工作。\n以加法器DUT的编译：为例进行解释：\n在 Adder 文件夹中，执行以下命令将 Verilog 文件编译为 C++ Class：\npicker Adder.v -w Adder.fst -S Adder -t picker_out_adder -l cpp -e -v --sim verilator 这个命令会将 Adder.v 文件作为 Top 文件，并将其编译为 C++ Class，使用 verilator 仿真器。编译过程会生成一系列中间文件，其中包括 Verilog 文件、C++ 源代码等。\n","categories":["示例项目","学习材料"],"description":"开放验证平台DUT的编译相关知识。","excerpt":"开放验证平台DUT的编译相关知识。","ref":"/mlvp/docs/basic/compile/","tags":["examples","docs"],"title":"DUT编译"},{"body":"","categories":["示例项目","教程"],"description":"基于开放验证平台完成验证的复杂案例。","excerpt":"基于开放验证平台完成验证的复杂案例。","ref":"/mlvp/docs/advance_case/","tags":["examples","docs"],"title":"高级案例"},{"body":"1. 概述 验证环境并不是全部由verifier编写的，可以用到很多已经编写好的，复用程度高的验证模板，例如某些agent，而这些模板就是VIP。 VIP（Verfication IP）代码确认与验证技术，是预先验证过的内建验证结构，提供了完整的、灵活的应用机制，可以方便地插入到基于仿真的确认测试中，可以大大提高验证可重用性和验证效率。\nVIP 提供一套全面测试环境，帮助设计者和验证者确认其设计功能的正确性，可用于各个层次的仿真验证。通常，VIP 是基于标准协议的，如：AMBA、PCIE、USB、Ethernet 等。VIP 中包括很多验证部件 IP，这些 IP 都严格遵循这些标准协议、已经被验证过，通常包括：产生 testbench 所必须的基础部件、根据协议等的驱动driver和sequence，以及相应的覆盖率模型、dut软件模型、说明文档。\n大型项目中，涉及到众多协议和标准，所以会涉及到很多VIP，还涉及C++等跨平台联合仿真\n1.1. 使用场景 ● 验证设计IP 就是IC设计者会通过购买稳定VIP来对自己的设计进行验证。 当然也可以自己开发VIP\n● 集成设计IP 设计IP的参数众多，不同的参数配置会产生不同的性能、不同的功能。 所以需要集成人员，将多个设计IP进行连接、配置、调度，那么对应的VIP也要进行继承\n● 子系统、SoC系统开发者 设计的IP向上层集成时，也涉及到VIP的使用和集成，例如使用什么样的sequence进行定向测试\n1.2. VIP 的优势和特点 ● 不断更新的标准 什么PCIe、DDR、USB、AMBA等各种协议呀，经常不断更新。 为了使硬件之间能够相互兼容，设计IP就要不断修正、完善使自己的IP兼容新的标准，相应地验证IP也要不断迭代更新。 而有了VIP之后，集成人员和验证人员就不需要花费力气去兼容协议，而将重点放在功能上去即可。\n● 虚拟dut 就是说，如果用硬件模型仿真，可能会耗时巨大。VIP提供的一些用SystemC、Systemverilog等软件模拟的硬件，可加快仿真速度\n● 内置开发的协议冲突检查器 在设计和VIP之间的接口上集成了VIP监视器。它可以用来监视总线上的trans，也可以用来自动验证协议规则。无论何时从DUT发送或接收任何trans，都有可能违反VIP中开发的内置协议检查器中的协议规则，从而引发违反协议的错误\n*● 提供各种详细的错误报告\n1.3. VIP 的集成 ● 模块级 module级别的验证其实就是之前一直讲的验证框架，只不过将验证框架的内容替换成VIP\n● 子系统级 对于多个module集成之后的子系统而言，可将VIP嵌入系统中，替换子系统中的某些控制module或响应module，进行含有driver、sequencer的UVM_ACTIVE测试。\n如果驱动测试没问题，就可以接上真正的硬件模块了，然后将VIP中相应的agent设定为UVM_PASSIVE，只保留monitor监测就好。\n● 芯片级 系统级别，集成程度更高，就会涉及到系统级别的VIP，系统中某些Process、Memory等硬件，并不是真的硬件而是VIP提供的 这是一种虚拟的处理器，可通过SystemC、SystemVerilog实现这样的核，这是为了加快仿真速度\n","categories":["示例项目","教程"],"description":"XXXX。","excerpt":"XXXX。","ref":"/mlvp/docs/advance_func/ovip/","tags":["examples","docs"],"title":"验证IP"},{"body":" 本节主要介绍如何基于Picker验证DUT。\nDUT测试是芯片验证过程中的关键步骤之一，指的是对被测设计（Design Under Test，即DUT）进行验证和测试的过程。在DUT测试中，验证工程师会通过各种测试方法和技术，对DUT的功能、性能和时序等方面进行全面的评估，以确保DUT能够按照设计要求正常工作，并且满足用户的需求和期望。\n以加法器DUT的测试：为例进行解释：\n在测试过程中，我们将创建一个示例项目，并编写测试代码来验证加法器的功能。\n#include \"UT_Adder.hpp\" int main() { UTAdder *dut = new UTAdder(\"libDPIAdder.so\"); // 进行测试... delete dut; return 0; } 在这段代码中，我们创建了一个 UTAdder 类的实例，然后进行测试。\n接着，编译测试代码。在 Adder 文件夹中，执行 make 命令，编译测试代码并生成可执行文件。\n最后，运行测试。执行生成的可执行文件，即可运行测试，并观察输出结果。\n","categories":["示例项目","学习材料"],"description":"开放验证平台DUT验证的相关知识。","excerpt":"开放验证平台DUT验证的相关知识。","ref":"/mlvp/docs/basic/test_dut/","tags":["examples","docs"],"title":"DUT验证"},{"body":"","categories":["示例项目","教程"],"description":"XXXX。","excerpt":"XXXX。","ref":"/mlvp/docs/advance_func/test_framework/","tags":["examples","docs"],"title":"验证框架"},{"body":"","categories":["示例项目","教程"],"description":"XXXX。","excerpt":"XXXX。","ref":"/mlvp/docs/advance_func/vcs/","tags":["examples","docs"],"title":"VCS 支持"},{"body":" 在我们完成DUT验证后，编写验证报告是至关重要的一环。本节将从整体角度概述验证报告的结构以及报告所需覆盖的内容。\n1. 验证的范围 1.1 什么是验证范围\n在芯片验证过程中，验证范围是指需要进行验证的范围或内容的总体描述。它确定了验证活动所需覆盖的功能、性能、边界条件、接口以及其他关键方面。\n1.2 举例说明\n以加法器功能验证为例，本块内容应该至少描述清楚以下内容：\n（1）基本功能验证：\n确认加法器能够正确执行加法运算，包括对两个输入数进行相加并产生正确的结果。 测试加法器对不同数据宽度（例如8位、16位、32位）的支持，并验证其在不同数据宽度下的加法功能是否正常工作。 边界条件验证：\n验证加法器在最小值、最大值以及边界情况下的加法运算是否正确，例如边界值加法、最大值加法和最小值加法。 测试加法器对于特殊情况（如进位、溢出）的处理是否符合设计要求。\n（2）异常输入验证：\n检查加法器对于不合法输入的处理能力，如无效输入、非数字字符或格式错误输入的情况。 验证加法器在面对不符合规范的输入时能够产生正确的错误提示或异常处理。\n（3）多输入/多操作模式验证：\n确认加法器能够处理多组输入，并正确执行相加操作。 验证加法器在连续多次相加操作下是否能够保持正确的累加结果。\n2. 验证环境说明 2.1 什么是验证环境\n验证环境是用于运行芯片顶层功能验证的各个组件（component）的集合。它主要包含以下几个部分：\n（1）被测设计（DUT）：\nDUT是待验证的设计单元，即加法器。它是验证的主体，通过验证环境中的测试向量和输入数据进行功能验证。\n（2）CPU子环境（MPI Agent）：\nMPI（Message Passing Interface）Agent是与外部处理器（CPU）通信的组件。它负责处理来自CPU的验证指令，并将验证结果返回给CPU。MPI Agent与CPU之间通过消息传递机制进行通信，以启动验证过程并提供验证结果。\n（3）PTU/PRU子环境（SPT Agent）：\nSPT（System Port Test）Agent是与外部测试单元（PTU/PRU）通信的组件。它负责与PTU/PRU进行数据交换和配置寄存器访问，以验证加法器的功能和性能。SPT Agent通过与PTU/PRU之间的接口通信，控制测试流程并收集验证数据。\n（4）参考模块（RM）：\n参考模块（Reference Model）是验证过程中的参照标准。它包含了预期的加法器功能和性能规格。验证结果将与参考模块的预期结果进行比对，以确认验证的正确性。参考模块通常由设计规格或功能规范定义，并在验证环境中用于验证结果的验证。\n（5）检查器（Checker）：\n检查器是验证环境中的组件，用于检查仿真结果与参考模块预期结果之间的一致性。它负责比对仿真输出和参考模块的预期输出，并生成验证报告。检查器确保验证结果与设计规格的一致性，以确认验证的准确性和完整性。\n（6）脚本（Makefile）：\nMakefile是验证环境的自动化脚本，用于管理验证流程的各个步骤。它包括编译、运行仿真、分析结果等操作，并提供了一种方便的方式来执行验证任务。通过脚本的自动化处理，可以提高验证效率并减少人工错误的可能性。\n2.2 举例说明\n以加法器功能验证为例，本块内容应该至少描述清楚以下内容：\n（1）DUT版本信息：\nDUT名称： 加法器 版本信息： v1.0 设计语言： Verilog HDL 设计工具： Synopsys Design Compiler\n（2）验证平台说明：\n平台名称： FPGA Verification Platform FPGA型号： Xilinx Virtex UltraScale+ VU9P 仿真工具： Cadence Xcelium Simulator 编译工具： Xilinx Vivado\n（2.1）验证环境架构：\nMPI Agent： 负责与CPU子环境通信，接收和发送验证指令。 SPT Agent： 与PTU/PRU子环境通信，负责与芯片接口进行数据交换和配置寄存器访问。 参考模块（RM）： 包含了预期的加法器功能和性能规格，作为验证结果的参照。 检查器（Checker）： 检查仿真结果与参考模块预期结果之间的一致性，以确认验证的正确性。 脚本（Makefile）： 包含了验证流程的自动化脚本，用于编译、运行仿真以及结果分析。\n（2.2）目录结构：\n列出工作目录下所有文件及文件的概要。\n（2.3）主要文件说明：\n对工作目录中重要文件进行补充说明。\n3. 覆盖率分析 3.1 什么是覆盖率分析\n覆盖率分析是软件开发和测试过程中的一种质量评估技术，用于衡量测试对软件代码或功能的覆盖程度。它主要分为两个方面：代码覆盖率分析和功能覆盖率分析。\n（1）代码覆盖率分析：\n代码覆盖率分析关注的是测试用例对软件代码的覆盖程度。它衡量了测试用例执行过程中究竟有多少代码被执行到，以及这些代码中的哪些部分被执行。代码覆盖率分析通常包括语句覆盖率（Statement Coverage）、分支覆盖率（Branch Coverage）、条件覆盖率（Condition Coverage）和路径覆盖率（Path Coverage）等指标。\n（2）功能覆盖率分析：\n功能覆盖率分析关注的是测试用例对软件功能的覆盖程度。它衡量了测试用例是否覆盖了软件规格中定义的各项功能需求。功能覆盖率分析通常包括输入空间覆盖率（Input Space Coverage）、功能操作覆盖率（Functional Operation Coverage）、错误处理覆盖率（Error Handling Coverage）等指标。 覆盖率分析通过分析测试用例的执行情况，可以帮助评估测试的全面性和有效性。较高的覆盖率通常意味着测试用例对软件的覆盖程度更高，从而提高了软件的质量和可靠性。覆盖率分析结果也可以指导测试用例的设计和调整，以进一步提高测试的效率和完整性。\n3.2 举例说明\n以加法器功能验证为例，本块内容应该至少描述清楚以下内容：\n（1）代码覆盖率分析：\n代码覆盖率分析用于评估测试是否覆盖了设计代码中的各个部分和逻辑路径。对于加法器的验证，代码覆盖率分析可以通过以下方式进行：\n语句覆盖率： 确保测试覆盖了加法器设计代码中的所有语句和指令，以验证代码的执行路径。 分支覆盖率： 确保测试覆盖了加法器设计代码中的所有条件分支和控制流程，以验证不同条件下的执行路径。 条件覆盖率： 确保测试覆盖了加法器设计代码中的所有条件表达式的各种可能取值，以验证条件判断的正确性。 路径覆盖率： 确保测试覆盖了加法器设计代码中的所有可能执行路径，以验证代码的完整性和正确性。\n（2）功能覆盖率分析：\n功能覆盖率分析旨在评估测试是否涵盖了设计规格中定义的各项功能要求。对于加法器的验证，功能覆盖率可以通过以下方式进行分析和优化：\n输入空间覆盖率： 确保测试覆盖了所有可能的输入组合，包括边界情况和特殊情况（如进位、溢出）。 功能操作覆盖率： 确保测试覆盖了加法器所有可能的操作模式和功能特性，如单次加法、多次连续加法、不同数据宽度下的加法等。 错误处理覆盖率： 确保测试覆盖了加法器对异常情况的处理，如无效输入、非法操作等，以验证其错误处理能力和容错性。\n4. 未解决Bug列表或待改进方案 4.1 什么是未解决Bug列表或待改进方案\n在芯片验证过程中，未解决Bug列表或待改进方案是一个关键的文档，用于跟踪和记录在验证过程中发现的问题和改进点。该列表通常由验证团队维护，并在整个验证过程中进行更新和追踪。\n内容包括但不限于以下方面：\n（1）Bug描述： 每个Bug或待改进方案应该清晰地描述问题的性质、出现的条件、预期行为和实际行为之间的差异。\n（2）Bug优先级： 每个Bug应该根据其对验证工作的影响和紧迫程度确定优先级，以帮助团队优先处理关键问题。\n（3）Bug状态： 每个Bug应该有一个明确定义的状态，如“已确认”、“正在修复”、“待验证”、“已关闭”等，以跟踪Bug的处理进度。\n（4）Bug责任人： 每个Bug应指定一个责任人负责跟进和解决，确保问题得到及时处理。\n（5）Bug跟踪编号： 每个Bug应有一个唯一的标识符，便于跟踪和引用，通常使用Bug跟踪系统中提供的编号。\n4.2 举例说明\nBug编号\tBug描述\t优先级\t状态\t责任人 BUG-001\t加法器对于带有进位的加法操作结果错误\t高\t待修复\t小明 BUG-002\t加法器在32位输入时出现性能下降 中\t正在修复 小红 BUG-003\t加法器在处理负数输入时产生异常结果\t低\t已确认\t小刚 BUG-004\t加法器在高速时钟下出现时序问题\t高\t待验证\t小亮\n7. 验证结论 验证结论是在完成芯片验证过程后得出的最终结论，用于总结验证工作的结果并对验证对象的状态进行评估和描述。此处需要明确覆盖率具体指标等内容。\n","categories":["示例项目","学习材料"],"description":"概述验证报告的结构与内容。","excerpt":"概述验证报告的结构与内容。","ref":"/mlvp/docs/basic/report/","tags":["examples","docs"],"title":"验证报告"},{"body":"","categories":["示例项目","教程"],"description":"XXXX。","excerpt":"XXXX。","ref":"/mlvp/docs/advance_func/uvm/","tags":["examples","docs"],"title":"UVM对接"},{"body":" 本学习资源介绍验证相关的基本概念、技术，以及如何使用本项目提供的开源工具进行芯片验证\n学习本材料前，假定您已经拥有linux、python等相关的基础知识。\n相关学习材料：\n一生一芯的Linux基础 《Linux 101》在线讲义 Python官方教程 Javatpoint上的Git基础 若计划参与本平台上发布的“开源开放验证项目”，建议提前完成了一生一芯计划中“预学习阶段”的学习。\n","categories":"","description":"","excerpt":" 本学习资源介绍验证相关的基本概念、技术，以及如何使用本项目提供的开源工具进行芯片验证\n学习本材料前，假定您已经拥有linux、python …","ref":"/mlvp/docs/","tags":"","title":"学习资源"},{"body":"","categories":["示例项目","教程"],"description":"使用开放验证平台工具的高级功能的扩展教程，用于支持多文件、多自定义参数的复杂项目。","excerpt":"使用开放验证平台工具的高级功能的扩展教程，用于支持多文件、多自定义参数的复杂项目。","ref":"/mlvp/docs/quick-start/advance/","tags":["examples","docs"],"title":"高级特征"},{"body":"XXXX\n","categories":["示例项目","教程"],"description":"XXX。","excerpt":"XXX。","ref":"/mlvp/docs/quick-start/advance/wave/","tags":["examples","docs"],"title":"生成DUT波形"},{"body":"XXXX\n","categories":["示例项目","教程"],"description":"XXX。","excerpt":"XXX。","ref":"/mlvp/docs/quick-start/advance/multifile/","tags":["examples","docs"],"title":"多文件输入"},{"body":"XXXX\n","categories":["示例项目","教程"],"description":"XXX。","excerpt":"XXX。","ref":"/mlvp/docs/quick-start/advance/coverage-/","tags":["examples","docs"],"title":"输出覆盖率"},{"body":"","categories":["示例项目","教程"],"description":"XXXX。","excerpt":"XXXX。","ref":"/mlvp/docs/quick-start/frameworks/","tags":["examples","docs"],"title":"软件测试框架"},{"body":"1. 软件测试 在正式开始pytest 之间我们先了解一下软件的测试，软件测试一般分为如下四个方面\n单元测试：称模块测试，针对软件设计中的最小单位——程序模块，进行正确性检查的测试工作 集成测试：称组装测试，通常在单元测试的基础上，将所有程序模块进行有序的、递增测试，重点测试不同模块的接口部分 系统测试：将整个软件系统看成一个整体进行测试，包括对功能、性能以及软件所运行的软硬件环境进行测试 验收测试：指按照项目任务书或合同、供需双方约定的验收依据文档进行的对整个系统的测试与评审，决定是否接收或拒收系统 pytest最初是作为一个单元测试框架而设计的，但它也提供了许多功能，使其能够进行更广泛的测试，包括集成测试，系统测试，他是一个非常成熟的全功能的python 测试框架。 它通过收集测试函数和模块，并提供丰富的断言库来简化测试的编写和运行\n收集测试用例：pytest 会搜索当前目录及其子目录中的 Python 文件，找到符合命名约定的测试文件和测试函数。 运行测试：它可以通过命令行运行所有测试用例，也可以运行特定的测试文件、模块或者单个测试函数 断言 ：提供了丰富的断言库，用于验证测试结果是否符合预期。这些断言包括等值比较、异常抛出、容器包含等等 Fixture：pytest 使用 fixture 机制来管理测试用例的环境设置和清理工作 简单灵活，容易上手 支持参数化 测试用例的skip和xfail，自动失败重试等处理 2. 安装 # 安装pytest： pip install pytest # 升级pytest pip install -U pytest # 查看pytest版本 pytest --version # 查看已安装包列表 pip list # 查看pytest帮助文档 pytest -h # 安装第三方插件 pip install pytest-sugar pip install pytest-rerunfailures pip install pytest-xdist pip install pytest-assume pip install pytest-html 3. 使用 3.1. 命名规则 首先在使用pytest 时我们的模块名通常是以test 开头或者test 结尾 #test_*.py 或 *_test.py test_demo1 demo2_test 模块中的类名要以Test 开始且不能有init 方法 class TestDemo1: class TestLogin: 类中定义的测试方法名要以test_开头 test_demo1(self) test_demo2(self) 测试用例的例子 class test_one: def test_demo1(self): print(\"测试用例1\") def test_demo2(self): print(\"测试用例2\") 3.2. 参数解析 打印详细运行日志信息：pytest -v (最高级别信息-verbose) S 是带控制台输出结果，也是输出详细，可以打印测试用例中 print 的输出：pytest -v -s 文件名 执行单独一个 pytest 模块：pytest 文件名. Py 运行某个模块里面某个类：pytest 文件名. Py:: 类名 运行某个模块里面某个类里面的方法：pytest 文件名. Py:: 类名:: 方法名 -k：运行测试用例名称中包含某个字符串的测试用例：pytest -k “类名 and not 方法名”，如 pytest -k “TestDemo and not test_one” -m ：也叫冒烟用例运行带有某标记的测试用例 (pytest. mark. 标记名) -x：出现一个失败用例就立即停止 –maxfail = num：当错误达到 num 的时候就停止运行： –html 路径：生成html 报告 冒烟用例：\n3.3. 使用 可以在main 方法或者终端中使用pytest\n# 不带参数使用 if __name__ == '__main__': pytest.main() # 带参数使用 if __name__ == '__main__': pytest.main([\"‐vs\"]) # 命令行使用 ./testcase/test_one.py --html=./report/report.html ","categories":["示例项目","教程"],"description":"XXX。","excerpt":"XXX。","ref":"/mlvp/docs/quick-start/frameworks/pytest/","tags":["examples","docs"],"title":"PyTest"},{"body":"Hypothesis 在传统的软件测试中，我们通常需要手动编写测试用例，并为每个用例指定输入和预期输出。这种方式存在一些问题，例如测试用例覆盖不全面、边界条件容易被忽略等。Hypothesis 库通过属性基测试的思想，可以自动生成测试数据，并使用这些数据进行自动化测试。它的目标是发现潜在的错误和边界情况，从而提高代码的质量和可靠性\nHypothesis 的核心思想是使用假设（hypothesis）来推断代码的行为，并根据这些假设来生成测试数据\n1. 基本概念 测试函数：即待测试的函数或方法，我们需要对其进行测试。 属性：定义了测试函数应该满足的条件。属性是以装饰器的形式应用于测试函数上的。 策略：用于生成测试数据的生成器。Hypothesis 提供了一系列内置的策略，如整数、字符串、列表等。我们也可以自定义策略。 测试生成器：基于策略生成测试数据的函数。Hypothesis 会自动为我们生成测试数据，并将其作为参数传递给测试函数。 2. 安装 可以使用pip 命令安装 Hypothesis，然后在python 中导入就可以使用\npip install hypothesis import hypothesis 3. 使用 3.1. 属性和策略 Hypothesis 使用属性装饰器来定义测试函数的属性。最常用的装饰器是 @given，它指定了测试函数应该满足的属性。\n我们可以通过@given 装饰器定义了一个测试函数 test_addition。并给x 添加对应的属性，测试生成器会自动为测试函数生成测试数据，并将其作为参数传递给函数，例如\ndef addition(number: int) -\u003e int: return number + 1 @given(x=integers(), y=integers())　def test_addition(x, y):　assert x + 1 == addition（1） 其中Integers () 是一个内置的策略，用于生成整数类型的测试数据。Hypothesis 提供了丰富的内置策略，用于生成各种类型的测试数据。除了 Integers ()之外，还有字符串、布尔值、列表、字典等策略。例如使用 text () 策略生成字符串类型的测试数据，使用 lists (text ()) 策略生成字符串列表类型的测试数据\n@given(s=text(), l=lists(text())) def test_string_concatenation(s, l):　result = s + \"\".join(l)　assert len(result) == len(s) + sum(len(x) for x in l) 除了可以使用内置的策略以外，还可以使用自定义策略来生成特定类型的测试数据，例如我们可以生产一个非负整形的策略\ndef non_negative_integers(): return integers(min_value=0) @given(x=non_negative_integers()) def test_positive_addition(x): assert x + 1 \u003e x 3.2. 期望 我们可以通过expect 来指明需要的函数期待得到的结果\n@given(x=integers()) def test_addition(x): expected = x + 1 actual = addition(x) 3.3. 假设和断言 在使用 Hypothesis 进行测试时，我们可以使用标准的 Python 断言来验证测试函数的属性。Hypothesis 会自动为我们生成测试数据，并根据属性装饰器中定义的属性来运行测试函数。如果断言失败，Hypothesis 会尝试缩小测试数据的范围，以找出导致失败的最小样例。\n假如我们有一个字符串反转函数，我们可以通过assert 来判断翻转两次后他是不是等于自身\ndef test_reverse_string(s): expected = x + 1 actual = addition(x) assert actual == expected ","categories":["示例项目","教程"],"description":"XXX。","excerpt":"XXX。","ref":"/mlvp/docs/quick-start/frameworks/hypothesis/","tags":["examples","docs"],"title":"Hypothesis"},{"body":"","categories":["示例项目","教程"],"description":"依据不同语言实现的验证环境，可以在这里找到对应的示范","excerpt":"依据不同语言实现的验证环境，可以在这里找到对应的示范","ref":"/mlvp/docs/quick-start/multi-lang/","tags":["examples","docs"],"title":"其他编程语言"},{"body":"流程介绍 基础库 在本章节中，我们将介绍如何使用Picker将RTL代码编译为C++ Class，并编译为动态库。\n首先，Picker工具会解析RTL代码，根据指定的 Top Module ，创建一个新的 Module 封装该模块的输入输出端口，并导出DPI/API以操作输入端口、读取输出端口。 工具通过指定Top Module所在的文件和 Module Name来确定需要封装的模块。此时可以将 Top 理解为软件编程中的main。\n其次，Picker工具会使用指定的 仿真器 编译RTL代码，并生成一个DPI库文件。该库文件内包含模拟运行RTL代码所需要的逻辑（即为硬件模拟器）。 对于VCS，该库文件为.so（动态库）文件，对于Verilator，该库文件为.a（静态库）文件。\nDPI的含义是 Direct Programming Interface，可以理解为一种API规范。\n接下来，Picker工具会根据配置参数，渲染源代码中定义的基类，生成用于对接仿真器并隐藏仿真器细节的基类（wrapper）。然后链接基类与DPI库文件，生成一个 UT动态库文件。 此时，该UT库文件使用了Picker工具模板中提供的统一API，相比于DPI库文件中与仿真器强相关的API，UT库文件为仿真器生成的硬件模拟器，提供了统一的API接口。 截至这一步生成UT库文件在不同语言中是通用的！如果没有另行说明，其他高级语言均会通过调用UT动态库以实现对硬件模拟器的操作。 最后，Picker工具会根据配置参数和解析的RTL代码，生成一段 C++ Class 的源码。这段源码即是 RTL 硬件模块在软件中的定义 (.hpp) 及实现 (.cpp) 。实例化该类即相当于创建了一个硬件模块。 该类继承自基类，并实现了基类中的纯虚函数，以用软件方式实例化硬件。\n不将类的实现这一步也封装进动态库的原因有两点：\n由于UT库文件需要在不同语言中通用，而不同语言实现类的方式不同。为了通用性，不将类的实现封装进动态库。 为了便于调试，提升代码可读性，方便用户进行二次封装和修改。 生成可执行文件 在本章节中，我们将介绍如何基于上一章节生成的基础库（包含动态库，类的声明及定义），编写测试用例，生成可执行文件。\n首先，用户需要编写测试用例，即实例化上一章节生成的类，并调用类中的方法，以实现对硬件模块的操作。\n详情可以参考随机数生成器验证-配置测试代码中实例化及初始化的过程。\n其次，用户需要根据基础库所应用的不同仿真器，应用不同的链接参数以生成可执行文件。对应的参数在template/cpp/cmake/*.cmake中有定义。\n最终根据配置的链接参数，编译器会链接基础库，生成可执行文件。\n以 加法器验证 为例，picker_out_adder/cpp/cmake/*.cmake即是上述表项2所述模板的拷贝。\nvcs.cmake定义了使用VCS仿真器生成的基础库的链接参数，verilator.cmake定义了使用Verilator仿真器生成的基础库的链接参数。\n使用方案 参数 --language cpp 或 -l cpp 用于指定生成C++基础库。 参数 -e 用于生成包含示例项目的可执行文件。 参数 -v 用于保留生成项目时的中间文件。 ","categories":["教程"],"description":"基于C++封装DUT硬件的运行环境，并编译为动态库。","excerpt":"基于C++封装DUT硬件的运行环境，并编译为动态库。","ref":"/mlvp/docs/quick-start/multi-lang/cpp/","tags":["docs"],"title":"C++"},{"body":"","categories":["教程"],"description":"基于Python封装DUT硬件的运行环境，并打包为Python module。","excerpt":"基于Python封装DUT硬件的运行环境，并打包为Python module。","ref":"/mlvp/docs/quick-start/multi-lang/java/","tags":["docs"],"title":"Java"},{"body":"","categories":"","description":"","excerpt":"","ref":"/mlvp/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/mlvp/tags/docs/","tags":"","title":"Docs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/mlvp/tags/examples/","tags":"","title":"Examples"},{"body":"","categories":"","description":"","excerpt":"","ref":"/mlvp/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/mlvp/categories/%E6%95%99%E7%A8%8B/","tags":"","title":"教程"},{"body":"","categories":"","description":"","excerpt":"","ref":"/mlvp/categories/%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE/","tags":"","title":"示例项目"},{"body":" ","categories":"","description":"","excerpt":" ","ref":"/mlvp/","tags":"","title":"Goldydocs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/mlvp/search/","tags":"","title":"搜索结果"},{"body":"","categories":"","description":"","excerpt":"","ref":"/mlvp/categories/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/","tags":"","title":"学习材料"}]