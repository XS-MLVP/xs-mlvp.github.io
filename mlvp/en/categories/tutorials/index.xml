<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorials on UnityChip Verification</title>
    <link>https://xs-mlvp.github.io/mlvp/en/categories/tutorials/</link>
    <description>Recent content in Tutorials on UnityChip Verification</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 08 Jan 2025 14:45:41 +0800</lastBuildDate>
    <atom:link href="https://xs-mlvp.github.io/mlvp/en/categories/tutorials/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Complete Verification of Nutshell Cache</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/advance_case/nutshellcache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/advance_case/nutshellcache/</guid>
      <description>Verification Report Chinese version:&#xA;https://github.com/XS-MLVP/Example-NutShellCache/blob/master/nutshell_cache_report_demo.pdf&#xA;English verision:&#xA;TBD&#xA;Verification Environment &amp;amp; Test Case Code https://github.com/XS-MLVP/Example-NutShellCache</description>
    </item>
    <item>
      <title>Quick Start</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/quick-start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/quick-start/</guid>
      <description>This page will briefly introduce what verification is, as well as concepts used in the examples, such as DUT (Design Under Test) and RM (Reference Model).&#xA;Chip Verification Chip verification is a crucial step to ensure the correctness and reliability of chip designs, including functional verification, formal verification, and physical verification. This material only covers functional verification, focusing on simulation-based chip functional verification. The processes and methods of chip functional verification have many similarities with software testing, such as unit testing, system testing, black-box testing, and white-box testing.</description>
    </item>
    <item>
      <title>Setting Up the Verification Environment</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/quick-start/installer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/quick-start/installer/</guid>
      <description>Installing the Picker Tool from Source Installing Dependencies cmake ( &amp;gt;=3.11 )&#xA;gcc ( Supports C++20, at least GCC version 10, recommended 11 or higher )&#xA;python3 ( &amp;gt;=3.8 )&#xA;verilator ( ==4.218 )&#xA;verible-verilog-format ( &amp;gt;=0.0-3428-gcfcbb82b )&#xA;swig ( &amp;gt;=4.2.0 , for multi-language support )&#xA;Please ensure that the tools like verible-verilog-format have been added to the environment variable $PATH, so they can be called directly from the command line.</description>
    </item>
    <item>
      <title>Using C&#43;&#43;</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/multi-lang/cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/multi-lang/cpp/</guid>
      <description>Principle Introduction Basic Library In this chapter, we will introduce how to use Picker to compile RTL code into a C++ class and compile it into a dynamic library.&#xA;First, the Picker tool parses the RTL code, creates a new module based on the specified Top Module, encapsulates the module&amp;rsquo;s input and output ports, and exports DPI/API to operate the input ports and read the output ports.&#xA;The tool determines the module to be encapsulated by specifying the file and Module Name of the Top Module.</description>
    </item>
    <item>
      <title>Environment Usage</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/</guid>
      <description>This page will briefly introduce what verification is and concepts used in the examples, such as DUT (Design Under Test) and RM (Reference Model).</description>
    </item>
    <item>
      <title>TileLink Protocol</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/advance_case/tilelink/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/advance_case/tilelink/</guid>
      <description></description>
    </item>
    <item>
      <title>Verification Basics</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/basic/</guid>
      <description>Introduction to chip verification using the Guoke Cache as an example, covering the basic verification process and report writing.</description>
    </item>
    <item>
      <title>Waveform Generation</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/wave/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/wave/</guid>
      <description>Usage When using the Picker tool to encapsulate the DUT, use the -w [wave_file] option to specify the waveform file to be saved. Different waveform file types are supported for different backend simulators, as follows:&#xA;Verilator .vcd format waveform file. .fst format waveform file, a more efficient compressed file. VCS .fsdb format waveform file, a more efficient compressed file. Note that if you choose to generate the libDPI_____.so file yourself, the waveform file format is not restricted by the above constraints.</description>
    </item>
    <item>
      <title>Case 1: Adder</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/quick-start/eg-adder/</link>
      <pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/quick-start/eg-adder/</guid>
      <description>RTL Source Code In this case, we drive a 64-bit adder (combinational circuit) with the following source code:&#xA;// A verilog 64-bit full adder with carry in and carry out module Adder #( parameter WIDTH = 64 ) ( input [WIDTH-1:0] a, input [WIDTH-1:0] b, input cin, output [WIDTH-1:0] sum, output cout ); assign {cout, sum} = a + b + cin; endmodule This adder contains a 64-bit adder with inputs of two 64-bit numbers and a carry-in signal, outputting a 64-bit sum and a carry-out signal.</description>
    </item>
    <item>
      <title>Multi-File Input</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/multifile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/multifile/</guid>
      <description>Multi-File Input and Output In many cases, a module in one file may instantiate modules in other files. In such cases, you can use the picker tool&amp;rsquo;s -f option to process multiple Verilog source files. For example, suppose you have three source files: Cache.sv, CacheStage.sv, and CacheMeta.sv:&#xA;File List Cache.sv // In module Cache( ... ); CacheStage s1( ... ); CacheStage s2( ... ); CacheStage s3( ... ); CacheMeta cachemeta( .</description>
    </item>
    <item>
      <title>Using Java ...</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/multi-lang/java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/multi-lang/java/</guid>
      <description>Currently, Picker supports C++/Python. Other languages such as Java, Golang, Javascript, Scala, etc., will be supported after the Python interface is stabilized.</description>
    </item>
    <item>
      <title>Advanced Case Studies</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/advance_case/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/advance_case/</guid>
      <description></description>
    </item>
    <item>
      <title>Case 2: Random Number Generator</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/quick-start/eg-rmg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/quick-start/eg-rmg/</guid>
      <description>RTL Source Code In this example, we drive a random number generator, with the source code as follows:&#xA;module RandomGenerator ( input wire clk, input wire reset, input [15:0] seed, output [15:0] random_number ); reg [15:0] lfsr; always @(posedge clk or posedge reset) begin if (reset) begin lfsr &amp;lt;= seed; end else begin lfsr &amp;lt;= {lfsr[14:0], lfsr[15] ^ lfsr[14]}; end end assign random_number = lfsr; endmodule This random number generator contains a 16-bit LFSR, with a 16-bit seed as input and a 16-bit random number as output.</description>
    </item>
    <item>
      <title>Coverage Statistics</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/coverage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/coverage/</guid>
      <description>The Picker tool supports generating code line coverage reports, and the MLVP（https://github.com/XS-MLVP/mlvp）project supports generating functional coverage reports.&#xA;Code Line Coverage Currently, the Picker tool supports generating code line coverage reports based on the Verilator simulator.&#xA;Verilator The Verilator simulator provides coverage support.&#xA;The implementation is as follows:&#xA;Use the verilator_coverage tool to process or merge coverage databases, ultimately generating a coverage.info file for multiple DUTs. Use the genhtml command of the lcov tool based on coverage.</description>
    </item>
    <item>
      <title>Case 3: Dual-Port Stack (Callback)</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/quick-start/eg-stack-callback/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/quick-start/eg-stack-callback/</guid>
      <description>Introduction to the Dual-Port Stack A dual-port stack is a data structure that supports simultaneous operations on two ports. Compared to a traditional single-port stack, a dual-port stack allows simultaneous read and write operations. In scenarios such as multithreaded concurrent read and write operations, the dual-port stack can provide better performance. In this example, we provide a simple dual-port stack implementation, with the source code as follows:&#xA;module dual_port_stack ( input clk, input rst, // Interface 0 input in0_valid, output in0_ready, input [7:0] in0_data, input [1:0] in0_cmd, output out0_valid, input out0_ready, output [7:0] out0_data, output [1:0] out0_cmd, // Interface 1 input in1_valid, output in1_ready, input [7:0] in1_data, input [1:0] in1_cmd, output out1_valid, input out1_ready, output [7:0] out1_data, output [1:0] out1_cmd ); // Command definitions localparam CMD_PUSH = 2&amp;#39;b00; localparam CMD_POP = 2&amp;#39;b01; localparam CMD_PUSH_OKAY = 2&amp;#39;b10; localparam CMD_POP_OKAY = 2&amp;#39;b11; // Stack memory and pointer reg [7:0] stack_mem[0:255]; reg [7:0] sp; reg busy; reg [7:0] out0_data_reg, out1_data_reg; reg [1:0] out0_cmd_reg, out1_cmd_reg; reg out0_valid_reg, out1_valid_reg; assign out0_data = out0_data_reg; assign out0_cmd = out0_cmd_reg; assign out0_valid = out0_valid_reg; assign out1_data = out1_data_reg; assign out1_cmd = out1_cmd_reg; assign out1_valid = out1_valid_reg; always @(posedge clk or posedge rst) begin if (rst) begin sp &amp;lt;= 0; busy &amp;lt;= 0; end else begin // Interface 0 Request Handling if (!</description>
    </item>
    <item>
      <title>Integrated Testing Framework</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/frameworks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/frameworks/</guid>
      <description>In traditional chip verification practices, frameworks like UVM are widely adopted. Although they provide a comprehensive set of verification methodologies, they are typically confined to specific hardware description languages and simulation environments. Our tool breaks these limitations by converting simulation code into C++ or Python, allowing us to leverage software verification tools for more comprehensive testing. Given Python&amp;rsquo;s robust ecosystem, this project primarily uses Python as an example, briefly introducing two classic software testing frameworks: Pytest and Hypothesis.</description>
    </item>
    <item>
      <title>Case 4: Dual-Port Stack (Coroutines)</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/quick-start/eg-stack-async/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/quick-start/eg-stack-async/</guid>
      <description>Introduction to the Dual-Port Stack and Environment Setup The dual-port stack used in this case is identical to the one implemented in Case 3. Please refer to the Introduction to the Dual-Port Stack and Driver Environment Setup in Case 3 for more details.&#xA;Driving the DUT Using Coroutines In Case 3, we used callbacks to drive the DUT. While callbacks offer a way to perform parallel operations, they break the execution flow into multiple function calls and require maintaining a large amount of intermediate state, making the code more complex to write and debug.</description>
    </item>
    <item>
      <title>Multi-language Support</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/multi-lang/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/multi-lang/</guid>
      <description></description>
    </item>
    <item>
      <title>PyTest</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/frameworks/pytest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/frameworks/pytest/</guid>
      <description>Software Testing Before we start with pytest, let&amp;rsquo;s understand software testing. Software testing generally involves the following four aspects:&#xA;Unit Testing: Also known as module testing, it involves checking the correctness of program modules, which are the smallest units in software design. Integration Testing: Also known as assembly testing, it usually builds on unit testing by sequentially and incrementally testing all program modules, focusing on the interface parts of different modules.</description>
    </item>
    <item>
      <title>Hypothesis</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/frameworks/hypothesis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/frameworks/hypothesis/</guid>
      <description>Hypothesis In the previous section, we manually wrote test cases and specified inputs and expected outputs for each case. This method has some issues, such as incomplete test case coverage and the tendency to overlook boundary conditions. Hypothesis is a Python library for property-based testing. Its main goal is to make testing simpler, faster, and more reliable. It uses a method called property-based testing, where you can write some hypotheses for your code, and Hypothesis will automatically generate test cases to verify these hypotheses.</description>
    </item>
  </channel>
</rss>
