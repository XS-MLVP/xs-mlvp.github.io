<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sample Projects on UnityChip Verification</title>
    <link>https://xs-mlvp.github.io/mlvp/en/categories/sample-projects/</link>
    <description>Recent content in Sample Projects on UnityChip Verification</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://xs-mlvp.github.io/mlvp/en/categories/sample-projects/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Quick Start</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/quick-start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/quick-start/</guid>
      <description>This page will briefly introduce what verification is, as well as concepts used in the examples, such as DUT (Design Under Test) and RM (Reference Model).&#xA;Chip Verification Chip verification is a crucial step to ensure the correctness and reliability of chip designs, including functional verification, formal verification, and physical verification. This material only covers functional verification, focusing on simulation-based chip functional verification. The processes and methods of chip functional verification have many similarities with software testing, such as unit testing, system testing, black-box testing, and white-box testing.</description>
    </item>
    <item>
      <title>Environment Usage</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/</guid>
      <description>This page will briefly introduce what verification is and concepts used in the examples, such as DUT (Design Under Test) and RM (Reference Model).</description>
    </item>
    <item>
      <title>Verification Basics</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/basic/</guid>
      <description>Introduction to chip verification using the Guoke Cache as an example, covering the basic verification process and report writing.</description>
    </item>
    <item>
      <title>Waveform Generation</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/wave/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/wave/</guid>
      <description>Usage When using the Picker tool to encapsulate the DUT, use the -w [wave_file] option to specify the waveform file to be saved. Different waveform file types are supported for different backend simulators, as follows:&#xA;Verilator .vcd format waveform file. .fst format waveform file, a more efficient compressed file. VCS .fsdb format waveform file, a more efficient compressed file. Note that if you choose to generate the libDPI_____.so file yourself, the waveform file format is not restricted by the above constraints.</description>
    </item>
    <item>
      <title>Creating DUT</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/basic/create_dut/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/basic/create_dut/</guid>
      <description>Using Guoke Cache as an example, this document introduces how to create a DUT based on Chisel.&#xA;In this document, a DUT (Design Under Test) refers to the circuit or system being verified during the chip verification process. The DUT is the primary subject of verification. When creating a DUT based on the picker tool, it is essential to consider the functionality, performance requirements, and verification goals of the subject under test.</description>
    </item>
    <item>
      <title>Multi-File Input</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/multifile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/multifile/</guid>
      <description>Multi-File Input and Output In many cases, a module in one file may instantiate modules in other files. In such cases, you can use the picker tool&amp;rsquo;s -f option to process multiple Verilog source files. For example, suppose you have three source files: Cache.sv, CacheStage.sv, and CacheMeta.sv:&#xA;File List Cache.sv // In module Cache( ... ); CacheStage s1( ... ); CacheStage s2( ... ); CacheStage s3( ... ); CacheMeta cachemeta( .</description>
    </item>
    <item>
      <title>Coverage Statistics</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/coverage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/coverage/</guid>
      <description>The Picker tool supports generating code line coverage reports, and the MLVP（https://github.com/XS-MLVP/mlvp）project supports generating functional coverage reports.&#xA;Code Line Coverage Currently, the Picker tool supports generating code line coverage reports based on the Verilator simulator.&#xA;Verilator The Verilator simulator provides coverage support.&#xA;The implementation is as follows:&#xA;Use the verilator_coverage tool to process or merge coverage databases, ultimately generating a coverage.info file for multiple DUTs. Use the genhtml command of the lcov tool based on coverage.</description>
    </item>
    <item>
      <title>Integrated Testing Framework</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/frameworks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/frameworks/</guid>
      <description>In traditional chip verification practices, frameworks like UVM are widely adopted. Although they provide a comprehensive set of verification methodologies, they are typically confined to specific hardware description languages and simulation environments. Our tool breaks these limitations by converting simulation code into C++ or Python, allowing us to leverage software verification tools for more comprehensive testing. Given Python&amp;rsquo;s robust ecosystem, this project primarily uses Python as an example, briefly introducing two classic software testing frameworks: Pytest and Hypothesis.</description>
    </item>
    <item>
      <title>Multi-language Support</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/multi-lang/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/multi-lang/</guid>
      <description></description>
    </item>
    <item>
      <title>PyTest</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/frameworks/pytest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/frameworks/pytest/</guid>
      <description>Software Testing Before we start with pytest, let&amp;rsquo;s understand software testing. Software testing generally involves the following four aspects:&#xA;Unit Testing: Also known as module testing, it involves checking the correctness of program modules, which are the smallest units in software design. Integration Testing: Also known as assembly testing, it usually builds on unit testing by sequentially and incrementally testing all program modules, focusing on the interface parts of different modules.</description>
    </item>
    <item>
      <title>Hypothesis</title>
      <link>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/frameworks/hypothesis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/mlvp/en/docs/env_usage/frameworks/hypothesis/</guid>
      <description>Hypothesis In the previous section, we manually wrote test cases and specified inputs and expected outputs for each case. This method has some issues, such as incomplete test case coverage and the tendency to overlook boundary conditions. Hypothesis is a Python library for property-based testing. Its main goal is to make testing simpler, faster, and more reliable. It uses a method called property-based testing, where you can write some hypotheses for your code, and Hypothesis will automatically generate test cases to verify these hypotheses.</description>
    </item>
  </channel>
</rss>
