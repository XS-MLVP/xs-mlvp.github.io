<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Goldydocs on UnityChip Verification</title>
    <link>https://open-verify.cc/mlvp/en/</link>
    <description>Recent content in Goldydocs on UnityChip Verification</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://open-verify.cc/mlvp/en/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bundle API</title>
      <link>https://open-verify.cc/mlvp/en/docs/mlvp/api/bundle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/mlvp/api/bundle/</guid>
      <description></description>
    </item>
    <item>
      <title>Chip Verification</title>
      <link>https://open-verify.cc/mlvp/en/docs/basic/ic_verify/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/basic/ic_verify/</guid>
      <description>This page provides a brief introduction to chip verification, including concepts used in examples such as DUT (Design Under Test) and RM (Reference Model).&#xA;The chip verification process needs to align with the actual situation of the company or team. There is no absolute standard that meets all requirements and must be referenced.&#xA;What is Chip Verification? The chip design-to-production process involves three main stages: chip design, chip manufacturing, and chip packaging/testing.</description>
    </item>
    <item>
      <title>Complete Verification of Nutshell Cache</title>
      <link>https://open-verify.cc/mlvp/en/docs/advance_case/nutshellcache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/advance_case/nutshellcache/</guid>
      <description>Verification Report Chinese version:&#xA;https://github.com/XS-MLVP/Example-NutShellCache/blob/master/nutshell_cache_report_demo.pdf&#xA;English verision:&#xA;TBD&#xA;Verification Environment &amp;amp; Test Case Code https://github.com/XS-MLVP/Example-NutShellCache</description>
    </item>
    <item>
      <title>How to Drive Using Test Environment Interfaces</title>
      <link>https://open-verify.cc/mlvp/en/docs/mlvp/cases/executor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/mlvp/cases/executor/</guid>
      <description>How to Simultaneously Call Multiple Driver Functions Once the verification environment is set up, you can write test cases using the interfaces provided by the verification environment. However, it is often difficult to call two driver functions simultaneously using conventional serial code. This becomes especially important when multiple interfaces need to be driven at the same time, and mlvp provides a simple way to handle such scenarios.&#xA;Simultaneously Calling Multiple Driver Functions of Different Categories For example, suppose the current Env structure is as follows:</description>
    </item>
    <item>
      <title>How to Use an Asynchronous Environment</title>
      <link>https://open-verify.cc/mlvp/en/docs/mlvp/env/start_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/mlvp/env/start_test/</guid>
      <description>Starting the Event Loop In the previously described verification environment, we designed a standardized setup. However, if we attempt to write it as a simple single-threaded program, we may encounter complex implementation issues.&#xA;For instance, consider having two driver methods that drive two different interfaces. Inside each driver method, we need to wait for several clock cycles of the DUT (Device Under Test), and both methods must run simultaneously. In a basic single-threaded program, running both driver methods concurrently can be quite challenging.</description>
    </item>
    <item>
      <title>Quick Start</title>
      <link>https://open-verify.cc/mlvp/en/docs/mlvp/quick-start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/mlvp/quick-start/</guid>
      <description>Installation toffee Toffee is a Python-based hardware verification framework designed to help users build hardware verification environments more conveniently and systematically using Python. It leverages the multi-language conversion tool picker, which converts Verilog code of hardware designs into Python Packages, enabling users to drive and verify hardware designs in Python.&#xA;Toffee requires the following dependencies:&#xA;Python 3.6.8+&#xA;Picker 0.9.0+&#xA;Once these dependencies are installed, you can install Toffee via pip:</description>
    </item>
    <item>
      <title>Setting Up the Verification Environment</title>
      <link>https://open-verify.cc/mlvp/en/docs/quick-start/installer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/quick-start/installer/</guid>
      <description>Installing the Picker Tool from Source Installing Dependencies cmake ( &amp;gt;=3.11 )&#xA;gcc ( Supports C++20, at least GCC version 10, recommended 11 or higher )&#xA;python3 ( &amp;gt;=3.8 )&#xA;verilator ( ==4.218 )&#xA;verible-verilog-format ( &amp;gt;=0.0-3428-gcfcbb82b )&#xA;swig ( &amp;gt;=4.2.0 , for multi-language support )&#xA;Please ensure that the tools like verible-verilog-format have been added to the environment variable $PATH, so they can be called directly from the command line.</description>
    </item>
    <item>
      <title>Tool Introduction</title>
      <link>https://open-verify.cc/mlvp/en/docs/env_usage/picker_usage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/env_usage/picker_usage/</guid>
      <description>To meet the requirements of an open verification environment, we have developed the Picker tool, which is used to convert RTL designs into multi-language interfaces for verification. We will use the environment generated by the Picker tool as the basic verification environment. Next, we will introduce the Picker tool and its basic usage.&#xA;Introduction to Picker Picker is an auxiliary tool for chip verification with two main functions:&#xA;Packaging RTL Design Verification Modules: Picker can package RTL design verification modules (.</description>
    </item>
    <item>
      <title>Using C&#43;&#43;</title>
      <link>https://open-verify.cc/mlvp/en/docs/multi-lang/cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/multi-lang/cpp/</guid>
      <description>Principle Introduction Basic Library In this chapter, we will introduce how to use Picker to compile RTL code into a C++ class and compile it into a dynamic library.&#xA;First, the Picker tool parses the RTL code, creates a new module based on the specified Top Module, encapsulates the module&amp;rsquo;s input and output ports, and exports DPI/API to operate the input ports and read the output ports.&#xA;The tool determines the module to be encapsulated by specifying the file and Module Name of the Top Module.</description>
    </item>
    <item>
      <title>Digital Circuits</title>
      <link>https://open-verify.cc/mlvp/en/docs/basic/ic_base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/basic/ic_base/</guid>
      <description>This page introduces the basics of digital circuits. Digital circuits use digital signals and are the foundation of most modern computers.&#xA;What Are Digital Circuits Digital circuits are electronic circuits that use two discrete voltage levels to represent information. Typically, digital circuits use two power supply voltages to indicate high (H) and low (L) levels, representing the digits 1 and 0 respectively. This representation uses binary signals to transmit and process information.</description>
    </item>
    <item>
      <title>How to Use Bundle</title>
      <link>https://open-verify.cc/mlvp/en/docs/mlvp/env/bundle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/mlvp/env/bundle/</guid>
      <description>Bundle serves as an intermediary layer in the mlvp verification environment, facilitating interaction between the Agent and the DUT while ensuring their decoupling. Additionally, Bundle helps define the hierarchy of DUT interface layers, making access to the DUT interface clearer and more convenient.&#xA;A Simple Definition of a Bundle To define a Bundle, you need to create a new class that inherits from the Bundle class in mlvp. Here’s a simple example of defining a Bundle:</description>
    </item>
    <item>
      <title>How to Use Pytest to Manage Test Cases</title>
      <link>https://open-verify.cc/mlvp/en/docs/mlvp/cases/pytest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/mlvp/cases/pytest/</guid>
      <description>Writing Test Cases In mlvp, test cases are managed using pytest. pytest is a powerful Python testing framework. If you are not familiar with pytest, you can refer to the official pytest documentation .&#xA;Writing Your First Test Case First, we need to create a test case file, for example, test_adder.py. The file should start with test_ or end with _test.py so that pytest can recognize it. Then we can write our first test case in it.</description>
    </item>
    <item>
      <title>TileLink Protocol</title>
      <link>https://open-verify.cc/mlvp/en/docs/advance_case/tilelink/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/advance_case/tilelink/</guid>
      <description></description>
    </item>
    <item>
      <title>Waveform Generation</title>
      <link>https://open-verify.cc/mlvp/en/docs/env_usage/wave/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/env_usage/wave/</guid>
      <description>Usage When using the Picker tool to encapsulate the DUT, use the -w [wave_file] option to specify the waveform file to be saved. Different waveform file types are supported for different backend simulators, as follows:&#xA;Verilator .vcd format waveform file. .fst format waveform file, a more efficient compressed file. VCS .fsdb format waveform file, a more efficient compressed file. Note that if you choose to generate the libDPI_____.so file yourself, the waveform file format is not restricted by the above constraints.</description>
    </item>
    <item>
      <title>Writing a Standardized Verification Environment</title>
      <link>https://open-verify.cc/mlvp/en/docs/mlvp/canonical_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/mlvp/canonical_env/</guid>
      <description>Overview The main task of writing verification code can be broadly divided into two parts: building the verification environment and writing test cases .Building the verification environment aims to encapsulate the Design Under Test (DUT) so that the verification engineer does not have to deal with complex interface signals when driving the DUT, but can instead directly use the high-level interfaces provided by the verification environment. If a reference model needs to be written, it should also be part of the verification environment.</description>
    </item>
    <item>
      <title>Case 1: Adder</title>
      <link>https://open-verify.cc/mlvp/en/docs/quick-start/eg-adder/</link>
      <pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/quick-start/eg-adder/</guid>
      <description>RTL Source Code In this case, we drive a 64-bit adder (combinational circuit) with the following source code:&#xA;// A verilog 64-bit full adder with carry in and carry out module Adder #( parameter WIDTH = 64 ) ( input [WIDTH-1:0] a, input [WIDTH-1:0] b, input cin, output [WIDTH-1:0] sum, output cout ); assign {cout, sum} = a + b + cin; endmodule This adder contains a 64-bit adder with inputs of two 64-bit numbers and a carry-in signal, outputting a 64-bit sum and a carry-out signal.</description>
    </item>
    <item>
      <title>Creating DUT</title>
      <link>https://open-verify.cc/mlvp/en/docs/basic/create_dut/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/basic/create_dut/</guid>
      <description>Using Guoke Cache as an example, this document introduces how to create a DUT based on Chisel.&#xA;In this document, a DUT (Design Under Test) refers to the circuit or system being verified during the chip verification process. The DUT is the primary subject of verification. When creating a DUT based on the picker tool, it is essential to consider the functionality, performance requirements, and verification goals of the subject under test.</description>
    </item>
    <item>
      <title>How to Write an Agent</title>
      <link>https://open-verify.cc/mlvp/en/docs/mlvp/env/agent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/mlvp/env/agent/</guid>
      <description>An Agent in the mlvp verification environment provides a high-level encapsulation of signals within a class of Bundles, allowing the upper-level driver code to drive and monitor the signals in the Bundle without worrying about specific signal assignments.An Agent consists of driver methods and monitor methods , where the driver methods actively drive the signals in the Bundle, and the monitor methods passively observe the signals in the Bundle.&#xA;Initializing the Agent To define an Agent, you need to create a new class that inherits from the Agent class in mlvp.</description>
    </item>
    <item>
      <title>How to Write Test Points</title>
      <link>https://open-verify.cc/mlvp/en/docs/mlvp/cases/cov/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/mlvp/cases/cov/</guid>
      <description>Test Points in Verification In mlvp, a test point (Cover Point) refers to the smallest unit of verification for a specific function of the design, while a test group (Cover Group) is a collection of related test points. To define a test point, you need to specify the name of the test point and its trigger condition. For example, you can define a test point such as, &amp;ldquo;When the result of the adder operation is non-zero, the result is correct.</description>
    </item>
    <item>
      <title>Multi-File Input</title>
      <link>https://open-verify.cc/mlvp/en/docs/env_usage/multifile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/env_usage/multifile/</guid>
      <description>Multi-File Input and Output In many cases, a module in one file may instantiate modules in other files. In such cases, you can use the picker tool&amp;rsquo;s -f option to process multiple Verilog source files. For example, suppose you have three source files: Cache.sv, CacheStage.sv, and CacheMeta.sv:&#xA;File List Cache.sv // In module Cache( ... ); CacheStage s1( ... ); CacheStage s2( ... ); CacheStage s3( ... ); CacheMeta cachemeta( .</description>
    </item>
    <item>
      <title>Using Java ...</title>
      <link>https://open-verify.cc/mlvp/en/docs/multi-lang/java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/multi-lang/java/</guid>
      <description>Currently, Picker supports C++/Python. Other languages such as Java, Golang, Javascript, Scala, etc., will be supported after the Python interface is stabilized.</description>
    </item>
    <item>
      <title>Case 2: Random Number Generator</title>
      <link>https://open-verify.cc/mlvp/en/docs/quick-start/eg-rmg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/quick-start/eg-rmg/</guid>
      <description>RTL Source Code In this example, we drive a random number generator, with the source code as follows:&#xA;module RandomGenerator ( input wire clk, input wire reset, input [15:0] seed, output [15:0] random_number ); reg [15:0] lfsr; always @(posedge clk or posedge reset) begin if (reset) begin lfsr &amp;lt;= seed; end else begin lfsr &amp;lt;= {lfsr[14:0], lfsr[15] ^ lfsr[14]}; end end assign random_number = lfsr; endmodule This random number generator contains a 16-bit LFSR, with a 16-bit seed as input and a 16-bit random number as output.</description>
    </item>
    <item>
      <title>Coverage Statistics</title>
      <link>https://open-verify.cc/mlvp/en/docs/env_usage/coverage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/env_usage/coverage/</guid>
      <description>The Picker tool supports generating code line coverage reports, and the MLVP（https://github.com/XS-MLVP/mlvp）project supports generating functional coverage reports.&#xA;Code Line Coverage Currently, the Picker tool supports generating code line coverage reports based on the Verilator simulator.&#xA;Verilator The Verilator simulator provides coverage support. The implementation is as follows:&#xA;Use the verilator_coverage tool to process or merge coverage databases, ultimately generating a coverage.info file for multiple DUTs. Use the genhtml command of the lcov tool based on coverage.</description>
    </item>
    <item>
      <title>How to Build an Env</title>
      <link>https://open-verify.cc/mlvp/en/docs/mlvp/env/build_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/mlvp/env/build_env/</guid>
      <description>Env is used in the mlvp verification environment to package the entire verification setup. It directly instantiates all the agents needed in the verification environment and is responsible for passing the required bundles to these agents. Once the Env is created, the specification for writing reference models is also determined. Reference models written according to this specification can be directly attached to the Env, allowing it to handle automatic synchronization of the reference models.</description>
    </item>
    <item>
      <title>Case 3: Dual-Port Stack (Callback)</title>
      <link>https://open-verify.cc/mlvp/en/docs/quick-start/eg-stack-callback/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/quick-start/eg-stack-callback/</guid>
      <description>Introduction to the Dual-Port Stack A dual-port stack is a data structure that supports simultaneous operations on two ports. Compared to a traditional single-port stack, a dual-port stack allows simultaneous read and write operations. In scenarios such as multithreaded concurrent read and write operations, the dual-port stack can provide better performance. In this example, we provide a simple dual-port stack implementation, with the source code as follows:&#xA;module dual_port_stack ( input clk, input rst, // Interface 0 input in0_valid, output in0_ready, input [7:0] in0_data, input [1:0] in0_cmd, output out0_valid, input out0_ready, output [7:0] out0_data, output [1:0] out0_cmd, // Interface 1 input in1_valid, output in1_ready, input [7:0] in1_data, input [1:0] in1_cmd, output out1_valid, input out1_ready, output [7:0] out1_data, output [1:0] out1_cmd ); // Command definitions localparam CMD_PUSH = 2&amp;#39;b00; localparam CMD_POP = 2&amp;#39;b01; localparam CMD_PUSH_OKAY = 2&amp;#39;b10; localparam CMD_POP_OKAY = 2&amp;#39;b11; // Stack memory and pointer reg [7:0] stack_mem[0:255]; reg [7:0] sp; reg busy; reg [7:0] out0_data_reg, out1_data_reg; reg [1:0] out0_cmd_reg, out1_cmd_reg; reg out0_valid_reg, out1_valid_reg; assign out0_data = out0_data_reg; assign out0_cmd = out0_cmd_reg; assign out0_valid = out0_valid_reg; assign out1_data = out1_data_reg; assign out1_cmd = out1_cmd_reg; assign out1_valid = out1_valid_reg; always @(posedge clk or posedge rst) begin if (rst) begin sp &amp;lt;= 0; busy &amp;lt;= 0; end else begin // Interface 0 Request Handling if (!</description>
    </item>
    <item>
      <title>DUT Verification</title>
      <link>https://open-verify.cc/mlvp/en/docs/basic/test_dut/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/basic/test_dut/</guid>
      <description>This section introduces the general process of verifying a DUT based on Picker.&#xA;The goal of the open verification platform is functional verification, which generally involves the following steps:&#xA;1. Determine the verification object and goals Typically, the design documentation of the DUT is also delivered to the verification engineer. At this point, you need to read the documentation or source code to understand the basic functions, main structure, and expected functionalities of the verification object.</description>
    </item>
    <item>
      <title>How to Write a Reference Model</title>
      <link>https://open-verify.cc/mlvp/en/docs/mlvp/env/ref_model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/mlvp/env/ref_model/</guid>
      <description>A reference model is used to simulate the behavior of the design under verification, aiding in the validation process. In the mlvp verification environment, the reference model needs to follow the Env interface specifications so it can be attached to Env, allowing automatic synchronization by Env.&#xA;Two Ways to Implement a Reference Model mlvp provides two methods for implementing a reference model, both of which can be attached to Env for automatic synchronization.</description>
    </item>
    <item>
      <title>Starting a New Verification Task</title>
      <link>https://open-verify.cc/mlvp/en/docs/mlvp/verification/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/mlvp/verification/</guid>
      <description>With mlvp, you can now set up a complete verification environment and conveniently write test cases. However, in real-world scenarios, it can be challenging to understand how to get started and ultimately complete a verification task. After writing code, common issues may include difficulties in correctly partitioning the Bundle, misunderstanding the high-level semantic encapsulation of the Agent, and not knowing what to do after setting up the environment.&#xA;In this section, we will introduce how to complete a new verification task from scratch and how to use mlvp effectively to accomplish it.</description>
    </item>
    <item>
      <title>Case 4: Dual-Port Stack (Coroutines)</title>
      <link>https://open-verify.cc/mlvp/en/docs/quick-start/eg-stack-async/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/quick-start/eg-stack-async/</guid>
      <description>Introduction to the Dual-Port Stack and Environment Setup The dual-port stack used in this case is identical to the one implemented in Case 3. Please refer to the Introduction to the Dual-Port Stack and Driver Environment Setup in Case 3 for more details.&#xA;Driving the DUT Using Coroutines In Case 3, we used callbacks to drive the DUT. While callbacks offer a way to perform parallel operations, they break the execution flow into multiple function calls and require maintaining a large amount of intermediate state, making the code more complex to write and debug.</description>
    </item>
    <item>
      <title>Verification Report</title>
      <link>https://open-verify.cc/mlvp/en/docs/basic/report/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/basic/report/</guid>
      <description>After we complete the DUT verification, writing a verification report is a crucial step. This section will provide an overview of the structure of the verification report and the content that needs to be covered.&#xA;The verification report is a review of the entire verification process and an important supporting document for determining the reasonableness of the verification. Generally, the verification report should include the following content:&#xA;Basic document information (author, log, version, etc.</description>
    </item>
    <item>
      <title>PyTest</title>
      <link>https://open-verify.cc/mlvp/en/docs/env_usage/frameworks/pytest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/env_usage/frameworks/pytest/</guid>
      <description>Software Testing Before we start with pytest, let&amp;rsquo;s understand software testing. Software testing generally involves the following four aspects:&#xA;Unit Testing: Also known as module testing, it involves checking the correctness of program modules, which are the smallest units in software design. Integration Testing: Also known as assembly testing, it usually builds on unit testing by sequentially and incrementally testing all program modules, focusing on the interface parts of different modules.</description>
    </item>
    <item>
      <title>Hypothesis</title>
      <link>https://open-verify.cc/mlvp/en/docs/env_usage/frameworks/hypothesis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/docs/env_usage/frameworks/hypothesis/</guid>
      <description>Hypothesis In the previous section, we manually wrote test cases and specified inputs and expected outputs for each case. This method has some issues, such as incomplete test case coverage and the tendency to overlook boundary conditions. Hypothesis is a Python library for property-based testing. Its main goal is to make testing simpler, faster, and more reliable. It uses a method called property-based testing, where you can write some hypotheses for your code, and Hypothesis will automatically generate test cases to verify these hypotheses.</description>
    </item>
    <item>
      <title>Search Results</title>
      <link>https://open-verify.cc/mlvp/en/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/mlvp/en/search/</guid>
      <description></description>
    </item>
  </channel>
</rss>
