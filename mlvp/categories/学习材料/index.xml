<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开放验证平台学习资源 – 学习材料</title>
    <link>https://xs-mlvp.github.io/mlvp/categories/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/</link>
    <description>Recent content in 学习材料 on 开放验证平台学习资源</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	  <atom:link href="https://xs-mlvp.github.io/mlvp/categories/%E5%AD%A6%E4%B9%A0%E6%9D%90%E6%96%99/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: 创建DUT</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/basic/create_dut/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/basic/create_dut/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;本节主要介绍如何基于Picker创建DUT。&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;创建DUT（Design Under Test）是指在芯片验证过程中，设计并实现被测对象的电路或系统。DUT是验证的主体，是需要验证的电路设计。在创建DUT时，通常需要考虑被测对象的功能、性能要求和验证目标，然后使用硬件描述语言（HDL）如Verilog或VHDL编写相应的电路描述代码，或通过图形化设计工具生成电路设计。创建DUT是验证过程中的第一步，其质量和准确性直接影响着后续的验证工作。&lt;/p&gt;
&lt;p&gt;以&lt;a href=&#34;%22/zh-cn/docs/quick-start/%22&#34;&gt;加法器DUT的创建：&lt;/a&gt;为例，进行解释：&lt;/p&gt;
&lt;p&gt;创建一个名为 Adder 的文件夹，并在其中创建一个名为 Adder.v 的文件。这个文件将包含加法器的 Verilog 代码。下面是一个示例的加法器 Verilog 代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Adder&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;#(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;parameter&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;WIDTH&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;input&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;WIDTH&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;input&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;WIDTH&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;input&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;output&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;WIDTH&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;output&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cout&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;assign&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cout&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;  &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cin&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;endmodule&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;UDT解释：&lt;/p&gt;
&lt;p&gt;module Adder &amp;hellip; endmodule: 定义了一个名为 Adder 的模块，该模块实现了加法器的功能。&lt;/p&gt;
&lt;p&gt;parameter WIDTH = 64: 使用 parameter 关键字定义了一个名为 WIDTH 的参数，默认值为 64。这个参数可以控制加法器的输入和输出的位宽。&lt;/p&gt;
&lt;p&gt;input [WIDTH-1:0] a, input [WIDTH-1:0] b: 定义了两个输入端口 a 和 b，它们的宽度为 WIDTH。这里使用了一个向量（vector）来表示输入端口的多个位。&lt;/p&gt;
&lt;p&gt;input cin: 定义了一个输入端口 cin，表示加法器的进位输入。&lt;/p&gt;
&lt;p&gt;output [WIDTH-1:0] sum, output cout: 定义了两个输出端口 sum 和 cout，分别表示加法器的和输出和进位输出。&lt;/p&gt;
&lt;p&gt;assign: 该关键字用于将一个表达式的值赋给一个信号。&lt;/p&gt;
&lt;p&gt;{cout, sum}: 这是一个连续赋值语句，表示将右边表达式的值分别赋给左边的两个信号 cout 和 sum。&lt;/p&gt;
&lt;p&gt;a + b + cin: 这是一个表达式，表示将输入端口 a、b 和 cin 的值相加。由于 a、b 和 sum 都是位宽为 WIDTH 的向量，因此这里进行的是位宽为 WIDTH 的加法运算。&lt;/p&gt;
&lt;p&gt;通过连续赋值语句，将加法器的输出 sum 和 cout 分别赋值为表达式 a + b + cin 的结果的低 WIDTH 位和高 WIDTH 位。&lt;/p&gt;
&lt;p&gt;endmodule: 表示模块定义结束。&lt;/p&gt;
&lt;p&gt;这段 Verilog 代码定义了一个参数化的加法器模块，能够根据参数 WIDTH 控制输入输出的位宽。加法器的输入包括两个 WIDTH 位的数 a 和 b，以及一个单独的进位信号 cin。输出包括一个 WIDTH 位的和 sum 和一个单独的进位输出 cout。加法器的实现通过简单的连续赋值语句，将输入的两个数和进位相加，得到输出的和与进位。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: DUT编译</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/basic/compile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/basic/compile/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;本节主要介绍如何基于Picker编译DUT。&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;编译DUT是指将被测设计（Design Under Test，即DUT）的硬件描述语言（HDL）代码转换为可供仿真和验证使用的逻辑网表的过程。这个过程通常包括综合、优化、映射和布线等步骤，其主要目的是将抽象的HDL代码转换为实际的电路网表，以便进行后续的仿真和验证工作。&lt;/p&gt;
&lt;p&gt;以&lt;a href=&#34;%22/content/zh-cn/docs/quick-start/%22&#34;&gt;加法器DUT的编译：&lt;/a&gt;为例进行解释：&lt;/p&gt;
&lt;p&gt;在 Adder 文件夹中，执行以下命令将 Verilog 文件编译为 C++ Class：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;picker&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Adder&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Adder&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;fst&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;S&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Adder&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;picker_out_adder&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;l&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cpp&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;sim&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;verilator&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个命令会将 Adder.v 文件作为 Top 文件，并将其编译为 C++ Class，使用 verilator 仿真器。编译过程会生成一系列中间文件，其中包括 Verilog 文件、C++ 源代码等。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: DUT验证</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/basic/test_dut/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/basic/test_dut/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;本节主要介绍如何基于Picker验证DUT。&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;DUT测试是芯片验证过程中的关键步骤之一，指的是对被测设计（Design Under Test，即DUT）进行验证和测试的过程。在DUT测试中，验证工程师会通过各种测试方法和技术，对DUT的功能、性能和时序等方面进行全面的评估，以确保DUT能够按照设计要求正常工作，并且满足用户的需求和期望。&lt;/p&gt;
&lt;p&gt;以&lt;a href=&#34;%22/content/zh-cn/docs/quick-start/%22&#34;&gt;加法器DUT的测试：&lt;/a&gt;为例进行解释：&lt;/p&gt;
&lt;p&gt;在测试过程中，我们将创建一个示例项目，并编写测试代码来验证加法器的功能。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;UT_Adder.hpp&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;UTAdder&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dut&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;UTAdder&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;libDPIAdder.so&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// 进行测试...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;delete&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;dut&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这段代码中，我们创建了一个 UTAdder 类的实例，然后进行测试。&lt;/p&gt;
&lt;p&gt;接着，编译测试代码。在 Adder 文件夹中，执行 make 命令，编译测试代码并生成可执行文件。&lt;/p&gt;
&lt;p&gt;最后，运行测试。执行生成的可执行文件，即可运行测试，并观察输出结果。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 验证报告</title>
      <link>https://xs-mlvp.github.io/mlvp/docs/basic/report/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/mlvp/docs/basic/report/</guid>
      <description>
        
        
        

&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;p&gt;在我们完成DUT验证后，编写验证报告是至关重要的一环。本节将从整体角度概述验证报告的结构以及报告所需覆盖的内容。&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id=&#34;1-验证的范围&#34;&gt;1. 验证的范围&lt;/h2&gt;
&lt;p&gt;1.1 什么是验证范围&lt;/p&gt;
&lt;p&gt;在芯片验证过程中，验证范围是指需要进行验证的范围或内容的总体描述。它确定了验证活动所需覆盖的功能、性能、边界条件、接口以及其他关键方面。&lt;/p&gt;
&lt;p&gt;1.2 举例说明&lt;/p&gt;
&lt;p&gt;以加法器功能验证为例，本块内容应该至少描述清楚以下内容：&lt;/p&gt;
&lt;p&gt;（1）基本功能验证：&lt;/p&gt;
&lt;p&gt;确认加法器能够正确执行加法运算，包括对两个输入数进行相加并产生正确的结果。
测试加法器对不同数据宽度（例如8位、16位、32位）的支持，并验证其在不同数据宽度下的加法功能是否正常工作。
边界条件验证：&lt;/p&gt;
&lt;p&gt;验证加法器在最小值、最大值以及边界情况下的加法运算是否正确，例如边界值加法、最大值加法和最小值加法。
测试加法器对于特殊情况（如进位、溢出）的处理是否符合设计要求。&lt;/p&gt;
&lt;p&gt;（2）异常输入验证：&lt;/p&gt;
&lt;p&gt;检查加法器对于不合法输入的处理能力，如无效输入、非数字字符或格式错误输入的情况。
验证加法器在面对不符合规范的输入时能够产生正确的错误提示或异常处理。&lt;/p&gt;
&lt;p&gt;（3）多输入/多操作模式验证：&lt;/p&gt;
&lt;p&gt;确认加法器能够处理多组输入，并正确执行相加操作。
验证加法器在连续多次相加操作下是否能够保持正确的累加结果。&lt;/p&gt;
&lt;h2 id=&#34;2-验证环境说明&#34;&gt;2. 验证环境说明&lt;/h2&gt;
&lt;p&gt;2.1 什么是验证环境&lt;/p&gt;
&lt;p&gt;验证环境是用于运行芯片顶层功能验证的各个组件（component）的集合。它主要包含以下几个部分：&lt;/p&gt;
&lt;p&gt;（1）被测设计（DUT）：&lt;/p&gt;
&lt;p&gt;DUT是待验证的设计单元，即加法器。它是验证的主体，通过验证环境中的测试向量和输入数据进行功能验证。&lt;/p&gt;
&lt;p&gt;（2）CPU子环境（MPI Agent）：&lt;/p&gt;
&lt;p&gt;MPI（Message Passing Interface）Agent是与外部处理器（CPU）通信的组件。它负责处理来自CPU的验证指令，并将验证结果返回给CPU。MPI Agent与CPU之间通过消息传递机制进行通信，以启动验证过程并提供验证结果。&lt;/p&gt;
&lt;p&gt;（3）PTU/PRU子环境（SPT Agent）：&lt;/p&gt;
&lt;p&gt;SPT（System Port Test）Agent是与外部测试单元（PTU/PRU）通信的组件。它负责与PTU/PRU进行数据交换和配置寄存器访问，以验证加法器的功能和性能。SPT Agent通过与PTU/PRU之间的接口通信，控制测试流程并收集验证数据。&lt;/p&gt;
&lt;p&gt;（4）参考模块（RM）：&lt;/p&gt;
&lt;p&gt;参考模块（Reference Model）是验证过程中的参照标准。它包含了预期的加法器功能和性能规格。验证结果将与参考模块的预期结果进行比对，以确认验证的正确性。参考模块通常由设计规格或功能规范定义，并在验证环境中用于验证结果的验证。&lt;/p&gt;
&lt;p&gt;（5）检查器（Checker）：&lt;/p&gt;
&lt;p&gt;检查器是验证环境中的组件，用于检查仿真结果与参考模块预期结果之间的一致性。它负责比对仿真输出和参考模块的预期输出，并生成验证报告。检查器确保验证结果与设计规格的一致性，以确认验证的准确性和完整性。&lt;/p&gt;
&lt;p&gt;（6）脚本（Makefile）：&lt;/p&gt;
&lt;p&gt;Makefile是验证环境的自动化脚本，用于管理验证流程的各个步骤。它包括编译、运行仿真、分析结果等操作，并提供了一种方便的方式来执行验证任务。通过脚本的自动化处理，可以提高验证效率并减少人工错误的可能性。&lt;/p&gt;
&lt;p&gt;2.2 举例说明&lt;/p&gt;
&lt;p&gt;以加法器功能验证为例，本块内容应该至少描述清楚以下内容：&lt;/p&gt;
&lt;p&gt;（1）DUT版本信息：&lt;/p&gt;
&lt;p&gt;DUT名称： 加法器
版本信息： v1.0
设计语言： Verilog HDL
设计工具： Synopsys Design Compiler&lt;/p&gt;
&lt;p&gt;（2）验证平台说明：&lt;/p&gt;
&lt;p&gt;平台名称： FPGA Verification Platform
FPGA型号： Xilinx Virtex UltraScale+ VU9P
仿真工具： Cadence Xcelium Simulator
编译工具： Xilinx Vivado&lt;/p&gt;
&lt;p&gt;（2.1）验证环境架构：&lt;/p&gt;
&lt;p&gt;MPI Agent： 负责与CPU子环境通信，接收和发送验证指令。
SPT Agent： 与PTU/PRU子环境通信，负责与芯片接口进行数据交换和配置寄存器访问。
参考模块（RM）： 包含了预期的加法器功能和性能规格，作为验证结果的参照。
检查器（Checker）： 检查仿真结果与参考模块预期结果之间的一致性，以确认验证的正确性。
脚本（Makefile）： 包含了验证流程的自动化脚本，用于编译、运行仿真以及结果分析。&lt;/p&gt;
&lt;p&gt;（2.2）目录结构：&lt;/p&gt;
&lt;p&gt;列出工作目录下所有文件及文件的概要。&lt;/p&gt;
&lt;p&gt;（2.3）主要文件说明：&lt;/p&gt;
&lt;p&gt;对工作目录中重要文件进行补充说明。&lt;/p&gt;
&lt;h2 id=&#34;3-覆盖率分析&#34;&gt;3. 覆盖率分析&lt;/h2&gt;
&lt;p&gt;3.1 什么是覆盖率分析&lt;/p&gt;
&lt;p&gt;覆盖率分析是软件开发和测试过程中的一种质量评估技术，用于衡量测试对软件代码或功能的覆盖程度。它主要分为两个方面：代码覆盖率分析和功能覆盖率分析。&lt;/p&gt;
&lt;p&gt;（1）代码覆盖率分析：&lt;/p&gt;
&lt;p&gt;代码覆盖率分析关注的是测试用例对软件代码的覆盖程度。它衡量了测试用例执行过程中究竟有多少代码被执行到，以及这些代码中的哪些部分被执行。代码覆盖率分析通常包括语句覆盖率（Statement Coverage）、分支覆盖率（Branch Coverage）、条件覆盖率（Condition Coverage）和路径覆盖率（Path Coverage）等指标。&lt;/p&gt;
&lt;p&gt;（2）功能覆盖率分析：&lt;/p&gt;
&lt;p&gt;功能覆盖率分析关注的是测试用例对软件功能的覆盖程度。它衡量了测试用例是否覆盖了软件规格中定义的各项功能需求。功能覆盖率分析通常包括输入空间覆盖率（Input Space Coverage）、功能操作覆盖率（Functional Operation Coverage）、错误处理覆盖率（Error Handling Coverage）等指标。
覆盖率分析通过分析测试用例的执行情况，可以帮助评估测试的全面性和有效性。较高的覆盖率通常意味着测试用例对软件的覆盖程度更高，从而提高了软件的质量和可靠性。覆盖率分析结果也可以指导测试用例的设计和调整，以进一步提高测试的效率和完整性。&lt;/p&gt;
&lt;p&gt;3.2 举例说明&lt;/p&gt;
&lt;p&gt;以加法器功能验证为例，本块内容应该至少描述清楚以下内容：&lt;/p&gt;
&lt;p&gt;（1）代码覆盖率分析：&lt;/p&gt;
&lt;p&gt;代码覆盖率分析用于评估测试是否覆盖了设计代码中的各个部分和逻辑路径。对于加法器的验证，代码覆盖率分析可以通过以下方式进行：&lt;/p&gt;
&lt;p&gt;语句覆盖率： 确保测试覆盖了加法器设计代码中的所有语句和指令，以验证代码的执行路径。
分支覆盖率： 确保测试覆盖了加法器设计代码中的所有条件分支和控制流程，以验证不同条件下的执行路径。
条件覆盖率： 确保测试覆盖了加法器设计代码中的所有条件表达式的各种可能取值，以验证条件判断的正确性。
路径覆盖率： 确保测试覆盖了加法器设计代码中的所有可能执行路径，以验证代码的完整性和正确性。&lt;/p&gt;
&lt;p&gt;（2）功能覆盖率分析：&lt;/p&gt;
&lt;p&gt;功能覆盖率分析旨在评估测试是否涵盖了设计规格中定义的各项功能要求。对于加法器的验证，功能覆盖率可以通过以下方式进行分析和优化：&lt;/p&gt;
&lt;p&gt;输入空间覆盖率： 确保测试覆盖了所有可能的输入组合，包括边界情况和特殊情况（如进位、溢出）。
功能操作覆盖率： 确保测试覆盖了加法器所有可能的操作模式和功能特性，如单次加法、多次连续加法、不同数据宽度下的加法等。
错误处理覆盖率： 确保测试覆盖了加法器对异常情况的处理，如无效输入、非法操作等，以验证其错误处理能力和容错性。&lt;/p&gt;
&lt;h2 id=&#34;4-未解决bug列表或待改进方案&#34;&gt;4. 未解决Bug列表或待改进方案&lt;/h2&gt;
&lt;p&gt;4.1 什么是未解决Bug列表或待改进方案&lt;/p&gt;
&lt;p&gt;在芯片验证过程中，未解决Bug列表或待改进方案是一个关键的文档，用于跟踪和记录在验证过程中发现的问题和改进点。该列表通常由验证团队维护，并在整个验证过程中进行更新和追踪。&lt;/p&gt;
&lt;p&gt;内容包括但不限于以下方面：&lt;/p&gt;
&lt;p&gt;（1）Bug描述： 每个Bug或待改进方案应该清晰地描述问题的性质、出现的条件、预期行为和实际行为之间的差异。&lt;/p&gt;
&lt;p&gt;（2）Bug优先级： 每个Bug应该根据其对验证工作的影响和紧迫程度确定优先级，以帮助团队优先处理关键问题。&lt;/p&gt;
&lt;p&gt;（3）Bug状态： 每个Bug应该有一个明确定义的状态，如“已确认”、“正在修复”、“待验证”、“已关闭”等，以跟踪Bug的处理进度。&lt;/p&gt;
&lt;p&gt;（4）Bug责任人： 每个Bug应指定一个责任人负责跟进和解决，确保问题得到及时处理。&lt;/p&gt;
&lt;p&gt;（5）Bug跟踪编号： 每个Bug应有一个唯一的标识符，便于跟踪和引用，通常使用Bug跟踪系统中提供的编号。&lt;/p&gt;
&lt;p&gt;4.2 举例说明&lt;/p&gt;
&lt;p&gt;Bug编号	    Bug描述	                                优先级	    状态	     责任人
BUG-001	    加法器对于带有进位的加法操作结果错误	     高	      待修复	    小明
BUG-002	    加法器在32位输入时出现性能下降              中	      正在修复      小红
BUG-003	    加法器在处理负数输入时产生异常结果	         低	      已确认	    小刚
BUG-004	    加法器在高速时钟下出现时序问题	             高	      待验证	    小亮&lt;/p&gt;
&lt;h2 id=&#34;7-验证结论&#34;&gt;7. 验证结论&lt;/h2&gt;
&lt;p&gt;验证结论是在完成芯片验证过程后得出的最终结论，用于总结验证工作的结果并对验证对象的状态进行评估和描述。此处需要明确覆盖率具体指标等内容。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
