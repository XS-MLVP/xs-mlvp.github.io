<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bitmap on 万众一芯之香山处理器</title>
    <link>https://open-verify.cc/UnityChipForXiangShan/tags/bitmap/</link>
    <description>Recent content in Bitmap on 万众一芯之香山处理器</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/UnityChipForXiangShan/tags/bitmap/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bitmap Checker</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/modules/00_bm_checker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/modules/00_bm_checker/</guid>
      <description>&lt;h1 id=&#34;bitmap-checker硬件模块&#34;&gt;Bitmap Checker硬件模块&lt;/h1&gt;&#xA;&lt;h2 id=&#34;bitmap-checker简介&#34;&gt;Bitmap checker简介&lt;/h2&gt;&#xA;&lt;p&gt;Bitmap checker 的作用是将来自外部（ptw/lptw/hptw）的请求发送至cache，并根据是否命中进行内存访问查权限。最后将cache返回的或者内存访问得到的权限发送回请求源。&lt;/p&gt;&#xA;&lt;p&gt;此外，bitmap（walker）支持non blocking 特性，每一个请求来源都有FSM负责录入请求进行处理。但是一次只能有一个fsm进行cache访问。&lt;/p&gt;&#xA;&lt;h2 id=&#34;状态机描述&#34;&gt;状态机描述&lt;/h2&gt;&#xA;&lt;p&gt;为了保持non blocking，有8个独立的状态机（entries）并行运行。每个 entry 维护独立的状态和数据处理。当有请求进入时，从下到上依次将fsm填满，由于总共就8个请求来源，因此不会出现无空闲fsm可用的情况。&lt;/p&gt;&#xA;&lt;p&gt;当entry的PA重复时，仅有一个fsm会进行一次查cache 或者访问memory，其余重复fsm项的状态会被部分跳过。重复表示PA的tag位[47:18] 一致。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;PA&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;段&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;tag&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;Bitmap offset&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;Page offset&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;位&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;[47:18]&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;[17:12]&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;[11:0]&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h4 id=&#34;bitmap-checker-模块状态机&#34;&gt;Bitmap checker 模块状态机&lt;/h4&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../modul00_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;状态机状态&#34;&gt;状态机状态&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;状态&lt;/th&gt;&#xA;          &lt;th&gt;说明&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;state_idle&lt;/td&gt;&#xA;          &lt;td&gt;标明该fsm状态为空，可以录入新请求&lt;br/&gt;当io.req.fire时，切换到新状态&lt;br/&gt;转换条件：&lt;br/&gt;&lt;ul&gt;&lt;li&gt;io.req.fire → state_addr_check (无重复请求)&lt;/li&gt;&lt;li&gt;io.req.fire &amp;amp;&amp;amp; to_wait → state_mem_waiting (检测到重复请求在等待) 同时写入重复项的id到fsm&lt;/li&gt;&lt;li&gt;io.req.fire &amp;amp;&amp;amp; to_mem_out → state_mem_out (重复请求已完成) 同时写入重复项的id到fsm&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;state_addr_check&lt;/td&gt;&#xA;          &lt;td&gt;进行pmp检查&lt;br/&gt;转换条件：&lt;br/&gt;&lt;ul&gt;&lt;li&gt;accessFault=true → state_mem_out (检查失败)&lt;/li&gt;&lt;li&gt;accessFault=false → state_cache_req (检查通过)&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;state_cache_req&lt;/td&gt;&#xA;          &lt;td&gt;将cachereq拉高，fire后→ state_cache_resp&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;state_cache_resp&lt;/td&gt;&#xA;          &lt;td&gt;Cache resp fire后更新：&lt;ul&gt;&lt;li&gt;hit=true → state_mem_out (缓存命中)&lt;/li&gt;&lt;li&gt;hit=false &amp;amp;&amp;amp; cm_to_mem_out → state_mem_out (重复请求已完成) 同时写入重复项的id到fsm&lt;/li&gt;&lt;li&gt;hit=false &amp;amp;&amp;amp; cm_to_wait → state_mem_waiting (检测到重复请求) 同时写入重复项的id到fsm&lt;/li&gt;&lt;li&gt;hit=false → state_mem_req (无重复请求) &lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;state_mem_req&lt;/td&gt;&#xA;          &lt;td&gt;拉高valid 并等待，mem req fire时，将所有重复项目的id跟新为本fsm id，并将所有重复和本机 state 设置为mem wait&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;state_mem_waiting&lt;/td&gt;&#xA;          &lt;td&gt;Fire时→state_mem_out，并将所有的符合id项目内值全部跟新为mem返回值&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;state_mem_out&lt;/td&gt;&#xA;          &lt;td&gt;拉高 resp valid ，fire时→ state_idle&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;接口信号&#34;&gt;接口信号&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;信号&lt;/th&gt;&#xA;          &lt;th&gt;位宽&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Io.mem&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;内存访问相关信号&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.mem.resp.bits.id&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;memory 响应返回的 ID(需为bitmap编号)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.mem.resp.bits.value&lt;/td&gt;&#xA;          &lt;td&gt;512&lt;/td&gt;&#xA;          &lt;td&gt;memory 返回的 bitmap 数据块&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.mem.req_mask&lt;/td&gt;&#xA;          &lt;td&gt;20&lt;/td&gt;&#xA;          &lt;td&gt;Memory 请求屏蔽位&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.mem.req.bits.addr&lt;/td&gt;&#xA;          &lt;td&gt;56&lt;/td&gt;&#xA;          &lt;td&gt;memory 请求的 bitmap 数据地址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.mem.req.bits.id&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;memory 请求的编号(恒定为bitmap编号)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.mem.req.bits.hptw_bypassed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Io.Req&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;请求信号&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.req.bits.bmppn&lt;/td&gt;&#xA;          &lt;td&gt;27&lt;/td&gt;&#xA;          &lt;td&gt;被检查的物理页号 PPN&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.req.bits.id&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;请求编号，用于标识请求来源（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.req.bits.vpn&lt;/td&gt;&#xA;          &lt;td&gt;27&lt;/td&gt;&#xA;          &lt;td&gt;对应虚拟页号VPN&lt;/font&gt;，用于唤醒&lt;/font&gt;pagecache&lt;/font&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.req.bits.level&lt;/td&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;所查询页表的级别信息（&lt;/font&gt;0/1/2&lt;/font&gt;），用于唤醒&lt;/font&gt;pagecache&lt;/font&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.req.bits.way_info&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;TLB way &lt;/font&gt;编号用于唤醒&lt;/font&gt;pagecache&lt;/font&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.req.bits.hptw_bypassed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;用于唤醒&lt;/font&gt;pagecache&lt;/font&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Io.resp&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;返回结果&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.resp.bits.cf&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;检查权限是否允许访问&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.resp.bits.cfs&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;相邻8个（3bit地址空间）的权限&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.resp.bits.id&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;响应对应的请求id&lt;/font&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Io.pmp&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;Pmp&lt;/font&gt;查&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.pmp.req.bits.addr&lt;/td&gt;&#xA;          &lt;td&gt;56&lt;/td&gt;&#xA;          &lt;td&gt;进行PMP检查的物理地址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.pmp.req.bits.cmd&lt;/td&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;读/写权限请求类型（恒定为读）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.pmp.req.bits.size&lt;/td&gt;&#xA;          &lt;td&gt;3&lt;/td&gt;&#xA;          &lt;td&gt;请求访问大小（恒定）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.pmp.resp.ld&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;PMP Load 权限检查结果&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.pmp.resp.mmio&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;PMP MMIO 检查结果&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Io.wakeup&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;Resp&lt;/font&gt;时且非&lt;/font&gt;hptw bypassed &lt;/font&gt;进行重填pagecache&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.wakeup.bits.setIndex&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;唤醒用的setIndex&lt;/font&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.wakeup.bits.tag&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;唤醒tag&lt;/font&gt;（&lt;/font&gt;VPN&lt;/font&gt;高位）（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.wakeup.bits.isSp&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;是否为&lt;/font&gt;superpage&lt;/font&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.wakeup.bits.way_info&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;TLB&lt;/font&gt;对应的way &lt;/font&gt;信息（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.wakeup.bits.pte_index&lt;/td&gt;&#xA;          &lt;td&gt;6&lt;/td&gt;&#xA;          &lt;td&gt;PTE &lt;/font&gt;在段页表中的索引位置（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.wakeup.bits.check_success&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;是否 bitmap 检查通过&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Refill&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.refill.bits.data&lt;/td&gt;&#xA;          &lt;td&gt;64&lt;/td&gt;&#xA;          &lt;td&gt;要写入cache &lt;/font&gt;的bitmap &lt;/font&gt;数据&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CSR&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_sfence_valid&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;SFENCE &lt;/font&gt;操作有效信号（为高刷新&lt;/font&gt;fsm&lt;/font&gt;）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_satp_changed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;SATP &lt;/font&gt;寄存器变更标志（为高刷新&lt;/font&gt;fsm&lt;/font&gt;）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_vsatp_changed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;VSATP &lt;/font&gt;寄存器变更标志（为高刷新&lt;/font&gt;fsm&lt;/font&gt;）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_hgatp_changed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;HGATP &lt;/font&gt;寄存器变更标志（为高刷新&lt;/font&gt;fsm&lt;/font&gt;）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_mbmc_BMA&lt;/td&gt;&#xA;          &lt;td&gt;58&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap &lt;/font&gt;基址寄存器值&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>Shield-XS Bitmap 基础知识</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/basic/</guid>
      <description>&lt;p&gt;本节将介绍 bitmap 的一些基础知识，有助于理解为什么我们需要 bitmap，本节包含：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;背景描述&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;威胁模型&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;防御原理&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;工作流程&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;术语描述&#34;&gt;术语描述&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;缩写&lt;/th&gt;&#xA;          &lt;th&gt;全名&lt;/th&gt;&#xA;          &lt;th&gt;含义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TCB&lt;/td&gt;&#xA;          &lt;td&gt;Trusted Computing Base&lt;/td&gt;&#xA;          &lt;td&gt;可信计算基，负责底层硬件的安全可信操作&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TEE&lt;/td&gt;&#xA;          &lt;td&gt;Trusted Execution Environment&lt;/td&gt;&#xA;          &lt;td&gt;可信执行环境&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;MMU&lt;/td&gt;&#xA;          &lt;td&gt;Memory Management Unit&lt;/td&gt;&#xA;          &lt;td&gt;内存管理单元&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;RDSM&lt;/td&gt;&#xA;          &lt;td&gt;Root Domain Security Mananger&lt;/td&gt;&#xA;          &lt;td&gt;根域权限管理器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;C-SDSM&lt;/td&gt;&#xA;          &lt;td&gt;Confidencial Supervisor Domain Security Manager&lt;/td&gt;&#xA;          &lt;td&gt;可信监督域 权限管理器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;APLIC&lt;/td&gt;&#xA;          &lt;td&gt;advanced platform level interrupt controller&lt;/td&gt;&#xA;          &lt;td&gt;平台级中断控制器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;LLC&lt;/td&gt;&#xA;          &lt;td&gt;Last Lavel Cache&lt;/td&gt;&#xA;          &lt;td&gt;末级缓存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;DMA&lt;/td&gt;&#xA;          &lt;td&gt;Direct Memory Access&lt;/td&gt;&#xA;          &lt;td&gt;直接内存访问&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CVM&lt;/td&gt;&#xA;          &lt;td&gt;Confidencial Virtual Machine&lt;/td&gt;&#xA;          &lt;td&gt;可信虚拟机&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TLB&lt;/td&gt;&#xA;          &lt;td&gt;Translation Lookaside Buffer&lt;/td&gt;&#xA;          &lt;td&gt;页表缓存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;MBMC&lt;/td&gt;&#xA;          &lt;td&gt;machine level bitmap check&lt;/td&gt;&#xA;          &lt;td&gt;bitmap CSR 特殊状态寄存器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BMA&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap Adress&lt;/td&gt;&#xA;          &lt;td&gt;Shield Bitmap 专属内存区域基地址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CMODE&lt;/td&gt;&#xA;          &lt;td&gt;Confidencial Mode&lt;/td&gt;&#xA;          &lt;td&gt;开启bitmap后当前模式是否是可信&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BME&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap Enable&lt;/td&gt;&#xA;          &lt;td&gt;是否开启 Bitmap&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;PTW&lt;/td&gt;&#xA;          &lt;td&gt;Page Table Walker&lt;/td&gt;&#xA;          &lt;td&gt;页表遍历器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;HPTW&lt;/td&gt;&#xA;          &lt;td&gt;Hypervisor PTW&lt;/td&gt;&#xA;          &lt;td&gt;监督域页表遍历器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;LLPTW&lt;/td&gt;&#xA;          &lt;td&gt;Last Level PTW&lt;/td&gt;&#xA;          &lt;td&gt;末级页表遍历器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>背景描述</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/basic/00_bm_background/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/basic/00_bm_background/</guid>
      <description>&lt;h2 id=&#34;背景描述&#34;&gt;背景描述&lt;/h2&gt;&#xA;&lt;p&gt;自计算机问世以来，数据安全始终是至关重要的议题。在个人计算机时代，数据安全主要集中在单机硬盘等存储设备的安全性上。随着互联网时代的到来，数据安全的范畴扩展到了计算机之间数据传输的安全性，促使了安全传输协议的设计与发展。如今，在云计算时代，用户的大量数据被存储和处理在云端。在云环境中存储、共享和计算的数据面临着多重安全威胁。在云计算环境下，不同类型的负载面临各自的威胁模型包括但不限于：&lt;/p&gt;&#xA;&lt;p&gt;计算型负载：恶意软件可能侵入操作系统或固件，攻击 CPU 和内存资源，导致数据泄露或系统性能下降。&lt;/p&gt;&#xA;&lt;p&gt;内存型负载：恶意软件或进程可能试图访问内存型负载使用的内存区域，导致数据泄露或篡改。&lt;/p&gt;&#xA;&lt;p&gt;存储型负载：存储设备及其 DMA 功能可能被攻击者利用，直接访问或篡改存储设备内存，绕过传统安全检查。&lt;/p&gt;&#xA;&lt;p&gt;网络型负载：网络攻击可能利用网络接口控制器（NIC）等网络设备漏洞入侵系统，通过 DMA 功能访问或篡改内存中的敏感数据。&lt;/p&gt;&#xA;&lt;h4 id=&#34;不同工作负载面临的安全威胁&#34;&gt;不同工作负载面临的安全威胁&lt;/h4&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../basic00_1.png&#34; alt=&#34;不同工作负载面临的安全威胁&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;威胁模型&#34;&gt;威胁模型&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;类别&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;安全准则&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;内存分配&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;动态分配安全/非安全内存的能力&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;安全内存应根据需求动态分配或释放。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;内存机密性&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;内存隔离&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;防止非可信计算基（non-TCB）组件读取可信执行环境（TEE）的内存。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;抵御软件攻击的内存完整性&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;防止软件攻击（如内存重映射、别名攻击、重放攻击、数据破坏等）。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;共享内存&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;TEE控制与非TCB组件的数据共享&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;防止非TCB代码在未经TEE同意的情况下泄露信息。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;TEE控制与其他TEE的数据共DUT 享&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;支持TEE之间安全共享内存的能力。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;I/O保护&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;防止非TCB设备通过DMA访问TEE内存&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;禁止未被TCB接纳的外设设备访问TEE内存。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;来自TCB内设备的可信I/O&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;通过准入控制将设备绑定到TEE。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>单元验证</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/verification/00_bm_verification/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/verification/00_bm_verification/</guid>
      <description>&lt;h2 id=&#34;单元验证&#34;&gt;单元验证&lt;/h2&gt;&#xA;&lt;h3 id=&#34;tlb-相关功能验证&#34;&gt;TLB 相关功能验证&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;验证功能编号&lt;/th&gt;&#xA;          &lt;th&gt;验证描述&lt;/th&gt;&#xA;          &lt;th&gt;覆盖方法&lt;/th&gt;&#xA;          &lt;th&gt;排列组合示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TLB_001&lt;/td&gt;&#xA;          &lt;td&gt;ITLB hit/miss 场景验证&lt;/td&gt;&#xA;          &lt;td&gt;设计测试用例覆盖 ITLB 命中和未命中&lt;/td&gt;&#xA;          &lt;td&gt;4K/2M/1G/512G 页大小&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TLB_002&lt;/td&gt;&#xA;          &lt;td&gt;DTLB hit/miss 场景验证&lt;/td&gt;&#xA;          &lt;td&gt;设计测试用例覆盖 DTLB 命中和未命中&lt;/td&gt;&#xA;          &lt;td&gt;4K/2M/1G/512G 页大小&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TLB_003&lt;/td&gt;&#xA;          &lt;td&gt;L2TLB hit/miss 场景验证&lt;/td&gt;&#xA;          &lt;td&gt;设计测试用例覆盖 L2TLB 命中和替换&lt;/td&gt;&#xA;          &lt;td&gt;4K/2M/1G/512G 页大小&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TLB_004&lt;/td&gt;&#xA;          &lt;td&gt;L2TLB 压缩功能验证&lt;br/&gt;注：仅支持一阶段地址转换压缩，最多压缩8项&lt;/td&gt;&#xA;          &lt;td&gt;测试TLB 压缩场景下，Bitmap 查询结果是否正确&lt;/td&gt;&#xA;          &lt;td&gt;TLB 压缩启用 + 4K 页大小&lt;br/&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;bitmap-cache-相关功能验证&#34;&gt;Bitmap Cache 相关功能验证&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;验证功能编号&lt;/th&gt;&#xA;          &lt;th&gt;验证描述&lt;/th&gt;&#xA;          &lt;th&gt;覆盖方法&lt;/th&gt;&#xA;          &lt;th&gt;排列组合示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BITMAP_001&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap Cache hit/miss 场景验证&lt;/td&gt;&#xA;          &lt;td&gt;设计测试用例覆盖命中和未命中&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap Y/N + 跨bitmap cache line&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BITMAP_002&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap check 功能验证&lt;/td&gt;&#xA;          &lt;td&gt;验证 bitmap check 的正确性&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap check 启用 + 4K 页大小&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BITMAP_003&lt;/td&gt;&#xA;          &lt;td&gt;跨bitmap cache line 场景验证&lt;/td&gt;&#xA;          &lt;td&gt;测试跨 cache line 的访问行为&lt;/td&gt;&#xA;          &lt;td&gt;跨bitmap cache line + 2M 页大小&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BITMAP_004&lt;/td&gt;&#xA;          &lt;td&gt;NAPOT 拓展开启，验证Bitmap 的行为&lt;/td&gt;&#xA;          &lt;td&gt;开启NAPOT，设置PTE.n 位，验证Bitmap 检测流程&lt;/td&gt;&#xA;          &lt;td&gt;跨bitmap cache line + 64K 页大小切换PTE.n 位&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;bitmap-cache-和-tlb-组合相关功能验证&#34;&gt;Bitmap Cache 和 TLB 组合相关功能验证&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;验证功能编号&lt;/th&gt;&#xA;          &lt;th&gt;验证描述&lt;/th&gt;&#xA;          &lt;th&gt;覆盖方法&lt;/th&gt;&#xA;          &lt;th&gt;排列组合示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;TLB_BITMAP_001&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap与TLB混合命中场景验证&lt;/td&gt;&#xA;          &lt;td&gt;组合Bitmap命中与各级TLB命中，验证多级缓存协同&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap hit + ITLB/DTLB/L2TLB全命中&lt;br/&gt;&lt;br/&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;TLB_BITMAP_002&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;全未命中极端场景验证&lt;/td&gt;&#xA;          &lt;td&gt;设计冷启动或冲刷缓存后首次访问的全未命中用例&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap miss + ITLB/DTLB/L2TLB全miss + 触发页表遍历&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;TLB_BITMAP_003&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap跨行与TLB替换场景验证&lt;/td&gt;&#xA;          &lt;td&gt;强制Bitmap跨cache line访问并触发TLB替换（如duplicate access或页表更新）&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap跨行 + DTLB miss + L2TLB替换&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;TLB_BITMAP_004&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;重复访问与Cache/TLB交互验证&lt;/td&gt;&#xA;          &lt;td&gt;通过相同地址重复访问验证Bitmap/TLB的重复访问优化&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap重复命中 + ITLB重复命中 + 无替换&lt;br/&gt;Bitmap重复Miss + ITLB重复Miss + 替换&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;页表遍历ptw相关功能验证&#34;&gt;页表遍历（PTW）相关功能验证&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;验证功能编号&lt;/th&gt;&#xA;          &lt;th&gt;验证描述&lt;/th&gt;&#xA;          &lt;th&gt;覆盖方法&lt;/th&gt;&#xA;          &lt;th&gt;排列组合示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;PTW_001&lt;/td&gt;&#xA;          &lt;td&gt;PTW/HPTW/LLPTW 优先级验证&lt;/td&gt;&#xA;          &lt;td&gt;测试多级页表遍历的优先级&lt;/td&gt;&#xA;          &lt;td&gt;PTW + HPTW 并发&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;PTW_002&lt;/td&gt;&#xA;          &lt;td&gt;PTW 返回异常（access fault）验证&lt;/td&gt;&#xA;          &lt;td&gt;模拟 PTW 返回异常的场景&lt;/td&gt;&#xA;          &lt;td&gt;PTW return af + 跨Page&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;PTW_003&lt;/td&gt;&#xA;          &lt;td&gt;PTE 合法性验证&lt;/td&gt;&#xA;          &lt;td&gt;测试非法 PTE 的处理&lt;/td&gt;&#xA;          &lt;td&gt;非法 PTE + PMP check&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;异常与重放replay功能验证&#34;&gt;异常与重放（Replay）功能验证&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;验证功能编号&lt;/th&gt;&#xA;          &lt;th&gt;验证描述&lt;/th&gt;&#xA;          &lt;th&gt;覆盖方法&lt;/th&gt;&#xA;          &lt;th&gt;排列组合示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;REPLAY_001&lt;/td&gt;&#xA;          &lt;td&gt;标量 replay 场景验证&lt;/td&gt;&#xA;          &lt;td&gt;测试标量指令重放行为&lt;/td&gt;&#xA;          &lt;td&gt;标量 replay + access fault&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;REPLAY_002&lt;/td&gt;&#xA;          &lt;td&gt;向量访存 replay 场景验证&lt;/td&gt;&#xA;          &lt;td&gt;测试向量指令重放行为&lt;/td&gt;&#xA;          &lt;td&gt;向量 replay + 跨MMO&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;EXCEPT_001&lt;/td&gt;&#xA;          &lt;td&gt;异常优先级验证（access/page fault/guest page fault）&lt;/td&gt;&#xA;          &lt;td&gt;验证异常触发的优先级&lt;/td&gt;&#xA;          &lt;td&gt;page fault/guest page fault&lt;br/&gt;page table walker 过程中的PMP/bitmap 检测失败&lt;br/&gt;转换之后的物理地址PMP 检测失败&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;特权级与扩展功能验证&#34;&gt;特权级与扩展功能验证&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;验证功能编号&lt;/th&gt;&#xA;          &lt;th&gt;验证描述&lt;/th&gt;&#xA;          &lt;th&gt;覆盖方法&lt;/th&gt;&#xA;          &lt;th&gt;排列组合示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;PRIV_001&lt;/td&gt;&#xA;          &lt;td&gt;U/S/M 特权级切换验证&lt;/td&gt;&#xA;          &lt;td&gt;测试不同特权级下的访问权限&lt;/td&gt;&#xA;          &lt;td&gt;U/S/M + 4K/2M 页大小&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;EXT_001&lt;/td&gt;&#xA;          &lt;td&gt;H-extension 功能验证&lt;/td&gt;&#xA;          &lt;td&gt;测试 H-extension 启用和禁用场景&lt;/td&gt;&#xA;          &lt;td&gt;H-extension + 跨tlb entry&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;PMP_001&lt;/td&gt;&#xA;          &lt;td&gt;PMP check 功能验证&lt;/td&gt;&#xA;          &lt;td&gt;测试bitmap 内PMP 权限检查&lt;/td&gt;&#xA;          &lt;td&gt;PMP Y/N + 跨Page&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;fense验证&#34;&gt;Fense验证&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;验证功能编号&lt;/th&gt;&#xA;          &lt;th&gt;验证描述&lt;/th&gt;&#xA;          &lt;th&gt;覆盖方法&lt;/th&gt;&#xA;          &lt;th&gt;排列组合示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;MISC_001&lt;/td&gt;&#xA;          &lt;td&gt;Fence 操作验证&lt;/td&gt;&#xA;          &lt;td&gt;测试 fence 指令的同步效果&lt;/td&gt;&#xA;          &lt;td&gt;Fence + 切换Cmode&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;验证方法说明&#34;&gt;验证方法说明&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;覆盖方法&lt;/strong&gt;：通过随机测试、定向测试和边界值测试覆盖功能点。&lt;/p&gt;</description>
    </item>
    <item>
      <title>机器模式Bitmap控制状态寄存器</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/feature/00_bm_csr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/feature/00_bm_csr/</guid>
      <description>&lt;h2 id=&#34;机器模式-bitmap控制状态寄存器&#34;&gt;机器模式 Bitmap控制状态寄存器&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基本信息&#34;&gt;基本信息&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;寄存器名称&lt;/th&gt;&#xA;          &lt;th&gt;MBMC（Machine BitMap Control）&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;特权模式&lt;/td&gt;&#xA;          &lt;td&gt;机器模式&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;寄存器编号&lt;/td&gt;&#xA;          &lt;td&gt;0xBC2&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;读写权限&lt;/td&gt;&#xA;          &lt;td&gt;可读可写&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;功能描述&lt;/td&gt;&#xA;          &lt;td&gt;用来控制Shield-bitmap 的使能、同步、Shield-XS Bitmap 基地址等&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;字段描述&#34;&gt;字段描述&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;地址&lt;/th&gt;&#xA;          &lt;th&gt;字段&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;[61:3]&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;strong&gt;BMA (Bitmap Address)&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;Shield-XS Bitmap 基地址指定 Bitmap 数据结构在物理内存中的起始地址。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;CMODE (Current Mode)&lt;/td&gt;&#xA;          &lt;td&gt;表明当前执行模式CMODE = 1，表示安全模式CMODE = 0, 表示非安全模式。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;BCLEAR (Bitmap Clear)&lt;/td&gt;&#xA;          &lt;td&gt;Shield-XS Bitmap 同步位BCLEAR = 1，表示刷新所有Shield-bit 副本。&lt;br/&gt;&lt;strong&gt;注：实际使用过程，可结合HFence 指令&lt;/strong&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;0&lt;/td&gt;&#xA;          &lt;td&gt;BME (Bitmap Enable)&lt;/td&gt;&#xA;          &lt;td&gt;Shield-XS 使能位当 BME 置为 1 时，启用 Bitmap 功能。一旦启用，无法关闭，也无法修改 Bitmap 的基地址。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../feature00_1.png&#34; alt=&#34;Shield-XS Bitmap数据结构&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;shield-xs-bitmap数据结构&#34;&gt;Shield-XS Bitmap数据结构&lt;/h4&gt;&#xA;&lt;p&gt;上图为Shield-XS Bitmap的数据结构，所有的Shield-XS Bitmap权限数据都被存放在一块连续的物理内存区域中。其中基地址是存放Shield-XS Bitmap 数据结构的内存区域的起始物理地址。这个地址可以通过MBMC寄存器中的 BMA字段进行配置。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bitmap Cache</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/modules/01_bm_cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/modules/01_bm_cache/</guid>
      <description>&lt;h3 id=&#34;bitmap-cache硬件模块&#34;&gt;Bitmap Cache硬件模块&lt;/h3&gt;&#xA;&lt;h4 id=&#34;bitmap-cache简介&#34;&gt;Bitmap cache简介&lt;/h4&gt;&#xA;&lt;p&gt;Bitmap cache用于缓存 bitmap 数据块以减少 memory 访问延迟，存储最近访问的 bitmap 数据，&lt;strong&gt;共16个entry。每个 entry 存储一个 64-bit 数据段&lt;/strong&gt;。使用plru替换策略。&lt;/p&gt;&#xA;&lt;h4 id=&#34;bitmap模块结构&#34;&gt;Bitmap模块结构&lt;/h4&gt;&#xA;&lt;p&gt;Cache 一回合出结果，不需要pipeline。此外，refill也只需要一回合。Refill使用plru进行充填。&lt;/p&gt;&#xA;&lt;h4 id=&#34;bitmap-cache接口&#34;&gt;Bitmap cache接口&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;io_req&lt;/th&gt;&#xA;          &lt;th&gt;位宽&lt;/th&gt;&#xA;          &lt;th&gt;Bm 发起请求&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_req_bits_tag&lt;/td&gt;&#xA;          &lt;td&gt;36&lt;/td&gt;&#xA;          &lt;td&gt;Tag for cache lookup ([35:6] = tag)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_req_bits_order&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;发起请求的Fsm编号&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Io resp&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;返回bm请求&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_resp_bits_hit&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;是否hit cache&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_resp_bits_order&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;发起请求的Fsm编号&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_resp_bits_cfs&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;相邻8个的权限&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Io refill&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;Refill接口，来自bm，bm resp valid时发起重填&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_refill_bits_tag&lt;/td&gt;&#xA;          &lt;td&gt;36&lt;/td&gt;&#xA;          &lt;td&gt;Tag for cache refill ([35:6] = tag)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_refill_bits_data&lt;/td&gt;&#xA;          &lt;td&gt;64&lt;/td&gt;&#xA;          &lt;td&gt;Data to refill into cache&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_resp_bits_hit&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;是否hit cache&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CSR&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_sfence_valid&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;同步刷新请求有效（触发缓存刷新）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_satp_changed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;SATP CSR 变更标志（触发缓存刷新）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_vsatp_changed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;VSATP CSR 变更标志（触发缓存刷新）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_hgatp_changed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;HGATP CSR 变更标志（触发缓存刷新）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_mbmc_BCLEAR&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;缓存清除信号（触发缓存刷新）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>Shield-Bitmap Cache</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/feature/01_bm_acceleration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/feature/01_bm_acceleration/</guid>
      <description>&lt;h2 id=&#34;shield-bitmap-cache-性能加速&#34;&gt;Shield-Bitmap Cache 性能加速&lt;/h2&gt;&#xA;&lt;p&gt;当访问一个物理地址 (PA) 时，硬件通过查找 Shield-XS Bitmap 数据结构中对应的位置来确定该页是否具有安全属性。&lt;/p&gt;&#xA;&lt;p&gt;查找安全属性的物理地址计算公式如下：&lt;/p&gt;&#xA;&lt;p&gt;即 &lt;strong&gt;Shield-Bitmap 访问地址 = MBMC.BMA + PA[ XLEN-1 : 12 + log&lt;sub&gt;2&lt;/sub&gt;(XLEN/8) ]&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;随后用选出对应该 4KB 页的权限。如果对应比特位为 1 ，则表示该页具有安全属性，只能被安全敏感型负载访问；如果为 0 ，则表示该页不具有安全属性，可以被非安全敏感型负载访问。&lt;/p&gt;&#xA;&lt;h5 id=&#34;shield-xs-直接从内存中读取安全属性&#34;&gt;Shield-XS 直接从内存中读取安全属性&lt;/h5&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../feature01_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;开启Shield-XS 隔离之后，CPU 内部发起的任何一笔访存操作，都需要对标记安全属性的存储空间发起访问，从内存中获取安全属性的延迟过长，使得系统的性能变差。&lt;/p&gt;&#xA;&lt;p&gt;为了Shield-XS 隔离带来的性能损失，利用了程序的局部性，增加了Shield-Bitmap Cache,&#xA;当任何一笔访存需要获取安全属性时，优先从Shield-Bitmap Cache 中读取，只有Shield-Bitmap Cache Miss时，才会发起访存请求。&lt;/p&gt;&#xA;&lt;h5 id=&#34;shield-xs优先从shield-bitmap-cache中读取安全属性&#34;&gt;Shield-XS优先从Shield-BitMap Cache中读取安全属性&lt;/h5&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../feature01_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Shield-XS Bitmap总体设计</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/feature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/feature/</guid>
      <description>&lt;p&gt;本节介绍bitmap的总体设计，不包括具体的硬件实现，只解释概念，包含：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;机器模式 Bitmap控制状态寄存器&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Shield-Bitmap Cache 加速查表&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;虚拟化两阶段内存地址翻译转换原理&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;加入了Shield-XS安全检查后的内存地址转换流程&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>香山 bitmap 防御原理</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/basic/01_bm_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/basic/01_bm_principle/</guid>
      <description>&lt;h2 id=&#34;防御原理&#34;&gt;防御原理&lt;/h2&gt;&#xA;&lt;p&gt;针对日益复杂的负载的安全威胁，香山轻量动态隔离模型为经典负载机密虚拟机和容器设计了一种动态隔离机制，用来保护正在使用中的数据的机密性和完整性。依据不同的应用场景，将负载从安全的维度进行划分，分为安全敏感型负载和非安全敏感型负载。&lt;/p&gt;&#xA;&lt;p&gt;安全敏感型负载需要运行在可信执行环境下，用来保护正在使用中数据和代码的机密性和完整性。非安全敏感型负载对数据没有安全性保护需求，执行在开放的执行环境下，保证执行的效率。&lt;/p&gt;&#xA;&lt;p&gt;基于bitmap的安全隔离的防御机制，其核心原理是通过可信根在软件层面的标记（Shield-bit）来隔离和保护敏感工作负载（Sensitive Workloads）与普通工作负载（Normal Workloads），从而增强系统的安全性。以下是其防御原理的详细描述：&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-分类与标记&#34;&gt;1. 分类与标记&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;工作负载分类&lt;/strong&gt;：系统将工作负载分为两类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;敏感工作负载（Sensitive Workloads）&lt;/strong&gt;：需要高安全级别的任务，如机密虚拟机、安全容器的任务（隐私数据的访问、处理）等。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;普通工作负载（Normal Workloads）&lt;/strong&gt;：常规任务，代表系统中普通的应用程序或进程，安全要求较低。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;Shield-bit 标记&lt;/strong&gt;：通过 “Shield-bit”（&lt;strong&gt;每比特代表 4KB&lt;/strong&gt;）对敏感工作负载使用的资源进行标记，依据需此标记动态调整资源访问权限：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;Shield-bit = 1&lt;/code&gt; 表示&lt;strong&gt;安全敏感资源&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;Shield-bit = 0&lt;/code&gt; 表示&lt;strong&gt;非安全敏感资源&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-资源隔离&#34;&gt;2. 资源隔离&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;资源池划分&lt;/strong&gt;：&lt;a href=&#34;https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/basic/01_bm_principle/#light_model_img&#34;&gt;图中&lt;/a&gt;显示资源池中包含混合的敏感和普通工作负载，但通过 Shield-bit 实现逻辑隔离。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;资源类型保护&lt;/strong&gt;：敏感工作负载访问特定资源（如内存、IO设备、中断等）时，Shield-bit 会触发保护机制，防止普通工作负载或恶意程序越权访问。例如：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;内存隔离&lt;/strong&gt;：敏感数据的内存区域仅对标记为敏感的工作负载可访问。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;设备与中断保护&lt;/strong&gt;：关键外设或中断仅允许敏感工作负载调用。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;3-bypass-机制&#34;&gt;3. Bypass 机制&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;Bypass Shield-bit&lt;/strong&gt;：在单向隔离的情况下（仅对普通负载的资源访问作限制），安全敏感负载可绕过 Shield-bit 的机制直接访问资源提升性能。&lt;/p&gt;&#xA;&lt;h3 id=&#34;4-防御目标&#34;&gt;4. 防御目标&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;防止横向渗透&lt;/strong&gt;：攻击者通过普通工作负载漏洞无法访问敏感资源。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;最小权限原则&lt;/strong&gt;：每个工作负载仅能访问其必需的资源，降低攻击面。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;动态安全调整&lt;/strong&gt;：根据工作负载的敏感程度动态切换保护状态。&lt;/p&gt;&#xA;&lt;h3 id=&#34;5-技术实现&#34;&gt;5. 技术实现&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;硬件支持&lt;/strong&gt;：依赖内存管理单元（MMU）的扩展功能。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;软件协同&lt;/strong&gt;：由可信计算基负责标记管理和资源调度。&lt;/p&gt;&#xA;&lt;span id=&#34;light_model_img&#34;/&gt;&#xA;&lt;h4 id=&#34;香山shield-xs-轻量隔离模型&#34;&gt;香山Shield-XS 轻量隔离模型&lt;/h4&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../basic01_1.png&#34; alt=&#34;香山Shield-XS 轻量隔离模型&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;6-核心工作流程&#34;&gt;6. 核心工作流程&lt;/h3&gt;&#xA;&lt;h4 id=&#34;shield-xs-隔离模型工作流程&#34;&gt;Shield-XS 隔离模型工作流程&lt;/h4&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../basic01_2.png&#34; alt=&#34;Shield-XS 隔离模型工作流程&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;A. 启动&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;系统初始化，加载固件（Firmware TCB）和可信执行环境（TEE TCB）。&lt;/p&gt;&#xA;&lt;p&gt;开启Bitmap安全检测功能。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;B. 配置&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;设定安全策略，例如定义受保护资源（内存、IO、中断等）访问权限。&lt;/p&gt;&#xA;&lt;p&gt;TEE-TCB 依据应用需求配置不同资源的安全/非安全属性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bitmap 与L2TLB交互</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/modules/02_bm_l2tlb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/modules/02_bm_l2tlb/</guid>
      <description>&lt;h3 id=&#34;bitmap-与l2tlb内的交互&#34;&gt;Bitmap 与L2TLB内的交互&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../module02_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;page-cache-与-bitmap-检测机制的交互&#34;&gt;Page Cache 与 Bitmap 检测机制的交互&lt;/h4&gt;&#xA;&lt;h5 id=&#34;新增信号&#34;&gt;新增信号&lt;/h5&gt;&#xA;&lt;p&gt;发向 PTW 的 bitmap check 信号：用于触发 PTW 进行 bitmap 检测。&lt;/p&gt;&#xA;&lt;p&gt;发向 HPTW 的 bitmap check 信号：用于触发 HPTW 进行 bitmap 检测。&lt;/p&gt;&#xA;&lt;p&gt;接收来自 bitmap 的重填信号（bitmap wakeup）：用于接收 bitmap 检测结果并更新缓存。&lt;/p&gt;&#xA;&lt;h5 id=&#34;bitmap-wakeup接口-refill-bitmap&#34;&gt;Bitmap Wakeup接口: refill bitmap&lt;/h5&gt;&#xA;&lt;p&gt;功能描述：当接收到 wake up valid 信号时，将 check_success 结果写入对应的 sp 或 l0 的 cache bitmap reg 中。&lt;/p&gt;&#xA;&lt;p&gt;工作原理：cache bitmap reg 用于标识缓存项是否通过 bitmap 检测。值为 1 表示已通过检测；值为 0 表示检测未通过或尚未检测。如果发现 PtwCache 命中的表项未通过检测，则触发 Bitmap 检测流程，并通过 bitmap wakeup 更新缓存项。此外，在走表过程中所有bitmap返回的项都会回填page cache。&lt;/p&gt;</description>
    </item>
    <item>
      <title>bitmap的工作流程</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/basic/02_bm_workflow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/basic/02_bm_workflow/</guid>
      <description>&lt;h2 id=&#34;bitmap的工作流程是怎样的&#34;&gt;bitmap的工作流程是怎样的？&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../basic02_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-识别负载类型&#34;&gt;1. 识别负载类型&lt;/h3&gt;&#xA;&lt;p&gt;根据应用场景和安全需求，将负载分为安全敏感型负载和非安全敏感型负载：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;安全敏感型负载&lt;/strong&gt;：需要在可信执行环境中运行，以保护数据和代码的机密性和完整性。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;非安全敏感型负载&lt;/strong&gt;：可以在开放的执行环境中运行，主要关注执行效率。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-设置隔离属性&#34;&gt;2. 设置隔离属性&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;定义隔离属性&lt;/strong&gt;：为不同类型负载设置隔离属性，包括单向隔离和双向隔离。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;单向隔离&lt;/strong&gt;：允许安全敏感型负载访问非安全敏感型负载的资源，但不允许反向访问。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;双向隔离&lt;/strong&gt;：安全敏感型负载和非安全敏感型负载之间互相不能访问对方的资源。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;3-划分资源池&#34;&gt;3. 划分资源池&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;划分物理内存资源&lt;/strong&gt;：将物理内存划分为不同的资源池以支持不同负载的隔离需求。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;安全资源池&lt;/strong&gt;：分配给安全敏感型负载。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;非安全资源池&lt;/strong&gt;：分配给非安全敏感型负载。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;4-配置安全属性&#34;&gt;4. 配置安全属性&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;设置内存页安全状态&lt;/strong&gt;：使用Bitmap数据结构标记每个物理内存页的安全状态。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;安全页&lt;/strong&gt;：标记为1，表示该页属于安全资源池。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;非安全页&lt;/strong&gt;：标记为0，表示该页属于非安全资源池。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;5-动态分配资源&#34;&gt;5. 动态分配资源&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;按需分配内存&lt;/strong&gt;：根据负载的启动和运行时需求，动态分配相应的内存资源。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;安全敏感型负载&lt;/strong&gt;：从安全资源池分配内存，并确保其访问受限于安全页。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;非安全敏感型负载&lt;/strong&gt;：从非安全资源池分配内存，允许其访问非安全页。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;6-隔离检测判断&#34;&gt;6. 隔离检测判断&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;判断隔离类型&lt;/strong&gt;：判断当前负载是否需要单向隔离或者双向隔离。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;单向隔离&lt;/strong&gt;：仅对非安全敏感型负载进行安全性检测，确保其不访问安全资源。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;双向隔离&lt;/strong&gt;：对所有负载类型进行隔离检测，确保不同负载之间互不干扰。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;7-安全性检测&#34;&gt;7. 安全性检测&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;执行访问控制检查&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于单向隔离情况，检查非安全敏感型负载是否试图访问安全资源。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于双向隔离情况，检查所有负载类型是否试图越界访问其他类型的资源。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;8-动态回收资源&#34;&gt;8. 动态回收资源&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;释放不再使用的资源&lt;/strong&gt;：负载执行完毕后，其占用的内存资源被回收并返回到相应的资源池中，以便后续其他负载的使用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Shield-XS Bitmap 硬件设计</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/modules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/modules/</guid>
      <description>&lt;h2 id=&#34;shield-xs-bitmap-硬件设计&#34;&gt;Shield-XS Bitmap 硬件设计&lt;/h2&gt;&#xA;&lt;p&gt;在硬件实现层面，Bitmap 机制由两个关键组件构成，即 Bitmap Checker 和 Bitmap Cache。其中，Checker 的职责是读取内存中的权限信息，以确保内存访问的安全性；而 Cache 则旨在加速查找过程，提升整体性能。需要指出的是，当前实现仅支持单向隔离功能。&#xA;这意味着在实际应用场景中，它能够有效地防止非安全敏感型负载对安全内存区域的非法访问，但尚未支持更高阶的双向隔离功能，即安全与非安全负载之间的互相访问限制。&lt;/p&gt;&#xA;&lt;h4 id=&#34;shield-xs-bitmap-硬件示意图&#34;&gt;Shield-XS Bitmap 硬件示意图&lt;/h4&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../mod00.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;上图展示了一次虚拟地址到物理地址转换过程中如何结合&lt;strong&gt;Shield-Bitmap安全机制&lt;/strong&gt;进行访问权限检查。&#xA;以及bitmap cache hit 和miss的不同处理。在L1TLB hit时，无需进行bitmap检查，因为L1TLB只会存储bitmap 检查为 allow的项。&#xA;如果miss，在L2TLB的page cache中查找，如果页表项和对应的bitmap 均未命中，则先进行查表，后进行bitmap检查并返回结果。如果页表项命中但未进行过bitmap 检查，则只进行bitmap检查。 如果都命中，则直接返回。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bitmap接口时序图</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/modules/03_bm_timing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/modules/03_bm_timing/</guid>
      <description>&lt;h2 id=&#34;bitmap接口时序图&#34;&gt;Bitmap接口时序图&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../module03_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;信号&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_req_ready&lt;/td&gt;&#xA;          &lt;td&gt;8个fsm中有至少一个idle时为高，可以视为常态高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_req_valid&lt;/td&gt;&#xA;          &lt;td&gt;新请求进入时高，平时为低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_resp_ready&lt;/td&gt;&#xA;          &lt;td&gt;当请求源（ptw hptw llptw）发送请求，等待返回时会拉高，平时无请求时为低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_resp_valid&lt;/td&gt;&#xA;          &lt;td&gt;当返回查询结果时拉高，平时为低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_mem_req_ready&lt;/td&gt;&#xA;          &lt;td&gt;有其它mem请求时（ptw llptw hptw）为低，平时为高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_mem_req_valid&lt;/td&gt;&#xA;          &lt;td&gt;cache miss时发起mem请求拉高，平时为低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_mem_resp_valid&lt;/td&gt;&#xA;          &lt;td&gt;mem 返回结果拉高，平时为低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_cache_req_valid&lt;/td&gt;&#xA;          &lt;td&gt;bimap fsm 发起 cache 请求拉高，平时为低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_cache_req_ready&lt;/td&gt;&#xA;          &lt;td&gt;常态高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_cache_resp_valid&lt;/td&gt;&#xA;          &lt;td&gt;io_cache_req_valid下一clk 拉高平时低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_cache_resp_ready&lt;/td&gt;&#xA;          &lt;td&gt;io_cache_req_valid 下一clk 拉高平时低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>Shield-Bitmap 地址翻译</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/feature/02_bm_mmu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/feature/02_bm_mmu/</guid>
      <description>&lt;h1 id=&#34;虚拟化两阶段地址翻译流程&#34;&gt;虚拟化两阶段地址翻译流程&lt;/h1&gt;&#xA;&lt;p&gt;bitmap和MMU-L2TLB耦合，会在虚拟化两阶段地址走表翻译完成后才进行隔离检查。如果bitmap检查没有通过，就向MMU-L1TLB 发送af。因此对L1TLB以及其上面的模块来说，bitmap是透明的。所以，在进一步介绍前，需要先了解MMU处理虚拟化两阶段地址的流程。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;两阶段翻译&lt;/strong&gt;：Guest Virtual Address (GVA) → Guest Physical Address (GPA) → Host Physical Address (HPA)&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;关键寄存器&lt;/strong&gt; ：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;hgatp&lt;/strong&gt; ：控制G-stage（客户机阶段）页表根地址&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;vsatp&lt;/strong&gt; ：控制VS-stage（虚拟化监督模式阶段）页表根地址&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;1. VAPT (Virtual Address Protection and Translation)&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt; ：管理客户机虚拟地址（GVA）到客户机物理地址（GPA）的第一阶段翻译（VS-stage）。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&lt;strong&gt;字段名&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;位宽&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;MODE&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;页表模式：&lt;br/&gt; &lt;ul&gt;&lt;li&gt;&lt;code&gt;0&lt;/code&gt;: 关闭翻译&lt;/li&gt; &lt;li&gt;&lt;code&gt;1&lt;/code&gt;: Sv32&lt;/li&gt; &lt;li&gt;&lt;code&gt;8&lt;/code&gt;: Sv39&lt;/li&gt; &lt;li&gt;&lt;code&gt;9&lt;/code&gt;: Sv48&lt;/li&gt; &lt;li&gt;&lt;code&gt;10&lt;/code&gt;: Sv57&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;ASID&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;16&lt;/td&gt;&#xA;          &lt;td&gt;地址空间标识符（Address Space ID），隔离不同客户机的地址空间&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;PPN&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;44&lt;/td&gt;&#xA;          &lt;td&gt;物理页号（Physical Page Number），指向VS-stage页表的根页表地址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;RESERVED&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;保留位，必须写0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;G&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;全局映射标志（Global bit），若为1则忽略ASID匹配&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;2. SVAPT (Supervisor Virtual Address Protection and Translation)&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Shield-XS_Bitmap 单元验证</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/verification/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/verification/</guid>
      <description>&lt;p&gt;本文档将会对需要验证的点进行说明&lt;/p&gt;</description>
    </item>
    <item>
      <title>香山bitmap 应用场景</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/basic/03_bm_scenario/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/basic/03_bm_scenario/</guid>
      <description>&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-机密虚拟机&#34;&gt;1. 机密虚拟机&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../basic03_1.png&#34; alt=&#34;应用场景-机密虚拟机&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Shield-XS用于普通虚拟机和机密虚拟机的隔离。在机密虚拟机（Confidential VM， CVM）环境中，bitmap 用于标记和隔离安全内存区域。&lt;/p&gt;&#xA;&lt;p&gt;普通虚拟机在访问内存时，硬件通过 bitmap 检查机制确保其只能访问被授权的内存区域，从而实现虚拟机之间的内存隔离。&lt;/p&gt;&#xA;&lt;p&gt;注：机密虚拟机之间的隔离通过MMU 完成，不需要经过Bitmap 的检查机制。&lt;/p&gt;&#xA;&lt;p&gt;CVM Bitmap 的资源的标记和分配由C-SDSM (Confidential Supervisor Domain Security Manager) 完成，Hypervisor 和 CVM 通过TEECall 和 TEEResume 进行安全世界的交互。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../basic03_2.png&#34; alt=&#34;安全世界接口&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;TEECall&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从普通世界（Normal World）切换到安全世界（TEE），进入敏感工作负载执行流程。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;TEEResume&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从 TEE 返回普通世界，恢复 Normal Workloads 的执行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-安全增强容器&#34;&gt;2. 安全增强容器&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../basic03_3.png&#34; alt=&#34;应用场景-容器&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;上图显示了bitmap在容器中的应用场景。安全容器和普通容器都位于可信计算基的保护范围内。在安全容器中运行的应用程序可能包含敏感数据或关键业务逻辑。为了防止这些数据被普通容器或恶意软件访问，采用通过 &lt;strong&gt;bitmap 机制&lt;/strong&gt;进行隔离。&lt;/p&gt;&#xA;&lt;p&gt;Bitmap 数据结构用于标记哪些物理页属于安全容器的存储空间，通过将对应该容器内存区域的位图数据写为1，确保普通容器无法访问这些存储空间。只有安全容器内的应用程可以访问这些被标记为安全的内存页。&lt;/p&gt;&#xA;&lt;p&gt;普通容器中的应用程序可能来自不可信的来源。通过 bitmap 机制，普通容器的内存访问被限制在非安全内存区域。任何试图访问安全内存的请求都会被硬件拦截，并触发Access Fault。&lt;/p&gt;&#xA;&lt;p&gt;在上述场景的具体的实施细节中，&lt;strong&gt;&lt;font style=&#34;color:#ee0000;&#34;&gt;软件模块负责Bitmap管理和配置 ， 硬件机制负责Bitmap检查和同步。&lt;font&gt;&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Shield-Bitmap 地址翻译2</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/feature/03_bm_mmu_with_bm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/feature/03_bm_mmu_with_bm/</guid>
      <description>&lt;h1 id=&#34;加入了shield-xs安全检查后的内存地址转换流程&#34;&gt;加入了Shield-XS安全检查后的内存地址转换流程&lt;/h1&gt;&#xA;&lt;p&gt;如前文所述， bitmap和MMU耦合。现在将介绍增加了bitmap后的MMU地址翻译流程。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../feature03_1.jpeg&#34; alt=&#34; &#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;从 &lt;strong&gt;客户虚拟地址&lt;/strong&gt; 到 &lt;strong&gt;主机物理地址&lt;/strong&gt; 的转换过程，同时涉及 &lt;strong&gt;安全属性检查&lt;/strong&gt; 和 Shield-Bitmap&lt;strong&gt;高速缓存访问&lt;/strong&gt;。以下是详细步骤：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;客户虚拟地址（Guest Virtual Address）&lt;/strong&gt;: 流程开始于计算单元（如CPU）使用客户虚拟地址发出内存访问请求。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;访问一级快表（L1TLB Lookup）&lt;/strong&gt;: 首先查询一级快表（&lt;strong&gt;L1TLB&lt;/strong&gt;），检查是否已缓存该地址的映射。只有经历过bitmap检查才会出现在L1TLB Cache中。因此和L2TLB Cache不同，L1TLB Cache 不会存储bitmap检查位。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;一级快表缓存命中？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;是&lt;/strong&gt; → 直接从L1TLB Cache获取主机物理地址（Host Physical Address）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;否&lt;/strong&gt; → 进入下一级查询（访问二级快表）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;访问二级快表（L2TLB Lookup）&lt;/strong&gt;: 如果一级快表未命中，继续查询二级快表（L2TLB），检查二级快表是否有对应的映射。L2TLB Cache 存储安全允许位（cf）表示 是否经过bitmap 检查。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;二级快表缓存命中？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;cf 和 L2TLB 页表项均命中&lt;/strong&gt; → 获取主机物理地址，并回填一级快表（更新L1TLB）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;L2TLB 页表项命中，bitmap cf 未设&lt;/strong&gt;→ 发送请求至bitmap，进行权限检查。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;否&lt;/strong&gt; → 触发 &lt;strong&gt;页表遍历（Page Table Walker）&lt;/strong&gt;，从内存中加载页表映射关系，随后进行bitmap检查。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;进行页表遍历&lt;/strong&gt;：从内存中加载页表映射关系&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;主机虚拟地址 → 主机物理地址转换&lt;/strong&gt;：通过页表遍历获取主机物理地址（Host Physical Address）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;安全性检查允许访问（Security Check）&lt;/strong&gt;： 对物理地址进行 &lt;strong&gt;安全属性检查&lt;/strong&gt;。如果检查失败，可能触发访问错误（Access Fault）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>开销评估</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/modules/04_bm_cost/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/05_bitmap/modules/04_bm_cost/</guid>
      <description>&lt;h2 id=&#34;开销评估&#34;&gt;开销评估&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;1. 基本配置&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;类别&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;配置项&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;参数**&lt;/strong&gt;/*&lt;strong&gt;*设置&lt;/strong&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Shield-Bit 配置&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;有效 Shield-XS 隔离模型&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;-&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;设置 Shield-Bitmap&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;_&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Shield-Bitmap缓存大小&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;128 × 8 Bytes&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;KunminghuV2 配置&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;TileLink Prototype&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;-&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;缓存层级配置&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;L1 指令/数据缓存大小&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;64KB&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;L1 指令/数据 TLB&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;48-全关联（Full Association）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;L2 缓存大小&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;1MB&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;L3 缓存大小&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;16MB&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;&lt;strong&gt;2. SPEC2006 性能数据&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;SPECInt2006 Simpoint est.@&lt;strong&gt;3GHz&lt;/strong&gt; &lt;strong&gt;GEOMEAN 44.62 &lt;strong&gt;-&amp;gt;&lt;/strong&gt; 44.29 (0.72% )&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../module04_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;图 9.1 SPEC2006 性能开销&lt;/p&gt;&#xA;&lt;p&gt;性能开销与DTLB Miss-rate 呈正比。有效的减少 DTLB 和 Shield-bitmap Cache 的miss-rate, 可以进一步提升性能。例如将缓存从 16 项扩展到 128 项，可使 GemsFDTD 的性能开销从 6.51% 降低至 2.36%。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
