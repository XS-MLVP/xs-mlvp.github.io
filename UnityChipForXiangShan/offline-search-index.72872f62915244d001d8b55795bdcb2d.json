[{"body":"脚本目标 该脚本的目标是提供 RTL 到 Python DUT 的编译、目标覆盖文件，以及自定义功能等内容。\n创建过程 确定文件名称 在香山昆明湖 DUT 验证进展中选择需要验证的 UT，如果没有或者进一步细化，可通过编辑configs/dutree/xiangshan-kmh.yaml自行添加。\n脚本文件的命名格式如下：\nscripts/build_\u003c顶层模块\u003e_\u003c下层模块名\u003e_..._\u003c目标模块名\u003e.py 目前本项目内置了 4 个顶层模块：\nut_frontend 前端 ut_backend 后端 ut_mem_block 访存 ut_misc 其他 其中的子模块没有ut_前缀（顶层目录有该前缀是为了和其他目录区分开）。\n例如验证目标 DUT 为：backend.ctrl_block.decode，需要创建的脚本名称为 build_ut_backend_ctrl_block_decode.py。\n编写 build(cfg) -\u003e bool 函数 build 函数定义如下：\ndef build(cfg) -\u003e bool: \"\"\"编译DUT Args: cfg: 运行时配置，可通过它访问配置项，例如 cfg.rtl.version Return: 返回 True 或者 False，表明该函数是否完成预期目标 \"\"\" build 在 make dut 时会被调用，其主要是将目标 RTL 转换为 Python 模块。在该过程中也可以加入其他必要过程，例如编译依赖项等。以build_ut_backend_ctrl_block_decode.py为例，主要完成了 RTL 检查、DUT 检查、RTL 编译、disasm 依赖编译等工作：\ndef build(cfg) -\u003e bool: # import 相关依赖 from toffee_test.markers import match_version from comm import is_all_file_exist, get_rtl_dir, exe_cmd, get_root_dir # 检查RTL版本（version参数为空，表示所有版本都支持） if not match_version(cfg.rtl.version, []): warning(\"backend_ctrlblock_decode: %s\" % f\"Unsupported RTL version {cfg.rtl.version}\") return False # 检查在当前RTL中，目标文件是否存在 f = is_all_file_exist([\"rtl/RVCExpander.sv\", \"rtl/PreDecode.sv\", \"rtl/DecodeStage.sv\"], get_rtl_dir(cfg=cfg)) assert f is True, f\"File {f} not found\" # 如果dut中不存在RVCExpander/PreDecode/DecodeStage，则调用picker进行Python打包 if not os.path.exists(get_root_dir(\"dut/RVCExpander\")): info(\"Exporting RVCExpander.sv\") s, out, err = exe_cmd(f'picker export --cp_lib false {get_rtl_dir(\"rtl/RVCExpander.sv\", cfg=cfg) } --lang python --tdir {get_root_dir(\"dut\")}/ -w rvc.fst -c') assert s, \"Failed to export RVCExpander.sv: %s\\n%s\" % (out, err) if not os.path.exists(get_root_dir(\"dut/PreDecode\")): info(\"Exporting PreDecode.sv\") s, _, _ = exe_cmd(f'picker export --cp_lib false {get_rtl_dir(\"rtl/PreDecode.sv\", cfg=cfg) } --lang python --tdir {get_root_dir(\"dut\")}/ -w predecode.fst -c') assert s, \"Failed to export PreDecode.sv\" if not os.path.exists(get_root_dir(\"dut/DecodeStage\")): info(\"Exporting DecodeStage.sv\") s, _, _ = exe_cmd(f'picker export --cp_lib false {get_rtl_dir(\"rtl/DecodeStage.sv\", cfg=cfg) } --fs { get_root_dir(\"scripts/backend_ctrlblock_decode/rtl_files.f\") } --lang python --tdir {get_root_dir(\"dut\")}/ -w decode.fst -c') assert s, \"Failed to export DecodeStage.sv\" # 如果tools中不存在disasm/build，则需要编译disasm if not os.path.exists(get_root_dir(\"tools/disasm/build\")): info(\"Building disasm\") s, _, _ = exe_cmd(\"make -C %s\" % get_root_dir(\"tools/disasm\")) assert s, \"Failed to build disasm\" # 编译成功 return True picker 的使用方式请参考其文档和使用\n在scripts目录中可以创建子目录保存 UT 验证需要的文件，例如 decode 模块创建了scripts/backend_ctrlblock_decode目录，其中的rtl_file.f用来指定输入的 RTL 文件，line_coverage.ignore用来保存需要忽略的代码行统计。自定义目录的命名需要合理，且能通过名字判断其所属模块和文件。\n编写 line_coverage_files(cfg) -\u003e list[str] 函数 line_coverage_files 函数的定义如下：\ndef line_coverage_files(cfg)-\u003e list[str]: \"\"\"指定需要覆盖的文件 Args: cfg: 运行时配置，可通过它访问配置项，例如 cfg.rtl.version Return: 返回统计代码行覆盖率的目标RTL文件名 \"\"\" 在build_ut_backend_ctrl_block_decode.py文件中，line_coverage_files函数的定义如下：\ndef line_coverage_files(cfg): return [\"PreDecode.v\", \"DecodeStage.v\"] 标识该模块关注的是对PreDecode.v, DecodeStage.v文件的覆盖。如果要开启测试结果处理，还需要在configs/_default.yaml中的doc-result下disable=False（默认参数是False，也就是开启状态）;如果不开启测试结果处理则(disable = True)。注意，如果不开启测试结果处理，那么上述函数就不会被调用。\n","categories":"","description":"","excerpt":"脚本目标 该脚本的目标是提供 RTL 到 Python DUT 的编译、目标覆盖文件，以及自定义功能等内容。\n创建过程 确定文件名称 在香山 …","ref":"/UnityChipForXiangShan/docs/03_add_test/01_build_script/","tags":"","title":"添加编译脚本"},{"body":"确定目录结构 UT(单元测试)所在的目录位置的层级结构应该与名称一致，例如backend.ctrl_block.decode应当位于ut_backend/ctrl_block/decode目录，且每层目录都需要有__init__.py，便于通过 python 进行import。\nut_backend/ctrl_block/decode ├── env │ ├── decode_wrapper.py │ ├── __init__.py ├── __init__.py ├── README.md └── test_rv_decode.py 模块（例如decode）中的代码目录结构由贡献者自行决定，但需要满足 python 规范，且逻辑和命名合理。\n编写测试环境 在 UT 验证模块的测试环境中，目标是完成以下工作：\n对 DUT 进行功能封装，为测试提供稳定 API 定义功能覆盖率 定义必要 fixture 提供给测试用例 在合理时刻统计覆盖率 以 decode 环境中的 RVCExpander 为例（ut_backend/ctrl_block/decode/env/decode_wrapper.py）：\n1. DUT 封装 class RVCExpander(toffee.Bundle): def __init__(self, cover_group, **kwargs): super().__init__() self.cover_group = cover_group self.dut = DUTRVCExpander(**kwargs) # 创建DUT self.dut.io_in.AsImmWrite() # DUTRVCExpander为组合电路，将输入引脚设置为ImmWrite写入模式 self.io = toffee.Bundle.from_prefix(\"io_\", self.dut) # 通过 Bundle 使用前缀关联引脚 self.bind(self.dut) # 把 Bundle 与 DUT 进行绑定 def expand(self, instr): self.io[\"in\"].value = instr # 给DUT引脚赋值 self.dut.RefreshComb() # 推动组合电路 self.cover_group.sample() # 调用sample对功能覆盖率进行统计 return self.io[\"out_bits\"].value, self.io[\"ill\"].value # 返回结果 和 是否是非法指令 def stat(self): # 获取当前状态 return { \"instr\": self.io[\"in\"].value, # 输入指令 \"decode\": self.io[\"out_bits\"].value, # 返回展开结果 \"ilegal\": self.io[\"ill\"].value != 0, # 输入是否非法 } 在上述例子中，class RVCExpander对DUTRVCExpander进行了封装，对外提供了两个 API：\nexpand(instr: int) -\u003e (int, int) ：该函数用于接受输入指令 instr 进行解码，返回（结果，非法指令标记）。如果非法指令标记不为 0，者说明输入指令非法。 stat() -\u003e dict(instr, decode, ilegal)：该函数用于返回当前的状态，其中包含当前的输入指令，解码结果以及非法指令标记。 上述 API 屏蔽了 DUT 的引脚，对外程序通用功能。\n2. 定义功能覆盖率 尽可能的在 Env 中定义好功能覆盖率，如果有必要也可以在测试用例中定义覆盖率。toffee 功能覆盖率的定义请参考什么是功能覆盖率。为了完善功能检查点和测试用例之间的对应关系，功能覆盖率定义完成后，需要在适合的位置进行检查点和测试用例的对应（测试点反标）。\nimport toffee.funcov as fc # 创建功能覆盖率组 g = fc.CovGroup(UT_FCOV(\"../../INT\")) def init_rvc_expander_funcov(expander, g: fc.CovGroup): \"\"\"Add watch points to the RVCExpander module to collect function coverage information\"\"\" # 1. Add point RVC_EXPAND_RET to check expander return value: # - bin ERROR. The instruction is not illegal # - bin SUCCE. The instruction is not expanded g.add_watch_point(expander, { \"ERROR\": lambda x: x.stat()[\"ilegal\"] == False, \"SUCCE\": lambda x: x.stat()[\"ilegal\"] != False, }, name = \"RVC_EXPAND_RET\") ... # 5. Reverse mark function coverage to the check point def _M(name): # get the module name return module_name_with(name, \"../../test_rv_decode\") # - mark RVC_EXPAND_RET g.mark_function(\"RVC_EXPAND_RET\", _M([\"test_rvc_expand_16bit_full\", \"test_rvc_expand_32bit_full\", \"test_rvc_expand_32bit_randomN\"]), bin_name=[\"ERROR\", \"SUCCE\"]) ... 在上述代码中添加了名为RVC_EXPAND_RET的功能检查点来检查RVCExpander模块是否具有返回非法指令的能力。需要满足ERROR和SUCCE两个条件，即stat()中的ileage需要有True也需要有False值。在定义完检查点后，通过mark_function方法，对会覆盖到该检查的测试用例进行了标记。\n3. 定义必要fixture version_check = get_version_checker(\"openxiangshan-kmh-*\") # 指定满足要的RTL版本 @pytest.fixture() def rvc_expander(request): version_check() # 进行版本检查 fname = request.node.name # 获取调用该fixture的测试用例 wave_file = get_out_dir(\"decoder/rvc_expander_%s.fst\" % fname) # 设置波形文件路径 coverage_file = get_out_dir(\"decoder/rvc_expander_%s.dat\" % fname) # 设置代码覆盖率文件路径 coverage_dir = os.path.dirname(coverage_file) os.makedirs(coverage_dir, exist_ok=True) # 目标目录不正在则创建目录 expander = RVCExpander(g, coverage_filename=coverage_file, waveform_filename=wave_file) # 创建RVCExpander init_rvc_expander_funcov(expander, g) # 初始化功能检查点 yield expander # 返回创建好的 RVCExpander 给 Test Case expander.dut.Finish() # Tests Case运行完成后，结束DUT set_line_coverage(request, coverage_file) # 把生成的代码覆盖率文件告诉 toffee-report set_func_coverage(request, g) # 把生成的功能覆盖率数据告诉 toffee-report g.clear() # 清空功能覆盖统计 上述 fixture 完成了以下功能：\n进行 RTL 版本检查，如果不满足\"openxiangshan-kmh-*\"要求，则跳过调用改 fixture 的测试用例 创建 DUT，并指定了波形，代码行覆盖率文件路径（路径中含有调用该 fixure 的用例名称：fname） 调用init_rvc_expander_funcov添加功能覆盖点 结束 DUT，处理代码行覆盖率和功能覆盖率（发往 toffee-report 进行处理） 清空功能覆盖率 *注：在 PyTest 中，执行测试用例test_A(rvc_expander, ....)前，会自动调用并执行rvc_expander(request)中yield关键字前的部分，然后通过yield返回rvc_expander调用test_A用例，用例执行完成后，再继续执行fixture中yield关键字之后的部分。\n4. 统计覆盖率 N = 10 T = 1\u003c\u003c16 @pytest.mark.toffee_tags(TAG_LONG_TIME_RUN) @pytest.mark.parametrize(\"start,end\", [(r*(T//N), (r+1)*(T//N) if r \u003c N-1 else T) for r in range(N)]) def test_rvc_expand_16bit_full(rvc_expander, start, end): \"\"\"Test the RVC expand function with a full compressed instruction set Description: Perform an expand check on 16-bit compressed instructions within the range from 'start' to 'end'. \"\"\" # Add check point: RVC_EXPAND_RANGE to check expander input range. # When run to here, the range[start, end] is covered covered = -1 g.add_watch_point(rvc_expander, { \"RANGE[%d-%d]\"%(start, end): lambda _: covered == end }, name = \"RVC_EXPAND_ALL_16B\", dynamic_bin=True) # Reverse mark function to the check point g.mark_function(\"RVC_EXPAND_ALL_16B\", test_rvc_expand_16bit_full, bin_name=\"RANGE[%d-%d]\"%(start, end)) # Drive the expander and check the result rvc_expand(rvc_expander, generate_rvc_instructions(start, end)) # When go to here, the range[start, end] is covered covered = end g.sample() # 覆盖率采样 在定义了覆盖率之后，还需要在测试用例中进行覆盖率统计。上述代码中，在测试用例中使用add_watch_point添加了一个功能检查点rvc_expander，并在后面进行了标记和采样,而且在最后一样对覆盖率进行了采样。 覆盖率采样，实际上是通过回调函数触发了一次add_watch_point中bins的判断，当其中bins的判断结果为True时，就会统计一次Pass。\nEnv 编写要求 需要进行 RTL 版本检查 Env 提供的 API 需要和引脚、时序无关 Env 提供的 API 需要稳定，不能随意进行接口/返回值修改 需要定义必要的 fixture 需要初始化功能检查点（功能检查点可以独立成一个模块） 需要进行覆盖率统计 需要有说明文档 ","categories":"","description":"","excerpt":"确定目录结构 UT(单元测试)所在的目录位置的层级结构应该与名称一致，例如backend.ctrl_block.decode应当位 …","ref":"/UnityChipForXiangShan/docs/03_add_test/02_build_env/","tags":"","title":"构建测试环境"},{"body":"命名要求 所有测试用例文件请以test_*.py的方式进行命名，*用测试目标替换（例如test_rv_decode.py）。所有测试用例也需要以test_前缀开头。用例名称需要具有明确意义。\n命名举例如下：\ndef test_a(): # 不合理，无法通过a判断测试目标 pass def test_rvc_expand_16bit_full(): # 合理，可以通过用例名称大体知道测试内容 pass 使用 Assert 在每个测试用例中，都需要通过assert来判断本测试是否通过。 pytest统计的是assert语句的结果，因此assert语句需要保证能够通过。\ndef test_rvi_inst(decoder, rvc_expander): \"\"\" Test the RVI instruction set. randomly generate instructions for testing Args: decoder (fixure): the fixture of the decoder \"\"\" need_log_file = True insn_list_temp = generate_random_32bits(100) ref_lists = convert_reference_format(rvc_expander, insn_list_temp, True, libdisasm.disasm, libdisasm.disasm_free_mem) assert decode_run(decoder, ref_lists, need_log_file,\"test_rvi_inst\") == True, \"RVI decode error\" g.add_cover_point(decoder, {\"illegal_inst_triggers_an_exception\": lambda _: decoder.Get_decode_checkpoint_illeagl_inst() != 0}, name=\"RVI_illegal_inst\").sample() g.add_cover_point(decoder, {\"fast_check_random_32bit_int\": lambda _: True}, name=\"RVI\").sample() 编写注释 每个测试用例都需要添加必要的说明和注释，需要满足Python 注释规范。\n测试用例说明参考格式：\ndef test_\u003cname\u003e(a: type_a, b: type_b): \"\"\"Test abstract Args: a (type_a): description of arg a. b (type_b): description of arg b. Detailed test description here (if need). \"\"\" ... 用例管理 为了方便测试用例管理，可通过 toffee-test 提供的@pytest.mark.toffee_tags标签功能，请参考 本网站的其他部分和toffee-test。\n参考用例 如果很多测试用例（Test）具有相同的操作，该公共操作部分可以提炼成一个通用函数。以 RVCExpander 验证为例，可以把压缩指令的展开与参考模型（disasm）的对比封装成以下函数：\ndef rvc_expand(rvc_expander, ref_insts): \"\"\"compare the RVC expand result with the reference Args: rvc_expander (warpper): the fixture of the RVC expander ref_insts (list[int]]): the reference instruction list \"\"\" find_error = 0 for insn in ref_insts: insn_disasm = disasmbly(insn) _, instr_ex = rvc_expander.expand(insn) if (insn_disasm == \"unknown\") and (instr_ex == 0): debug(f\"find bad inst:{insn}, ref: 1, dut: 0\") find_error +=1 elif (insn_disasm != \"unknown\") and (instr_ex == 1): debug(f\"find bad inst:{insn}, ref: 0, dut: 1\") find_error +=1 assert 0 == find_error, \"RVC expand error (%d errros)\" % find_error 在上述公共部分中有 assert，因此调用该函数的 Test 也能提过该 assert 判断运行结果是否提过。\n在测试用例的开发过程中，通常存在大量的调试工作，为了让验证环境快速就位，需要编写一些“冒烟测试”进行调试。RVCExpander 展开 16 位压缩指令的冒烟测试如下：\n@pytest.mark.toffee_tags(TAG_SMOKE) def test_rvc_expand_16bit_smoke(rvc_expander): \"\"\"Test the RVC expand function with 1 compressed instruction\"\"\" rvc_expand(rvc_expander, generate_rvc_instructions(start=100, end=101)) 为了方便进行管理，上述测试用例通过toffee_tags标记上了 SMOKE 标签。它的输入参数为rvc_expander，则在在运行时，会自动调用对应同名的fixture进行该参数的填充。\nRVCExpander 展开 16 位压缩指令的测试目标是对 2^16 所有压缩指令进行遍历，检测所有情况是否都与参考模型 disasm 一致。在实现上，如果仅仅用一个 Test 进行遍历，则需要耗费大量时间，为此我们可以利用 PyTest 提供的parametrize对 test 进行参数化配置，然后通过pytest-xdist插件并行执行：\nN = 10 T = 1\u003c\u003c16 @pytest.mark.toffee_tags(TAG_LONG_TIME_RUN) @pytest.mark.parametrize(\"start,end\", [(r*(T//N), (r+1)*(T//N) if r \u003c N-1 else T) for r in range(N)]) def test_rvc_expand_16bit_full(rvc_expander, start, end): \"\"\"Test the RVC expand function with a full compressed instruction set Description: Perform an expand check on 16-bit compressed instructions within the range from 'start' to 'end'. \"\"\" # Add check point: RVC_EXPAND_RANGE to check expander input range. # When run to here, the range[start, end] is covered g.add_watch_point(rvc_expander, { \"RANGE[%d-%d]\"%(start, end): lambda _: True }, name = \"RVC_EXPAND_ALL_16B\").sample() # Reverse mark function to the check point g.mark_function(\"RVC_EXPAND_ALL_16B\", test_rvc_expand_16bit_full, bin_name=\"RANGE[%d-%d]\"%(start, end)) # Drive the expander and check the result rvc_expand(rvc_expander, generate_rvc_instructions(start, end)) 在上述用例中定义了参数化参数start, end，用来指定压缩指令的开始值和结束值，然后通过装饰器@pytest.mark.parametrize对他们进行分组赋值。变量 N 可以指定将目标数据进行分组的组数，默认设置为 10 组。在运行时用例test_rvc_expand_16bit_full会展开为test_rvc_expand_16bit_full[0-6553]至test_rvc_expand_16bit_full[58977-65536]10 个测试用例运行。\n","categories":"","description":"","excerpt":"命名要求 所有测试用例文件请以test_*.py的方式进行命名，*用测试目标替换（例如test_rv_decode.py）。所有测试用例也需 …","ref":"/UnityChipForXiangShan/docs/03_add_test/03_add_test/","tags":"","title":"添加测试用例"},{"body":"代码覆盖率是一项评价指标，它衡量了被测代码中哪些部分被执行了，哪些部分没有被执行。通过统计代码覆盖率，可以评估测试的有效性和覆盖程度。\n代码覆盖率包括：\n行覆盖率(line coverage): 被测代码中被执行的行数，最简单的指标，一般期望达到 100%。 条件覆盖率(branch coverage): 每一个控制结构的每个分支是否均被执行。例如，给定一个 if 语句，其 true 和 false 分支是否均被执行？ 有限状态机覆盖率(fsm coverage): 状态机所有状态是否都达到过。 翻转覆盖率(toggle coverage): 统计被测代码中被执行的翻转语句，检查电路的每个节点是否都有 0 -\u003e 1 和 1 -\u003e 0 的跳变。 路径覆盖率(path coverage): 检查路径的覆盖情况。在 always 语句块和 initial 语句块中，有时会使用 if … else 和 case 语句，在电路结构上便会产生一系列的数据路径。。 *我们主要使用的模拟器是 Verilator,优先考虑行覆盖率。Verilator 支持覆盖率统计，因此我们在构建 DUT 时，如果要开启覆盖率统计，需要在编译选项中添加-c参数。\n本项目中相关涉及位置 开启覆盖率需要在编译时（使用 picker 命令时）加上“-c”参数（参考 picker 的参数解释），同时在文件中设置启用行覆盖率，这样在使用 toffee 测试时，才能够生成覆盖率统计文件。\n结合上面的描述，在本项目中也就是编译，编写和启用行覆盖率函数和测试的时候会涉及到代码覆盖率：\n添加编译脚本部分 编写编译脚本\n# 省略前面 if not os.path.exists(get_root_dir(\"dut/RVCExpander\")): info(\"Exporting RVCExpander.sv\") s, out, err = exe_cmd(f'picker export --cp_lib false {get_rtl_dir(\"rtl/RVCExpander.sv\", cfg=cfg) } --lang python --tdir {get_root_dir(\"dut\")}/ -w rvc.fst -c') assert s, \"Failed to export RVCExpander.sv: %s\\n%s\" % (out, err) # 省略后面 在s, out, err=...这一行，我们使用 picker 命令，并且开启代码了覆盖率(命令最后的\"-c\"参数)。\n设置目标覆盖文件(line_coverage_files 函数)\n按照需求编写line_coverage_files(cfg) -\u003e list[str]函数，并且开启测试结果处理(doc_result.disable = False)让其被调用。\n构建测试环境部分 定义必要 fixture\nset_line_coverage(request, coverage_file) # 把生成的代码覆盖率文件告诉 toffee-report 通过函数toffee-test.set_line_coverage把覆盖率文件传递给 toffe-test，这样其才能够收集数据，以便于后面生成的报告带有行覆盖率。\n忽略指定统计 有时候，我们可能需要手动指定某些内容不参与覆盖率统计。例如有些是不需要被统计的，有些统计不到是正常的。这时候我们就可以忽略这些内容，这对优化覆盖率报告或调试非常有帮助。 目前我们的框架可以使用两种方式来实现忽略统计的功能：\n1.通过 verilator 指定忽略统计的内容 使用 verilator_coverage_off/on 指令 Verilator 支持通过注释指令来忽略特定代码段的覆盖率统计。例如，使用如下的指令：\n// *verilator coverage_off* // 忽略统计的代码段 ... // *verilator coverage_on* 举个例子\nmodule example; always @(posedge clk) begin // *verilator coverage_off* if (debug_signal) begin $display(\"This is for debugging only\"); end // *verilator coverage_on* if (enable) begin do_something(); end end endmodule 在上述示例中，debug_signal 部分的代码将不会计入覆盖率统计，而 enable 部分仍然会被统计。\n更多 verilator 的忽略统计方式请参照verilator 官方文档\n2.通过 toffee 指定需要过滤掉的内存 def set_line_coverage(request, datfile, ignore=[]): \"\"\"Pass Args: request (pytest.Request): Pytest的默认fixture， datfile (string): DUT生成的 ignore (list[str]): 覆盖率过滤文件/或者文件夹 \"\"\" ignore 参数可以指定在覆盖率文件中需要过滤掉的内容，例如：\n... set_line_coverage(request, coverage_file, get_root_dir(\"scripts/backend_ctrlblock_decode\")) 在统计覆盖率时，会在\"scripts/backend_ctrlblock_decode\"目录中搜索到line_coverage.ignore文件，然后按其中每行的通配符进行过滤。\n# Line covarge ignore file # ignore Top file */DecodeStage_top*% 上述文件表示，在统计覆盖率时，会忽略掉包含\"DecodeStage_top\"关键字的文件（实际上是收集了对应的数据，但是最后统计的时候忽略了）。\n查看统计结果 在经过前面所有步骤之后，包括准备测试环境中的下载 RTL 代码、编译 DUT、编辑配置 ；添加测试中的添加编译脚本,构建测试环境、添加测试用例。\n现在运行测试,之后就默认在out/report目录会生成 html 版本的测试报告。\n也可以在进度概述图形下方的“当前版本”选择对应的测试报告(按照测试时间命名)，然后点击右侧链接即可查看统计结果。\n","categories":"","description":"","excerpt":"代码覆盖率是一项评价指标，它衡量了被测代码中哪些部分被执行了，哪些部分没有被执行。通过统计代码覆盖率，可以评估测试的有效性和覆盖程度。\n代码 …","ref":"/UnityChipForXiangShan/docs/03_add_test/04_cover_line/","tags":"","title":"代码覆盖率"},{"body":"功能覆盖率（Functional Coverage）是一种用户定义的度量标准，用于度量验证中已执行的设计规范的比例。功能覆盖率关注的是设计的功能和特性是否被测试用例覆盖到了。\n反标是指将功能点与测试用例对应起来。这样，在统计时，就能看到每个功能点对应了哪些测试用例，从而方便查看哪些功能点用的测试用例多，哪些功能点用的测试用例少，有利于后期的测试用例优化。\n本项目中相关涉及位置 功能覆盖率需要我们先定义了才能统计，主要是在构建测试环境的时候涉及。\n在构建测试环境中：\n定义功能覆盖率： 创建了功能覆盖率组,添加观察点和反标 定义必要 fixture： 把统计结果传递给 toffee-report 统计覆盖率： 添加观察点和反标 其他：\n在 Test case 中使用，可以在每个测试用例里也编写一个功能点。 功能覆盖率使用流程 指定 Group 名称 测试报告通过 Group 名字和 DUT 名字进行匹配，利用 comm.UT_FCOV 获取 DUT 前缀，例如在 Python 模块ut_backend/ctrl_block/decode/env/decode_wrapper.py中进行如下调用：\nfrom comm import UT_FCOV # 本模块名为：ut_backend.ctrl_block.decode.env.decode_wrapper # 通过../../去掉了上级模块env和decode_wrapper # UT_FCOV会默认去掉前缀 ut_ name = UT_FCOV(\"../../INT\") name 的值为backend.ctrl_block.decode.INT，在最后统计结果时，会按照最长前缀匹配到目标 UT（即匹配到：backend.ctrl_block.decode 模块）\n创建覆盖率组 使用toffee的funcov可以创建覆盖率组。\nimport toffee.funcov as fc # 使用上面指定的GROUP名字 g = fc.CovGroup(name) 创建的g对象就表示了一个功能覆盖率组，可以使用其来提供观察点和反标。\n添加观察点和反标 在每个测试用例内部，可以使用add_watch_point（add_cover_point是其别名，二者完全一致）来添加观察点和mark_function来添加反标。 观察点是，当对应的信号触发了我们在观察点内部定义的要求后，这个观察点的名字（也就是功能点）就会被统计到功能覆盖率中。 反标是，将功能点和测试用例进行关联，这样在统计时，就能看到每个功能点对应了哪些测试用例。\n对于观察点的位置，需要根据实际情况来定，一般来说，在测试用例外直接添加观察点是没有问题的。 不过有时候我们可以更加的灵活。\n在测试用例之外（decode_wrapper.py中） def init_rvc_expander_funcov(expander, g: fc.CovGroup): \"\"\"Add watch points to the RVCExpander module to collect function coverage information\"\"\" # 1. Add point RVC_EXPAND_RET to check expander return value: # - bin ERROR. The instruction is not illegal # - bin SUCCE. The instruction is not expanded g.add_watch_point(expander, { \"ERROR\": lambda x: x.stat()[\"ilegal\"] == False, \"SUCCE\": lambda x: x.stat()[\"ilegal\"] != False, }, name = \"RVC_EXPAND_RET\") # 5. Reverse mark function coverage to the check point def _M(name): # get the module name return module_name_with(name, \"../../test_rv_decode\") # - mark RVC_EXPAND_RET g.mark_function(\"RVC_EXPAND_RET\",_M([\"test_rvc_expand_16bit_full\", \"test_rvc_expand_32bit_full\", \"test_rvc_expand_32bit_randomN\"]), bin_name=[\"ERROR\", \"SUCCE\"]) # The End return None 这个例子的第一个g.add_watch_point是放在测试用例之外的，因为它和现有的测试用例没有直接关系，放在测试用例之外反而更加方便。添加观察点之后，只要add_watch_point方法中的bins条件触发了，我们的toffee-test框架就能够收集到对应的功能点。\n在测试用例之中（test_rv_decode.py中） N=10 T=1\u003c\u003c32 @pytest.mark.toffee_tags([TAG_LONG_TIME_RUN, TAG_RARELY_USED]) @pytest.mark.parametrize(\"start,end\", [(r*(T//N), (r+1)*(T//N) if r \u003c N-1 else T) for r in range(N)]) def test_rvc_expand_32bit_full(rvc_expander, start, end): \"\"\"Test the RVC expand function with a full 32 bit instruction set Description: Randomly generate N 32-bit instructions for each check, and repeat the process K times. \"\"\" # Add check point: RVC_EXPAND_ALL_32B to check instr bits. covered = -1 g.add_watch_point(rvc_expander, {\"RANGE[%d-%d]\"%(start, end): lambda _: covered == end}, name = \"RVC_EXPAND_ALL_32B\", dynamic_bin=True) # Reverse mark function to the check point g.mark_function(\"RVC_EXPAND_ALL_32B\", test_rvc_expand_32bit_full) # Drive the expander and check the result rvc_expand(rvc_expander, list([_ for _ in range(start, end)])) # When go to here, the range[start, end] is covered covered = end g.sample() 这个例子的观察点在测试用例里面，因为这里的start和end是由pytest.mark.parametrize来决定的，数值不是固定的，所以我们需要在测试用例里面添加观察点。\n采样 在上一个例子的最后，我们调用了g.sample()，这个函数的作用是告诉toffee-test，add_watch_point里的bins已经执行过了，判断一下是不是True，是的话就为这个观察点记录一次Pass。\n有手动就有自动。我们可以在构建测试环境时，在定义fixture中加入StepRis(lambda x: g.sample()),这样就会在每个时钟周期的上升沿自动采样。\n@pytest.fixture() def decoder(request): # before test init_rv_decoder_funcov(g) func_name = request.node.name # If the output directory does not exist, create it output_dir_path = get_out_dir(\"decoder/log\") os.makedirs(output_dir_path, exist_ok=True) decoder = Decode(DUTDecodeStage( waveform_filename=get_out_dir(\"decoder/decode_%s.fst\"%func_name), coverage_filename=get_out_dir(\"decoder/decode_%s.dat\"%func_name), )) decoder.dut.InitClock(\"clock\") decoder.dut.StepRis(lambda x: g.sample()) yield decoder # after test decoder.dut.Finish() coverage_file = get_out_dir(\"decoder/decode_%s.dat\"%func_name) if not os.path.exists(coverage_file): raise FileNotFoundError(f\"File not found: {coverage_file}\") set_line_coverage(request, coverage_file, get_root_dir(\"scripts/backend_ctrlblock_decode\")) set_func_coverage(request, g) g.clear() 如上面所示，我们在yield之前调用了g.sample()，这样就会在每个时钟周期的上升沿自动采样。\nStepRis函数的作用是在每个时钟周期的上升沿执行传入的函数，详情可参照picker使用介绍\n","categories":"","description":"","excerpt":"功能覆盖率（Functional Coverage）是一种用户定义的度量标准，用于度量验证中已执行的设计规范的比例。功能覆盖率关注的是设计的 …","ref":"/UnityChipForXiangShan/docs/03_add_test/05_cover_func/","tags":"","title":"功能覆盖率"},{"body":"前端模块验证文档\n","categories":"","description":"","excerpt":"前端模块验证文档\n","ref":"/UnityChipForXiangShan/docs/98_ut/01_frontend/","tags":"","title":"Frontend"},{"body":" 当前版本： 20241204085334-main-335e7e0d4ffc2c7a17f8d95e7c75cbd428b14a61 20241204062337-main-f8903a8c4021ba3e310bf097b07147892729341c 20241201142531-main-365f53f574ba5c6875b3389824a3c898c642ed2b 20241129112435-main-79ccae9d5df92c4e167547564b97bd8846b7ecb6 20241129111104-main-8e0cb45a86ec3ffd779723e17ede379081431c42 查看测试报告 香山昆明湖架构各个模块验证情况如上图中所示。总统计数据如下：\n总测试用例数（Total Cases）： - 测试用例通过数（Passed Cases）： - 测试用例通过率（Passed Rate）： - 测试用例未过数（Failed Cases）： - 测试用例跳过数（Skipped Cases）： - 测试用例跳过率（Skip Rate）： - 总功能覆盖点数（Function Coverage）： - 覆盖点已覆盖数（Covered Functions）： - 覆盖点已覆盖率（Covered Rate）： - 总代码行覆盖率（Total Lines）： - 总代码行覆盖数（Covered Lines）： - 总代码行覆盖率（Covered Rate）： - *总代码行会随着DUT的增加而不断增加，因此：总代码行覆盖率不是最终覆盖率\n其他内容快捷连接：\nDUT文档与功能 待确认bug列表 已发现bug列表 已修复bug列表 正在进行的任务列表 已完成的任务列表 香山昆明湖DUT验证进展 注：本文档中的统计信息根据测试结果自动生成\n数据自动更新日期：1970-01-01 00:00:00 ","categories":"","description":"","excerpt":" 当前版本： 20241204085334-main-335e7e0d4ffc2c7a17f8d95e7c75cbd428b14a61 …","ref":"/UnityChipForXiangShan/docs/","tags":"","title":"进度概述"},{"body":"TBD\n","categories":"","description":"","excerpt":"TBD\n","ref":"/UnityChipForXiangShan/docs/98_ut/01_frontend/02_ifu/","tags":"","title":"IFU"},{"body":"TBD\n","categories":"","description":"","excerpt":"TBD\n","ref":"/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ifu_rvc_exp/","tags":"","title":"IFU-RVC-Expander"},{"body":" 当前版本： 20241204085334-main-335e7e0d4ffc2c7a17f8d95e7c75cbd428b14a61 20241204062337-main-f8903a8c4021ba3e310bf097b07147892729341c 20241201142531-main-365f53f574ba5c6875b3389824a3c898c642ed2b 20241129112435-main-79ccae9d5df92c4e167547564b97bd8846b7ecb6 20241129111104-main-8e0cb45a86ec3ffd779723e17ede379081431c42 查看测试报告 上图共有-个模块，默认情况下模块为灰色，当模块中的测试用例数大于-时，该模块被完全点亮。目前已经完全点亮的模块为-个，待点亮的模块有-个。\n通用处理器模块简介 高性能处理器是现代计算设备的核心，它们通常由三个主要部分组成：前端、后端和访存系统。这些部分协同工作，以确保处理器能够高效地执行复杂的计算任务。\n前端：前端部分，也被称为指令获取和解码阶段，负责从内存中获取指令并将其解码成处理器可以理解的格式。这一阶段是处理器性能的关键，因为它直接影响到处理器可以多快地开始执行指令。前端通常包括指令缓存、分支预测单元和指令解码器。指令缓存用于存储最近访问过的指令，以减少对主内存的访问次数，从而提高处理速度。分支预测单元则尝试预测程序中的条件分支，以便提前获取和解码后续指令，这样可以减少等待分支结果的时间。\n后端：后端部分，也称为执行阶段，是处理器中负责实际执行指令的地方。这一阶段包括了算术逻辑单元（ALU）、浮点单元（FPU）和各种执行单元。这些单元负责进行算术运算、逻辑运算、数据传输和其他处理器操作。后端的设计通常非常复杂，因为它需要支持多种指令集架构（ISA）并优化性能。为了提高效率，现代处理器通常采用超标量架构，这意味着它们可以同时执行多条指令。\n访存：访存系统是处理器与内存之间交互的桥梁。它包括了数据缓存、内存控制器和高速缓存一致性协议。数据缓存用于存储处理器频繁访问的数据，以减少对主内存的访问次数。内存控制器负责管理处理器与内存之间的数据传输。高速缓存一致性协议确保在多处理器系统中，所有处理器看到的内存状态是一致的。\n高性能处理器的设计需要在这三个部分之间找到平衡，以实现最佳的性能。这通常涉及到复杂的微架构设计，以及对处理器流水线的优化。\n","categories":"","description":"","excerpt":" 当前版本： 20241204085334-main-335e7e0d4ffc2c7a17f8d95e7c75cbd428b14a61 …","ref":"/UnityChipForXiangShan/docs/00_unitychip_for_xiangshan/","tags":"","title":"目标验证单元"},{"body":"基础环境需求 本项目基于Python编程语言进行UT验证，采用的工具和测试框架为picker和toffe，环境需求如下：\nLinux操作系统。建议WSL2下安装Ubuntu22.04。 Python。建议Python3.11。 picker。按照快速开始中的提示安装最新版本。 lcov 用于后续test阶段报告生成。使用包管理器即可下载：sudo apt install lcov 环境配置完成后，clone仓库：\ngit clone https://github.com/XS-MLVP/UnityChipForXiangShan.git cd UnityChipForXiangShan pip3 install -r requirements.txt # 安装python依赖（例如 toffee） 下载RTL代码： 默认从仓库https://github.com/XS-MLVP/UnityChipXiangShanRTLs中下载。用户也可以自行按照XiangShan文档编译生成RTL。\nmake rtl # 该命下载最新的rtl代码，并解压至rtl目录，并创建软连接 所有RTL下载包请在UnityChipXiangShanRTLs中查看。\nRTL压缩包的命名规范为：名称-微架构-Git标记-日期编号.tar.gz，例如openxiangshan-kmh-97e37a2237-24092701.tar.gz。在使用时，仓库代码会过滤掉git标记和后缀，例如通过 cfg.rtl.version 访问到的版本号为：openxiangshan-kmh-24092701。压缩包内的目录结构为：\nopenxiangshan-kmh-97e37a2237-24092701.tar.gz └── rtl # 目录 |-- *.sv # 所有sv文件 `-- *.v # 所有v文件 编译DUT 该过程的目的是将RTL通过picker工具打包为Python模块。可以通过make命令指定被打包DUT，也可以一次性打包所有DUT。\n如果想要自行打包某个dut，需要创建编写scripts目录中的build_ut_\u003cname\u003e.py脚本。这一脚本必须实现一个build方法，在打包时会被自动调用。此外还有一个line_coverage_files方法，用于指定行覆盖率参考的文件。\npicker的打包支持内部信号的加入，详见picker的--internal参数，传递给其一个自定义的yaml即可。\n# 调用scripts目录中的build_ut_\u003cname\u003e.py中的build方法，创建待验证的Python版DUT make dut DUTS=\u003cname\u003e # DUTS的值如果有多个，需要用逗号隔开，支持通配符。DUTS默认值为 \"*\"，编译所有DUT # 例如： make dut DUTS=backend_ctrl_block_decode 以make dut DUTS=backend_ctrl_block_decode为例，命令执行完成后，会在dut目录下生成对应的Python包：\ndut/ ├── __init__.py ├── DecodeStage ├── Predecode └── RVCExpander 完成转换后，在测试用例代码中可以import对应的DUT，例如：\nfrom dut.PreDecode import DUTPreDecode dut = DUTPreDecode() 编辑配置 运行rtl、dut、test等命令时，默认使用configs/_default.yaml中的配置项。\n当然，也可以使用自定义配置，方法如下：\n# 指定自定义CFG文件 make CFG=path/to/your_cfg.yaml 类似地，可以在命令行直接指定键值对传入。目前仅有test相关阶段支持命令行配置键值对：\n# 指定KV，传递命令行参数，键值对之间用空格隔开 make test KV=\"log.term-level=\\'debug\\' test.skip-tags=[\\'RARELY_USED\\']\" ","categories":"","description":"","excerpt":"基础环境需求 本项目基于Python编程语言进行UT验证，采用的工具和测试框架为picker和toffe，环境需求如下：\nLinux操作系 …","ref":"/UnityChipForXiangShan/docs/01_verfiy_env/","tags":"","title":"准备验证环境"},{"body":"本项目基于PyTest测试框架进行验证。运行测试时，PyTest框架自动搜索所有test_*.py文件，并自动执行其中所有以test_开头的测试用例（Test Case）。\n# 执行所有ut_*目录中的test case make test_all # 执行指定目录下的test case make test target=\u003cdir\u003e # 例如执行ut_backend/ctrl_block/decode目录中所有的test case make test target=ut_backend/ctrl_block/decode 可通过args参数传递Pytest的运行参数，例如启动x-dist插件的多核功能：\nmake test args=\"-n 4\" # 启用 4 个进程 make test args=\"-n auto\" # 让框架自动选择启用多少个进程 *注：x-dist可以在多节点上并发运行测试，可参考其文档\n运行完成后，默认在out/report目录会生成html版本的测试报告，其 html 文件可通过浏览器直接打开查看（VS Code IDE建议安装Open In Default Browser插件）。\n运行测试主要完成以下三部分内容：\n按要求运行Test Case，可通过cfg.tests中的选项进行配置 统计测试结果，输出测试报告。有toffee-report自动生成 (总测试报告，所有Test的结果合并在一起) 根据需要（cfg.doc_result.disable = True）在测试报告上进行进一步数据统计 ","categories":"","description":"","excerpt":"本项目基于PyTest测试框架进行验证。运行测试时，PyTest框架自动搜索所有test_*.py文件，并自动执行其中所有以test_开头的 …","ref":"/UnityChipForXiangShan/docs/02_run_test/","tags":"","title":"运行测试"},{"body":"添加一个全新的 DUT 测试用例，需要完成以下三部分内容：\n添加编译脚本： 在scripts目录下使用python编写对应rtl的编译文件（例如build_ut_backend_ctrl_block_decode.py）。 构建测试环境： 在目录中创建目标测试 UT 目录（例如ut_backend/ctrl_block/decode）。如果有需要的话，可以在tools、comm等模块中添加该 DUT 测试需要的基础工具。 添加测试用例： 在测试 UT 目录，按PyTest 规范添加测试用例。 如果是在已有的 DUT 测试中增加内容，按原有目录结构添加即可。\n如何通过 picker 和 toffee 库进行 Python 芯片验证，请参考：https://open-verify.cc/mlvp/docs\n在测试时还需要关心以下内容：\nUT 模块说明: 在添加的模块顶层文件夹中，添加README.md说明，具体格式和要求请参考模板。 代码覆盖率：代码覆盖率是芯片验证的重要指标，一般需需要覆盖目标 DUT 的所有代码。 功能覆盖率：功能覆盖率即目标功能验证完成了多少，一般需要达到 100%。 在后续的文档中，我们将以 decode 模块为例，详细说明上述过程。\n*注：目录或文件名称需要合理，以便于能通过命名知晓其具体含义。\n","categories":"","description":"","excerpt":"添加一个全新的 DUT 测试用例，需要完成以下三部分内容：\n添加编译脚本： 在scripts目录下使用python编写对应rtl的编译文件（ …","ref":"/UnityChipForXiangShan/docs/03_add_test/","tags":"","title":"添加测试"},{"body":"如何提交Bug 按 ISSUE 模板进行提交，标记上对应的标签（bug，bug等级等）\n对应模块的维护者进行检查，并修改他给出的标记和香山分\n如何提交文档 本仓库文档文档以PR的形式在本仓库提交，DUT文档在仓库xxxxx中进行提交。\n本项目欢迎任何人以ISSUE、DISCUSS、Fork、PR的方式参与。\n万众一芯QQ交流群：\n","categories":"","description":"","excerpt":"如何提交Bug 按 ISSUE 模板进行提交，标记上对应的标签（bug，bug等级等）\n对应模块的维护者进行检查， …","ref":"/UnityChipForXiangShan/docs/06_join_us/","tags":"","title":"如何参与本项目"},{"body":"# Description Please include a summary of the changes and the related issue. Please also include relevant motivation and context. List any dependencies that are required for this change. Fixes # (issue) ## Type of change Please delete options that are not relevant. - [ ] Bug fix (non-breaking change which fixes an issue) - [ ] New feature (non-breaking change which adds functionality) - [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected) - [ ] This change requires a documentation update # How Has This Been Tested? Please describe the tests that you ran to verify your changes. Provide instructions so we can reproduce. Please also list any relevant details for your test configuration - [ ] Test A - [x] Test B **Test Configuration**: * Firmware version: * Hardware: * Toolchain: * SDK: # Checklist: - [ ] My code follows the style guidelines of this project - [ ] I have performed a self-review of my code - [ ] I have commented my code, particularly in hard-to-understand areas - [ ] I have made corresponding changes to the documentation - [ ] My changes generate no new warnings - [ ] I have added tests that prove my fix is effective or that my feature works - [ ] New and existing unit tests pass locally with my changes - [ ] Any dependent changes have been merged and published in downstream modules 展示效果如下：\nDescription Please include a summary of the changes and the related issue. Please also include relevant motivation and context. List any dependencies that are required for this change.\nFixes # (issue)\nType of change Please delete options that are not relevant.\nBug fix (non-breaking change which fixes an issue) New feature (non-breaking change which adds functionality) Breaking change (fix or feature that would cause existing functionality to not work as expected) This change requires a documentation update How Has This Been Tested? Please describe the tests that you ran to verify your changes. Provide instructions so we can reproduce. Please also list any relevant details for your test configuration\nTest A Test B Test Configuration:\nFirmware version: Hardware: Toolchain: SDK: Checklist: My code follows the style guidelines of this project I have added the appropriate labels I have performed a self-review of my code I have commented my code, particularly in hard-to-understand areas I have made corresponding changes to the documentation My changes generate no new warnings I have added tests that prove my fix is effective or that my feature works New and existing unit tests pass locally with my changes Any dependent changes have been merged and published in downstream modules ","categories":"","description":"","excerpt":"# Description Please include a summary of the changes and the related …","ref":"/UnityChipForXiangShan/docs/08_template_pr/","tags":"","title":"模板-PR"},{"body":"后端模块验证文档\n","categories":"","description":"","excerpt":"后端模块验证文档\n","ref":"/UnityChipForXiangShan/docs/98_ut/02_backend/","tags":"","title":"Backend"},{"body":" 什么是BPU\n","categories":"","description":"","excerpt":" 什么是BPU\n","ref":"/UnityChipForXiangShan/en/docs/bpu/","tags":"","title":"分支预测器（Branch Prediction Unit, BPU）"},{"body":"TBD\n","categories":"","description":"","excerpt":"TBD\n","ref":"/UnityChipForXiangShan/en/docs/bpu/00_ftb/","tags":"","title":"FTB"},{"body":"TBD\n","categories":"","description":"","excerpt":"TBD\n","ref":"/UnityChipForXiangShan/en/docs/bpu/02_ittage/","tags":"","title":"ITTAGE"},{"body":"TBD\n","categories":"","description":"","excerpt":"TBD\n","ref":"/UnityChipForXiangShan/en/docs/bpu/01_tage/","tags":"","title":"TAGE"},{"body":"TBD\n","categories":"","description":"","excerpt":"TBD\n","ref":"/UnityChipForXiangShan/en/docs/","tags":"","title":"XiangShan UT"},{"body":"## Description A brief description of the issue. ## Steps to Reproduce 1. Describe the first step 2. Describe the second step 3. Describe the third step 4. ... ## Expected Result Describe what you expected to happen. ## Actual Result Describe what actually happened. ## Screenshots If applicable, add screenshots to help explain your problem. ## Environment - OS: [e.g. Windows 10, macOS 10.15, Ubuntu 20.04] - Browser: [e.g. Chrome 86, Firefox 82, Safari 14] - Version: [e.g. 1.0.0] ## Additional Information Add any other context about the problem here. 展示效果如下：\nDescription A brief description of the issue.\nSteps to Reproduce Describe the first step Describe the second step Describe the third step … Expected Result Describe what you expected to happen.\nActual Result Describe what actually happened.\nScreenshots If applicable, add screenshots to help explain your problem.\nEnvironment OS: [e.g. Windows 10, macOS 10.15, Ubuntu 20.04] Browser: [e.g. Chrome 86, Firefox 82, Safari 14] Version: [e.g. 1.0.0] Additional Information Add any other context about the problem here.\nChecklist I have searched the existing issues I have added the appropriate labels I have reproduced the issue with the latest version I have provided a detailed description of the bug I have provided steps to reproduce the issue I have included screenshots (if applicable) I have provided the environment details (OS, version, etc.) ","categories":"","description":"","excerpt":"## Description A brief description of the issue. ## Steps to Reproduce …","ref":"/UnityChipForXiangShan/docs/09_template_issue/","tags":"","title":"模板-ISSUE"},{"body":"# 模块名称 ## 测试目标 \u003c测试目标、测试方法描述\u003e ## 测试环境 \u003c测试环境描述，依赖描述\u003e ## 功能检测 \u003c给出目标待测功能与对应的检测方法\u003e |序号|所属模块|功能描述|检查点描述|检查标识|检查项| |-|-|-|-|-|-| |-|-|-|-|-|-| ## 验证接口 \u003c接口的描述\u003e ## 用例说明 #### 测试用例1 |步骤|操作内容|预期结果|覆盖功能点| |-|-|-|-| |-|-|-|-| #### 测试用例2 |步骤|操作内容|预期结果|覆盖功能点| |-|-|-|-| |-|-|-|-| ## 目录结构 \u003c对本模块的目录结构进行描述\u003e ## 检测列表 - [ ] 本文档符合指定[模板]()要求 - [ ] Env提供的API不包含任何DUT引脚和时序信息 - [ ] Env的API保持稳定（共有[ X ]个） - [ ] Env中对所支持的RTL版本（支持版本[ X ]）进行了检查 - [ ] 功能点（共有[ X ]个）与[设计文档]()一致 - [ ] 检查点（共有[ X ]个）覆盖所有功能点 - [ ] 检查点的输入不依赖任何DUT引脚，仅依赖Env的标准API - [ ] 所有测试用例（共有[ X ]个）都对功能检查点进行了反标 - [ ] 所有测试用例都是通过 assert 进行的结果判断 - [ ] 所有DUT或对应wrapper都是通过fixture创建 - [ ] 在上述fixture中对RTL版本进行了检查 - [ ] 创建DUT或对应wrapper的fixture进行了功能和代码行覆盖率统计 - [ ] 设置代码行覆盖率时对过滤需求进行了检查 展示效果如下：\n模块名称 测试目标 \u003c测试目标、测试方法描述\u003e\n测试环境 \u003c测试环境描述，依赖描述\u003e\n功能检测 \u003c给出目标待测功能与对应的检测方法\u003e\n序号 所属模块 功能描述 检查点描述 检查标识 检查项 - - - - - - 验证接口 \u003c接口的描述\u003e\n用例说明 测试用例1 步骤 操作内容 预期结果 覆盖功能点 - - - - 测试用例2 步骤 操作内容 预期结果 覆盖功能点 - - - - 目录结构 \u003c对本模块的目录结构进行描述\u003e\n检测列表 本文档符合指定模板要求 Env提供的API不包含任何DUT引脚和时序信息 Env的API保持稳定（共有[ X ]个） Env中对所支持的RTL版本（支持版本[ X ]）进行了检查 功能点（共有[ X ]个）与设计文档一致 检查点（共有[ X ]个）覆盖所有功能点 检查点的输入不依赖任何DUT引脚，仅依赖Env的标准API 所有测试用例（共有[ X ]个）都对功能检查点进行了反标 所有测试用例都是通过 assert 进行的结果判断 所有DUT或对应wrapper都是通过fixture创建 在上述fixture中对RTL版本进行了检查 创建DUT或对应wrapper的fixture进行了功能和代码行覆盖率统计 设置代码行覆盖率时对过滤需求进行了检查 ","categories":"","description":"","excerpt":"# 模块名称 ## 测试目标 \u003c测试目标、测试方法描述\u003e ## 测试环境 \u003c测试环境描述，依赖描述\u003e ## 功能检测 \u003c给出目标待测功能与对 …","ref":"/UnityChipForXiangShan/docs/10_template_ut_readme/","tags":"","title":"模板-UT-README"},{"body":"访存模块验证文档\n","categories":"","description":"","excerpt":"访存模块验证文档\n","ref":"/UnityChipForXiangShan/docs/98_ut/03_memblock/","tags":"","title":"Mem Block"},{"body":"其他模块验证文档\n","categories":"","description":"","excerpt":"其他模块验证文档\n","ref":"/UnityChipForXiangShan/docs/98_ut/04_misc/","tags":"","title":"Misc"},{"body":"comm 模块 在comm中提供了部分可公用的API，可通过以下方式进行调用：\n# import all from comm import * # or direct import functions you need from com import function_you_need # or access from module import comm comm.function_you_need() cfg 子模块 get_config(cfg=None) 获取当前的Config配置\n输入：如果cfg不为空，则返回cfg。否则则自动通过toffee获取全局Config。 返回：Config对象 import comm cfg = comm.get_config() print(cfg.rtl.version) cfg_as_str(cfg: CfgObject): 把config对象转换为字符类型\n输入：Config对象 返回：编码后的Config对象 import comm cfg_str = comm.cfg_as_str(comm.get_config()) cfg_from_str(cfg_str) 把字符类型的Config对象还原\n输入：编码后的Config对象 返回：Config对象 import comm cfg = comm.cfg_from_str(cfg_str) dump_cfg(cfg: CfgObject = None, cfg_file=None) 把config对象保持到文件\n输入： cfg 需要保存的config cfg_file 目标文件 import comm cfg = comm.get_config() comm.dump_cfg(cfg, \"config.yaml\") functions 子模块 get_log_dir(subdir=\"\", cfg=None) 获取日志目录\n输入： subdir： 子目录 cfg：配置文件 输出：日志目录 import comm my_log = comm.get_log_dir(\"my_log\") print(my_log) # /workspace/UnityChipForXiangShan/out/log/my_log get_out_dir(subdir=\"\", cfg=None) 获取输出目录\n输入： subdir： 子目录 cfg：配置文件 输出：输出目录 get_rtl_dir(subdir=\"\", cfg=None) 获取RTL目录\n输入： subdir： 子目录 cfg：配置文件 输出：RTL目录 get_root_dir(subdir=\"\") 获取根目录：\n输入：根目录下的子目录 输出：当前仓库的根目录 is_all_file_exist(files_to_check, dir) 判断文件是否在指定目录中都存在\n输入： files_to_check: 需要检查的文件列表 dir：目标目录 输出：是否都存在，只要有一个文件不存在都返回False time_format(seconds=None, fmt=\"%Y%m%d-%H%M%S\") 格式化时间\n输入： seconds：需要格式化的时间，为None表示当前时间 fmt：时间格式 返回：格式化之后的时间字符串 import comm import time print(time_format(time.time())) # 20241202-083726 base64_encode(input_str) base64编码：\n输入：需要编码的字符串 输出：编码之后的字符串 import comm print(comm.base64_encode(\"test\")) # dGVzdA== base64_decode(base64_str) base64解码：\n输入：bas64编码 输出：解码之后的原始字符串 import comm print(comm.base64_decode(\"dGVzdA==\")) # test exe_cmd(cmd, no_log=False) 执行操作系统命令：\n输入： cmd：需要执行的os命令 是否需要返回命令行输出 输出：success，stdout、sterr sucess：命令是否执行成功 命令标准输出字符串（no_log=True时，强制为空） 命令标准错误字符串（no_log=True时，强制为空） import comm su, st, er = exe_cmd(\"pwd\") print(st) get_git_commit() 获取当前仓库git commit号\nget_git_branch() 获取当前仓库git 分支名称\nUT_FCOV(group, ignore_prefix=“ut_”) 获取功能覆盖率分组\n输入： group 分组名称 ignore_prefix需要去掉的前缀 输出：带模块前缀的覆盖率分组名 例如，在ut_backend/ctrl_block/decode/env/decode_wrapper.py中调用：\nprint(UT_FCOV(\"../../INT\")) # out backend.ctrl_block.decode.INT get_version_checker(target_version) 获取版本检测函数\n输入：目标版本字符串 输出：检测函数 返回的检测函数，一般在fixture中进行版本判断。\nimport comm import pytest checker = comm.get_version_checker(\"openxiangshan-kmh-24092701+\") @pytest.fixture def fixture(): checker() ... module_name_with(names, prefix=None) 给names统一加上模块前缀\n输入： nanmes 需要添加前缀的字符列表 prefix 模块前缀 返回：添加完成后的字符串列表 例如在a/b/c/d/e.py文件中调用该方法：\nimport comm print(comm.module_name_with([\"X\", \"Y\"], ,\"../../x\")) # out [\"a.b.c.x.X\", \"a.b.c.x.Y\"] ","categories":"","description":"","excerpt":"comm 模块 在comm中提供了部分可公用的API，可通过以下方式进行调用：\n# import all from comm import …","ref":"/UnityChipForXiangShan/docs/95_api/","tags":"","title":"常用API"},{"body":"测试用例管理 如果测试用例和目标RTL版本紧密相关，RTL发生变化，之前的测试用例不一定适用。此外，不同场景下有不同需求，例如验证测试环境时，不运行耗时太长的用例等。因此需要对用例进行管理，让用户能在在特定场景下跳过某些用例。为了实现该目标，我们需要通过pytest.mark.toffee_tags对于每个用例进行tag和version标记。然后在配置文件中设置需要跳过哪些tag或者只运行哪些tag的测试。\n@pytest.mark.toffee_tags(\"my_tag\", \"version1 \u003c version13\") def test_case_1(): ... 例如上述test_case_1被标记上了标签my_tag，支持版本设置为version1到version13。因此可以在配置文件中指定test.skip-tags=[\"my_tag\"]，来表示运行过程中跳过该用例。\npytest.mark.toffee_tags的参数说明如下：\n@pytest.mark.toffee_tags( tag: Optional[list, str] = [] # 用例标签 version: Optional[list, str] = [], # 用例rtl版本需求 skip: callable = None, # 自定义是否调过该用例，skip(tag, version, item): (skip, reason) ) toffee_tags函数的参数tag支持str和list[str]类型。version参数也可以是str和list[str]类型，当为list类型时，进行精确匹配，如果为str则匹配规则如下：\nname-number1 \u003c namer-number2: 表示版本需要在number1和number2之间（包含边界，number表示数字，也可以为小数，eg 1.11） name-number1+：表示number1版本以及以后的版本 name-number1-：表示number1版本以及以前的版本 如果不存在上述情况，且有*或者?表示通配符类型。其他情况为精确匹配。\n预定义标签，可以在comm/constants.py中查看，例如：\n# Predefined tags for test cases TAG_LONG_TIME_RUN = \"LONG_TIME_RUN\" # 运行时间长 TAG_SMOKE = \"SMOKE\" # 冒烟测试 TAG_RARELY_USED = \"RARELY_USED\" # 非常少用 TAG_REGRESSION = \"REGRESSION\" # 回归测试 TAG_PERFORMANCE = \"PERFORMANCE\" # 性能测试 TAG_STABILITY = \"STABILITY\" # 稳定测试 TAG_SECURITY = \"SECURITY\" # 安全测试 TAG_COMPATIBILITY = \"COMPATIBILITY\" # 兼容测试 TAG_OTHER = \"OTHER\" # 其他 TAG_CI = \"CI\" # 集成测试 TAG_DEBUG = \"DEBUG\" # 测试 TAG_DEMO = \"DEMO\" # demo 在默认配置中(config/_default.yaml)，会过滤掉：LONG_TIME_RUN、REGRESSION、RARELY_USED、CI 标记的测试。\n可以通过@pytest.mark.toffee_tags可以为每个用例添加标签，也可以在模块中定义如下变量，实现对整个模块的所有测试用例添加标签。\ntoffee_tags_default_tag = [] # 对应 tag 参数 toffee_tags_default_version = [] # 对应 version 参数 toffee_tags_default_skip = None # 对应 skip 参数 *注：本环境中的版本号会自动过滤掉git标记，例如下载的RTL名称为openxiangshan-kmh-97e37a2237-24092701.tar.gz，则其版本号在本项目中为：openxiangshan-kmh-24092701, 可通过cfg.rtl.version或者comm.get_config().rtl.version获得。\n版本检查 除了可以用标签toffee_tags自动检查版本外，还可以通过get_version_checker主动进行检查。一个单元测试通常由测试环境（Test Env）和测试用例组成（Test Case），Env对RTL引脚和功能进行封装，然后向Case提供稳定API，因此在Env中需要进行RTL版本判断，判断是否需要跳过使用本环境的所有测试用例。例如在Env中：\n... from comm import get_version_checker version_check = get_version_checker(\"openxiangshan-kmh-*\") # 获取RTL版本检查器，同toffee_tags中的veriosn参数 @pytest.fixture() def my_fixture(request): version_check() # 在 fixture 中主动检查 .... yield dut ... 在上述例子中，Env在名称为my_fixture的fixture中主动进行了版本检查。因此，在测试用例每次调用它时都会进行版本检查，如果检查不满足要求，则会跳过该用例的执行。\n仓库目录说明 UnityChipForXiangShan ├── LICENSE # 开源协议 ├── Makefile # Makefile主文件 ├── README.en.md # 英文readme ├── README.zh.md # 中文readme ├── __init__.py # Python模块文件，可以把整个UnityChipForXiangShan当成一个模块进行import ├── pytest.ini # PyTest 配置文件 ├── comm # 公用组件：日志，函数，配置等 ├── configs # 配置文件目录 ├── documents # 文档 ├── dut # dut生成目录 ├── out # log，report等生成目录 ├── requirements.txt # python依赖 ├── rtl # rtl缓存 ├── run.py # 主python入口文件 ├── scripts # dut编译脚本 ├── tools # 公共工具模块 ├── ut_backend # 后端测试用例 ├── ut_frontend # 前端测试用例 ├── ut_mem_block # 访存测试用例 └── ut_misc # 其他测试用例 配置文件说明 默认配置与说明如下：\n# 默认配置文件 # 配置加载顺序: _default.yaml -\u003e 用户指定的 *.yaml -\u003e 命令行参数 eg: log.term-level='debug' # RTL 配置 rtl: # RLT下载地址，从该地址获取所有*.gz.tar文件当成目标RTL base-url: https://\u003cyour_rtl_download_address\u003e # 需要下载的RTL版本 eg: openxiangshan-kmh-97e37a2237-24092701 version: latest # 需要存储RTL的目录，相对于当前配置文件的路径 cache-dir: \"../rtl\" # 测试用例配置（tag和case支持通配符） test: # 跳过标签，所有带有该标签的测试用例都会被跳过 skip-tags: [\"LONG_TIME_RUN\", \"RARELY_USED\", \"REGRESSION\", \"CI\"] # 目标标签，只有带有该标签的测试用例才会被执行（skip-tags会覆盖run-tags） run-tags: [] # 跳过的测试用例，所有带有该名字（或者模块名）的测试用例都会被跳过。 skip-cases: [] # 目标测试用例，只有带有该名字（或者模块名）的测试用例才会被执行（skip-cases会覆盖run-cases）。 run-cases: [] # 跳过异常，所有抛出该异常的测试用例都会被跳过 skip-exceptions: [] # 输出配置 output: # 输出目录，相对于当前配置文件的路径 out-dir: \"../out\" # 测试报告配置 report: # 报告生成目录，相对于output.out-dir report-dir: \"report\" # 报告名称，支持变量替换：%{host} 主机名，%{pid} 进程ID，%{time} 当前时间 report-name: \"%{host}-%{pid}-%{time}/index.html\" # 报告内容 information: # 报告标题 title: \"XiangShan KMH Test Report\" # 报告用户信息 user: name: \"User\" email: \"User@example.email.com\" # 目标行覆盖率 eg: 90 表示 90% line_grate: 99 # 其他需要展示的信息，key为标题，value为内容 meta: Version: \"1.0\" # 日志配置 log: # 根输出级别 root-level: \"debug\" # 终端输出级别 term-level: \"info\" # 文件日志输出级别 file-dir: \"log\" # 文件日志名称，支持变量替换：%{host} 主机名，%{pid} 进程ID，%{time} 当前时间 file-name: \"%{host}-%{pid}-%{time}.log\" # 文件日志输出级别 file-level: \"info\" # 测试结果配置（该数据用于填充documents中的统计图等，原始数据来源于toffee-test生成的report） # 运行完测试后，可通过 `make doc` 查看结果 doc-result: # 是否开测试结果后处理 disable: False # 目标DUT的组织结构配置 dutree: \"%{root}/configs/dutree/xiangshan-kmh.yaml\" # 结果名称，将会保存到输出的report目录 result-name: \"ut_data_progress.json\" # 创建的测试报告的软连接到 hugo report-link: \"%{root}/documents/static/data/reports\" 可在上述配置文件中添加自定义参数，通过cfg = comm.get_config()获取全局配置信息，然后通过cfg.your_key进行访问。cfg信息为只读信息，默认情况下不能进行修改。\n","categories":"","description":"","excerpt":"测试用例管理 如果测试用例和目标RTL版本紧密相关，RTL发生变化，之前的测试用例不一定适用。此外，不同场景下有不同需求，例如验证测试环境 …","ref":"/UnityChipForXiangShan/docs/96_others/","tags":"","title":"其他"},{"body":"为了方便将所有人的贡献集合在一起，需要在编码、环境、文档编写等方面采用相同的“规范”。\n环境要求 python： 在python编码过程中，尽可能的采用标准库，采用兼容Python3大部分版本的通用语法（尽可能的在Python3.6 - Python3.12中通用），不要使用过旧或者过新的语法。 操作系统： 建议Ubuntu 22.04，windows下，建议使用WSL2环境。 hugo 建议版本 0.124.1（版本过旧不支持软连接） 少依赖 尽可能少的使用第三方C++/C库 picker 建议使用wheel安装picker工具和xspcomm库 测试用例 代码风格 建议采用 PEP 8 规范 build脚本 需要按DUT的命名结构进行规范命名，不然无法正确收集验证结果。例如backend.ctrl_block.decodeUT在scripts目录中对应的build文件名称应该为build_ut_backend_ctrl_block_decode.py(以固定前缀build_ut_开始，点.用下划线_进行替换)。在脚本中实现 build(cfg) -\u003e bool 和 line_coverage_files(cfg) -\u003e list[str] 方法。build用于编译DUT为python模块，line_coverage_files方法用于返回需要统计的代码行覆盖率文件。 用例标签 如果用例无法做到版本通用，需要用pytest.mark.toffee_tags标记支持的版本。 用例抽象 编写的测试用例输入不能出现DUT的具体引脚等强耦合内容，只能调用基于DUT之上的函数封装。例如对于加法器 adder，需要把dut的目标功能封装为 dut_wrapper.add(a: int, b: int) -\u003e int, bool，在test_case中仅仅调用 sum, c = add(a, b)进行测试。 覆盖抽象 在编写功能覆盖率时，其检查点函数的输入也不能有DUT引脚。 环境抽象 对于一个验证，通常分为2部分：Test Case 和 Env （用例以外的都统一称为Env，它包含DUT、驱动、监控等），其中Env需要提供对外的功能抽象接口，不能对外呈现出太多细节。 测试说明 在每个DUT的验证环境中，需要通过README.md对该环境进行说明，例如需要对Env提供给Case的接口进行说明，目录结构说明等。 PR编写 标题 简洁明了，能概括PR的主要内容。 详细描述 详细说明PR的目的，修改的内容以及相关背景信息。入解决已有的问题需要给出链接（例如Issue）。 关联问题 在描述中关联相关问题，例如 Fixes #123，以便在合并PR时关闭关联问题。 测试 需要进行测试，并对测试结果进行描述 文档 PR涉及到的文档需要同步修改 分解 当PR涉及到的修改很多时，需要判断是否拆分成多个PR 检查清单 检查编译是否通过、代码风格是否合理、是否测试通过、是否有必要的注释等 模板 以及提供的PR模块请参考链接。 ISSUE编写 要求同上\n","categories":"","description":"","excerpt":"为了方便将所有人的贡献集合在一起，需要在编码、环境、文档编写等方面采用相同的“规范”。\n环境要求 python： 在python编码过程中， …","ref":"/UnityChipForXiangShan/docs/97_constraint/","tags":"","title":"必要规范"},{"body":"","categories":"","description":"","excerpt":"","ref":"/UnityChipForXiangShan/docs/98_ut/","tags":"","title":"验证文档"},{"body":"在提交 issue、pull request、discussion 时，如果指定对应模块的 maintainer 能更及时的得到响应。目前已有的维护人员如下（首字母排名）：\n验证工具：\npicker：Makiras, SFangYy, yaozhicheng toffee/toffe-test：Miical, yaozhicheng 主UT模块：\nfrontend：Gao-Zeyu backend: TBD mem_block: TBD misc: TBD 子UT模块：\nfrontend.bpu.ftb\t: TBD frontend.bpu.uftb\t: TBD frontend.bpu.ittage\t: TBD frontend.bpu.tagesc\t: FrankOu2001 frontend.bpu.ras\t: TBD frontend.ftq\t: TBD frontend.ibuffer\t: TBD frontend.icache\t: TBD frontend.ifu\t: TBD frontend.instr_uncache\t: TBD frontend.itlb\t: TBD frontend.pmp\t: TBD backend.ctrl_block.decode\t: my-mayfly, TheKiteRunner24 backend.ctrl_block.rename.*: TBD backend.ctrl_block.dispatch*: TBD backend.ctrl_block.mem_ctrl: TBD backend.ctrl_block.redirect_gen: TBD backend.ctrl_block.rob: TBD backend.ctrl_block.pc_gpa_mem: TBD backend.data_path: TBD backend.scheduler.*: TBD backend.exu_block.*: TBD backend.og2_for_vector: TBD backend.pc_target_mem: TBD backend.wb_data_path: TBD backend.wb_fu_busy_table: TBD backend.bypass_network: TBD mem_block.lsq.*: TBD mem_block.dtlb: TBD mem_block.load_store_unit: TBD mem_block.dcache: TBD mem_block.pmp: TBD mem_block.prefetcher: TBD mem_block.v_mem.*: TBD mem_block.ptw: TBD mem_block.uncache: TBD mem_block.sbuffer: TBD misc.l2_cache: TBD misc.mmio: TBD *其他维护者陆续更新中\n如果您对本项目感兴趣，欢迎申请成为本项目中的维护者。\n","categories":"","description":"","excerpt":"在提交 issue、pull request、discussion 时，如果指定对应模块的 maintainer 能更及时的得到响应。目前已 …","ref":"/UnityChipForXiangShan/docs/99_maintain/","tags":"","title":"维护者"},{"body":"","categories":"","description":"","excerpt":"","ref":"/UnityChipForXiangShan/en/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/UnityChipForXiangShan/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/UnityChipForXiangShan/en/search/","tags":"","title":"Search Results"},{"body":"","categories":"","description":"","excerpt":"","ref":"/UnityChipForXiangShan/en/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/UnityChipForXiangShan/tags/","tags":"","title":"Tags"},{"body":" ","categories":"","description":"","excerpt":" ","ref":"/UnityChipForXiangShan/en/","tags":"","title":"XiangShan UT Docs"},{"body":" ","categories":"","description":"","excerpt":" ","ref":"/UnityChipForXiangShan/","tags":"","title":"XiangShan UT Docs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/UnityChipForXiangShan/search/","tags":"","title":"搜索结果"}]