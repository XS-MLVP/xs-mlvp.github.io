<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>添加测试 on 万众一芯之香山处理器</title>
    <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/</link>
    <description>Recent content in 添加测试 on 万众一芯之香山处理器</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>添加编译脚本</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/01_build_script/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/01_build_script/</guid>
      <description>脚本目标 该脚本的目标是提供RTL到Python DUT的编译、目标覆盖文件，以及自定义功能等内容。&#xA;创建过程 确定文件名称 在香山昆明湖DUT验证进展中选择需要验证的UT，如果没有或者进一步细化，可通过编辑configs/dutree/xiangshan-kmh.yaml自行添加。&#xA;脚本文件的命名格式如下：&#xA;scripts/build_&amp;lt;顶层模块&amp;gt;_&amp;lt;下层模块名&amp;gt;_..._&amp;lt;目标模块名&amp;gt;.py 目前本项目内置了4个顶层模块：&#xA;ut_frontend 前端 ut_backend 后端 ut_mem_block 访存 ut_misc 其他 其中的子模块没有ut_前缀（顶层目录有该前缀是为了和其他目录区分开）。&#xA;例如验证目标DUT为：backend.ctrl_block.decode，需要创建的脚本名称为 build_ut_backend_ctrl_block_decode.py。&#xA;编写 build(cfg) -&amp;gt; bool 函数 build函数定义如下：&#xA;def build(cfg) -&amp;gt; bool: &amp;#34;&amp;#34;&amp;#34;编译DUT Args: cfg: 运行时配置，可通过它访问配置项，例如 cfg.rtl.version Return: 返回 True 或者 False，表明该函数是否完成预期目标 &amp;#34;&amp;#34;&amp;#34; build在make dut 时会被调用，其主要是将目标 RTL 转换为 Python 模块。在该过程中也可以加入其他必要过程，例如编译依赖项等。以build_ut_backend_ctrl_block_decode.py为例，主要完成了RTL检查、DUT检查、RTL编译、disasm依赖编译等工作：&#xA;def build(cfg) -&amp;gt; bool: # import 相关依赖 from toffee_test.markers import match_version from comm import is_all_file_exist, get_rtl_dir, exe_cmd, get_root_dir # 检查RTL版本（version参数为空，表示所有版本都支持） if not match_version(cfg.</description>
    </item>
    <item>
      <title>构建测试环境</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/02_build_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/02_build_env/</guid>
      <description>确定目录结构 UT(单元测试)所在的目录位置的层级结构应该与名称一致，例如backend.ctrl_block.decode应当位于ut_backend/ctrl_block/decode目录，且每层目录都需要有__init__.py，便于通过 python 进行import。&#xA;ut_backend/ctrl_block/decode ├── env │ ├── decode_wrapper.py │ ├── __init__.py ├── __init__.py ├── README.md └── test_rv_decode.py 模块（例如decode）中的代码目录结构由贡献者自行决定，但需要满足 python 规范，且逻辑和命名合理。&#xA;编写测试环境 在 UT 验证模块的测试环境中，目标是完成以下工作：&#xA;对 DUT 进行功能封装，为测试提供稳定 API 定义功能覆盖率 定义必要 fixture 提供给测试用例 在合理时刻统计覆盖率 以 decode 环境中的 RVCExpander 为例（ut_backend/ctrl_block/decode/env/decode_wrapper.py）：&#xA;1. DUT 封装 class RVCExpander(toffee.Bundle): def __init__(self, cover_group, **kwargs): super().__init__() self.cover_group = cover_group self.dut = DUTRVCExpander(**kwargs) # 创建DUT self.dut.io_in.AsImmWrite() # DUTRVCExpander为组合电路，将输入引脚设置为ImmWrite写入模式 self.io = toffee.Bundle.from_prefix(&amp;#34;io_&amp;#34;, self.dut) # 通过 Bundle 使用前缀关联引脚 self.bind(self.dut) # 把 Bundle 与 DUT 进行绑定 def expand(self, instr): self.</description>
    </item>
    <item>
      <title>添加测试用例</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/03_add_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/03_add_test/</guid>
      <description>命名要求 所有测试用例文件请以test_*.py的方式进行命名，*用测试目标替换（例如test_rv_decode.py）。所有测试用例也需要以test_前缀开头。用例名称需要具有明确意义。&#xA;命名举例如下：&#xA;def test_a(): # 不合理，无法通过a判断测试目标 pass def test_rvc_expand_16bit_full(): # 合理，可以通过用例名称大体知道测试内容 pass 使用 Assert 在每个测试用例中，都需要通过assert来判断本测试是否通过。 pytest统计的是assert语句的结果，因此assert语句需要保证能够通过。&#xA;def test_rvi_inst(decoder, rvc_expander): &amp;#34;&amp;#34;&amp;#34; Test the RVI instruction set. randomly generate instructions for testing Args: decoder (fixure): the fixture of the decoder &amp;#34;&amp;#34;&amp;#34; need_log_file = True insn_list_temp = generate_random_32bits(100) ref_lists = convert_reference_format(rvc_expander, insn_list_temp, True, libdisasm.disasm, libdisasm.disasm_free_mem) assert decode_run(decoder, ref_lists, need_log_file,&amp;#34;test_rvi_inst&amp;#34;) == True, &amp;#34;RVI decode error&amp;#34; g.add_cover_point(decoder, {&amp;#34;illegal_inst_triggers_an_exception&amp;#34;: lambda _: decoder.Get_decode_checkpoint_illeagl_inst() != 0}, name=&amp;#34;RVI_illegal_inst&amp;#34;).sample() g.</description>
    </item>
    <item>
      <title>代码覆盖率</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</guid>
      <description>代码覆盖率是一项评价指标，它衡量了被测代码中哪些部分被执行了，哪些部分没有被执行。通过统计代码覆盖率，可以评估测试的有效性和覆盖程度。&#xA;代码覆盖率包括：&#xA;行覆盖率(line coverage): 被测代码中被执行的行数，最简单的指标，一般期望达到 100%。 条件覆盖率(branch coverage): 每一个控制结构的每个分支是否均被执行。例如，给定一个 if 语句，其 true 和 false 分支是否均被执行？ 有限状态机覆盖率(fsm coverage): 状态机所有状态是否都达到过。 翻转覆盖率(toggle coverage): 统计被测代码中被执行的翻转语句，检查电路的每个节点是否都有 0 -&amp;gt; 1 和 1 -&amp;gt; 0 的跳变。 路径覆盖率(path coverage): 检查路径的覆盖情况。在 always 语句块和 initial 语句块中，有时会使用 if &amp;hellip; else 和 case 语句，在电路结构上便会产生一系列的数据路径。。 本项目中相关涉及位置 添加编译脚本 picker 命令行开启代码覆盖率(&amp;quot;-c&amp;quot;参数)、设置目标覆盖文件(line_coverage_files 函数)&#xA;构建测试环境-3.定义必要 fixture 通过函数toffee-test.set_line_coverage把覆盖率文件传递给 toffe-test。&#xA;忽略指定统计 1、通过 verilator 指定忽略统计的内容&#xA;2、提过 toffee 指定需要过滤掉的内存&#xA;def set_line_coverage(request, datfile, ignore=[]): &amp;#34;&amp;#34;&amp;#34;Pass Args: request (pytest.Request): Pytest的默认fixture， datfile (string): DUT生成的 ignore (list[str]): 覆盖率过滤文件/或者文件夹 &amp;#34;&amp;#34;&amp;#34; ignore 参数可以指定在覆盖率文件中需要过滤掉的内容，例如：</description>
    </item>
    <item>
      <title>功能覆盖率</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</guid>
      <description>什么是功能覆盖率 [TBD]、为什么需要反标 功能覆盖率（Functional Coverage）是一种用户定义的度量标准，用于度量验证中已执行的设计规范的比例。功能覆盖率关注的是设计的功能和特性是否被测试用例覆盖到了。&#xA;反标是指从功能测试回溯到代码覆盖率，通过将功能点与代码逻辑关联起来，反向追踪测试覆盖率。 例如：&#xA;将功能点映射到相关代码模块或路径。 检查测试覆盖率工具报告，分析对应功能点的代码是否被执行。 确定测试用例对功能的覆盖程度，以及代码的遗漏部分。 本项目中相关涉及位置 在构建测试环境中：&#xA;定义功能覆盖率： 创建了功能覆盖率组,添加观察点和反标 定义必要fixture： 把统计结果传递给toffee-report 统计覆盖率： 添加观察点和反标 其他：&#xA;Test case中使用 指定Group名称 测试报告通过Group名字和 DUT名字进行匹配，利用comm.UT_FCOV 获取 DUT前缀，例如在Python模块ut_backend/ctrl_block/decode/env/decode_wrapper.py中进行如下调用：&#xA;from comm import UT_FCOV # 本模块名为：ut_backend.ctrl_block.decode.env.decode_wrapper # 通过../../去掉了上级模块env和decode_wrapper # UT_FCOV会默认去掉前缀 ut_ name = UT_FCOV(&amp;#34;../../INT&amp;#34;) name的值为backend.ctrl_block.decode.INT，在最后统计结果时，会按照最长前缀匹配到目标UT（即匹配到：backend.ctrl_block.decode 模块）</description>
    </item>
  </channel>
</rss>
