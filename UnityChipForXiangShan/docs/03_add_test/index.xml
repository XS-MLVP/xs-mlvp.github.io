<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>添加测试 on 万众一芯之香山处理器</title>
    <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/</link>
    <description>Recent content in 添加测试 on 万众一芯之香山处理器</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>添加编译脚本</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/01_build_script/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/01_build_script/</guid>
      <description>脚本目标 该脚本的目标是提供RTL到Python DUT的编译、目标覆盖文件，以及自定义功能等内容。&#xA;创建过程 确定文件名称 在香山昆明湖DUT验证进展中选择需要验证的UT，如果没有或者进一步细化，可通过编辑config/dutree/xiangshan=lmh.yaml自行添加。&#xA;脚本文件的命名格式如下：&#xA;scripts/build_ut_&amp;lt;顶层模块&amp;gt;_&amp;lt;下层模块名&amp;gt;[...].&amp;lt;目标模块名&amp;gt;.py 目前本项目内置了4个顶层模块：&#xA;ut_frontend 前端 ut_backend 后端 ut_mem_block 访存 ut_misc 其他 其中的子模块没有ut_前缀（顶层目录有该前缀是为了和其他目录区分开）。&#xA;例如验证目标DUT为：backend.ctrl_block.decode，需要创建的脚本名称为 build_ut_backend_ctrl_block_decode.py。&#xA;编写 build(cfg) -&amp;gt; bool 函数 build函数定义如下：&#xA;def build(cfg) -&amp;gt; bool: &amp;#34;&amp;#34;&amp;#34;编译DUT Args: cfg: 运行时配置，可通过它访问配置项，例如 cfg.rtl.version Return: 返回 True 或者 False，表明该函数是否完成预期目标 &amp;#34;&amp;#34;&amp;#34; build在make dut 时会被调用，其主要是将目标 RTL 转换为 Python 模块。在该过程中也可以加入其他必要过程，例如编译依赖项等。以build_ut_backend_ctrl_block_decode.py为例，主要完成了RTL检查、DUT检查、RTL编译、disasm依赖编译等工作：&#xA;def build(cfg) -&amp;gt; bool: # import 相关依赖 from toffee_test.markers import match_version from comm import is_all_file_exist, get_rtl_dir, exe_cmd, get_root_dir # 检查RTL版本（version参数为空，表示所有版本都支持） if not match_version(cfg.</description>
    </item>
    <item>
      <title>构建测试环境</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/02_build_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/02_build_env/</guid>
      <description>确定目录结构 单元测试所在的目录位置的层级结构应该与名称一致，例如backend.ctrl_block.decode应当位于ut_backend/ctrl_block/decode目录，且每层目录都需要有__init__.py，便于通过Python进行import。模块（例如decode）中的代码目录结构由贡献者自行决定，当需要满足python规范，且逻辑合理，命名合理。&#xA;编写测试环境 在UT验证模块的测试环境中，目标是完成以下工作：&#xA;对DUT进行功能封装，提供稳定测试API 定义功能覆盖率 定义必要fixture提供给测试用例 在合理时刻统计覆盖率 以decode环境中的RVCExpander为例（ut_backend/ctrl_block/decode/env/decode_wrapper.py）：&#xA;1. DUT封装 class RVCExpander(toffee.Bundle): def __init__(self, cover_group, **kwargs): super().__init__() self.cover_group = cover_group self.dut = DUTRVCExpander(**kwargs) # 创建DUT self.dut.io_in.AsImmWrite() # DUTRVCExpander为组合电路，将输入引脚设置为ImmWrite写入模式 self.io = toffee.Bundle.from_prefix(&amp;#34;io_&amp;#34;, self.dut) # 通过 Bundle 关联引脚 self.bind(self.dut) # 把 Bunldle 与 DUT 进行绑定 def expand(self, instr): self.io[&amp;#34;in&amp;#34;].value = instr # 给DUT引脚赋值 self.dut.RefreshComb() # 推动组合电路 self.cover_group.sample() # 调用sample对功能覆盖率进行统计 return self.io[&amp;#34;out_bits&amp;#34;].value, self.io[&amp;#34;ill&amp;#34;].value # 返回结果 和 是否是非法指令 def stat(self): # 获取当前状态 return { &amp;#34;instr&amp;#34;: self.</description>
    </item>
    <item>
      <title>添加测试用例</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/03_add_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/03_add_test/</guid>
      <description>命名要求 所有测试用例文件请以test_*.py的方式进行命名，*用测试目标替换。所有测试用例也需要以test_前缀开头。用例名称需要具有明确意义。&#xA;命名举例如下：&#xA;def test_a(): # 不合理，无法通过a判断测试目标 pass def test_rvc_expand_16bit_full(): # 合理，可以通过用例名称大体知道测试内容 pass 使用Assert 在每个测试用例中，都需要通过 assert 来判断本测试是否通过。&#xA;编写注释 每个测试用例都需要添加必要的说明和注释，需要满足Python注释规范。&#xA;测试用例说明参考格式：&#xA;def test_&amp;lt;name&amp;gt;(a: type_a, b: type_b): &amp;#34;&amp;#34;&amp;#34;Test abstract Args: a (type_a): description of arg a. b (type_b): description of arg b. Detailed test description here (if need). &amp;#34;&amp;#34;&amp;#34; ... 用例管理 为了方便测试用例管理，可通过toffee-test提供的@pytest.mark.toffee_tags标签功能，请参考此处。&#xA;参考用例 如果很多测试用例（Test）具有相同的操作，该公共操作部分可以提炼成一个通用函数。以RVCExpander验证为例，可以把压缩指令的展开与参考模型（disasm）的对比封装成以下函数：&#xA;def rvc_expand(rvc_expander, ref_insts): &amp;#34;&amp;#34;&amp;#34;compare the RVC expand result with the reference Args: rvc_expander (warpper): the fixture of the RVC expander ref_insts (list[int]]): the reference instruction list &amp;#34;&amp;#34;&amp;#34; find_error = 0 for insn in ref_insts: insn_disasm = disasmbly(insn) _, instr_ex = rvc_expander.</description>
    </item>
    <item>
      <title>代码覆盖率</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</guid>
      <description>TBD [简单描述 + 参考]&#xA;本项目中相关涉及位置 1. build script picker命令行开启代码覆盖率(picker -c参数)、设置目标覆盖文件(line_coverage_files函数)&#xA;1. Env中的fixture 通过函数toffee-test.set_line_coverage把覆盖率文件传递给toffe-test。&#xA;忽略指定统计 1、通过 verilator 指定忽略统计的内容&#xA;2、提过toffee指定需要过滤掉的内存&#xA;def set_line_coverage(request, datfile, ignore=[]): &amp;#34;&amp;#34;&amp;#34;Pass Args: request (pytest.Request): Pytest的默认fixture， datfile (string): DUT生成的 ignore (list[str]): 覆盖率过滤文件/或者文件夹 &amp;#34;&amp;#34;&amp;#34; ignore参数可以指定在覆盖率文件中需要过滤掉的内容，例如：&#xA;... set_line_coverage(request, coverage_file, get_root_dir(&amp;#34;scripts/backend_ctrlblock_decode&amp;#34;)) 在统计覆盖率时，会在&amp;quot;scripts/backend_ctrlblock_decode&amp;quot;目录中搜索到line_coverage.ignore文件，然后按其中没行的通配符进行过滤。&#xA;查看统计结果 在 测试报告 和 进度章节 有展示</description>
    </item>
    <item>
      <title>功能覆盖率</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</guid>
      <description>什么是功能覆盖率 [TBD]、为什么需要反标&#xA;本项目中相关涉及位置 1、Env 中创建 cover group 2、Env 或者 Test case中使用 3、fixture传递结果给toffee-report&#xA;指定Group名称 测试报告通过Group名字和 DUT名字进行匹配，利用comm.UT_FCOV 获取 DUT前缀，例如在Python模块ut_backend/ctrl_block/decode/env/decode_wrapper.py中进行如下调用：&#xA;from comm import UT_FCOV # 本模块名为：ut_backend.ctrl_block.decode.env.decode_wrapper # 通过../../去掉了上级模块env和decode_wrapper # UT_FCOV会默认去掉前缀 ut_ name = UT_FCOV(&amp;#34;../../INT&amp;#34;) name的值为backend.ctrl_block.decode.INT，在最后统计结果时，会安装最长前缀匹配到目标UT（即匹配到：backend.ctrl_block.decode 模块）</description>
    </item>
  </channel>
</rss>
