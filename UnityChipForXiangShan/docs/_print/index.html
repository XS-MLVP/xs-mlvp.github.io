<!doctype html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-cn" class="no-js">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="canonical" type="text/html" href="https://open-verify.cc/UnityChipForXiangShan/docs/">
<link rel="alternate" type="application/rss&#43;xml" href="https://open-verify.cc/UnityChipForXiangShan/docs/index.xml">
<meta name="robots" content="noindex, nofollow">


<link rel="shortcut icon" href="/UnityChipForXiangShan/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/UnityChipForXiangShan/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/android-192x192.png" sizes="192x192">

<title>进度概述 | 万众一芯之香山处理器</title>
<meta name="description" content="本项目旨在通过开源众包的方式对香山处理器的昆明湖架构进行单元（Unit Test, UT）验证。下图是香山昆明湖架构各个模块验证情况。
当前版本： 20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty 查看测试报告 总统计数据如下：
总测试用例数（Total Cases）： - 测试用例通过数（Passed Cases）： - 测试用例通过率（Passed Rate）： - 测试用例未过数（Failed Cases）： - 测试用例跳过数（Skipped Cases）： - 测试用例跳过率（Skip Rate）： - 总功能覆盖点数（Function Coverage）： - 覆盖点已覆盖数（Covered Functions）： - 覆盖点已覆盖率（Covered Rate）： - 总代码行覆盖率（Total Lines）： - 总代码行覆盖数（Covered Lines）： - 总代码行覆盖率（Covered Rate）： - *总代码行会随着DUT的增加而不断增加，因此：总代码行覆盖率不是最终覆盖率">
<meta property="og:url" content="https://open-verify.cc/UnityChipForXiangShan/docs/">
  <meta property="og:site_name" content="万众一芯之香山处理器">
  <meta property="og:title" content="进度概述">
  <meta property="og:description" content="本项目旨在通过开源众包的方式对香山处理器的昆明湖架构进行单元（Unit Test, UT）验证。下图是香山昆明湖架构各个模块验证情况。
当前版本： 20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty 查看测试报告 总统计数据如下：
总测试用例数（Total Cases）： - 测试用例通过数（Passed Cases）： - 测试用例通过率（Passed Rate）： - 测试用例未过数（Failed Cases）： - 测试用例跳过数（Skipped Cases）： - 测试用例跳过率（Skip Rate）： - 总功能覆盖点数（Function Coverage）： - 覆盖点已覆盖数（Covered Functions）： - 覆盖点已覆盖率（Covered Rate）： - 总代码行覆盖率（Total Lines）： - 总代码行覆盖数（Covered Lines）： - 总代码行覆盖率（Covered Rate）： - *总代码行会随着DUT的增加而不断增加，因此：总代码行覆盖率不是最终覆盖率">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="website">

  <meta itemprop="name" content="进度概述">
  <meta itemprop="description" content="本项目旨在通过开源众包的方式对香山处理器的昆明湖架构进行单元（Unit Test, UT）验证。下图是香山昆明湖架构各个模块验证情况。
当前版本： 20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty 查看测试报告 总统计数据如下：
总测试用例数（Total Cases）： - 测试用例通过数（Passed Cases）： - 测试用例通过率（Passed Rate）： - 测试用例未过数（Failed Cases）： - 测试用例跳过数（Skipped Cases）： - 测试用例跳过率（Skip Rate）： - 总功能覆盖点数（Function Coverage）： - 覆盖点已覆盖数（Covered Functions）： - 覆盖点已覆盖率（Covered Rate）： - 总代码行覆盖率（Total Lines）： - 总代码行覆盖数（Covered Lines）： - 总代码行覆盖率（Covered Rate）： - *总代码行会随着DUT的增加而不断增加，因此：总代码行覆盖率不是最终覆盖率">
  <meta itemprop="dateModified" content="2025-09-22T09:16:42+08:00">
  <meta itemprop="wordCount" content="55">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="进度概述">
  <meta name="twitter:description" content="本项目旨在通过开源众包的方式对香山处理器的昆明湖架构进行单元（Unit Test, UT）验证。下图是香山昆明湖架构各个模块验证情况。
当前版本： 20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty 查看测试报告 总统计数据如下：
总测试用例数（Total Cases）： - 测试用例通过数（Passed Cases）： - 测试用例通过率（Passed Rate）： - 测试用例未过数（Failed Cases）： - 测试用例跳过数（Skipped Cases）： - 测试用例跳过率（Skip Rate）： - 总功能覆盖点数（Function Coverage）： - 覆盖点已覆盖数（Covered Functions）： - 覆盖点已覆盖率（Covered Rate）： - 总代码行覆盖率（Total Lines）： - 总代码行覆盖数（Covered Lines）： - 总代码行覆盖率（Covered Rate）： - *总代码行会随着DUT的增加而不断增加，因此：总代码行覆盖率不是最终覆盖率">
<link rel="preload" href="/UnityChipForXiangShan/scss/main.min.356574e8308264151b533ef504ebe576b67671f54b4f4d7f8077b25dc08441c6.css" as="style" integrity="sha256-NWV06DCCZBUbUz71BOvldrZ2cfVLT01/gHeyXcCEQcY=" crossorigin="anonymous">
<link href="/UnityChipForXiangShan/scss/main.min.356574e8308264151b533ef504ebe576b67671f54b4f4d7f8077b25dc08441c6.css" rel="stylesheet" integrity="sha256-NWV06DCCZBUbUz71BOvldrZ2cfVLT01/gHeyXcCEQcY=" crossorigin="anonymous">
<script
  src="https://code.jquery.com/jquery-3.7.1.min.js"
  integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g=="
  crossorigin="anonymous"></script>
<script defer
  src="https://unpkg.com/lunr@2.3.9/lunr.min.js"
  integrity="sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli"
  crossorigin="anonymous"></script>
<link rel="stylesheet" href="/UnityChipForXiangShan/css/prism.css"/>

    <script>
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?6aacb1c7ca0a3ef4e3aa84c1eaa237dd";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
    </script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z2ZY6ZE84"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-4Z2ZY6ZE84');
    </script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />

<script>
    $(document).ready(function() {
        $('a[name="multi-lang-toggle"]').on('click', function(event) {
            var language = $(this).attr('lang');
            var codeDiv = $(this).closest('.highlight');
            var preNodes = codeDiv.find('pre');
            preNodes.each(function(index, preNode) {
                if ($(preNode).attr("name").toLowerCase().indexOf(language.toLowerCase()) !== -1) {
                    preNode.style.display = 'block';
                } else {
                    preNode.style.display = 'none';
                }
            });
            var alist = codeDiv.find('a[name="multi-lang-toggle"]');
            alist.each(function(index, aNode) {
                if ($(aNode).attr('lang').toLowerCase() === language.toLowerCase()) {
                    aNode.style.fontWeight = 'bold';
                } else {
                    aNode.style.fontWeight = 'normal';
                }
            });
        })
        $(this).find('pre[name^="group-lang-code-"]').each(function(index, preNode) {
            if (preNode.style.display !== 'none') {
                var language = $(preNode).attr("name").replace('group-lang-code-', '');
                var alist = $(this).closest('.highlight').find('a[name="multi-lang-toggle"]');
                alist.each(function(index, aNode) {
                    if ($(aNode).attr('lang').toLowerCase() === language.toLowerCase()) {
                        aNode.style.fontWeight = 'bold';
                    } else {
                        aNode.style.fontWeight = 'normal';
                    }
                });
            }
        });
    });
</script>
    
  </head>
  <body class="td-section">
    <header>
      <nav class="td-navbar js-navbar-scroll" data-bs-theme="dark">
<div class="container-fluid flex-column flex-md-row">
  <a class="navbar-brand" href="/UnityChipForXiangShan/"><span class="navbar-brand__logo navbar-logo"><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" style="enable-background:new 0 0 500 500"><g><path style="fill:#fff" d="M116.8525 421.9722c-5.7041.0-10.3442-4.3127-10.3442-9.6129V88.183c0-5.3002 4.6401-9.6117 10.3442-9.6117H320.858c3.0347.0 9.3959.5498 11.7506 2.6302l.3545.3442 58.905 63.2912c2.3101 2.491 2.9202 8.4928 2.9202 11.3184v256.2039c0 5.3002-4.6407 9.6129-10.3436 9.6129H116.8525z"/><g><g><g><path style="fill:#767676" d="M384.4445 423.2066H116.852c-6.3839.0-11.5786-4.8658-11.5786-10.8474V88.1831c0-5.9804 5.1947-10.8461 11.5786-10.8461h204.0062c.377.0 9.2786.0329 12.568 2.9389l.3947.3833 58.9508 63.337c3.2135 3.4652 3.2514 11.7924 3.2514 12.1593v256.2036C396.0231 418.3408 390.8284 423.2066 384.4445 423.2066zM116.5079 411.9189c.0848.0278.1999.0531.3441.0531h267.5925c.1442.0.2581-.0253.3441-.0531V156.1556c-.0076-.9033-.3593-3.7347-.7034-5.0037l-57.6527-61.9416c-1.4651-.3176-4.4533-.6389-5.5742-.6389H116.852c-.143.0-.2594.024-.3441.0531V411.9189zm267.4533-261.149zM327.0321 89.371v.0013V89.371z"/></g></g></g><g><g><path style="fill:#5b7fc0" d="M189.0874 210.1754l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4473C177.5953 212.627 183.0601 210.1742 189.0874 210.1754zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 234.1722 197.0804 232.033z"/><path style="opacity:.3;fill:#fff" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/><g><defs><path id="SVGID_1_" d="M194.7376 237.6875c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 234.2399 196.1861 236.239 194.7376 237.6875z"/></defs><clipPath id="SVGID_2_"><use xlink:href="#SVGID_1_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_2_);fill:#fff" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/><path style="opacity:.13;clip-path:url(#SVGID_2_);fill:#020202" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/></g><g><defs><path id="SVGID_3_" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/></defs><clipPath id="SVGID_4_"><use xlink:href="#SVGID_3_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_4_);fill:#5b7fc0" d="M172.6595 215.6045c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8475-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 209.1953 176.6171 211.647 172.6595 215.6045z"/></g></g><rect x="198.8952" y="225.1043" style="fill:#5b7fc0" width="122.6266" height="13.8671"/></g><g><path style="fill:#d95140" d="M189.0874 155.7611l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.0249 2.454-11.4897 6.4116-15.4473C177.5953 158.2128 183.0601 155.7599 189.0874 155.7611zm7.993 21.8577c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.2508 181.7667 197.0816 179.758 197.0804 177.6188z"/><path style="opacity:.3;fill:#fff" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/><g><defs><path id="SVGID_5_" d="M194.7376 183.2733c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 179.8256 196.1861 181.8248 194.7376 183.2733z"/></defs><clipPath id="SVGID_6_"><use xlink:href="#SVGID_5_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_6_);fill:#fff" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/><path style="opacity:.13;clip-path:url(#SVGID_6_);fill:#020202" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/></g><g><defs><path id="SVGID_7_" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/></defs><clipPath id="SVGID_8_"><use xlink:href="#SVGID_7_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_8_);fill:#d95140" d="M172.6595 161.1903c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 154.7811 176.6171 157.2327 172.6595 161.1903z"/></g><rect x="198.8952" y="170.69" style="fill:#d95140" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#56a55c" d="M189.5379 264.6147l.0012-.0012c7.7751.0012 15.0294 4.1862 18.932 10.9235 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032-5.8394.0-11.3281-2.2733-15.458-6.4032-4.13-4.13-6.4032-9.6186-6.4056-15.4628.0012-6.0249 2.454-11.4897 6.4116-15.4472C178.0458 267.0663 183.5105 264.6135 189.5379 264.6147zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6538 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.7013 290.6202 197.5321 288.6115 197.5309 286.4723z"/><path style="opacity:.3;fill:#fff" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/><g><defs><path id="SVGID_9_" d="M195.1881 292.1268c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9941 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.5344 288.6792 196.6366 290.6783 195.1881 292.1268z"/></defs><clipPath id="SVGID_10_"><use xlink:href="#SVGID_9_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_10_);fill:#fff" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/><path style="opacity:.13;clip-path:url(#SVGID_10_);fill:#020202" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/></g><g><defs><path id="SVGID_11_" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/></defs><clipPath id="SVGID_12_"><use xlink:href="#SVGID_11_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_12_);fill:#56a55c" d="M173.11 270.0439c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7325-11.1497-10.9151-18.926-10.9151C182.5311 263.6346 177.0676 266.0863 173.11 270.0439z"/></g></g><rect x="199.3456" y="279.5436" style="fill:#56a55c" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#f1bc42" d="M189.0874 318.7208l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3305-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4472C177.5953 321.1724 183.0601 318.7196 189.0874 318.7208zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 342.7176 197.0804 340.5784z"/><path style="opacity:.3;fill:#fff" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/><g><defs><path id="SVGID_13_" d="M194.7376 346.2329c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 342.7853 196.1861 344.7844 194.7376 346.2329z"/></defs><clipPath id="SVGID_14_"><use xlink:href="#SVGID_13_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_14_);fill:#fff" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/><path style="opacity:.13;clip-path:url(#SVGID_14_);fill:#020202" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/></g><g><defs><path id="SVGID_15_" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/></defs><clipPath id="SVGID_16_"><use xlink:href="#SVGID_15_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_16_);fill:#f1bc42" d="M172.6595 324.15c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8474-1.0151-7.6327-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 317.7407 176.6171 320.1924 172.6595 324.15z"/></g></g><rect x="198.8952" y="333.6497" style="fill:#f1bc42" width="122.6266" height="13.8671"/></g></g></svg></span><span class="navbar-brand__name">万众一芯之香山处理器</span></a>
  <div class="td-navbar-nav-scroll ms-md-auto" id="main_navbar">
    <ul class="navbar-nav">
      <li class="nav-item dropdown d-none d-lg-block">
        <div class="dropdown">
  <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">中文</a>
  <ul class="dropdown-menu">
    <li><a class="dropdown-item" href="/UnityChipForXiangShan/en/docs/">English</a></li>
    </ul>
</div></li>
      </ul>
  </div>
  <div class="d-none d-lg-block">
    <div class="td-search td-search--offline">
  <div class="td-search__icon"></div>
  <input
    type="search"
    class="td-search__input form-control"
    placeholder="站内搜索…"
    aria-label="站内搜索…"
    autocomplete="off"
    
    data-offline-search-index-json-src="/UnityChipForXiangShan/offline-search-index.70b91e43a4f67e624b2f2e817b8fa993.json"
    data-offline-search-base-href="/"
    data-offline-search-max-results="10"
  >
</div>
  </div>
</div>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 ps-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/UnityChipForXiangShan/docs/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">进度概述</h1>





    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-0dcba8abab46333b47bb5f2e2beb4acc">目标验证单元</a></li>


    
  
    
    
	
<li>2: <a href="#pg-e819c695f47dc3893fee99c05230ff78">准备验证环境</a></li>


    
  
    
    
	
<li>3: <a href="#pg-a5fd55875e0540351befe9b3a6e05b98">运行测试</a></li>


    
  
    
    
	
<li>4: <a href="#pg-6f6b342069bf0da19ce0bf410bce92e2">添加测试</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>4.1: <a href="#pg-dbf9b443ff7a2ae1b419d7f271fac95a">添加编译脚本</a></li>


    
  
    
    
	
<li>4.2: <a href="#pg-53f38485d7ee0ef1d06f36fbe61bda5b">构建测试环境</a></li>


    
  
    
    
	
<li>4.3: <a href="#pg-4cd74e2d3f7d9b1031b77dd328511afa">添加测试用例</a></li>


    
  
    
    
	
<li>4.4: <a href="#pg-c6c51e44e9add2a2d66a22a310fc796b">代码覆盖率</a></li>


    
  
    
    
	
<li>4.5: <a href="#pg-f2938880e10d36d978ade908698b9760">功能覆盖率</a></li>


    
  

    </ul>
    
  
    
    
	
<li>5: <a href="#pg-07ebcfe55daf3596c9e3470979e4e81e">如何参与本项目</a></li>


    
  
    
    
	
<li>6: <a href="#pg-1d0ac3d7094a9a644440034e44c77115">模板-PR</a></li>


    
  
    
    
	
<li>7: <a href="#pg-4efe7d3d46d7929f2a2b248110be165b">模板-ISSUE</a></li>


    
  
    
    
	
<li>8: <a href="#pg-68658f28e70d830f706f538c1d44b165">模板-UT-README</a></li>


    
  
    
    
	
<li>9: <a href="#pg-08609283b091262ac299662399e11d12">常用API</a></li>


    
  
    
    
	
<li>10: <a href="#pg-8a2981468f57aaf0314d1df6c5431ce9">其他</a></li>


    
  
    
    
	
<li>11: <a href="#pg-69941129f79fb8261f7f1fe7b92e7c0a">必要规范</a></li>


    
  
    
    
	
<li>12: <a href="#pg-a8a5b9eb9136a6246521abc3abcc6fe5">验证文档</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>12.1: <a href="#pg-896ce137500976f8efacd0b63e691b2b">验证文档规范</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>12.1.1: <a href="#pg-2764f80f939ebbd5618718ed34996a4c">文档模板</a></li>


    
  
    
    
	
<li>12.1.2: <a href="#pg-7a9ca318935b3c19c5a8b79dbfbdeb2b">FIFO文档案例</a></li>


    
  
    
    
	
<li>12.1.3: <a href="#pg-819feb66d3ed443e53bb22589b5ccde0">果壳Cache文档案例</a></li>


    
  

    </ul>
    
  
    
    
	
<li>12.2: <a href="#pg-3f5913187fe632a6790a8f4605680463">Frontend</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>12.2.1: <a href="#pg-caf9bb86b5b54160af08befebec88eee">FTQ概述</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>12.2.1.1: <a href="#pg-7ff52559ce920632c127396bd7ec9421">FTQ顶层</a></li>


    
  
    
    
	
<li>12.2.1.2: <a href="#pg-8b82b413ea6abfeab9ebac3ba72e7b9c">FTQ子队列</a></li>


    
  
    
    
	
<li>12.2.1.3: <a href="#pg-a08c000e80bb83d7987b168d3f0ac2f5">FTQ接收BPU分支预测结果</a></li>


    
  
    
    
	
<li>12.2.1.4: <a href="#pg-bbc889120c17b68caa4f605372b47a0e">FTQ向IFU发送取指目标</a></li>


    
  
    
    
	
<li>12.2.1.5: <a href="#pg-902c9098c896a3c8e9e6f1dff8bed38e">IFU向FTQ写回预译码信息</a></li>


    
  
    
    
	
<li>12.2.1.6: <a href="#pg-9c89ab197585abfab0c8084355d958c0">FTQ接收后端重定向</a></li>


    
  
    
    
	
<li>12.2.1.7: <a href="#pg-a21c8d5c61630fe55cf5e4227e97c8f6">FTQ接收IFU重定向</a></li>


    
  
    
    
	
<li>12.2.1.8: <a href="#pg-d5eaae05e615ad48e9d4009fee393d14">FTQ向后端发送取指目标</a></li>


    
  
    
    
	
<li>12.2.1.9: <a href="#pg-060cd9108a272839369f1158228bfaa9">执行单元修改FTQ状态队列</a></li>


    
  
    
    
	
<li>12.2.1.10: <a href="#pg-63ebff3aa1d2952064b973785cdcbf35">冲刷指针和状态队列</a></li>


    
  
    
    
	
<li>12.2.1.11: <a href="#pg-5a73ff17101ad6634015b300133e5fb2">FTQ向BPU发送更新与重定向信息</a></li>


    
  

    </ul>
    
  
    
    
	
<li>12.2.2: <a href="#pg-67bdf4e7d2ffbf4ef76d0613f5caefbf">ICache</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>12.2.2.1: <a href="#pg-9dd28b73c093d88ee2b921332ab31c44">CtrlUnit</a></li>


    
  
    
    
	
<li>12.2.2.2: <a href="#pg-cc1ecb7ceb308765a81e31303c5aea88">ICache</a></li>


    
  
    
    
	
<li>12.2.2.3: <a href="#pg-50120bb49e006cebe08f3f3d10a23195">IPrefetchPipe</a></li>


    
  
    
    
	
<li>12.2.2.4: <a href="#pg-777e92538bab7ee062508e3c71e1460d">MainPipe</a></li>


    
  
    
    
	
<li>12.2.2.5: <a href="#pg-10e6e7e44838197595b01ddda75ad636">MissUnit</a></li>


    
  
    
    
	
<li>12.2.2.6: <a href="#pg-8feff2ec4ca745f27b9938a74f513167">WayLookup</a></li>


    
  

    </ul>
    
  
    
    
	
<li>12.2.3: <a href="#pg-025e98ca37bba9c567819bf7fb3e31b4">IFU</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>12.2.3.1: <a href="#pg-b6043999ec4323fa2a7093430cf55927">F3PreDecoder</a></li>


    
  
    
    
	
<li>12.2.3.2: <a href="#pg-5f2f31e1befa41958bf77d99689773e7">FrontendTrigger</a></li>


    
  
    
    
	
<li>12.2.3.3: <a href="#pg-0d356cd150522df33f83d0453f191ac5">PredChecker</a></li>


    
  
    
    
	
<li>12.2.3.4: <a href="#pg-888bbeaad1aa779245a92ddc66145346">PreDecode</a></li>


    
  
    
    
	
<li>12.2.3.5: <a href="#pg-7aee3086abe25d91883317856094fc76">RVCExpander</a></li>


    
  

    </ul>
    
  
    
    
	
<li>12.2.4: <a href="#pg-645785e2f920783aa88dc445517a7128">ITLB</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>12.2.4.1: <a href="#pg-822b35c9edec39da6ca0fd8aa11c9d2a">IO接口说明</a></li>


    
  
    
    
	
<li>12.2.4.2: <a href="#pg-41bd3132649e65462a6efff11c317d7b">功能详述</a></li>


    
  
    
    
	
<li>12.2.4.3: <a href="#pg-8bca4e6bf58524f8693521bd6ceaf50b">关键信号说明</a></li>


    
  
    
    
	
<li>12.2.4.4: <a href="#pg-281abdcb1782ae5b04b47c9045b8633a">环境配置</a></li>


    
  

    </ul>
    
  

    </ul>
    
  
    
    
	
<li>12.3: <a href="#pg-6031fdd6c9ad34a8373b09e559c59778">Backend</a></li>


    
    <ul>
        
  
  
  
  

  

    </ul>
    
  
    
    
	
<li>12.4: <a href="#pg-758903f793d925071c9e0df49f07dc3f">Mem Block</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>12.4.1: <a href="#pg-8e01ee1a953553bff1b3873e6247576f">LSQ</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>12.4.1.1: <a href="#pg-c714e6fc3c1c9ea3ab166d48ea03e3f6">LoadQueueRAR</a></li>


    
  
    
    
	
<li>12.4.1.2: <a href="#pg-9a032f0cfdc8a7fe72dfec1c535356c4">LoadQueueRAW</a></li>


    
  
    
    
	
<li>12.4.1.3: <a href="#pg-35dc1dc6afba5e734160023fd9acf073">LoadQueueReplay</a></li>


    
  
    
    
	
<li>12.4.1.4: <a href="#pg-17df67412d57fff58f56428e76c07bdb">LoadQueueUncache</a></li>


    
  
    
    
	
<li>12.4.1.5: <a href="#pg-f3cd9f0b7554ba3e703118e43b113fbb">StoreQueue</a></li>


    
  
    
    
	
<li>12.4.1.6: <a href="#pg-366929e8b710d65054748c1a2afe5b56">VirtualLoadQueue</a></li>


    
  

    </ul>
    
  
    
    
	
<li>12.4.2: <a href="#pg-c6606764ae0dd34ef700d409c04fd9eb">LSU</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>12.4.2.1: <a href="#pg-cae277314de45b24dc43679a076417b4">StoreUnit</a></li>


    
  
    
    
	
<li>12.4.2.2: <a href="#pg-ee675f9c192f352a52e83ce5a137f604">微报告模板</a></li>


    
  

    </ul>
    
  
    
    
	
<li>12.4.3: <a href="#pg-e87cd3c3ae2d38ec14b6cb12f832a155">Shield-XS:基于Bitmap的安全隔离机制</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>12.4.3.1: <a href="#pg-d94efa552f365634197e1fbc8c58ee6c">Shield-XS Bitmap 基础知识</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>12.4.3.1.1: <a href="#pg-dd1286eb042d33c71170880919743180">背景描述</a></li>


    
  
    
    
	
<li>12.4.3.1.2: <a href="#pg-750b311a404f64437ad197e254e70ed8">香山 bitmap 防御原理</a></li>


    
  
    
    
	
<li>12.4.3.1.3: <a href="#pg-b732fa4bed6f7770e375f277d3134d11">bitmap的工作流程</a></li>


    
  
    
    
	
<li>12.4.3.1.4: <a href="#pg-769d220f5cb16bbfee3403c98ead0181">香山bitmap 应用场景</a></li>


    
  

    </ul>
    
  
    
    
	
<li>12.4.3.2: <a href="#pg-72e5ff01bbf5ddaaf23ddb325bbb52a1">Shield-XS Bitmap总体设计</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>12.4.3.2.1: <a href="#pg-a454fbac0661cacfe3738f76653fb9ed">机器模式Bitmap控制状态寄存器</a></li>


    
  
    
    
	
<li>12.4.3.2.2: <a href="#pg-8b0eada6be406a3b39784ffd6e146a6c">Shield-Bitmap Cache</a></li>


    
  
    
    
	
<li>12.4.3.2.3: <a href="#pg-50afc8cbee1484cfa9fbda0874aefbd2">Shield-Bitmap 地址翻译</a></li>


    
  
    
    
	
<li>12.4.3.2.4: <a href="#pg-8dd0a9f224170387a7af921f320750fe">Shield-Bitmap 地址翻译2</a></li>


    
  

    </ul>
    
  
    
    
	
<li>12.4.3.3: <a href="#pg-d051174c05fff6ce5497d8fbdb061286">Shield-XS Bitmap 硬件设计</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>12.4.3.3.1: <a href="#pg-6bd34d855a03cd0a22829234e9921d00">Bitmap Checker</a></li>


    
  
    
    
	
<li>12.4.3.3.2: <a href="#pg-32bdcacdae91419ec8cfff490d7c275a">Bitmap Cache</a></li>


    
  
    
    
	
<li>12.4.3.3.3: <a href="#pg-9cbbfef57ed1a52990970341b25766a2">Bitmap 与L2TLB交互</a></li>


    
  
    
    
	
<li>12.4.3.3.4: <a href="#pg-3c50cf87a79affd2dbf46b97a5ca0cdb">Bitmap接口时序图</a></li>


    
  
    
    
	
<li>12.4.3.3.5: <a href="#pg-a389bb1cb5d66249a6bc82fcc214610f">开销评估</a></li>


    
  

    </ul>
    
  
    
    
	
<li>12.4.3.4: <a href="#pg-787663ae6e6572d44662342c140b5dcc">Shield-XS_Bitmap 单元验证</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>12.4.3.4.1: <a href="#pg-3be48c9a62a64a4bc3986d27082ba76c">单元验证</a></li>


    
  

    </ul>
    
  

    </ul>
    
  

    </ul>
    
  
    
    
	
<li>12.5: <a href="#pg-8dbadf515bd82346f64914c420b7494c">Misc</a></li>


    
    <ul>
        
  
  
  
  

  

    </ul>
    
  

    </ul>
    
  
    
    
	
<li>13: <a href="#pg-3acd98556bb6e01bccfdb9fe2c4cfdc0">维护者</a></li>


    
  

    </ul>


<div class="content">
      <script src="../js/echarts.min.js"></script>
<script src="../js/chart_meta.js"></script>
<script>
function update_charts(data_url){
    show_meta_chart("meta_chart", data_url)
    updateDUTestStatus(data_url)
}
</script>
<p>本项目旨在通过开源众包的方式对<a href="https://github.com/OpenXiangShan/XiangShan">香山处理器</a>的昆明湖架构进行单元（Unit Test, UT）验证。下图是香山昆明湖架构各个模块验证情况。</p>
<div id="meta_chart" style="width: 100%;height:400px;"></div>
<div style="text-align: center; width: 100%;">

<label>当前版本：</label>
<select id="indexurlSelect" onchange="updateLink()" style="border: 0px">
    
    
    
    
    
    <option value="20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty" data-url="../data/reports//UnityChipForXiangShan/20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty"  selected>20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty</option>
    
</select>
<a id="indexgoLink" href="#" target=“_blank“>查看测试报告</a>

<script>
function updateLink() {
    var select = document.getElementById("indexurlSelect");
    var goLink = document.getElementById("indexgoLink");
    var opt = select.options[select.selectedIndex];
    if(!opt){
        return
    }
    var url = opt.getAttribute("data-url").replaceAll("/UnityChipForXiangShan/", "");
    goLink.href = url;
    
    window["update_charts"](url + "/ut_data_progress.json");
    
}
document.addEventListener('DOMContentLoaded', function() {
    updateLink()
});
</script>

</div>
<br>
<p>总统计数据如下：</p>
<table>
    <ol>
    <tr>
        <td>总测试用例数（Total Cases）：</td>
        <td  style="text-align: left; font-weight: bold;"><em id="em_id_report_cases_toal">-</em></td>
        <td>测试用例通过数（Passed Cases）：</td>
        <td  style="text-align: left; font-weight: bold;"><em id="em_id_report_cases_pass">-</em></td>
        <td>测试用例通过率（Passed Rate）：</td>
        <td  style="text-align: left; font-weight: bold;"><em id="em_id_report_cases_prate">-</em></td>
    </tr>
    <tr>
        <td>测试用例未过数（Failed Cases）：</td>
        <td  style="text-align: left; font-weight: bold;"><em id="em_id_report_cases_fail">-</em></td>
        <td>测试用例跳过数（Skipped Cases）：</td>
        <td  style="text-align: left; font-weight: bold;"><em id="em_id_report_cases_skip">-</em></td>
        <td>测试用例跳过率（Skip Rate）：</td>
        <td  style="text-align: left; font-weight: bold;"><em id="em_id_report_cases_srate">-</em></td>
    </tr>
    <tr>
        <td>总功能覆盖点数（Function Coverage）：</td>
        <td  style="text-align: left; font-weight: bold;"><em id="em_id_report_function_total">-</em></td>
        <td>覆盖点已覆盖数（Covered Functions）：</td>
        <td  style="text-align: left; font-weight: bold;"><em id="em_id_report_function_cover">-</em></td>
        <td>覆盖点已覆盖率（Covered Rate）：</td>
        <td  style="text-align: left; font-weight: bold;"><em id="em_id_report_function_rate">-</em></td>
    </tr>
    <tr>
        <td>总代码行覆盖率（Total Lines）：</td>
        <td  style="text-align: left; font-weight: bold;"><em id="em_id_report_line_total">-</em></td>
        <td>总代码行覆盖数（Covered Lines）：</td>
        <td  style="text-align: left; font-weight: bold;"><em id="em_id_report_line_cover">-</em></td>
        <td>总代码行覆盖率（Covered Rate）：</td>
        <td  style="text-align: left; font-weight: bold;"><em id="em_id_report_line_rate">-</em></td>
    </tr>
    </ol>
</table>
<p>*总代码行会随着DUT的增加而不断增加，因此：总代码行覆盖率不是最终覆盖率</p>
<p>其他内容快捷连接：</p>
<ul>
<li><strong><a href="https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/">DUT文档与功能</a></strong></li>
<li><strong><a href="https://github.com/XS-MLVP/UnityChipForXiangShan/labels/bug%20need%20to%20confirm">待确认bug列表</a></strong></li>
<li><strong><a href="https://github.com/XS-MLVP/UnityChipForXiangShan/labels/bug%20confirmed">已发现bug列表</a></strong></li>
<li><strong><a href="https://github.com/XS-MLVP/UnityChipForXiangShan/labels/bug%20fixed">已修复bug列表</a></strong></li>
<li><strong><a href="https://open-verify.cc/crowdsourcing/kunming_lake">正在进行的任务列表</a></strong></li>
<li><strong><a href="https://open-verify.cc/crowdsourcing/kunming_lake">已完成的任务列表</a></strong></li>
</ul>
<br>
<div style="text-align: center; width: 100%;">
<h4 id="testmap">香山昆明湖DUT验证进展</h4>
</div>
<br>

<style>
.div-dut-test-report {
    all:none;
    display: flex;
    align-items: center;
    text-align: center;
     
    width: 100%;
    margin: 0 auto;
    overflow: auto;
}
.div-dut-test-report tbody {
    --bs-table-striped-bg: white;
}
.div-dut-test-report .td-name {
    text-align: left;
}
.div-dut-test-report .td-index {
    text-align: center;
}
.div-dut-test-report table {
    width: 90%;
    margin: 0 auto;
}
.div-dut-test-report td {
    text-align: right;
}

.div-dut-test-report .td-desc{
    text-align: left;
}

.div-dut-test-report th {
    text-align: right;
}
.div-dut-test-report tr {
    border-bottom: 1px solid #ddd;
}
.em-red {
    color: yellow;
    font-weight: bold;
    background-color: rgb(247, 36, 152);
    border-radius: 2px;
}
.em-orange {
    color: white;
    font-weight: bold;
    background-color: orange;
    border-radius: 2px;
}
.em-green {
    font-weight: bold;
    color: yellow;
    background-color: green;
    border-radius: 2px;
}
.modal-linecov {
    display: none;  
    position: absolute;  
    z-index: 1;
    background-color: rgb(0,0,0);
    background-color: rgba(0,0,0,0.4);
}
.modal-content {
    background-color: #fefefe;
    padding: 20px;
    border: 1px solid #888;
    width: 300px;
    position: absolute;
}
.close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
}


table .td-desc .tooltiptext {
  visibility: hidden;
  width: 250px;
  background-color: rgb(87, 87, 87);
  color: #fff1f1;
  text-align: center;
  border-radius: 6px;
  padding: 5px 0;

   
  position: absolute;
  z-index: 1;
}

.td-desc:hover .tooltiptext{
    visibility: visible;
}

</style>

<div id="line-file-modal" class="modal-linecov">
    <div class="modal-content" id="linecov-text">
    </div>
</div>

<div class="div-dut-test-report">
<table id="dut-test-items" align="center" class="td-initial">
</table>
</div>

<script>
function closeLineCovModal() {
    $("#line-file-modal").hide();
}

$(window).click(function(event) {
    var modal = $("#line-file-modal");
    if (! modal.is(":hidden")) {
        if (! $(event.target).closest(".modal-content").length){
            closeLineCovModal();
        }
    }
});

function updateDUTestStatus(data_url){
    $.getJSON(data_url, function (data) {
        $("#dut-test-items").html(
"            <tbody align=\"center\">\
    <tr>\
        <th class=\"td-index\">Index</th>\
        <th class=\"td-name\">Name</th>\
        <th class=\"td-desc\">Description </th> \
        <th>Document</th>\
        <th>&nbsp;&nbsp;Cases</th>\
        <th>&nbsp;&nbsp;&nbsp;Fail</th>\
        <th>&nbsp;&nbsp;&nbsp;SKip</th>\
        <th>CsRate (%)</th>\
        <th>Checks\
        <th>Fail\
        <th>CkRate (%)</th>\
        <th>Lines</th>\
        <th>CvRate (%)</th>\
        <th>Maintainer</th>\
    </tr>\
  </tbody>");
        var prefix = data.tree.meta.paths;
        var index = 1;
        function calcRateColor(rate){
            var color = "";
            if(rate < data.config.rate_low){
                color = "red";
            } else if(rate < data.config.rate_middle){
                color = "orange";
            } else if(rate > data.config.rate_high){
                color = "green";
            }
            return "<em class=\"em-"+color+"\">" + rate + "</em>";
        }
        function calcRate(a, b){
            if(b === 0){
                return 0;
            }
            return calcRateColor((a / b * 100).toFixed(2));
        }
        function redItem(item){
            if (item > 0) {
                return "<em class=\"em-red\">" + item + "</em>";
            }
            return item;
        }
        function getDocUrl(url){
            if(url){
                return "<a href=\"" + url + "\" target=\"_blank\">Detail</a>";
            }
            return "-";
        }
        function getLinFileUrl(paths){
            var txt = ""
            var meta = data.extend[paths]
            if (!meta) return txt;
            meta.target_line_coverage_files.forEach(f=> {
                var url = null;
                if(!f.includes("not found")){
                    meta.matched_line_coverage_files.forEach(u=> {
                        if(u[0].includes(f)){
                            var base_url = data_url.split("/").slice(0, -1).join("/");
                            txt += "<li><a href=\"" + base_url + u[0] + "\" target=\"_blank\">" + f + "</a> <em style=\"float: right;\"> ("
                                +u[1]+"/"+u[2]+")<em> </li>";
                        }else{
                            console.log("not found: " + f + " in " + u);
                        }
                    });
                }else{
                    txt += "<li>" + f + "</li>";
                }
            });
            return $("#linecov-text").html(txt);
        }
        function openLineCovModal(event, paths) {
            event.preventDefault();
            event.stopPropagation();
            closeLineCovModal();
            getLinFileUrl(paths);
            var modal = $("#line-file-modal")
            var text = $("#linecov-text")
            modal.css({
                left: event.pageX - text.width()/2 + "px",
                top: event.pageY - text.height()/2 + "px"
            });
            modal.show();
        }
        window.openLineCovModal = openLineCovModal;
        function getLineCovUrl(paths, hints, total){
            var text = hints + "/" + total;
            if(total > 0){
                return "<a href=\"\" onclick=\"openLineCovModal(event, '" + paths + "')\">" + text + "</a>";
            }
            return text;
        }
        function getCaseUrl(paths, pass, total){
            if (total < 1){
                return "0/0";
            }
            var url = data_url.split("/").slice(0, -1).join("/") + "?";
            var K = "K=details,file,,,span," + paths.split("/").slice(2, -1).join("/");
            return "<a href=\""+ url + K +"\" target=\"_blank\">" + pass + "/" + total + "</a>";
        }
        function getCaseFailSkipUrl(paths, fail, skip){
            if (fail < 1){
                if(skip){
                    return "0"
                }
                return redItem(fail);
            }
            var url = data_url.split("/").slice(0, -1).join("/") + "?";
            var key = skip ? "skipped" : "failed";
            var K = "K=details,file,span,"+key+",span," + paths.split("/").slice(2, -1).join("/");
            var text = skip? fail: redItem(fail);
            return "<a href=\""+ url + K +"\" target=\"_blank\">" + text + "</a>";
        }
        function getFuncovUrl(paths, cover, total){
            if (total < 1){
                return "0/0";
            }
            var group_name = paths.split("/").slice(2, -1).join(".")
            var url = data_url.split("/").slice(0, -1).join("/") + "?";
            var K_case = "ShowFunCov=1&K=li,group_name,,,span," + group_name + "&K=ul,group_name,,,span,"+ group_name;
            return "<a href=\""+ url + K_case +"\" target=\"_blank\">" + cover + "/" + total + "</a>";
        }
        function getFuncovFailUrl(paths, cover, total){
            if (total == cover || total < 1){
                return "0";
            }
            var group_name = paths.split("/").slice(2, -1).join(".")
            var url = data_url.split("/").slice(0, -1).join("/") + "?";
            var K_case = "ShowFunCov=1&K=li,group_name,,,span," + group_name + "&K=ul,group_name,,,span,"+ group_name;
            var K_fail = K_case + "&K=li,point_name,,,span,Failed&K=ul,grou_name,,,ul,failed";
            return "<a href=\""+ url + K_fail +"\" target=\"_blank\">" + redItem(total - cover) + "</a>";
        }

        function getDescComp(desc) {
            initial = "<td class=\"td-desc\">";
            end = "</td>"
            scale = 15
            if (desc.length <= scale){
                return initial + desc + end
            }

            emit_desc = desc.substr(0, scale) + "..."
            tooltip_res = "<div class=\"tooltiptext\">" + desc + "</div>"
            return initial + emit_desc + tooltip_res + end

        }

        function traverse(node) {
            if (!node.children || node.children.length === 0) {
                var meta = node.meta
                var desc = node.desc
                var maintainer = node.maintainers || "TBD"
                if (node.maintainers){
                    maintainers = []
                    for (let i = 0; i < node.maintainers.length; i++){
                        let cur = node.maintainers[i]
                        let tmp_maintainer = cur.name || "TBD";
                        if (tmp_maintainer.length > 5){
                            tmp_maintainer = tmp_maintainer.substr(0, 4) + "..."
                        }
                        if (cur.page){
                            tmp_maintainer = "<a style=\"display: block;\" href=\"" + cur.page + "\">" + tmp_maintainer + "</p>"
                        } else {
                            tmp_maintainer = "<p>" + tmp_maintainer + "</p>"
                        }
                        maintainers.push(tmp_maintainer)
                    }
                    maintainer = maintainers.join(' ')
                }
                $("#dut-test-items").html($("#dut-test-items").html() + 
                    "<tr><td class=\"td-index\">" + index + "</td>" +
                    "<td class=\"td-name\">" + meta.paths.replace(prefix + "/",
                        "").replaceAll("/", ".") + "</td>" +
                    getDescComp(desc) + 
                    "<td>" + getDocUrl(meta.doc_url) + "</td>" +
                    "<td>" + getCaseUrl(meta.paths, meta.cases.pass, meta.cases.total) + "</td>" +
                    "<td>" + getCaseFailSkipUrl(meta.paths, meta.cases.fail, false) + "</td>" +
                    "<td>" + getCaseFailSkipUrl(meta.paths, meta.cases.skip, true) + "</td>" +
                    "<td>" + calcRate(meta.cases.pass, meta.cases.total) + "</td>" +
                    "<td>" + getFuncovUrl(meta.paths, meta.functions.cover, meta.functions.total) + "</td>" +
                    "<td>" + getFuncovFailUrl(meta.paths, meta.functions.cover, meta.functions.total) + "</td>" +
                    "<td>" + calcRate(meta.functions.cover, meta.functions.total) + "</td>" +
                    "<td>" + getLineCovUrl(meta.paths, meta.lines.cover, meta.lines.total) + "</td>" +
                    "<td>" + calcRate(meta.lines.cover, meta.lines.total) + "</td>" +
                    "<td>" + maintainer + "</td>" +
                    "</tr>"
                );
                index++;
            } else {
                $.each(node.children, function(index, child) {
                    traverse(child);
                });
            }
        }
        traverse(data.tree);
    });
}
</script>

<div style="text-align: center; width: 100%;">
<br>
注：本文档中的统计信息根据测试结果自动生成<br>
数据自动更新日期：<em id="em_id_report_date">1970-01-01 00:00:00</em>
</div>

</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-0dcba8abab46333b47bb5f2e2beb4acc">1 - 目标验证单元</h1>
    
	<script src="../../js/echarts.min.js"></script>
<script src="../../js/chart_datatree.js"></script>
<script>
function update_dut_charts(data_url){
    show_datatree_chart("datatree_chart", data_url)
}
</script>
<br>
<div id="datatree_chart" style="width: 90%;height:800px;"></div>
<div style="text-align: center; width: 100%;">

<label>当前版本：</label>
<select id="duturlSelect" onchange="updateLink()" style="border: 0px">
    
    
    
    
    
    <option value="20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty" data-url="../../data/reports//UnityChipForXiangShan/20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty"  selected>20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty</option>
    
</select>
<a id="dutgoLink" href="#" target=“_blank“>查看测试报告</a>

<script>
function updateLink() {
    var select = document.getElementById("duturlSelect");
    var goLink = document.getElementById("dutgoLink");
    var opt = select.options[select.selectedIndex];
    if(!opt){
        return
    }
    var url = opt.getAttribute("data-url").replaceAll("/UnityChipForXiangShan/", "");
    goLink.href = url;
    
    window["update_dut_charts"](url + "/ut_data_progress.json");
    
}
document.addEventListener('DOMContentLoaded', function() {
    updateLink()
});
</script>

</div>
<br>
<p>上图共有<em id="em_id_report_dut_total">-</em>个模块，默认情况下模块为灰色，当模块中的测试用例数大于<em id="em_id_report_dut_min_light">-</em>时，该模块被完全点亮。目前已经完全点亮的模块为<em  id="em_id_report_dut_lighted">-</em>个，待点亮的模块有<em  id="em_id_report_dut_lighted_no">-</em>个。</p>
<h4 id="通用处理器模块简介">通用处理器模块简介</h4>
<p>高性能处理器是现代计算设备的核心，它们通常由三个主要部分组成：前端、后端和访存系统。这些部分协同工作，以确保处理器能够高效地执行复杂的计算任务。</p>
<ul>
<li>
<p><strong>前端</strong>：前端部分，也被称为指令获取和解码阶段，负责从内存中获取指令并将其解码成处理器可以理解的格式。这一阶段是处理器性能的关键，因为它直接影响到处理器可以多快地开始执行指令。前端通常包括指令缓存、分支预测单元和指令解码器。指令缓存用于存储最近访问过的指令，以减少对主内存的访问次数，从而提高处理速度。分支预测单元则尝试预测程序中的条件分支，以便提前获取和解码后续指令，这样可以减少等待分支结果的时间。</p>
</li>
<li>
<p><strong>后端</strong>：后端部分，也称为执行阶段，是处理器中负责实际执行指令的地方。这一阶段包括了算术逻辑单元（ALU）、浮点单元（FPU）和各种执行单元。这些单元负责进行算术运算、逻辑运算、数据传输和其他处理器操作。后端的设计通常非常复杂，因为它需要支持多种指令集架构（ISA）并优化性能。为了提高效率，现代处理器通常采用超标量架构，这意味着它们可以同时执行多条指令。</p>
</li>
<li>
<p><strong>访存</strong>：访存系统是处理器与内存之间交互的桥梁。它包括了数据缓存、内存控制器和高速缓存一致性协议。数据缓存用于存储处理器频繁访问的数据，以减少对主内存的访问次数。内存控制器负责管理处理器与内存之间的数据传输。高速缓存一致性协议确保在多处理器系统中，所有处理器看到的内存状态是一致的。</p>
</li>
</ul>
<p>高性能处理器的设计需要在这三个部分之间找到平衡，以实现最佳的性能。这通常涉及到复杂的微架构设计，以及对处理器流水线的优化。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e819c695f47dc3893fee99c05230ff78">2 - 准备验证环境</h1>
    
	<h4 id="基础环境需求">基础环境需求</h4>
<p>本项目基于<code>Python</code>编程语言进行UT验证，采用的工具和测试框架为<a href="https://github.com/XS-MLVP/picker">picker</a>和<a href="https://github.com/XS-MLVP/toffee">toffee</a>，<strong>环境需求</strong>如下：</p>
<ol>
<li>Linux操作系统。建议WSL2下安装Ubuntu22.04。</li>
<li>Python。建议Python3.11。</li>
<li>picker。按照<a href="https://open-verify.cc/mlvp/docs/quick-start/installer/">快速开始</a>中的提示安装最新版本。</li>
<li>lcov。用于后续test阶段报告生成。使用包管理器即可下载：<code>sudo apt install lcov</code></li>
</ol>
<p><strong>环境配置完成</strong>后，clone仓库：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone https://github.com/XS-MLVP/UnityChipForXiangShan.git
</span></span><span style="display:flex;"><span><span style="color:#204a87">cd</span> UnityChipForXiangShan
</span></span><span style="display:flex;"><span>pip3 install -r requirements.txt <span style="color:#8f5902;font-style:italic"># 安装 python 依赖（例如 toffee）</span>
</span></span></code></pre></div><h4 id="下载rtl代码">下载RTL代码：</h4>
<p>默认从仓库<a href="https://github.com/XS-MLVP/UnityChipXiangShanRTLs">https://github.com/XS-MLVP/UnityChipXiangShanRTLs</a>中下载。用户也可以自行按照XiangShan文档编译生成RTL。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>make rtl    <span style="color:#8f5902;font-style:italic"># 该命令下载最新的 rtl 代码，解压至 rtl 目录，并创建软链接</span>
</span></span></code></pre></div><p>可以用以下命令指定下载的 rtl 版本：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>make rtl <span style="color:#000">args</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#4e9a06">&#34;rtl.version=\&#39;openxiangshan-kmh-fad7803d-24120901\&#39;&#34;</span>
</span></span></code></pre></div><p>所有RTL下载包请在<a href="https://github.com/XS-MLVP/UnityChipXiangShanRTLs">UnityChipXiangShanRTLs</a>中查看。</p>
<p>RTL压缩包的命名规范为：<code>名称-微架构-Git标记-日期编号.tar.gz</code>，例如<code>openxiangshan-kmh-97e37a2237-24092701.tar.gz</code>。在使用时，仓库代码会过滤掉 git 标记和后缀，例如通过 cfg.rtl.version 访问到的版本号为：<code>openxiangshan-kmh-24092701</code>。压缩包内的目录结构为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openxiangshan-kmh-97e37a2237-24092701.tar.gz
</span></span><span style="display:flex;"><span>└── rtl           <span style="color:#8f5902;font-style:italic"># 目录</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">|</span>-- *.sv      <span style="color:#8f5902;font-style:italic"># 所有sv文件</span>
</span></span><span style="display:flex;"><span>    <span style="color:#4e9a06">`</span>-- *.v       <span style="color:#8f5902;font-style:italic"># 所有v文件</span>
</span></span></code></pre></div><h4 id="编译dut">编译DUT</h4>
<p>该过程的目的是将RTL通过picker工具打包为Python模块。可以通过make命令指定被打包DUT，也可以一次性打包所有DUT。</p>
<p>如果想要自行打包某个dut，需要创建编写scripts目录中的build_ut_&lt;name&gt;.py脚本。这一脚本必须实现一个build方法，在打包时会被自动调用。此外还有一个line_coverage_files方法，用于指定行覆盖率参考的文件。</p>
<p>picker的打包支持内部信号的加入，详见picker的--internal参数，传递给其一个自定义的yaml即可。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 调用scripts目录中的build_ut_&lt;name&gt;.py中的build方法，创建待验证的Python版DUT</span>
</span></span><span style="display:flex;"><span>make dut <span style="color:#000">DUTS</span><span style="color:#ce5c00;font-weight:bold">=</span>&lt;name&gt;  <span style="color:#8f5902;font-style:italic"># DUTS的值如果有多个，需要用逗号隔开，支持通配符。DUTS默认值为 &#34;*&#34;，编译所有DUT</span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 例如：</span>
</span></span><span style="display:flex;"><span>make dut <span style="color:#000">DUTS</span><span style="color:#ce5c00;font-weight:bold">=</span>backend_ctrl_block_decode
</span></span></code></pre></div><p>以<code>make dut DUTS=backend_ctrl_block_decode</code>为例，命令执行完成后，会在dut目录下生成对应的Python包：</p>
<pre tabindex="0"><code>dut/
├── __init__.py
├── DecodeStage
├── Predecode
└── RVCExpander
</code></pre><p>完成转换后，在测试用例代码中可以import对应的DUT，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">from</span> <span style="color:#000">dut.PreDecode</span> <span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">DUTPreDecode</span>
</span></span><span style="display:flex;"><span><span style="color:#000">dut</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">DUTPreDecode</span><span style="color:#000;font-weight:bold">()</span>
</span></span></code></pre></div><h4 id="编辑配置">编辑配置</h4>
<p>运行rtl、dut、test等命令时，默认使用configs/_default.yaml中的配置项。</p>
<p>当然，也可以使用自定义配置，方法如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 指定自定义CFG文件</span>
</span></span><span style="display:flex;"><span>make <span style="color:#000">CFG</span><span style="color:#ce5c00;font-weight:bold">=</span>path/to/your_cfg.yaml
</span></span></code></pre></div><p>类似地，可以在命令行直接指定键值对传入。目前仅有test相关阶段支持命令行配置键值对：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 指定KV，传递命令行参数，键值对之间用空格隔开</span>
</span></span><span style="display:flex;"><span>make <span style="color:#204a87">test</span> <span style="color:#000">KV</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#4e9a06">&#34;log.term-level=\&#39;debug\&#39; test.skip-tags=[\&#39;RARELY_USED\&#39;]&#34;</span>
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a5fd55875e0540351befe9b3a6e05b98">3 - 运行测试</h1>
    
	<p>本项目基于PyTest测试框架进行验证。运行测试时，PyTest框架自动搜索所有<code>test_*.py</code>文件，并自动执行其中所有以<code>test_</code>开头的测试用例（Test Case）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 执行所有ut_*目录中的test case</span>
</span></span><span style="display:flex;"><span>make test_all
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 执行指定目录下的test case</span>
</span></span><span style="display:flex;"><span>make <span style="color:#204a87">test</span> <span style="color:#000">target</span><span style="color:#ce5c00;font-weight:bold">=</span>&lt;dir&gt;
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 例如执行ut_backend/ctrl_block/decode目录中所有的test case</span>
</span></span><span style="display:flex;"><span>make <span style="color:#204a87">test</span> <span style="color:#000">target</span><span style="color:#ce5c00;font-weight:bold">=</span>ut_backend/ctrl_block/decode
</span></span></code></pre></div><p>可通过<code>args</code>参数传递Pytest的运行参数，例如启动x-dist插件的多核功能：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>make <span style="color:#204a87">test</span> <span style="color:#000">args</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#4e9a06">&#34;-n 4&#34;</span>     <span style="color:#8f5902;font-style:italic"># 启用 4 个进程</span>
</span></span><span style="display:flex;"><span>make <span style="color:#204a87">test</span> <span style="color:#000">args</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#4e9a06">&#34;-n auto&#34;</span>  <span style="color:#8f5902;font-style:italic"># 让框架自动选择启用多少个进程</span>
</span></span></code></pre></div><p>*注：x-dist可以在多节点上并发运行测试，可参考其<a href="https://pytest-xdist.readthedocs.io/en/stable/remote.html">文档</a></p>
<p>运行完成后，默认在<code>out/report</code>目录会生成html版本的测试报告，其 html 文件可通过浏览器直接打开查看（VS Code IDE建议安装<code>Open In Default Browser</code>插件）。</p>
<p>运行测试主要完成以下三部分内容：</p>
<ol>
<li>按要求运行Test Case，可通过<code>cfg.tests</code>中的选项进行配置</li>
<li>统计测试结果，输出测试报告。有toffee-report自动生成 (总测试报告，所有Test的结果合并在一起)</li>
<li>根据需要（<code>cfg.doc_result.disable = True</code>）在测试报告上进行进一步数据统计</li>
</ol>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6f6b342069bf0da19ce0bf410bce92e2">4 - 添加测试</h1>
    
	<p>添加一个全新的 DUT 测试用例，需要完成以下三部分内容(本节以前端的<code>ifu</code>下的<code>rvc_expander</code>为例)：</p>
<ol>
<li><strong>添加编译脚本</strong>： 在<code>scripts</code>目录下使用<code>python</code>编写对应<code>rtl</code>的编译文件（例如<code>build_ut_frontend_ifu_rvc_expander.py</code>）。</li>
<li><strong>构建测试环境</strong>： 在目录中创建目标测试 UT 目录（例如<code>ut_frontend/ifu/rvc_expander</code>）。如果有需要的话，可以在<code>tools、comm</code>等模块中添加该 DUT 测试需要的基础工具。</li>
<li><strong>添加测试用例</strong>： 在测试 UT 目录，按<a href="https://docs.pytest.org/en/stable/">PyTest 规范</a>添加测试用例。</li>
</ol>
<p>如果是在已有的 DUT 测试中增加内容，按原有目录结构添加即可。</p>
<p>如何通过 picker 和 toffee 库进行 Python 芯片验证，请参考：<a href="https://open-verify.cc/mlvp/docs">https://open-verify.cc/mlvp/docs</a></p>
<p>在测试时还需要关心以下内容：</p>
<ol>
<li><strong>UT 模块说明</strong>: 在添加的模块顶层文件夹中，添加<code>README.md</code>说明，具体格式和要求请参考<a href="https://open-verify.cc/UnityChipForXiangShan/docs/10_template_ut_readme/">模板</a>。</li>
<li><strong>代码覆盖率</strong>：代码覆盖率是芯片验证的重要指标，一般需需要覆盖目标 DUT 的所有代码。</li>
<li><strong>功能覆盖率</strong>：功能覆盖率即目标功能验证完成了多少，一般需要达到 100%。</li>
</ol>
<p>在后续的文档中，我们将继续以<code>rvc_expander</code>模块为例，详细说明上述过程。</p>
<p>*注：目录或文件名称需要合理，以便于能通过命名知晓其具体含义。</p>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-dbf9b443ff7a2ae1b419d7f271fac95a">4.1 - 添加编译脚本</h1>
    
	<h2 id="脚本目标">脚本目标</h2>
<p>在<code>scripts</code>目录下使用python编写对应rtl的编译文件（例如<code>build_ut_frontend_ifu_rvc_expander.py</code>）。<br>
该脚本的目标是提供 RTL 到 Python DUT 的编译、目标覆盖文件，以及自定义功能等内容。</p>
<h2 id="创建过程">创建过程</h2>
<h3 id="确定文件名称">确定文件名称</h3>
<p>在<a href="">香山昆明湖 DUT 验证进展</a>中选择需要验证的 UT，如果没有或者进一步细化，可通过编辑<code>configs/dutree/xiangshan-kmh.yaml</code>自行添加。<br>
比如，我们要验证的是前端部分的<code>ifu</code>模块下的<code>rvc_expander</code>模块，那么需要在<code>configs/dutree/xiangshan-kmh.yaml</code>中添加对应的部分（目前yaml中已经有该模块了，此处为举例）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">name</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;kmh_dut&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#204a87;font-weight:bold">desc</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;所有昆明湖DUT&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#204a87;font-weight:bold">children</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span>- <span style="color:#204a87;font-weight:bold">name</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;frontend&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">    </span><span style="color:#204a87;font-weight:bold">desc</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;前端模块&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">    </span><span style="color:#204a87;font-weight:bold">children</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">      </span>- <span style="color:#204a87;font-weight:bold">name</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;ifu&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">        </span><span style="color:#204a87;font-weight:bold">desc</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;指令单元 (Instruction Fetch Unit)&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">        </span><span style="color:#204a87;font-weight:bold">children</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">          </span>- <span style="color:#204a87;font-weight:bold">name</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;rvc_expander&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">            </span><span style="color:#204a87;font-weight:bold">desc</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;RVC指令扩充器&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span></code></pre></div><p>脚本文件的命名格式如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>scripts/build_&lt;顶层模块&gt;_&lt;下层模块名&gt;_..._&lt;目标模块名&gt;.py
</span></span></code></pre></div><p>目前本项目内置了 4 个顶层模块：</p>
<ol>
<li>ut_frontend 前端</li>
<li>ut_backend 后端</li>
<li>ut_mem_block 访存</li>
<li>ut_misc 其他</li>
</ol>
<p>其中的子模块没有<code>ut_</code>前缀（顶层目录有该前缀是为了和其他目录区分开）。</p>
<p>例如验证目标 DUT 为<code>rvc_expander</code>模块：<br>
该模块是属于前端的，所以顶级模块为<code>ut_frontend</code>，它的下层模块为<code>ifu</code>，目标模块为<code>rvc_expander</code>。<br>
通过刚才我们打开的<code>yaml</code>文件也可以知道，<code>frontend</code>的children 为<code>ifu</code>，<code>ifu</code>的children 为<code>rvc_expander</code>。 <br>
所以，需要创建的脚本名称为<code>build_ut_frontend_ifu_rvc_expander.py</code>。</p>
<h3 id="编写-buildcfg---bool-函数">编写 build(cfg) -&gt; bool 函数</h3>
<p>build 函数定义如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">build</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">cfg</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#204a87">bool</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#4e9a06">&#34;&#34;&#34;编译DUT
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    Args:
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        cfg: 运行时配置，可通过它访问配置项，例如 cfg.rtl.version
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    Return:
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        返回 True 或者 False，表明该函数是否完成预期目标
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    &#34;&#34;&#34;</span>
</span></span></code></pre></div><p>build 在 make dut 时会被调用，其主要是将目标 RTL 转换为 Python 模块。在该过程中也可以加入其他必要过程，例如编译依赖项等。以<code>build_ut_frontend_ifu_rvc_expander.py</code>为例，主要完成了 RTL 检查、DUT 检查、RTL 编译、disasm 依赖编译等工作：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">os</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">from</span> <span style="color:#000">comm</span> <span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">warning</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">info</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">build</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">cfg</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># import 相关依赖</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">from</span> <span style="color:#000">toffee_test.markers</span> <span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">match_version</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">from</span> <span style="color:#000">comm</span> <span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">is_all_file_exist</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">get_rtl_dir</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">exe_cmd</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">get_root_dir</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># 检查RTL版本（version参数为空，表示所有版本都支持）</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#204a87;font-weight:bold">not</span> <span style="color:#000">match_version</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">cfg</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">rtl</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">version</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;openxiangshan-kmh-*&#34;</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">warning</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;ifu frontend rvc expander: </span><span style="color:#4e9a06">%s</span><span style="color:#4e9a06">&#34;</span> <span style="color:#ce5c00;font-weight:bold">%</span> <span style="color:#4e9a06">f</span><span style="color:#4e9a06">&#34;Unsupported RTL version </span><span style="color:#4e9a06">{</span><span style="color:#000">cfg</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">rtl</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">version</span><span style="color:#4e9a06">}</span><span style="color:#4e9a06">&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#204a87;font-weight:bold">False</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># 检查在当前RTL中，目标文件是否存在</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">f</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">is_all_file_exist</span><span style="color:#000;font-weight:bold">([</span><span style="color:#4e9a06">&#34;rtl/RVCExpander.sv&#34;</span><span style="color:#000;font-weight:bold">],</span> <span style="color:#000">get_rtl_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">cfg</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#000">cfg</span><span style="color:#000;font-weight:bold">))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">assert</span> <span style="color:#000">f</span> <span style="color:#204a87;font-weight:bold">is</span> <span style="color:#204a87;font-weight:bold">True</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">f</span><span style="color:#4e9a06">&#34;File </span><span style="color:#4e9a06">{</span><span style="color:#000">f</span><span style="color:#4e9a06">}</span><span style="color:#4e9a06"> not found&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># 如果dut中不存在RVCExpander，则调用picker进行Python打包</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#204a87;font-weight:bold">not</span> <span style="color:#000">os</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">path</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">exists</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">get_root_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;dut/RVCExpander&#34;</span><span style="color:#000;font-weight:bold">)):</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">info</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Exporting RVCExpander.sv&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">s</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">out</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">err</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">exe_cmd</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">f</span><span style="color:#4e9a06">&#39;picker export --cp_lib false </span><span style="color:#4e9a06">{</span><span style="color:#000">get_rtl_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;rtl/RVCExpander.sv&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">cfg</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#000">cfg</span><span style="color:#000;font-weight:bold">)</span><span style="color:#4e9a06">}</span><span style="color:#4e9a06"> --lang python --tdir </span><span style="color:#4e9a06">{</span><span style="color:#000">get_root_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;dut&#34;</span><span style="color:#000;font-weight:bold">)</span><span style="color:#4e9a06">}</span><span style="color:#4e9a06">/ -w rvc.fst -c&#39;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">assert</span> <span style="color:#000">s</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;Failed to export RVCExpander.sv: </span><span style="color:#4e9a06">%s</span><span style="color:#4e9a06">\n</span><span style="color:#4e9a06">%s</span><span style="color:#4e9a06">&#34;</span> <span style="color:#ce5c00;font-weight:bold">%</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">out</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">err</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># 如果tools中不存在disasm/build，则需要编译disasm</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#204a87;font-weight:bold">not</span> <span style="color:#000">os</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">path</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">exists</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">get_root_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;tools/disasm/build&#34;</span><span style="color:#000;font-weight:bold">)):</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">info</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Building disasm&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">s</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">_</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">_</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">exe_cmd</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;make -C </span><span style="color:#4e9a06">%s</span><span style="color:#4e9a06">&#34;</span> <span style="color:#ce5c00;font-weight:bold">%</span> <span style="color:#000">get_root_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;tools/disasm&#34;</span><span style="color:#000;font-weight:bold">))</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">assert</span> <span style="color:#000">s</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;Failed to build disasm&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># 编译成功</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#204a87;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">line_coverage_files</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">cfg</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#4e9a06">&#34;RVCExpander.v&#34;</span><span style="color:#000;font-weight:bold">]</span>
</span></span></code></pre></div><p>picker 的使用方式请参考其<a href="https://github.com/XS-MLVP/picker/blob/master/README.zh.md">文档</a>和<a href="https://open-verify.cc/mlvp/docs/env_usage/picker_usage/">使用</a></p>
<p>在<code>scripts</code>目录中可以创建子目录保存 UT 验证需要的文件，例如 rvc_expander 模块创建了<code>scripts/frontend_ifu_rvc_expander</code>目录，其中的<code>rtl_file.f</code>用来指定输入的 RTL 文件，<code>line_coverage.ignore</code>用来保存需要忽略的代码行统计。自定义目录的命名需要合理，且能通过名字判断其所属模块和文件。</p>
<h3 id="编写-line_coverage_filescfg---liststr-函数">编写 line_coverage_files(cfg) -&gt; list[str] 函数</h3>
<p>line_coverage_files 函数的定义如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">line_coverage_files</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">cfg</span><span style="color:#000;font-weight:bold">)</span><span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#204a87">list</span><span style="color:#000;font-weight:bold">[</span><span style="color:#204a87">str</span><span style="color:#000;font-weight:bold">]:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#4e9a06">&#34;&#34;&#34;指定需要覆盖的文件
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    Args:
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        cfg: 运行时配置，可通过它访问配置项，例如 cfg.rtl.version
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    Return:
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        返回统计代码行覆盖率的目标RTL文件名
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    &#34;&#34;&#34;</span>
</span></span></code></pre></div><p>在<code>build_ut_frontend_ifu_rvc_expander.py</code>文件中，<code>line_coverage_files</code>函数的定义如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">line_coverage_files</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">cfg</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#4e9a06">&#34;RVCExpander.v&#34;</span><span style="color:#000;font-weight:bold">]</span>
</span></span></code></pre></div><p>标识该模块关注的是对<code>RVCExpander.v</code>文件的覆盖。如果要开启测试结果处理，还需要在<code>configs/_default.yaml</code>中的<code>doc-result</code>下<code>disable=False</code>（默认参数是<code>False</code>，也就是开启状态）;如果不开启测试结果处理则(<code>disable = True</code>)。注意，如果不开启测试结果处理，那么上述函数就不会被调用。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-53f38485d7ee0ef1d06f36fbe61bda5b">4.2 - 构建测试环境</h1>
    
	<h2 id="确定目录结构">确定目录结构</h2>
<p>UT(Unit Test, 单元测试)所在的目录位置的层级结构应该与名称一致，例如<code>frontend.ifu.rvc_expander</code>应当位于<code>ut_frontend/ifu/rvc_expander</code>目录，且每层目录都需要有<code>__init__.py</code>，便于通过 python 进行<code>import</code>。</p>
<p><strong>本章节的文件为<code>your_module_wrapper.py</code></strong>（如果你的模块是<code>rvc_expander</code>，那么文件就是<code>rvc_expander_wrapper.py</code>）。</p>
<p>wrapper 是包装的意思，也就是我们测试中需要用到的方法封装成和dut解耦合的API提供给测试用例使用。</p>
<p>*注：解耦合是为了测试用例和 DUT 解耦，使得测试用例可以独立于 DUT 进行编写和调试，也就是在测试用例中，不需要知道 DUT 的具体实现细节，只需要知道如何使用 API 即可。可以参照<a href="https://open-verify.cc/mlvp/docs/mlvp/canonical_env/#%E5%B0%86%E9%AA%8C%E8%AF%81%E4%BB%A3%E7%A0%81%E4%B8%8Edut%E8%BF%9B%E8%A1%8C%E8%A7%A3%E8%80%A6">将验证代码与DUT进行解耦</a></p>
<p>该文件应该放于<code>ut_frontend_or_backend/top_module/your_module/env</code>（这里依然以<code>rvc_expander</code>举例：<code>rvc_expander</code>属于前端，其顶层目录则应该是<code>ut_frontend</code>；<code>rvc_expander</code>的顶层模块是<code>ifu</code>，那么次级目录就是<code>ifu</code>;之后的就是<code>rvc_expander</code>自己了；最后，由于我们是在<strong>构建测试环境</strong>，再建一级<code>env</code>目录。将它们连起来就是：<code>ut_frontend_or_backend/top_module/your_module/env</code>）目录下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>ut_frontend/ifu/rvc_expander
</span></span><span style="display:flex;"><span>├── classical_version
</span></span><span style="display:flex;"><span>│   ├── env
</span></span><span style="display:flex;"><span>│   │   ├── __init__.py
</span></span><span style="display:flex;"><span>│   │   └── rvc_expander_wrapper.py
</span></span><span style="display:flex;"><span>│   ├── __init__.py
</span></span><span style="display:flex;"><span>│   └── test_rvc_expander.py
</span></span><span style="display:flex;"><span>├── __init__.py
</span></span><span style="display:flex;"><span>├── README.md
</span></span><span style="display:flex;"><span>└── toffee_version
</span></span><span style="display:flex;"><span>    ├── agent
</span></span><span style="display:flex;"><span>    │   └── __init__.py
</span></span><span style="display:flex;"><span>    ├── bundle
</span></span><span style="display:flex;"><span>    │   └── __init__.py
</span></span><span style="display:flex;"><span>    ├── env
</span></span><span style="display:flex;"><span>    │   ├── __init__.py
</span></span><span style="display:flex;"><span>    │   └── ref_rvc_expand.py
</span></span><span style="display:flex;"><span>    ├── __init__.py
</span></span><span style="display:flex;"><span>    └── <span style="color:#204a87">test</span>
</span></span><span style="display:flex;"><span>        ├── __init__.py
</span></span><span style="display:flex;"><span>        ├── rvc_expander_fixture.py
</span></span><span style="display:flex;"><span>        └── test_rvc.py
</span></span></code></pre></div><p>这里<code>rvc_expander</code>目录下有<code>classical_version</code>传统版本和<code>toffee_version</code>使用toffee的版本。
传统版本就是使用<code>pytest</code>框架来进行测试，<code>toffee</code>只使用了其<code>Bundle</code>;而在toffee版本中，我们会使用更多<code>toffee</code>的特性。      <br>
一般来说，<strong>使用传统版本就已经可以覆盖绝大多数情况了</strong>，只有在传统版本不能满足需求时，才需要使用<code>toffee</code>版本。<br>
编写测试环境的时候，<strong>两个版本选择一个就行</strong>。<br>
模块（例如<code>rvc_expander</code>）中的代码目录结构由贡献者自行决定（我们写的时候并<strong>不需要再建一级<code>classical_version</code>或<code>toffee_version</code>目录</strong>），但需要满足 python 规范，且逻辑和命名合理。</p>
<h2 id="env-编写要求">Env 编写要求</h2>
<ul>
<li>需要进行 RTL 版本检查</li>
<li>Env 提供的 API 需要和引脚、时序无关</li>
<li>Env 提供的 API 需要稳定，不能随意进行接口/返回值修改</li>
<li>需要定义必要的 fixture</li>
<li>需要初始化功能检查点（功能检查点可以独立成一个模块）</li>
<li>需要进行覆盖率统计</li>
<li>需要有说明文档</li>
</ul>
<h2 id="编写测试环境传统版本">编写测试环境：传统版本</h2>
<p>在 UT 验证模块的测试环境中，目标是完成以下工作：</p>
<ol>
<li>对 DUT 进行功能封装，为测试提供稳定 API</li>
<li>定义功能覆盖率</li>
<li>定义必要 fixture 提供给测试用例</li>
<li>在合理时刻统计覆盖率</li>
</ol>
<p>以 IFU 环境中的 RVCExpander 为例（<code>ut_frontend/ifu/rvc_expander/classical_version/env/rvc_expander_wrapper.py</code>）：</p>
<h3 id="1-dut-封装">1. DUT 封装</h3>
<p>以下内容位于<code>ut_frontend/ifu/rvc_expander/classical_version/env/rvc_expander_wrapper.py</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">class</span> <span style="color:#000">RVCExpander</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">toffee</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">Bundle</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">__init__</span><span style="color:#000;font-weight:bold">(</span><span style="color:#3465a4">self</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">cover_group</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#ce5c00;font-weight:bold">**</span><span style="color:#000">kwargs</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87">super</span><span style="color:#000;font-weight:bold">()</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">__init__</span><span style="color:#000;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">cover_group</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">cover_group</span>
</span></span><span style="display:flex;"><span>        <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">dut</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">DUTRVCExpander</span><span style="color:#000;font-weight:bold">(</span><span style="color:#ce5c00;font-weight:bold">**</span><span style="color:#000">kwargs</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic"># 创建DUT</span>
</span></span><span style="display:flex;"><span>        <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">io</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">toffee</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">Bundle</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">from_prefix</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;io_&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">dut</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic"># 通过 Bundle 使用前缀关联引脚</span>
</span></span><span style="display:flex;"><span>        <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">bind</span><span style="color:#000;font-weight:bold">(</span><span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">dut</span><span style="color:#000;font-weight:bold">)</span>                 <span style="color:#8f5902;font-style:italic"># 把 Bundle 与 DUT 进行绑定</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">expand</span><span style="color:#000;font-weight:bold">(</span><span style="color:#3465a4">self</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">instr</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">fsIsOff</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>        <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">io</span><span style="color:#000;font-weight:bold">[</span><span style="color:#4e9a06">&#34;in&#34;</span><span style="color:#000;font-weight:bold">]</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">value</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">instr</span>         <span style="color:#8f5902;font-style:italic"># 给DUT引脚赋值</span>
</span></span><span style="display:flex;"><span>        <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">io</span><span style="color:#000;font-weight:bold">[</span><span style="color:#4e9a06">&#34;fsIsOff&#34;</span><span style="color:#000;font-weight:bold">]</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">value</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">fsIsOff</span>  <span style="color:#8f5902;font-style:italic"># 给DUT引脚赋值</span>
</span></span><span style="display:flex;"><span>        <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">dut</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">RefreshComb</span><span style="color:#000;font-weight:bold">()</span>              <span style="color:#8f5902;font-style:italic"># 推动组合电路</span>
</span></span><span style="display:flex;"><span>        <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">cover_group</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">sample</span><span style="color:#000;font-weight:bold">()</span>           <span style="color:#8f5902;font-style:italic"># 调用sample对功能覆盖率进行统计</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">io</span><span style="color:#000;font-weight:bold">[</span><span style="color:#4e9a06">&#34;out_bits&#34;</span><span style="color:#000;font-weight:bold">]</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">value</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">io</span><span style="color:#000;font-weight:bold">[</span><span style="color:#4e9a06">&#34;ill&#34;</span><span style="color:#000;font-weight:bold">]</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">value</span>  <span style="color:#8f5902;font-style:italic"># 返回结果 和 是否是非法指令</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">stat</span><span style="color:#000;font-weight:bold">(</span><span style="color:#3465a4">self</span><span style="color:#000;font-weight:bold">):</span>                         <span style="color:#8f5902;font-style:italic"># 获取当前状态</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#4e9a06">&#34;instr&#34;</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">io</span><span style="color:#000;font-weight:bold">[</span><span style="color:#4e9a06">&#34;in&#34;</span><span style="color:#000;font-weight:bold">]</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">value</span><span style="color:#000;font-weight:bold">,</span>         <span style="color:#8f5902;font-style:italic"># 输入指令</span>
</span></span><span style="display:flex;"><span>            <span style="color:#4e9a06">&#34;decode&#34;</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">io</span><span style="color:#000;font-weight:bold">[</span><span style="color:#4e9a06">&#34;out_bits&#34;</span><span style="color:#000;font-weight:bold">]</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">value</span><span style="color:#000;font-weight:bold">,</span>  <span style="color:#8f5902;font-style:italic"># 返回展开结果</span>
</span></span><span style="display:flex;"><span>            <span style="color:#4e9a06">&#34;ilegal&#34;</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">io</span><span style="color:#000;font-weight:bold">[</span><span style="color:#4e9a06">&#34;ill&#34;</span><span style="color:#000;font-weight:bold">]</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">value</span> <span style="color:#ce5c00;font-weight:bold">!=</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">,</span>  <span style="color:#8f5902;font-style:italic"># 输入是否非法</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre></div><p>在上述例子中，<code>class RVCExpander</code>对<code>DUTRVCExpander</code>进行了封装，对外提供了两个 API：</p>
<ul>
<li>expand(instr: int, fsIsOff: bool) -&gt; (int, int) ：该函数用于接受输入指令 instr 进行解码，返回（结果，非法指令标记）。如果非法指令标记不为 0，者说明输入指令非法。</li>
<li>stat() -&gt; dict(instr, decode, ilegal)：该函数用于返回当前的状态，其中包含当前的输入指令，解码结果以及非法指令标记。</li>
</ul>
<p>上述 API <strong>屏蔽了 DUT 的引脚</strong>，对外程序通用功能。</p>
<h3 id="2-定义功能覆盖率">2. 定义功能覆盖率</h3>
<p>尽可能的在 Env 中定义好功能覆盖率，如果有必要也可以在测试用例中定义覆盖率。toffee 功能覆盖率的定义请参考<a href="http://localhost:1313/docs/03_add_test/05_cover_func/">什么是功能覆盖率</a>。为了完善功能检查点和测试用例之间的对应关系，功能覆盖率定义完成后，需要在适合的位置进行检查点和测试用例的对应（测试点反标）。</p>
<p>以下内容位于<code>ut_frontend/ifu/rvc_expander/classical_version/env/rvc_expander_wrapper.py</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">toffee.funcov</span> <span style="color:#204a87;font-weight:bold">as</span> <span style="color:#000">fc</span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 创建功能覆盖率组</span>
</span></span><span style="display:flex;"><span><span style="color:#000">g</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">fc</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">CovGroup</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">UT_FCOV</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;../../../CLASSIC&#34;</span><span style="color:#000;font-weight:bold">))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">init_rvc_expander_funcov</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">g</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#000">fc</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">CovGroup</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#4e9a06">&#34;&#34;&#34;Add watch points to the RVCExpander module to collect function coverage information&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># 1. Add point RVC_EXPAND_RET to check expander return value:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic">#    - bin ERROR. The instruction is not illegal</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic">#    - bin SUCCE. The instruction is not expanded</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">g</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">add_watch_point</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                                <span style="color:#4e9a06">&#34;ERROR&#34;</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">lambda</span> <span style="color:#000">x</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#000">x</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">stat</span><span style="color:#000;font-weight:bold">()[</span><span style="color:#4e9a06">&#34;illegal&#34;</span><span style="color:#000;font-weight:bold">]</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#204a87;font-weight:bold">False</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>                                <span style="color:#4e9a06">&#34;SUCCE&#34;</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">lambda</span> <span style="color:#000">x</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#000">x</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">stat</span><span style="color:#000;font-weight:bold">()[</span><span style="color:#4e9a06">&#34;illegal&#34;</span><span style="color:#000;font-weight:bold">]</span> <span style="color:#ce5c00;font-weight:bold">!=</span> <span style="color:#204a87;font-weight:bold">False</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>                          <span style="color:#000;font-weight:bold">},</span> <span style="color:#000">name</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;RVC_EXPAND_RET&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># 5. Reverse mark function coverage to the check point</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">_M</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">name</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>        <span style="color:#8f5902;font-style:italic"># get the module name</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000">module_name_with</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">name</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;../../test_rv_decode&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic">#  - mark RVC_EXPAND_RET</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">g</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">mark_function</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;RVC_EXPAND_RET&#34;</span><span style="color:#000;font-weight:bold">,</span>     <span style="color:#000">_M</span><span style="color:#000;font-weight:bold">([</span><span style="color:#4e9a06">&#34;test_rvc_expand_16bit_full&#34;</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>                                              <span style="color:#4e9a06">&#34;test_rvc_expand_32bit_full&#34;</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>                                              <span style="color:#4e9a06">&#34;test_rvc_expand_32bit_randomN&#34;</span><span style="color:#000;font-weight:bold">]),</span> <span style="color:#000">bin_name</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#000;font-weight:bold">[</span><span style="color:#4e9a06">&#34;ERROR&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;SUCCE&#34;</span><span style="color:#000;font-weight:bold">])</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">...</span>
</span></span></code></pre></div><p>在上述代码中添加了名为<code>RVC_EXPAND_RET</code>的功能检查点来检查<code>RVCExpander</code>模块是否具有返回非法指令的能力。需要满足<code>ERROR</code>和<code>SUCCE</code>两个条件，即<code>stat()</code>中的<code>illegal</code>需要有<code>True</code>也需要有<code>False</code>值。在定义完检查点后，通过<code>mark_function</code>方法，对会覆盖到该检查的测试用例进行了标记。</p>
<h3 id="3-定义必要fixture">3. 定义必要fixture</h3>
<p>以下内容位于<code>ut_frontend/ifu/rvc_expander/classical_version/env/rvc_expander_wrapper.py</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000">version_check</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">get_version_checker</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;openxiangshan-kmh-*&#34;</span><span style="color:#000;font-weight:bold">)</span>             <span style="color:#8f5902;font-style:italic"># 指定满足要的RTL版本</span>
</span></span><span style="display:flex;"><span><span style="color:#5c35cc;font-weight:bold">@pytest.fixture</span><span style="color:#000;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">rvc_expander</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">request</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">version_check</span><span style="color:#000;font-weight:bold">()</span>                                                    <span style="color:#8f5902;font-style:italic"># 进行版本检查</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">fname</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">request</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">node</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">name</span>                                          <span style="color:#8f5902;font-style:italic"># 获取调用该fixture的测试用例</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">wave_file</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">get_out_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;decoder/rvc_expander_</span><span style="color:#4e9a06">%s</span><span style="color:#4e9a06">.fst&#34;</span> <span style="color:#ce5c00;font-weight:bold">%</span> <span style="color:#000">fname</span><span style="color:#000;font-weight:bold">)</span>     <span style="color:#8f5902;font-style:italic"># 设置波形文件路径</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">coverage_file</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">get_out_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;decoder/rvc_expander_</span><span style="color:#4e9a06">%s</span><span style="color:#4e9a06">.dat&#34;</span> <span style="color:#ce5c00;font-weight:bold">%</span> <span style="color:#000">fname</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic"># 设置代码覆盖率文件路径</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">coverage_dir</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">os</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">path</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">dirname</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">coverage_file</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">os</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">makedirs</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">coverage_dir</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">exist_ok</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#204a87;font-weight:bold">True</span><span style="color:#000;font-weight:bold">)</span>                           <span style="color:#8f5902;font-style:italic"># 目标目录不存在则创建目录</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">expander</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">RVCExpander</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">g</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">coverage_filename</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#000">coverage_file</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">waveform_filename</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#000">wave_file</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>                                                                       <span style="color:#8f5902;font-style:italic"># 创建RVCExpander</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">expander</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">dut</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">io_in</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">AsImmWrite</span><span style="color:#000;font-weight:bold">()</span>                                    <span style="color:#8f5902;font-style:italic"># 设置io_in引脚的写入时机为立即写入             </span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">expander</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">dut</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">io_fsIsOff</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">AsImmWrite</span><span style="color:#000;font-weight:bold">()</span>                               <span style="color:#8f5902;font-style:italic"># 设置io_fsIsOff引脚的写入时机为立即写入  </span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">init_rvc_expander_funcov</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">g</span><span style="color:#000;font-weight:bold">)</span>                              <span style="color:#8f5902;font-style:italic"># 初始化功能检查点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">yield</span> <span style="color:#000">expander</span>                                                     <span style="color:#8f5902;font-style:italic"># 返回创建好的 RVCExpander 给 Test Case</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">expander</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">dut</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">Finish</span><span style="color:#000;font-weight:bold">()</span>                                              <span style="color:#8f5902;font-style:italic"># Tests Case运行完成后，结束DUT</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">set_line_coverage</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">request</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">coverage_file</span><span style="color:#000;font-weight:bold">)</span>                          <span style="color:#8f5902;font-style:italic"># 把生成的代码覆盖率文件告诉 toffee-report</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">set_func_coverage</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">request</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">g</span><span style="color:#000;font-weight:bold">)</span>                                      <span style="color:#8f5902;font-style:italic"># 把生成的功能覆盖率数据告诉 toffee-report</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">g</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">clear</span><span style="color:#000;font-weight:bold">()</span>                                                          <span style="color:#8f5902;font-style:italic"># 清空功能覆盖统计</span>
</span></span></code></pre></div><p>上述 fixture 完成了以下功能：</p>
<ol>
<li>进行 RTL 版本检查，如果不满足<code>&quot;openxiangshan-kmh-*&quot;</code>要求，则跳过调用改 fixture 的测试用例</li>
<li>创建 DUT，并指定了波形，代码行覆盖率文件路径（路径中含有调用该 fixure 的用例名称：fname）</li>
<li>调用<code>init_rvc_expander_funcov</code>添加功能覆盖点</li>
<li>结束 DUT，处理代码行覆盖率和功能覆盖率（发往 toffee-report 进行处理）</li>
<li>清空功能覆盖率</li>
</ol>
<p>*注：在 PyTest 中，执行测试用例<code>test_A(rvc_expander, ....)</code>前（<strong>rvc_expander是我们在使用fixure装饰器时定义的方法名</strong>），会自动调用并执行<code>rvc_expander(request)</code>中<code>yield</code>关键字前的部分（相当于初始化），然后通过<code>yield</code>返回<code>rvc_expander</code>调用<code>test_A</code>用例（<strong>yield返回的对象，在测试用例里就是我们fixture下定义的方法名</strong>），用例执行完成后，再继续执行<code>fixture</code>中<code>yield</code>关键字之后的部分。比如：参照下面统计覆盖率的代码，倒数第四行的
<code>rvc_expand(rvc_expander, generate_rvc_instructions(start, end))</code>，其中的<code>rvc_expander</code>就是我们在<code>fixture</code>中定义的方法名，也就是<code>yield</code>返回的对象。</p>
<h3 id="4-统计覆盖率">4. 统计覆盖率</h3>
<p>以下内容位于<code>ut_frontend/ifu/rvc_expander/classical_version/test_rvc_expander.py</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000">N</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">10</span>
</span></span><span style="display:flex;"><span><span style="color:#000">T</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">1</span><span style="color:#ce5c00;font-weight:bold">&lt;&lt;</span><span style="color:#0000cf;font-weight:bold">16</span>
</span></span><span style="display:flex;"><span><span style="color:#5c35cc;font-weight:bold">@pytest.mark.toffee_tags</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">TAG_LONG_TIME_RUN</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#5c35cc;font-weight:bold">@pytest.mark.parametrize</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;start,end&#34;</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>                         <span style="color:#000;font-weight:bold">[(</span><span style="color:#000">r</span><span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">//</span><span style="color:#000">N</span><span style="color:#000;font-weight:bold">),</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">r</span><span style="color:#ce5c00;font-weight:bold">+</span><span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000;font-weight:bold">)</span><span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">//</span><span style="color:#000">N</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#000">r</span> <span style="color:#ce5c00;font-weight:bold">&lt;</span> <span style="color:#000">N</span><span style="color:#ce5c00;font-weight:bold">-</span><span style="color:#0000cf;font-weight:bold">1</span> <span style="color:#204a87;font-weight:bold">else</span> <span style="color:#000">T</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">for</span> <span style="color:#000">r</span> <span style="color:#204a87;font-weight:bold">in</span> <span style="color:#204a87">range</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">N</span><span style="color:#000;font-weight:bold">)])</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">test_rvc_expand_16bit_full</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">rvc_expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">start</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">end</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#4e9a06">&#34;&#34;&#34;Test the RVC expand function with a full compressed instruction set
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    Description:
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        Perform an expand check on 16-bit compressed instructions within the range from &#39;start&#39; to &#39;end&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># Add check point: RVC_EXPAND_RANGE to check expander input range.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic">#   When run to here, the range[start, end] is covered</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">covered</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">-</span><span style="color:#0000cf;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">g</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">add_watch_point</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">rvc_expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                                <span style="color:#4e9a06">&#34;RANGE[</span><span style="color:#4e9a06">%d</span><span style="color:#4e9a06">-</span><span style="color:#4e9a06">%d</span><span style="color:#4e9a06">]&#34;</span><span style="color:#ce5c00;font-weight:bold">%</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">start</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">end</span><span style="color:#000;font-weight:bold">):</span> <span style="color:#204a87;font-weight:bold">lambda</span> <span style="color:#000">_</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#000">covered</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#000">end</span>
</span></span><span style="display:flex;"><span>                          <span style="color:#000;font-weight:bold">},</span> <span style="color:#000">name</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;RVC_EXPAND_ALL_16B&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">dynamic_bin</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#204a87;font-weight:bold">True</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># Reverse mark function to the check point</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">g</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">mark_function</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;RVC_EXPAND_ALL_16B&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">test_rvc_expand_16bit_full</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">bin_name</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#4e9a06">&#34;RANGE[</span><span style="color:#4e9a06">%d</span><span style="color:#4e9a06">-</span><span style="color:#4e9a06">%d</span><span style="color:#4e9a06">]&#34;</span><span style="color:#ce5c00;font-weight:bold">%</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">start</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">end</span><span style="color:#000;font-weight:bold">))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># Drive the expander and check the result</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">rvc_expand</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">rvc_expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">generate_rvc_instructions</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">start</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">end</span><span style="color:#000;font-weight:bold">))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># When go to here, the range[start, end] is covered</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">covered</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">g</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">sample</span><span style="color:#000;font-weight:bold">()</span>                                                              <span style="color:#8f5902;font-style:italic"># 覆盖率采样</span>
</span></span></code></pre></div><p>在定义了覆盖率之后，还需要在测试用例中进行覆盖率统计。上述代码中，在测试用例中使用<code>add_watch_point</code>添加了一个功能检查点<code>rvc_expander</code>，并在后面进行了标记和采样,而且在最后一样对覆盖率进行了采样。
覆盖率采样，实际上是通过回调函数触发了一次<code>add_watch_point</code>中bins的判断，当其中bins的判断结果为<code>True</code>时，就会统计一次Pass。</p>
<h2 id="编写测试环境toffee版本">编写测试环境：toffee版本</h2>
<p>使用python语言进行的测试可以通过引入我们的开源测试框架<a href="https://github.com/XS-MLVP/toffee">toffee</a>来得到更好的支持。</p>
<p>toffee的官方教程可以参考<a href="https://open-verify.cc/mlvp/docs/mlvp/">这里</a>。</p>
<h3 id="bundle快捷dut封装">bundle：快捷DUT封装</h3>
<p>toffee通过Bundle实现了对DUT的绑定。toffee提供了多种建立Bundle与DUT绑定的方法。相关代码参照<code>ut_frontend/ifu/rvc_expander/toffee_version/bundle</code>。</p>
<h4 id="手动绑定">手动绑定</h4>
<p>toffee框架下，用于支持绑定引脚的最底层类是Signal，其通过命名匹配的方式和DUT中的各个引脚进行绑定。相关代码参照<code>ut_frontend/ifu/rvc_expander/toffee_version</code>。</p>
<p>以最简单的RVCExpander为例，其io引脚形如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">module</span> <span style="color:#000">RVCExpander</span><span style="color:#000;font-weight:bold">(</span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">input</span>  <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">31</span><span style="color:#ce5c00;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">]</span> <span style="color:#000">io_in</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">input</span>         <span style="color:#000">io_fsIsOff</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">output</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">31</span><span style="color:#ce5c00;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">]</span> <span style="color:#000">io_out_bits</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">output</span>        <span style="color:#000">io_ill</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">);</span>
</span></span></code></pre></div><p>一共四个信号，io_in, io_fsIsOff, io_out_bits, io_ill。我们可以抽取共同的前缀，比如&quot;io_&quot;（不过由于in在python中有其他含义，其不能直接作为变量名，虽然可以使用setattr 和getattr方法来规避这个问题，但是出于代码简洁的考虑，我们只选取&quot;io&quot;作为前缀），将后续部分作为引脚名定义在对应的Bundle类中：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">class</span> <span style="color:#000">RVCExpanderIOBundle</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">Bundle</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000">_in</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">_fsIsOff</span> <span style="color:#000;font-weight:bold">,</span><span style="color:#000">_out_bits</span><span style="color:#000;font-weight:bold">,</span><span style="color:#000">_ill</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">Signals</span><span style="color:#000;font-weight:bold">(</span><span style="color:#0000cf;font-weight:bold">4</span><span style="color:#000;font-weight:bold">)</span>
</span></span></code></pre></div><p>然后在更高一级的Env或者Bundle中，采取from_prefix的方式完成前缀的绑定：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">agent</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">RVCExpanderAgent</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">RVCExpanderIOBundle</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">from_prefix</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;io&#34;</span><span style="color:#000;font-weight:bold">)</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">bind</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">dut</span><span style="color:#000;font-weight:bold">))</span>
</span></span></code></pre></div><h4 id="自动定义bundle">自动定义Bundle</h4>
<p>实际上，Bundle类的定义也不一定需要写明，可以仅仅通过前缀绑定：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">io</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">toffee</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">Bundle</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">from_prefix</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;io_&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">dut</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic"># 通过 Bundle 使用前缀关联引脚</span>
</span></span><span style="display:flex;"><span><span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">bind</span><span style="color:#000;font-weight:bold">(</span><span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">dut</span><span style="color:#000;font-weight:bold">)</span>   
</span></span></code></pre></div><p>如果Bundle的from_prefix方法传入dut，其将根据前缀和DUT的引脚名自动生成引脚的定义，而在访问的时候，使用dict访问的思路即可：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">io</span><span style="color:#000;font-weight:bold">[</span><span style="color:#4e9a06">&#34;in&#34;</span><span style="color:#000;font-weight:bold">]</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">value</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">instr</span>
</span></span><span style="display:flex;"><span><span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">io</span><span style="color:#000;font-weight:bold">[</span><span style="color:#4e9a06">&#34;fsIsOff&#34;</span><span style="color:#000;font-weight:bold">]</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">value</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">False</span>
</span></span></code></pre></div><h4 id="bundle代码生成">Bundle代码生成</h4>
<p>toffee框架的<a href="https://github.com/XS-MLVP/toffee/tree/master/scripts">scripts</a>提供了两个脚本。</p>
<p>bundle_code_gen.py脚本主要提供了三个方法：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">gen_bundle_code_from_dict</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">bundle_name</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#204a87">str</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">dut</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#204a87">dict</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#204a87">dict</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">max_width</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#204a87">int</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">120</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">gen_bundle_code_from_prefix</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">bundle_name</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#204a87">str</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">dut</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">prefix</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#204a87">str</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">max_width</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#204a87">int</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">120</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">gen_bundle_code_from_regex</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">bundle_name</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#204a87">str</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">dut</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">regex</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#204a87">str</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">max_width</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#204a87">int</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">120</span><span style="color:#000;font-weight:bold">):</span>
</span></span></code></pre></div><p>通过传入dut和生成规则（包括dict、prefix、regex三种），自动生成对应的bundle代码。</p>
<p>而bundle_code_intel_gen.py则解析picker生成的signals.json文件，自动生成层次化的bundle代码。可以直接在命令行调用：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>python bundle_code_intel_gen.py <span style="color:#ce5c00;font-weight:bold">[</span>signal<span style="color:#ce5c00;font-weight:bold">]</span> <span style="color:#ce5c00;font-weight:bold">[</span>target<span style="color:#ce5c00;font-weight:bold">]</span>
</span></span></code></pre></div><p>如发现自动生成脚本存在bug，欢迎提issue以便我们修正。</p>
<h3 id="agent驱动方法">Agent：驱动方法</h3>
<p>如果说Bundle是将DUT的数据职责进行抽象的话，那么Agent则是将DUT的行为职责封装为一个个接口。简单地说，Agent通过封装多个对外开放的方法，将多组IO操作抽象为一个具体的行为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">class</span> <span style="color:#000">RVCExpanderAgent</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">Agent</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">__init__</span><span style="color:#000;font-weight:bold">(</span><span style="color:#3465a4">self</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">bundle</span><span style="color:#000;font-weight:bold">:</span><span style="color:#000">RVCExpanderIOBundle</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87">super</span><span style="color:#000;font-weight:bold">()</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">__init__</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">bundle</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">bundle</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">bundle</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#5c35cc;font-weight:bold">@driver_method</span><span style="color:#000;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">async</span> <span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">expand</span><span style="color:#000;font-weight:bold">(</span><span style="color:#3465a4">self</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">instr</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">fsIsOff</span><span style="color:#000;font-weight:bold">):</span>             <span style="color:#8f5902;font-style:italic"># 传入参数：RVC指令和fs.status使能情况</span>
</span></span><span style="display:flex;"><span>        <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">bundle</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">_in</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">value</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">instr</span>                   <span style="color:#8f5902;font-style:italic"># 引脚赋值</span>
</span></span><span style="display:flex;"><span>        <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">bundle</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">_fsIsOff</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">value</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">fsIsOff</span>            <span style="color:#8f5902;font-style:italic"># 引脚赋值</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">await</span> <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">bundle</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">step</span><span style="color:#000;font-weight:bold">()</span>                        <span style="color:#8f5902;font-style:italic"># 推动时钟</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">bundle</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">_out_bits</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">value</span><span style="color:#000;font-weight:bold">,</span>             <span style="color:#8f5902;font-style:italic"># 返回值：扩展后指令</span>
</span></span><span style="display:flex;"><span>                <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">bundle</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">_ill</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">value</span>                  <span style="color:#8f5902;font-style:italic"># 返回值：指令合法校验</span>
</span></span></code></pre></div><p>譬如，RVCExpander的指令扩展功能接收输入的指令（可能为RVI指令，也可能为RVC指令）和CSR对fs.status的使能情况。我们将这个功能抽象为expand方法，提供除self以外的两个参数。同时，指令扩展最终将会返回传入指令对应的RVI指令和该指令是否合法的判断，对应地，该方法也返回这两个值。</p>
<h3 id="env测试环境">Env：测试环境</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">class</span> <span style="color:#000">RVCExpanderEnv</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">Env</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">__init__</span><span style="color:#000;font-weight:bold">(</span><span style="color:#3465a4">self</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">dut</span><span style="color:#000;font-weight:bold">:</span><span style="color:#000">DUTRVCExpander</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87">super</span><span style="color:#000;font-weight:bold">()</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">__init__</span><span style="color:#000;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">dut</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">io_in</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">xdata</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">AsImmWrite</span><span style="color:#000;font-weight:bold">()</span>        
</span></span><span style="display:flex;"><span>        <span style="color:#000">dut</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">io_fsIsOff</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">xdata</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">AsImmWrite</span><span style="color:#000;font-weight:bold">()</span>   <span style="color:#8f5902;font-style:italic"># 设置引脚写入时机</span>
</span></span><span style="display:flex;"><span>        <span style="color:#3465a4">self</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">agent</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">RVCExpanderAgent</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">RVCExpanderIOBundle</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">from_prefix</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;io&#34;</span><span style="color:#000;font-weight:bold">)</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">bind</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">dut</span><span style="color:#000;font-weight:bold">))</span> <span style="color:#8f5902;font-style:italic"># 补全前缀，绑定DUT</span>
</span></span></code></pre></div><h3 id="覆盖率定义">覆盖率定义</h3>
<p>定义覆盖率组的方式和前述方式类似，这里就不再赘述了。</p>
<h3 id="测试套件定义">测试套件定义</h3>
<p>测试套件的定义略有不同：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#5c35cc;font-weight:bold">@toffee_test.fixture</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">async</span> <span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">rvc_expander</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">toffee_request</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#000">toffee_test</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">ToffeeRequest</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">asyncio</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">version_check</span><span style="color:#000;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">dut</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">toffee_request</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">create_dut</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">DUTRVCExpander</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">start_clock</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">dut</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">init_rvc_expander_funcov</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">dut</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">gr</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#000">toffee_request</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">add_cov_groups</span><span style="color:#000;font-weight:bold">([</span><span style="color:#000">gr</span><span style="color:#000;font-weight:bold">])</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">expander</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">RVCExpanderEnv</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">dut</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">yield</span> <span style="color:#000">expander</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">cur_loop</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">asyncio</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">get_event_loop</span><span style="color:#000;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">for</span> <span style="color:#000">task</span> <span style="color:#204a87;font-weight:bold">in</span> <span style="color:#000">asyncio</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">all_tasks</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">cur_loop</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#000">task</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">get_name</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#4e9a06">&#34;__clock_loop&#34;</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000">task</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">cancel</span><span style="color:#000;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>            <span style="color:#204a87;font-weight:bold">try</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#204a87;font-weight:bold">await</span> <span style="color:#000">task</span>
</span></span><span style="display:flex;"><span>            <span style="color:#204a87;font-weight:bold">except</span> <span style="color:#000">asyncio</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">CancelledError</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#204a87;font-weight:bold">break</span>
</span></span></code></pre></div><p>由于toffee提供了更强大的测试覆盖率管理功能，因此不需要手动设置行覆盖率。同时，由于toffee的时钟机制，建议在套件代码最后额外检查任务是否全部结束。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-4cd74e2d3f7d9b1031b77dd328511afa">4.3 - 添加测试用例</h1>
    
	<h2 id="命名要求">命名要求</h2>
<p>所有测试用例文件请以<code>test_*.py</code>的方式进行命名，<code>*</code>用测试目标替换（例如<code>test_rvc_expander.py</code>）。所有测试用例也需要以<code>test_</code>前缀开头。用例名称需要具有明确意义。</p>
<p>命名举例如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">test_a</span><span style="color:#000;font-weight:bold">():</span> <span style="color:#8f5902;font-style:italic"># 不合理，无法通过a判断测试目标</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">test_rvc_expand_16bit_full</span><span style="color:#000;font-weight:bold">():</span> <span style="color:#8f5902;font-style:italic"># 合理，可以通过用例名称大体知道测试内容</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">pass</span>
</span></span></code></pre></div><h2 id="使用-assert">使用 Assert</h2>
<p>在每个测试用例中，都需要通过<code>assert</code>来判断本测试是否通过。
<code>pytest</code>统计的是<code>assert</code>语句的结果，因此<code>assert</code>语句需要保证能够通过。</p>
<p>以下内容位于<code>ut_frontend/ifu/rvc_expander/classical_version/test_rvc_expander.py</code>中：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">rvc_expand</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">rvc_expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">ref_insts</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">is_32bit</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#204a87;font-weight:bold">False</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">fsIsOff</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#204a87;font-weight:bold">False</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#4e9a06">&#34;&#34;&#34;compare the RVC expand result with the reference
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    Args:
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        rvc_expander (warpper): the fixture of the RVC expander
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        ref_insts (list[int]]): the reference instruction list
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">find_error</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">for</span> <span style="color:#000">insn</span> <span style="color:#204a87;font-weight:bold">in</span> <span style="color:#000">ref_insts</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">insn_disasm</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">disasmbly</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">insn</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">value</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">instr_ex</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">rvc_expander</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">expand</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">insn</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">fsIsOff</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#000">is_32bit</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#204a87;font-weight:bold">assert</span> <span style="color:#000">value</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#000">insn</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;RVC expand error, 32bit instruction need to be the same&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">insn_disasm</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#4e9a06">&#34;unknown&#34;</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">and</span>  <span style="color:#000;font-weight:bold">(</span><span style="color:#000">instr_ex</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000">debug</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">f</span><span style="color:#4e9a06">&#34;find bad inst:</span><span style="color:#4e9a06">{</span><span style="color:#000">insn</span><span style="color:#4e9a06">}</span><span style="color:#4e9a06">, ref: 1, dut: 0&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000">find_error</span> <span style="color:#ce5c00;font-weight:bold">+=</span><span style="color:#0000cf;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">elif</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">insn_disasm</span> <span style="color:#ce5c00;font-weight:bold">!=</span> <span style="color:#4e9a06">&#34;unknown&#34;</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">and</span>  <span style="color:#000;font-weight:bold">(</span><span style="color:#000">instr_ex</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>            <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">instr_filter</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">insn_disasm</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">!=</span> <span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000;font-weight:bold">):</span> 
</span></span><span style="display:flex;"><span>                <span style="color:#000">debug</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">f</span><span style="color:#4e9a06">&#34;find bad inst:</span><span style="color:#4e9a06">{</span><span style="color:#000">insn</span><span style="color:#4e9a06">}</span><span style="color:#4e9a06">,disasm:</span><span style="color:#4e9a06">{</span><span style="color:#000">insn_disasm</span><span style="color:#4e9a06">}</span><span style="color:#4e9a06">, ref: 0, dut: 1&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000">find_error</span> <span style="color:#ce5c00;font-weight:bold">+=</span><span style="color:#0000cf;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">assert</span> <span style="color:#0000cf;font-weight:bold">0</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#000">find_error</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;RVC expand error (</span><span style="color:#4e9a06">%d</span><span style="color:#4e9a06"> errros)&#34;</span> <span style="color:#ce5c00;font-weight:bold">%</span> <span style="color:#000">find_error</span>
</span></span></code></pre></div><h2 id="编写注释">编写注释</h2>
<p>每个测试用例都需要添加必要的说明和注释，需要满足<a href="https://peps.python.org/pep-0257/">Python 注释规范</a>。</p>
<p>测试用例说明参考格式：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">test_</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">name</span><span style="color:#ce5c00;font-weight:bold">&gt;</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#000">type_a</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#000">type_b</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#4e9a06">&#34;&#34;&#34;Test abstract
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    Args:
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        a (type_a): description of arg a.
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        b (type_b): description of arg b.
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    Detailed test description here (if need).
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">...</span>
</span></span></code></pre></div><h2 id="用例管理">用例管理</h2>
<p>为了方便测试用例管理，可通过 toffee-test 提供的<code>@pytest.mark.toffee_tags</code>标签功能，请参考
本网站的<a href="https://open-verify.cc/UnityChipForXiangShan/docs/98_others/">其他</a>部分和<a href="https://github.com/XS-MLVP/toffee-test/blob/master/README_zh.md#%E7%AE%A1%E7%90%86%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%B5%84%E6%BA%90">toffee-test</a>。</p>
<h2 id="参考用例">参考用例</h2>
<p>如果很多测试用例（Test）具有相同的操作，该公共操作部分可以提炼成一个通用函数。以 RVCExpander 验证为例，可以把压缩指令的展开与参考模型（disasm）的对比封装成以下函数：</p>
<p>以下内容位于<code>ut_frontend/ifu/rvc_expander/classical_version/test_rvc_expander.py</code>中：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">rvc_expand</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">rvc_expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">ref_insts</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">is_32bit</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#204a87;font-weight:bold">False</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">fsIsOff</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#204a87;font-weight:bold">False</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#4e9a06">&#34;&#34;&#34;compare the RVC expand result with the reference
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    Args:
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        rvc_expander (warpper): the fixture of the RVC expander
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        ref_insts (list[int]]): the reference instruction list
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">find_error</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">for</span> <span style="color:#000">insn</span> <span style="color:#204a87;font-weight:bold">in</span> <span style="color:#000">ref_insts</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">insn_disasm</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">disasmbly</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">insn</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">value</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">instr_ex</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">rvc_expander</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">expand</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">insn</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">fsIsOff</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#000">is_32bit</span><span style="color:#000;font-weight:bold">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#204a87;font-weight:bold">assert</span> <span style="color:#000">value</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#000">insn</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;RVC expand error, 32bit instruction need to be the same&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">insn_disasm</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#4e9a06">&#34;unknown&#34;</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">and</span>  <span style="color:#000;font-weight:bold">(</span><span style="color:#000">instr_ex</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000">debug</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">f</span><span style="color:#4e9a06">&#34;find bad inst:</span><span style="color:#4e9a06">{</span><span style="color:#000">insn</span><span style="color:#4e9a06">}</span><span style="color:#4e9a06">, ref: 1, dut: 0&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000">find_error</span> <span style="color:#ce5c00;font-weight:bold">+=</span><span style="color:#0000cf;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">elif</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">insn_disasm</span> <span style="color:#ce5c00;font-weight:bold">!=</span> <span style="color:#4e9a06">&#34;unknown&#34;</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">and</span>  <span style="color:#000;font-weight:bold">(</span><span style="color:#000">instr_ex</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>            <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">instr_filter</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">insn_disasm</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">!=</span> <span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000;font-weight:bold">):</span> 
</span></span><span style="display:flex;"><span>                <span style="color:#000">debug</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">f</span><span style="color:#4e9a06">&#34;find bad inst:</span><span style="color:#4e9a06">{</span><span style="color:#000">insn</span><span style="color:#4e9a06">}</span><span style="color:#4e9a06">,disasm:</span><span style="color:#4e9a06">{</span><span style="color:#000">insn_disasm</span><span style="color:#4e9a06">}</span><span style="color:#4e9a06">, ref: 0, dut: 1&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>                <span style="color:#000">find_error</span> <span style="color:#ce5c00;font-weight:bold">+=</span><span style="color:#0000cf;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">assert</span> <span style="color:#0000cf;font-weight:bold">0</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#000">find_error</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;RVC expand error (</span><span style="color:#4e9a06">%d</span><span style="color:#4e9a06"> errros)&#34;</span> <span style="color:#ce5c00;font-weight:bold">%</span> <span style="color:#000">find_error</span>
</span></span></code></pre></div><p>在上述公共部分中有 assert，因此调用该函数的 Test 也能提过该 assert 判断运行结果是否提过。</p>
<p>在测试用例的开发过程中，通常存在大量的调试工作，为了让验证环境快速就位，需要编写一些“冒烟测试”进行调试。RVCExpander 展开 16 位压缩指令的冒烟测试如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#5c35cc;font-weight:bold">@pytest.mark.toffee_tags</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">TAG_SMOKE</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">test_rvc_expand_16bit_smoke</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">rvc_expander</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#4e9a06">&#34;&#34;&#34;Test the RVC expand function with 1 compressed instruction&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">rvc_expand</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">rvc_expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">generate_rvc_instructions</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">start</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#0000cf;font-weight:bold">100</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">end</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#0000cf;font-weight:bold">101</span><span style="color:#000;font-weight:bold">))</span>
</span></span></code></pre></div><p>为了方便进行管理，上述测试用例通过<code>toffee_tags</code>标记上了 SMOKE 标签。它的输入参数为<code>rvc_expander</code>，则在在运行时，会自动调用对应同名的<code>fixture</code>进行该参数的填充。</p>
<p>RVCExpander 展开 16 位压缩指令的测试目标是对 2^16 所有压缩指令进行遍历，检测所有情况是否都与参考模型 disasm 一致。在实现上，如果仅仅用一个 Test 进行遍历，则需要耗费大量时间，为此我们可以利用 PyTest 提供的<code>parametrize</code>对 test 进行参数化配置，然后通过<code>pytest-xdist</code>插件并行执行：</p>
<p>以下内容位于<code>ut_frontend/ifu/rvc_expander/classical_version/test_rvc_expander.py</code>中：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000">N</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">10</span>
</span></span><span style="display:flex;"><span><span style="color:#000">T</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">1</span><span style="color:#ce5c00;font-weight:bold">&lt;&lt;</span><span style="color:#0000cf;font-weight:bold">16</span>
</span></span><span style="display:flex;"><span><span style="color:#5c35cc;font-weight:bold">@pytest.mark.toffee_tags</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">TAG_LONG_TIME_RUN</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#5c35cc;font-weight:bold">@pytest.mark.parametrize</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;start,end&#34;</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>                         <span style="color:#000;font-weight:bold">[(</span><span style="color:#000">r</span><span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">//</span><span style="color:#000">N</span><span style="color:#000;font-weight:bold">),</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">r</span><span style="color:#ce5c00;font-weight:bold">+</span><span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000;font-weight:bold">)</span><span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">//</span><span style="color:#000">N</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#000">r</span> <span style="color:#ce5c00;font-weight:bold">&lt;</span> <span style="color:#000">N</span><span style="color:#ce5c00;font-weight:bold">-</span><span style="color:#0000cf;font-weight:bold">1</span> <span style="color:#204a87;font-weight:bold">else</span> <span style="color:#000">T</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">for</span> <span style="color:#000">r</span> <span style="color:#204a87;font-weight:bold">in</span> <span style="color:#204a87">range</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">N</span><span style="color:#000;font-weight:bold">)])</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">test_rvc_expand_16bit_full</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">rvc_expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">start</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">end</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#4e9a06">&#34;&#34;&#34;Test the RVC expand function with a full compressed instruction set
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    Description:
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        Perform an expand check on 16-bit compressed instructions within the range from &#39;start&#39; to &#39;end&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># Add check point: RVC_EXPAND_RANGE to check expander input range.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic">#   When run to here, the range[start, end] is covered</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">g</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">add_watch_point</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">rvc_expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                                <span style="color:#4e9a06">&#34;RANGE[</span><span style="color:#4e9a06">%d</span><span style="color:#4e9a06">-</span><span style="color:#4e9a06">%d</span><span style="color:#4e9a06">]&#34;</span><span style="color:#ce5c00;font-weight:bold">%</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">start</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">end</span><span style="color:#000;font-weight:bold">):</span> <span style="color:#204a87;font-weight:bold">lambda</span> <span style="color:#000">_</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>                          <span style="color:#000;font-weight:bold">},</span> <span style="color:#000">name</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;RVC_EXPAND_ALL_16B&#34;</span><span style="color:#000;font-weight:bold">)</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">sample</span><span style="color:#000;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># Reverse mark function to the check point</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">g</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">mark_function</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;RVC_EXPAND_ALL_16B&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">test_rvc_expand_16bit_full</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">bin_name</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#4e9a06">&#34;RANGE[</span><span style="color:#4e9a06">%d</span><span style="color:#4e9a06">-</span><span style="color:#4e9a06">%d</span><span style="color:#4e9a06">]&#34;</span><span style="color:#ce5c00;font-weight:bold">%</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">start</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">end</span><span style="color:#000;font-weight:bold">))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># Drive the expander and check the result</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">rvc_expand</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">rvc_expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">generate_rvc_instructions</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">start</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">end</span><span style="color:#000;font-weight:bold">))</span>
</span></span></code></pre></div><p>在上述用例中定义了参数化参数<code>start</code>, <code>end</code>，用来指定压缩指令的开始值和结束值，然后通过装饰器<code>@pytest.mark.parametrize</code>对他们进行分组赋值。变量 N 可以指定将目标数据进行分组的组数，默认设置为 10 组。在运行时用例<code>test_rvc_expand_16bit_full</code>会展开为<code>test_rvc_expand_16bit_full[0-6553]</code>至<code>test_rvc_expand_16bit_full[58977-65536]</code>10 个测试用例运行。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c6c51e44e9add2a2d66a22a310fc796b">4.4 - 代码覆盖率</h1>
    
	<p>代码覆盖率是一项评价指标，它衡量了被测代码中哪些部分被执行了，哪些部分没有被执行。通过统计代码覆盖率，可以评估测试的有效性和覆盖程度。</p>
<p>代码覆盖率包括：</p>
<ul>
<li>行覆盖率(line coverage): 被测代码中被执行的行数，最简单的指标，一般期望达到 100%。</li>
<li>条件覆盖率(branch coverage): 每一个控制结构的每个分支是否均被执行。例如，给定一个 if 语句，其 true 和 false 分支是否均被执行？</li>
<li>有限状态机覆盖率(fsm coverage): 状态机所有状态是否都达到过。</li>
<li>翻转覆盖率(toggle coverage): 统计被测代码中被执行的翻转语句，检查电路的每个节点是否都有 0 -&gt; 1 和 1 -&gt; 0 的跳变。</li>
<li>路径覆盖率(path coverage): 检查路径的覆盖情况。在 always 语句块和 initial 语句块中，有时会使用 if &hellip; else 和 case 语句，在电路结构上便会产生一系列的数据路径。。</li>
</ul>
<p>*我们主要使用的模拟器是 Verilator,优先考虑<strong>行覆盖率</strong>。Verilator 支持覆盖率统计，因此我们在构建 DUT 时，如果要开启覆盖率统计，需要在编译选项中添加<code>-c</code>参数。</p>
<h2 id="本项目中相关涉及位置">本项目中相关涉及位置</h2>
<p>开启覆盖率需要在编译时（使用 picker 命令时）加上“-c”参数（参考 picker 的<a href="https://github.com/XS-MLVP/picker/blob/master/README.zh.md#%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A">参数解释</a>），同时在文件中设置启用行覆盖率，这样在使用 toffee 测试时，才能够生成覆盖率统计文件。</p>
<p>结合上面的描述，在本项目中也就是编译，编写和启用行覆盖率函数和测试的时候会涉及到代码覆盖率：</p>
<h3 id="添加编译脚本部分">添加编译脚本部分</h3>
<p><a href="/UnityChipForXiangShan/docs/03_add_test/01_build_script/#%e7%bc%96%e5%86%99-buildcfg---bool-%e5%87%bd%e6%95%b0">编写编译脚本</a></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 省略前面</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#204a87;font-weight:bold">not</span> <span style="color:#000">os</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">path</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">exists</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">get_root_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;dut/RVCExpander&#34;</span><span style="color:#000;font-weight:bold">)):</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">info</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;Exporting RVCExpander.sv&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">s</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">out</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">err</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">exe_cmd</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">f</span><span style="color:#4e9a06">&#39;picker export --cp_lib false </span><span style="color:#4e9a06">{</span><span style="color:#000">get_rtl_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;rtl/RVCExpander.sv&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">cfg</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#000">cfg</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>                                                              <span style="color:#4e9a06">}</span><span style="color:#4e9a06"> --lang python --tdir </span><span style="color:#4e9a06">{</span><span style="color:#000">get_root_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;dut&#34;</span><span style="color:#000;font-weight:bold">)</span><span style="color:#4e9a06">}</span><span style="color:#4e9a06">/ -w rvc.fst -c&#39;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">assert</span> <span style="color:#000">s</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;Failed to export RVCExpander.sv: </span><span style="color:#4e9a06">%s</span><span style="color:#4e9a06">\n</span><span style="color:#4e9a06">%s</span><span style="color:#4e9a06">&#34;</span> <span style="color:#ce5c00;font-weight:bold">%</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">out</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">err</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 省略后面</span>
</span></span></code></pre></div><p>在<code>s, out, err=...</code>这一行，我们使用 picker 命令，并且开启代码了覆盖率(命令最后的&quot;-c&quot;参数)。</p>
<p><a href="/UnityChipForXiangShan/docs/03_add_test/01_build_script/#%e7%bc%96%e5%86%99-line_coverage_filescfg---liststr-%e5%87%bd%e6%95%b0">设置目标覆盖文件(line_coverage_files 函数)</a></p>
<p>按照需求编写<code>line_coverage_files(cfg) -&gt; list[str]</code>函数，并且开启测试结果处理(<code>doc_result.disable = False</code>)让其被调用。</p>
<h3 id="构建测试环境部分">构建测试环境部分</h3>
<p><a href="/UnityChipForXiangShan/docs/03_add_test/02_build_env/#3-%e5%ae%9a%e4%b9%89%e5%bf%85%e8%a6%81fixture">定义必要 fixture</a></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000">set_line_coverage</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">request</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">coverage_file</span><span style="color:#000;font-weight:bold">)</span>                          <span style="color:#8f5902;font-style:italic"># 把生成的代码覆盖率文件告诉 toffee-report</span>
</span></span></code></pre></div><p>通过函数<code>toffee-test.set_line_coverage</code>把覆盖率文件传递给 toffe-test，这样其才能够收集数据，以便于后面生成的报告带有行覆盖率。</p>
<h2 id="忽略指定统计">忽略指定统计</h2>
<p>有时候，我们可能需要手动指定某些内容不参与覆盖率统计。例如有些是不需要被统计的，有些统计不到是正常的。这时候我们就可以忽略这些内容，这对优化覆盖率报告或调试非常有帮助。
目前我们的框架可以使用两种方式来实现忽略统计的功能：</p>
<h3 id="1通过-verilator-指定忽略统计的内容">1.通过 verilator 指定忽略统计的内容</h3>
<h4 id="使用-verilator_coverage_offon-指令">使用 verilator_coverage_off/on 指令</h4>
<p>Verilator 支持通过注释指令来忽略特定代码段的覆盖率统计。例如，使用如下的指令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// *verilator coverage_off*
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// 忽略统计的代码段
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">...</span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// *verilator coverage_on*
</span></span></span></code></pre></div><p>举个例子</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">module</span> <span style="color:#000">example</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">always</span> <span style="color:#000;font-weight:bold">@(</span><span style="color:#204a87;font-weight:bold">posedge</span> <span style="color:#000">clk</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">begin</span>
</span></span><span style="display:flex;"><span>        <span style="color:#8f5902;font-style:italic">// *verilator coverage_off*
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>        <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">debug_signal</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">begin</span>
</span></span><span style="display:flex;"><span>            <span style="color:#204a87">$display</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;This is for debugging only&#34;</span><span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">end</span>
</span></span><span style="display:flex;"><span>        <span style="color:#8f5902;font-style:italic">// *verilator coverage_on*
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>        <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">enable</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">begin</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000">do_something</span><span style="color:#000;font-weight:bold">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">end</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">endmodule</span>
</span></span></code></pre></div><p>在上述示例中，debug_signal 部分的代码将不会计入覆盖率统计，而 enable 部分仍然会被统计。</p>
<p>更多 verilator 的忽略统计方式请参照<a href="https://veripool.org/guide/latest/exe_verilator.html#configuration-files">verilator 官方文档</a></p>
<h3 id="2通过-toffee-指定需要过滤掉的内存">2.通过 toffee 指定需要过滤掉的内存</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">set_line_coverage</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">request</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">datfile</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">ignore</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#000;font-weight:bold">[]):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#4e9a06">&#34;&#34;&#34;Pass
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    Args:
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        request (pytest.Request): Pytest的默认fixture，
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        datfile (string): DUT生成的
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        ignore (list[str]): 覆盖率过滤文件/或者文件夹
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    &#34;&#34;&#34;</span>
</span></span></code></pre></div><p>ignore 参数可以指定在覆盖率文件中需要过滤掉的内容，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">...</span>
</span></span><span style="display:flex;"><span><span style="color:#000">set_line_coverage</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">request</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">coverage_file</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>                  <span style="color:#000">get_root_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;scripts/frontend_ifu_rvc_expander&#34;</span><span style="color:#000;font-weight:bold">))</span>
</span></span></code></pre></div><p>在统计覆盖率时，会在&quot;scripts/frontend_ifu_rvc_expander&quot;目录中搜索到<code>line_coverage.ignore</code>文件，然后按其中每行的通配符进行过滤。</p>
<pre tabindex="0"><code class="language-ignore" data-lang="ignore"># Line covarge ignore file
# ignore Top file
*/RVCExpander_top*%
</code></pre><p>上述文件表示，在统计覆盖率时，会忽略掉包含&quot;RVCExpander_top&quot;关键字的文件（实际上是收集了对应的数据，但是最后统计的时候忽略了）。</p>
<h2 id="查看统计结果">查看统计结果</h2>
<p>在经过前面所有步骤之后，包括准备测试环境中的<a href="/UnityChipForXiangShan/docs/01_verfiy_env/#%e4%b8%8b%e8%bd%bdrtl%e4%bb%a3%e7%a0%81">下载 RTL 代码</a>、<a href="/UnityChipForXiangShan/docs/01_verfiy_env/#%e7%bc%96%e8%af%91DUT">编译 DUT</a>、<a href="/UnityChipForXiangShan/docs/01_verfiy_env/#%e7%bc%96%e8%be%91%e9%85%8d%e7%bd%ae">编辑配置</a>
；添加测试中的<a href="/UnityChipForXiangShan/docs/03_add_test/01_build_script/">添加编译脚本</a>,<a href="/UnityChipForXiangShan/docs/03_add_test/02_build_env/">构建测试环境</a>、<a href="/UnityChipForXiangShan/docs/03_add_test/03_add_test/">添加测试用例</a>。</p>
<p>现在<a href="/UnityChipForXiangShan/docs/02_run_test/">运行测试</a>,之后就默认在<code>out/report</code>目录会生成 html 版本的测试报告。</p>
<p>也可以在<a href="https://open-verify.cc/UnityChipForXiangShan/docs/">进度概述</a>图形下方的“当前版本”选择对应的测试报告(按照测试时间命名)，然后点击右侧链接即可查看统计结果。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f2938880e10d36d978ade908698b9760">4.5 - 功能覆盖率</h1>
    
	<p>功能覆盖率（Functional Coverage）是一种<strong>用户定义</strong>的度量标准，用于度量验证中已执行的设计规范的比例。功能覆盖率关注的是设计的功能和特性是否被测试用例覆盖到了。</p>
<p>反标是指将功能点与测试用例对应起来。这样，在统计时，就能看到每个功能点对应了哪些测试用例，从而方便查看哪些功能点用的测试用例多，哪些功能点用的测试用例少，有利于后期的测试用例优化。</p>
<h2 id="本项目中相关涉及位置">本项目中相关涉及位置</h2>
<p>功能覆盖率需要我们先定义了才能统计，主要是在构建测试环境的时候涉及。</p>
<p>在<a href="https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/02_build_env/">构建测试环境</a>中：</p>
<ul>
<li><a href="/UnityChipForXiangShan/docs/03_add_test/02_build_env/#2-%e5%ae%9a%e4%b9%89%e5%8a%9f%e8%83%bd%e8%a6%86%e7%9b%96%e7%8e%87">定义功能覆盖率</a>： 创建了功能覆盖率组,添加观察点和反标</li>
<li><a href="/UnityChipForXiangShan/docs/03_add_test/02_build_env/#3-%e5%ae%9a%e4%b9%89%e5%bf%85%e8%a6%81fixture">定义必要 fixture</a>： 把统计结果传递给 toffee-report</li>
<li><a href="/UnityChipForXiangShan/docs/03_add_test/02_build_env/#4-%e7%bb%9f%e8%ae%a1%e8%a6%86%e7%9b%96%e7%8e%87">统计覆盖率</a>： 添加观察点和反标</li>
</ul>
<p>其他：</p>
<ul>
<li>在 Test case 中使用，可以在每个测试用例里也编写一个功能点。</li>
</ul>
<h2 id="功能覆盖率使用流程">功能覆盖率使用流程</h2>
<h3 id="指定-group-名称">指定 Group 名称</h3>
<p>测试报告通过 Group 名字和 DUT 名字进行匹配，利用 comm.UT_FCOV 获取 DUT 前缀，例如在 Python 模块<code>ut_frontend/ifu/rvc_expander/classical_version/env/rvc_expander_wrapper.py</code>中进行如下调用：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">from</span> <span style="color:#000">comm</span> <span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">UT_FCOV</span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 本模块名为：ut_frontend.ifu.rvc_expander.classical_version.env.rvc_expander_wrapper</span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 通过../../../去掉了classical_version和上级模块env，rvc_expander_wrapper</span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># UT_FCOV会默认去掉前缀 ut_</span>
</span></span><span style="display:flex;"><span><span style="color:#000">g</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">fc</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">CovGroup</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">UT_FCOV</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;../../../CLASSIC&#34;</span><span style="color:#000;font-weight:bold">))</span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># name = UT_FCOV(&#34;../../../CLASSIC&#34;)</span>
</span></span></code></pre></div><p>name 的值为<code>frontend.ifu.rvc_expander.CLASSIC</code>，在最后统计结果时，会按照最长前缀匹配到目标 UT（即匹配到：frontend.ifu.rvc_expander 模块）</p>
<h3 id="创建覆盖率组">创建覆盖率组</h3>
<p>使用<code>toffee</code>的<code>funcov</code>可以创建覆盖率组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">toffee.funcov</span> <span style="color:#204a87;font-weight:bold">as</span> <span style="color:#000">fc</span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 使用上面指定的GROUP名字</span>
</span></span><span style="display:flex;"><span><span style="color:#000">g</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">fc</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">CovGroup</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">name</span><span style="color:#000;font-weight:bold">)</span>
</span></span></code></pre></div><p>这两步也可以合成一句<code>g = fc.CovGroup(UT_FCOV(&quot;../../../CLASSIC&quot;))</code>。
创建的g对象就表示了一个功能覆盖率组，可以使用其来提供观察点和反标。</p>
<h3 id="添加观察点和反标">添加观察点和反标</h3>
<p>在每个测试用例内部，可以使用<code>add_watch_point</code>（<code>add_cover_point</code>是其别名，二者完全一致）来添加观察点和<code>mark_function</code>来添加反标。
观察点是，当对应的信号触发了我们在观察点内部定义的要求后，这个观察点的名字（也就是功能点）就会被统计到功能覆盖率中。
反标是，将功能点和测试用例进行关联，这样在统计时，就能看到每个功能点对应了哪些测试用例。</p>
<p>对于观察点的位置，需要根据实际情况来定，一般来说，在测试用例外直接添加观察点是没有问题的。
不过有时候我们可以更加的灵活。</p>
<ol>
<li>在测试用例之外（<code>decode_wrapper.py</code>中）</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">init_rvc_expander_funcov</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">g</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#000">fc</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">CovGroup</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#4e9a06">&#34;&#34;&#34;Add watch points to the RVCExpander module to collect function coverage information&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># 1. Add point RVC_EXPAND_RET to check expander return value:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic">#    - bin ERROR. The instruction is not illegal</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic">#    - bin SUCCE. The instruction is not expanded</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">g</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">add_watch_point</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>                                <span style="color:#4e9a06">&#34;ERROR&#34;</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">lambda</span> <span style="color:#000">x</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#000">x</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">stat</span><span style="color:#000;font-weight:bold">()[</span><span style="color:#4e9a06">&#34;ilegal&#34;</span><span style="color:#000;font-weight:bold">]</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#204a87;font-weight:bold">False</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>                                <span style="color:#4e9a06">&#34;SUCCE&#34;</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">lambda</span> <span style="color:#000">x</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#000">x</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">stat</span><span style="color:#000;font-weight:bold">()[</span><span style="color:#4e9a06">&#34;ilegal&#34;</span><span style="color:#000;font-weight:bold">]</span> <span style="color:#ce5c00;font-weight:bold">!=</span> <span style="color:#204a87;font-weight:bold">False</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>                          <span style="color:#000;font-weight:bold">},</span> <span style="color:#000">name</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;RVC_EXPAND_RET&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># 5. Reverse mark function coverage to the check point</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">_M</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">name</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>        <span style="color:#8f5902;font-style:italic"># get the module name</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000">module_name_with</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">name</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;../../test_rv_decode&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic">#  - mark RVC_EXPAND_RET</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">g</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">mark_function</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;RVC_EXPAND_RET&#34;</span><span style="color:#000;font-weight:bold">,</span><span style="color:#000">_M</span><span style="color:#000;font-weight:bold">([</span><span style="color:#4e9a06">&#34;test_rvc_expand_16bit_full&#34;</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>                                              <span style="color:#4e9a06">&#34;test_rvc_expand_32bit_full&#34;</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>                                              <span style="color:#4e9a06">&#34;test_rvc_expand_32bit_randomN&#34;</span><span style="color:#000;font-weight:bold">]),</span> <span style="color:#000">bin_name</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#000;font-weight:bold">[</span><span style="color:#4e9a06">&#34;ERROR&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;SUCCE&#34;</span><span style="color:#000;font-weight:bold">])</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># The End                                                                              </span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#204a87;font-weight:bold">None</span> 
</span></span></code></pre></div><p>这个例子的第一个<code>g.add_watch_point</code>是放在测试用例之外的，因为它和现有的测试用例没有直接关系，放在测试用例之外反而更加方便。添加观察点之后，只要<code>add_watch_point</code>方法中的<code>bins</code>条件触发了，我们的<code>toffee-test</code>框架就能够收集到对应的功能点。</p>
<ol start="2">
<li>在测试用例之中（<code>test_rvc_expander.py</code>中）</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000">N</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#0000cf;font-weight:bold">10</span>
</span></span><span style="display:flex;"><span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#0000cf;font-weight:bold">1</span><span style="color:#ce5c00;font-weight:bold">&lt;&lt;</span><span style="color:#0000cf;font-weight:bold">32</span>
</span></span><span style="display:flex;"><span><span style="color:#5c35cc;font-weight:bold">@pytest.mark.toffee_tags</span><span style="color:#000;font-weight:bold">([</span><span style="color:#000">TAG_LONG_TIME_RUN</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">TAG_RARELY_USED</span><span style="color:#000;font-weight:bold">])</span>
</span></span><span style="display:flex;"><span><span style="color:#5c35cc;font-weight:bold">@pytest.mark.parametrize</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;start,end&#34;</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>                         <span style="color:#000;font-weight:bold">[(</span><span style="color:#000">r</span><span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">//</span><span style="color:#000">N</span><span style="color:#000;font-weight:bold">),</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">r</span><span style="color:#ce5c00;font-weight:bold">+</span><span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000;font-weight:bold">)</span><span style="color:#ce5c00;font-weight:bold">*</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">//</span><span style="color:#000">N</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#000">r</span> <span style="color:#ce5c00;font-weight:bold">&lt;</span> <span style="color:#000">N</span><span style="color:#ce5c00;font-weight:bold">-</span><span style="color:#0000cf;font-weight:bold">1</span> <span style="color:#204a87;font-weight:bold">else</span> <span style="color:#000">T</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">for</span> <span style="color:#000">r</span> <span style="color:#204a87;font-weight:bold">in</span> <span style="color:#204a87">range</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">N</span><span style="color:#000;font-weight:bold">)])</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">test_rvc_expand_32bit_full</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">rvc_expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">start</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">end</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#4e9a06">&#34;&#34;&#34;Test the RVC expand function with a full 32 bit instruction set
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    Description:
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">        Randomly generate N 32-bit instructions for each check, and repeat the process K times.
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># Add check point: RVC_EXPAND_ALL_32B to check instr bits.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">covered</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">-</span><span style="color:#0000cf;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">g</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">add_watch_point</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">rvc_expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">{</span><span style="color:#4e9a06">&#34;RANGE[</span><span style="color:#4e9a06">%d</span><span style="color:#4e9a06">-</span><span style="color:#4e9a06">%d</span><span style="color:#4e9a06">]&#34;</span><span style="color:#ce5c00;font-weight:bold">%</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">start</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">end</span><span style="color:#000;font-weight:bold">):</span> <span style="color:#204a87;font-weight:bold">lambda</span> <span style="color:#000">_</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#000">covered</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#000">end</span><span style="color:#000;font-weight:bold">},</span>
</span></span><span style="display:flex;"><span>                      <span style="color:#000">name</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;RVC_EXPAND_ALL_32B&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">dynamic_bin</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#204a87;font-weight:bold">True</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># Reverse mark function to the check point</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">g</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">mark_function</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;RVC_EXPAND_ALL_32B&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">test_rvc_expand_32bit_full</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># Drive the expander and check the result</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">rvc_expand</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">rvc_expander</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#204a87">list</span><span style="color:#000;font-weight:bold">([</span><span style="color:#000">_</span> <span style="color:#204a87;font-weight:bold">for</span> <span style="color:#000">_</span> <span style="color:#204a87;font-weight:bold">in</span> <span style="color:#204a87">range</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">start</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">end</span><span style="color:#000;font-weight:bold">)]))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># When go to here, the range[start, end] is covered</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">covered</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">g</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">sample</span><span style="color:#000;font-weight:bold">()</span>
</span></span></code></pre></div><p>这个例子的观察点在测试用例里面，因为这里的<code>start</code>和<code>end</code>是由<code>pytest.mark.parametrize</code>来决定的，数值不是固定的，所以我们需要在测试用例里面添加观察点。</p>
<h3 id="采样">采样</h3>
<p>在上一个例子的最后，我们调用了<code>g.sample()</code>，这个函数的作用是告诉<code>toffee-test</code>，<code>add_watch_point</code>里的<code>bins</code>已经执行过了，判断一下是不是True，是的话就为这个观察点记录一次Pass。</p>
<p>有手动就有自动。我们可以在构建测试环境时，在定义fixture中加入<code>StepRis(lambda x: g.sample())</code>,这样就会在每个时钟周期的上升沿自动采样。</p>
<p>以下内容来自<code>ut_backend/ctrl_block/decode/env/decode_wrapper.py </code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#5c35cc;font-weight:bold">@pytest.fixture</span><span style="color:#000;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">decoder</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">request</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># before test</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">init_rv_decoder_funcov</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">g</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">func_name</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">request</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">node</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">name</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># If the output directory does not exist, create it</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">output_dir_path</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">get_out_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;decoder/log&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">os</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">makedirs</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">output_dir_path</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">exist_ok</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#204a87;font-weight:bold">True</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">decoder</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">Decode</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">DUTDecodeStage</span><span style="color:#000;font-weight:bold">(</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">waveform_filename</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#000">get_out_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;decoder/decode_</span><span style="color:#4e9a06">%s</span><span style="color:#4e9a06">.fst&#34;</span><span style="color:#ce5c00;font-weight:bold">%</span><span style="color:#000">func_name</span><span style="color:#000;font-weight:bold">),</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">coverage_filename</span><span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#000">get_out_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;decoder/decode_</span><span style="color:#4e9a06">%s</span><span style="color:#4e9a06">.dat&#34;</span><span style="color:#ce5c00;font-weight:bold">%</span><span style="color:#000">func_name</span><span style="color:#000;font-weight:bold">),</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">decoder</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">dut</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">InitClock</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;clock&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">decoder</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">dut</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">StepRis</span><span style="color:#000;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">lambda</span> <span style="color:#000">x</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#000">g</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">sample</span><span style="color:#000;font-weight:bold">())</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">yield</span> <span style="color:#000">decoder</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8f5902;font-style:italic"># after test</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">decoder</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">dut</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">Finish</span><span style="color:#000;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">coverage_file</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">get_out_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;decoder/decode_</span><span style="color:#4e9a06">%s</span><span style="color:#4e9a06">.dat&#34;</span><span style="color:#ce5c00;font-weight:bold">%</span><span style="color:#000">func_name</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#204a87;font-weight:bold">not</span> <span style="color:#000">os</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">path</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">exists</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">coverage_file</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">raise</span> <span style="color:#c00;font-weight:bold">FileNotFoundError</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">f</span><span style="color:#4e9a06">&#34;File not found: </span><span style="color:#4e9a06">{</span><span style="color:#000">coverage_file</span><span style="color:#4e9a06">}</span><span style="color:#4e9a06">&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">set_line_coverage</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">request</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">coverage_file</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">get_root_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;scripts/backend_ctrlblock_decode&#34;</span><span style="color:#000;font-weight:bold">))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">set_func_coverage</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">request</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">g</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">g</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">clear</span><span style="color:#000;font-weight:bold">()</span>
</span></span></code></pre></div><p>如上面所示，我们在<code>yield</code>之前调用了<code>g.sample()</code>，这样就会在每个时钟周期的上升沿自动采样。</p>
<p><code>StepRis</code>函数的作用是在每个时钟周期的上升沿执行传入的函数，详情可参照<a href="https://open-verify.cc/mlvp/docs/env_usage/picker_usage/">picker使用介绍</a></p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-07ebcfe55daf3596c9e3470979e4e81e">5 - 如何参与本项目</h1>
    
	<h3 id="如何提交bug">如何提交Bug</h3>
<p>按 ISSUE 模板进行提交，标记上对应的标签（bug，bug等级等）</p>
<p>对应模块的维护者进行检查，并修改他给出的标记和香山分支</p>
<h3 id="如何提交文档">如何提交文档</h3>
<p>本仓库文档以PR的形式在本仓库提交，DUT文档在仓库<a href="https://github.com/XS-MLVP/UnityChipForXiangShan/tree/main/documents/content/zh-cn/docs/98_UT">UnityChipForXiangShan/documents/content/zh-cn/docs/98_UT</a>中进行提交。</p>
<p>本项目欢迎任何人以<a href="https://github.com/XS-MLVP/UnityChipForXiangShan/issues"><code>ISSUE</code></a>、<a href="https://github.com/XS-MLVP/env-xs-ov-00-bpu/discussions"><code>DISCUSS</code></a>、<a href="https://github.com/XS-MLVP/UnityChipForXiangShan/fork"><code>Fork</code></a>、<a href="https://github.com/XS-MLVP/env-xs-ov-00-bpu/pulls"><code>PR</code></a>的方式参与。</p>
<p>万众一芯QQ交流群：</p>
<image src="600480230.jpg" alter="600480230" width=300px />

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1d0ac3d7094a9a644440034e44c77115">6 - 模板-PR</h1>
    
	<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold"># Description
</span></span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>Please include a summary of the changes and the related issue. 
</span></span><span style="display:flex;"><span>Please also include relevant motivation and context. 
</span></span><span style="display:flex;"><span>List any dependencies that are required for this change.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Fixes # (issue)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## Type of change
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>Please delete options that are not relevant.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> Bug fix (non-breaking change which fixes an issue)
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> New feature (non-breaking change which adds functionality)
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> Breaking change (fix or feature that would cause existing functionality to not work as expected)
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> This change requires a documentation update
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold"># How Has This Been Tested?
</span></span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>Please describe the tests that you ran to verify your changes. Provide instructions so we can reproduce. 
</span></span><span style="display:flex;"><span>Please also list any relevant details for your test configuration
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> Test A
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [x]</span> Test B
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">**Test Configuration**</span>:
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">*</span> Firmware version:
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">*</span> Hardware:
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">*</span> Toolchain:
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">*</span> SDK:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold"># Checklist:
</span></span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> My code follows the style guidelines of this project
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> I have performed a self-review of my code
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> I have commented my code, particularly in hard-to-understand areas
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> I have made corresponding changes to the documentation
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> My changes generate no new warnings
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> I have added tests that prove my fix is effective or that my feature works
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> New and existing unit tests pass locally with my changes
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> Any dependent changes have been merged and published in downstream modules
</span></span></code></pre></div><p>展示效果如下：</p>
<h1 id="description">Description</h1>
<p>Please include a summary of the changes and the related issue. Please also include relevant motivation
and context. List any dependencies that are required for this change.</p>
<p>Fixes # (issue)</p>
<h2 id="type-of-change">Type of change</h2>
<p>Please delete options that are not relevant.</p>
<ul>
<li><input disabled="" type="checkbox"> Bug fix (non-breaking change which fixes an issue)</li>
<li><input disabled="" type="checkbox"> New feature (non-breaking change which adds functionality)</li>
<li><input disabled="" type="checkbox"> Breaking change (fix or feature that would cause existing functionality to not work as expected)</li>
<li><input disabled="" type="checkbox"> This change requires a documentation update</li>
</ul>
<h1 id="how-has-this-been-tested">How Has This Been Tested?</h1>
<p>Please describe the tests that you ran to verify your changes. Provide instructions so we can reproduce.
Please also list any relevant details for your test configuration</p>
<ul>
<li><input disabled="" type="checkbox"> Test A</li>
<li><input checked="" disabled="" type="checkbox"> Test B</li>
</ul>
<p><strong>Test Configuration</strong>:</p>
<ul>
<li>Firmware version:</li>
<li>Hardware:</li>
<li>Toolchain:</li>
<li>SDK:</li>
</ul>
<h1 id="checklist">Checklist:</h1>
<ul>
<li><input disabled="" type="checkbox"> My code follows the style guidelines of this project</li>
<li><input disabled="" type="checkbox"> I have added the appropriate labels</li>
<li><input disabled="" type="checkbox"> I have performed a self-review of my code</li>
<li><input disabled="" type="checkbox"> I have commented my code, particularly in hard-to-understand areas</li>
<li><input disabled="" type="checkbox"> I have made corresponding changes to the documentation</li>
<li><input disabled="" type="checkbox"> My changes generate no new warnings</li>
<li><input disabled="" type="checkbox"> I have added tests that prove my fix is effective or that my feature works</li>
<li><input disabled="" type="checkbox"> New and existing unit tests pass locally with my changes</li>
<li><input disabled="" type="checkbox"> Any dependent changes have been merged and published in downstream modules</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-4efe7d3d46d7929f2a2b248110be165b">7 - 模板-ISSUE</h1>
    
	<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## Description
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>A brief description of the issue.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## Steps to Reproduce
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">1.</span> Describe the first step
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">2.</span> Describe the second step
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">3.</span> Describe the third step
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">4.</span> ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## Expected Result
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>Describe what you expected to happen.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## Actual Result
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>Describe what actually happened.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## Screenshots
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>If applicable, add screenshots to help explain your problem.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## Environment
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">-</span> OS: [e.g. Windows 10, macOS 10.15, Ubuntu 20.04]
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">-</span> Browser: [e.g. Chrome 86, Firefox 82, Safari 14]
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">-</span> Version: [e.g. 1.0.0]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## Additional Information
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>Add any other context about the problem here.
</span></span></code></pre></div><p>展示效果如下：</p>
<h2 id="description">Description</h2>
<p>A brief description of the issue.</p>
<h2 id="steps-to-reproduce">Steps to Reproduce</h2>
<ol>
<li>Describe the first step</li>
<li>Describe the second step</li>
<li>Describe the third step</li>
<li>&hellip;</li>
</ol>
<h2 id="expected-result">Expected Result</h2>
<p>Describe what you expected to happen.</p>
<h2 id="actual-result">Actual Result</h2>
<p>Describe what actually happened.</p>
<h2 id="screenshots">Screenshots</h2>
<p>If applicable, add screenshots to help explain your problem.</p>
<h2 id="environment">Environment</h2>
<ul>
<li>OS: [e.g. Windows 10, macOS 10.15, Ubuntu 20.04]</li>
<li>Browser: [e.g. Chrome 86, Firefox 82, Safari 14]</li>
<li>Version: [e.g. 1.0.0]</li>
</ul>
<h2 id="additional-information">Additional Information</h2>
<p>Add any other context about the problem here.</p>
<h2 id="checklist">Checklist</h2>
<ul>
<li><input disabled="" type="checkbox"> I have searched the existing issues</li>
<li><input disabled="" type="checkbox"> I have added the appropriate labels</li>
<li><input disabled="" type="checkbox"> I have reproduced the issue with the latest version</li>
<li><input disabled="" type="checkbox"> I have provided a detailed description of the bug</li>
<li><input disabled="" type="checkbox"> I have provided steps to reproduce the issue</li>
<li><input disabled="" type="checkbox"> I have included screenshots (if applicable)</li>
<li><input disabled="" type="checkbox"> I have provided the environment details (OS, version, etc.)</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-68658f28e70d830f706f538c1d44b165">8 - 模板-UT-README</h1>
    
	<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span><span style="color:#000080;font-weight:bold"># 模块名称
</span></span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 测试目标
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#204a87;font-weight:bold">测试目标</span><span style="color:#a40000">、</span><span style="color:#c4a000">测试方法描述</span><span style="color:#000;font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 测试环境
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#204a87;font-weight:bold">测试环境描述</span><span style="color:#a40000">，</span><span style="color:#c4a000">依赖描述</span><span style="color:#000;font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 功能检测
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#204a87;font-weight:bold">给出目标待测功能与对应的检测方法</span><span style="color:#000;font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>|序号|所属模块|功能描述|检查点描述|检查标识|检查项|
</span></span><span style="display:flex;"><span>|-|-|-|-|-|-|
</span></span><span style="display:flex;"><span>|-|-|-|-|-|-|
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 验证接口
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#204a87;font-weight:bold">接口的描述</span><span style="color:#000;font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 用例说明
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">#### 测试用例1
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>|步骤|操作内容|预期结果|覆盖功能点|
</span></span><span style="display:flex;"><span>|-|-|-|-|
</span></span><span style="display:flex;"><span>|-|-|-|-|
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">#### 测试用例2
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>|步骤|操作内容|预期结果|覆盖功能点|
</span></span><span style="display:flex;"><span>|-|-|-|-|
</span></span><span style="display:flex;"><span>|-|-|-|-|
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 目录结构
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#204a87;font-weight:bold">对本模块的目录结构进行描述</span><span style="color:#000;font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 检测列表
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> 本文档符合指定[模板]()要求
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> Env提供的API不包含任何DUT引脚和时序信息
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> Env的API保持稳定（共有[ X ]个）
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> Env中对所支持的RTL版本（支持版本[ X ]）进行了检查
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> 功能点（共有[ X ]个）与[设计文档]()一致
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> 检查点（共有[ X ]个）覆盖所有功能点
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> 检查点的输入不依赖任何DUT引脚，仅依赖Env的标准API
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> 所有测试用例（共有[ X ]个）都对功能检查点进行了反标
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> 所有测试用例都是通过 assert 进行的结果判断
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> 所有DUT或对应wrapper都是通过fixture创建
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> 在上述fixture中对RTL版本进行了检查
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> 创建DUT或对应wrapper的fixture进行了功能和代码行覆盖率统计
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">- [ ]</span> 设置代码行覆盖率时对过滤需求进行了检查
</span></span></code></pre></div><p>展示效果如下：</p>
<h1 id="模块名称">模块名称</h1>
<h2 id="测试目标">测试目标</h2>
<p>&lt;测试目标、测试方法描述&gt;</p>
<h2 id="测试环境">测试环境</h2>
<p>&lt;测试环境描述，依赖描述&gt;</p>
<h2 id="功能检测">功能检测</h2>
<p>&lt;给出目标待测功能与对应的检测方法&gt;</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>所属模块</th>
          <th>功能描述</th>
          <th>检查点描述</th>
          <th>检查标识</th>
          <th>检查项</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>-</td>
          <td>-</td>
          <td>-</td>
          <td>-</td>
          <td>-</td>
          <td>-</td>
      </tr>
  </tbody>
</table>
<h2 id="验证接口">验证接口</h2>
<p>&lt;接口的描述&gt;</p>
<h2 id="用例说明">用例说明</h2>
<h4 id="测试用例1">测试用例1</h4>
<table>
  <thead>
      <tr>
          <th>步骤</th>
          <th>操作内容</th>
          <th>预期结果</th>
          <th>覆盖功能点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>-</td>
          <td>-</td>
          <td>-</td>
          <td>-</td>
      </tr>
  </tbody>
</table>
<h4 id="测试用例2">测试用例2</h4>
<table>
  <thead>
      <tr>
          <th>步骤</th>
          <th>操作内容</th>
          <th>预期结果</th>
          <th>覆盖功能点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>-</td>
          <td>-</td>
          <td>-</td>
          <td>-</td>
      </tr>
  </tbody>
</table>
<h2 id="目录结构">目录结构</h2>
<p>&lt;对本模块的目录结构进行描述&gt;</p>
<h2 id="检测列表">检测列表</h2>
<ul>
<li><input disabled="" type="checkbox"> 本文档符合指定<a href="">模板</a>要求</li>
<li><input disabled="" type="checkbox"> Env提供的API不包含任何DUT引脚和时序信息</li>
<li><input disabled="" type="checkbox"> Env的API保持稳定（共有[ X ]个）</li>
<li><input disabled="" type="checkbox"> Env中对所支持的RTL版本（支持版本[ X ]）进行了检查</li>
<li><input disabled="" type="checkbox"> 功能点（共有[ X ]个）与<a href="">设计文档</a>一致</li>
<li><input disabled="" type="checkbox"> 检查点（共有[ X ]个）覆盖所有功能点</li>
<li><input disabled="" type="checkbox"> 检查点的输入不依赖任何DUT引脚，仅依赖Env的标准API</li>
<li><input disabled="" type="checkbox"> 所有测试用例（共有[ X ]个）都对功能检查点进行了反标</li>
<li><input disabled="" type="checkbox"> 所有测试用例都是通过 assert 进行的结果判断</li>
<li><input disabled="" type="checkbox"> 所有DUT或对应wrapper都是通过fixture创建</li>
<li><input disabled="" type="checkbox"> 在上述fixture中对RTL版本进行了检查</li>
<li><input disabled="" type="checkbox"> 创建DUT或对应wrapper的fixture进行了功能和代码行覆盖率统计</li>
<li><input disabled="" type="checkbox"> 设置代码行覆盖率时对过滤需求进行了检查</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-08609283b091262ac299662399e11d12">9 - 常用API</h1>
    
	<h2 id="comm-模块">comm 模块</h2>
<p>在comm中提供了部分可公用的API，可通过以下方式进行调用：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># import all</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">from</span> <span style="color:#000">comm</span> <span style="color:#204a87;font-weight:bold">import</span> <span style="color:#ce5c00;font-weight:bold">*</span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># or direct import functions you need</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">from</span> <span style="color:#000">com</span> <span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">function_you_need</span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># or access from module</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">comm</span>
</span></span><span style="display:flex;"><span><span style="color:#000">comm</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">function_you_need</span><span style="color:#000;font-weight:bold">()</span>
</span></span></code></pre></div><h3 id="cfg-子模块">cfg 子模块</h3>
<h4 id="get_configcfgnone">get_config(cfg=None)</h4>
<p>获取当前的Config配置</p>
<ul>
<li>输入：如果cfg不为空，则返回cfg。否则则自动通过toffee获取全局Config。</li>
<li>返回：Config对象</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">comm</span>
</span></span><span style="display:flex;"><span><span style="color:#000">cfg</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">comm</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">get_config</span><span style="color:#000;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87">print</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">cfg</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">rtl</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">version</span><span style="color:#000;font-weight:bold">)</span>
</span></span></code></pre></div><h4 id="cfg_as_strcfg-cfgobject">cfg_as_str(cfg: CfgObject):</h4>
<p>把config对象转换为字符类型</p>
<ul>
<li>输入：Config对象</li>
<li>返回：编码后的Config对象</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">comm</span>
</span></span><span style="display:flex;"><span><span style="color:#000">cfg_str</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">comm</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">cfg_as_str</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">comm</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">get_config</span><span style="color:#000;font-weight:bold">())</span>
</span></span></code></pre></div><h4 id="cfg_from_strcfg_str">cfg_from_str(cfg_str)</h4>
<p>把字符类型的Config对象还原</p>
<ul>
<li>输入：编码后的Config对象</li>
<li>返回：Config对象</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">comm</span>
</span></span><span style="display:flex;"><span><span style="color:#000">cfg</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">comm</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">cfg_from_str</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">cfg_str</span><span style="color:#000;font-weight:bold">)</span>
</span></span></code></pre></div><h4 id="dump_cfgcfg-cfgobject--none-cfg_filenone">dump_cfg(cfg: CfgObject = None, cfg_file=None)</h4>
<p>把config对象保持到文件</p>
<ul>
<li>输入：
<ul>
<li>cfg 需要保存的config</li>
<li>cfg_file 目标文件</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">comm</span>
</span></span><span style="display:flex;"><span><span style="color:#000">cfg</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">comm</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">get_config</span><span style="color:#000;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span><span style="color:#000">comm</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">dump_cfg</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">cfg</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;config.yaml&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span></code></pre></div><h3 id="functions-子模块">functions 子模块</h3>
<h4 id="get_log_dirsubdir-cfgnone">get_log_dir(subdir=&quot;&quot;, cfg=None)</h4>
<p>获取日志目录</p>
<ul>
<li>输入：
<ul>
<li>subdir： 子目录</li>
<li>cfg：配置文件</li>
</ul>
</li>
<li>输出：日志目录</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">comm</span>
</span></span><span style="display:flex;"><span><span style="color:#000">my_log</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">comm</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">get_log_dir</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;my_log&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87">print</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">my_log</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic"># /workspace/UnityChipForXiangShan/out/log/my_log</span>
</span></span></code></pre></div><h4 id="get_out_dirsubdir-cfgnone">get_out_dir(subdir=&quot;&quot;, cfg=None)</h4>
<p>获取输出目录</p>
<ul>
<li>输入：
<ul>
<li>subdir： 子目录</li>
<li>cfg：配置文件</li>
</ul>
</li>
<li>输出：输出目录</li>
</ul>
<h4 id="get_rtl_dirsubdir-cfgnone">get_rtl_dir(subdir=&quot;&quot;, cfg=None)</h4>
<p>获取RTL目录</p>
<ul>
<li>输入：
<ul>
<li>subdir： 子目录</li>
<li>cfg：配置文件</li>
</ul>
</li>
<li>输出：RTL目录</li>
</ul>
<h4 id="get_root_dirsubdir">get_root_dir(subdir=&quot;&quot;)</h4>
<p>获取根目录：</p>
<ul>
<li>输入：根目录下的子目录</li>
<li>输出：当前仓库的根目录</li>
</ul>
<h4 id="is_all_file_existfiles_to_check-dir">is_all_file_exist(files_to_check, dir)</h4>
<p>判断文件是否在指定目录中都存在</p>
<ul>
<li>输入：
<ul>
<li>files_to_check: 需要检查的文件列表</li>
<li>dir：目标目录</li>
</ul>
</li>
<li>输出：是否都存在，只要有一个文件不存在都返回False</li>
</ul>
<h4 id="time_formatsecondsnone-fmtymd-hms">time_format(seconds=None, fmt=&quot;%Y%m%d-%H%M%S&quot;)</h4>
<p>格式化时间</p>
<ul>
<li>输入：
<ul>
<li>seconds：需要格式化的时间，为None表示当前时间</li>
<li>fmt：时间格式</li>
</ul>
</li>
<li>返回：格式化之后的时间字符串</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">comm</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">time</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87">print</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">time_format</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">time</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">time</span><span style="color:#000;font-weight:bold">()))</span> <span style="color:#8f5902;font-style:italic"># 20241202-083726</span>
</span></span></code></pre></div><h4 id="base64_encodeinput_str">base64_encode(input_str)</h4>
<p>base64编码：</p>
<ul>
<li>输入：需要编码的字符串</li>
<li>输出：编码之后的字符串</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">comm</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87">print</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">comm</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">base64_encode</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;test&#34;</span><span style="color:#000;font-weight:bold">))</span> <span style="color:#8f5902;font-style:italic"># dGVzdA==</span>
</span></span></code></pre></div><h4 id="base64_decodebase64_str">base64_decode(base64_str)</h4>
<p>base64解码：</p>
<ul>
<li>输入：bas64编码</li>
<li>输出：解码之后的原始字符串</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">comm</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87">print</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">comm</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">base64_decode</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;dGVzdA==&#34;</span><span style="color:#000;font-weight:bold">))</span> <span style="color:#8f5902;font-style:italic"># test</span>
</span></span></code></pre></div><h4 id="exe_cmdcmd-no_logfalse">exe_cmd(cmd, no_log=False)</h4>
<p>执行操作系统命令：</p>
<ul>
<li>输入：
<ul>
<li>cmd：需要执行的os命令</li>
<li>是否需要返回命令行输出</li>
</ul>
</li>
<li>输出：success，stdout、sterr
<ul>
<li>sucess：命令是否执行成功</li>
<li>命令标准输出字符串（no_log=True时，强制为空）</li>
<li>命令标准错误字符串（no_log=True时，强制为空）</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">comm</span>
</span></span><span style="display:flex;"><span><span style="color:#000">su</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">st</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">er</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">exe_cmd</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;pwd&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87">print</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">st</span><span style="color:#000;font-weight:bold">)</span>
</span></span></code></pre></div><h4 id="get_git_commit">get_git_commit()</h4>
<p>获取当前仓库git commit号</p>
<h4 id="get_git_branch">get_git_branch()</h4>
<p>获取当前仓库git 分支名称</p>
<h4 id="ut_fcovgroup-ignore_prefixut_">UT_FCOV(group, ignore_prefix=&ldquo;ut_&rdquo;)</h4>
<p>获取功能覆盖率分组</p>
<ul>
<li>输入：
<ul>
<li>group 分组名称</li>
<li>ignore_prefix需要去掉的前缀</li>
</ul>
</li>
<li>输出：带模块前缀的覆盖率分组名</li>
</ul>
<p>例如，在<code>ut_backend/ctrl_block/decode/env/decode_wrapper.py</code>中调用：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87">print</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">UT_FCOV</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;../../INT&#34;</span><span style="color:#000;font-weight:bold">))</span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># out</span>
</span></span><span style="display:flex;"><span><span style="color:#000">backend</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">ctrl_block</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">decode</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">INT</span>
</span></span></code></pre></div><h4 id="get_version_checkertarget_version">get_version_checker(target_version)</h4>
<p>获取版本检测函数</p>
<ul>
<li>输入：目标版本字符串</li>
<li>输出：检测函数</li>
</ul>
<p>返回的检测函数，一般在fixture中进行版本判断。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">comm</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">pytest</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000">checker</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">comm</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">get_version_checker</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;openxiangshan-kmh-24092701+&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#5c35cc;font-weight:bold">@pytest.fixture</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">fixture</span><span style="color:#000;font-weight:bold">():</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000">checker</span><span style="color:#000;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ce5c00;font-weight:bold">...</span>
</span></span></code></pre></div><h4 id="module_name_withnames-prefixnone">module_name_with(names, prefix=None)</h4>
<p>给names统一加上模块前缀</p>
<ul>
<li>输入：
<ul>
<li>nanmes 需要添加前缀的字符列表</li>
<li>prefix 模块前缀</li>
</ul>
</li>
<li>返回：添加完成后的字符串列表</li>
</ul>
<p>例如在a/b/c/d/e.py文件中调用该方法：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">comm</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87">print</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">comm</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">module_name_with</span><span style="color:#000;font-weight:bold">([</span><span style="color:#4e9a06">&#34;X&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;Y&#34;</span><span style="color:#000;font-weight:bold">],</span> <span style="color:#000;font-weight:bold">,</span><span style="color:#4e9a06">&#34;../../x&#34;</span><span style="color:#000;font-weight:bold">))</span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># out</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">[</span><span style="color:#4e9a06">&#34;a.b.c.x.X&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;a.b.c.x.Y&#34;</span><span style="color:#000;font-weight:bold">]</span>
</span></span></code></pre></div><h4 id="get_all_rtl_filestop_module-cfg"><code>get_all_rtl_files(top_module, cfg)</code></h4>
<p>获取名称为 <code>top_module</code> 的模块所依赖的所有 RTL 文件（<code>.v</code> 或 <code>.sv</code>）的列表，并确保列表的第一个元素是 <code>top_module</code> 所在文件的绝对路径。所有 RTL 文件均位于 <code>UnityChipForXiangShan/rtl/rtl</code> 目录下。</p>
<ul>
<li>
<p>输入：</p>
<ul>
<li><code>top_module</code>：模块名称，类型为 <code>str</code>。</li>
<li><code>cfg</code>：配置信息，类型为 <code>CfgObject</code>。</li>
</ul>
</li>
<li>
<p>输出：</p>
<ul>
<li>返回一个包含字符串的列表，列表中的每个字符串为模块依赖的 RTL 文件的绝对路径。列表的第一个元素为 <code>top_module</code> 所在文件的路径。</li>
</ul>
</li>
</ul>
<p>假设 <code>top_module</code> 为 <code>&quot;ALU&quot;</code>，且其依赖的 RTL 文件包括 <code>ALU.sv</code>、<code>adder.v</code> 和 <code>multiplier.v</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000">paths</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">get_all_rtl_files</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;ALU&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">cfg</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#4e9a06">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">paths可能的内容：
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">[
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    &#34;/path/to/UnityChipForXiangShan/rtl/rtl/ALU.sv&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    &#34;/path/to/UnityChipForXiangShan/rtl/rtl/adder.v&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">    &#34;/path/to/UnityChipForXiangShan/rtl/rtl/multiplier.v&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">]
</span></span></span><span style="display:flex;"><span><span style="color:#4e9a06">&#34;&#34;&#34;</span>
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8a2981468f57aaf0314d1df6c5431ce9">10 - 其他</h1>
    
	<h2 id="测试用例管理">测试用例管理</h2>
<p>如果测试用例和目标RTL版本紧密相关，RTL发生变化，之前的测试用例不一定适用。此外，不同场景下有不同需求，例如验证测试环境时，不运行耗时太长的用例等。因此需要对用例进行管理，让用户能在在特定场景下跳过某些用例。为了实现该目标，我们需要通过<code>pytest.mark.toffee_tags</code>对于每个用例进行tag和version标记。然后在配置文件中设置需要跳过哪些tag或者只运行哪些tag的测试。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#5c35cc;font-weight:bold">@pytest.mark.toffee_tags</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;my_tag&#34;</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#4e9a06">&#34;version1 &lt; version13&#34;</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">test_case_1</span><span style="color:#000;font-weight:bold">():</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">...</span>
</span></span></code></pre></div><p>例如上述<code>test_case_1</code>被标记上了标签<code>my_tag</code>，支持版本设置为<code>version1</code>到<code>version13</code>。因此可以在配置文件中指定<code>test.skip-tags=[&quot;my_tag&quot;]</code>，来表示运行过程中跳过该用例。</p>
<p><code>pytest.mark.toffee_tags</code>的参数说明如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#5c35cc;font-weight:bold">@pytest.mark.toffee_tags</span><span style="color:#000;font-weight:bold">(</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">tag</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#000">Optional</span><span style="color:#000;font-weight:bold">[</span><span style="color:#204a87">list</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#204a87">str</span><span style="color:#000;font-weight:bold">]</span>     <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">[]</span>    <span style="color:#8f5902;font-style:italic"># 用例标签</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">version</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#000">Optional</span><span style="color:#000;font-weight:bold">[</span><span style="color:#204a87">list</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#204a87">str</span><span style="color:#000;font-weight:bold">]</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">[],</span>   <span style="color:#8f5902;font-style:italic"># 用例rtl版本需求</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">skip</span><span style="color:#000;font-weight:bold">:</span> <span style="color:#000">callable</span>               <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">None</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#8f5902;font-style:italic"># 自定义是否调过该用例，skip(tag, version, item): (skip, reason)</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">)</span>
</span></span></code></pre></div><p><code>toffee_tags</code>函数的参数<code>tag</code>支持<code>str</code>和<code>list[str]</code>类型。<code>version</code>参数也可以是<code>str</code>和<code>list[str]</code>类型，当为<code>list</code>类型时，进行精确匹配，如果为<code>str</code>则匹配规则如下：</p>
<ol>
<li><code>name-number1 &lt; namer-number2:</code> 表示版本需要在<code>number1</code>和<code>number2</code>之间（包含边界，<code>number</code>表示数字，也可以为小数，eg <code>1.11</code>）</li>
<li><code>name-number1+</code>：表示<code>number1</code>版本以及以后的版本</li>
<li><code>name-number1-</code>：表示<code>number1</code>版本以及以前的版本</li>
</ol>
<p>如果不存在上述情况，且有<code>*</code>或者<code>?</code>表示通配符类型。其他情况为精确匹配。</p>
<p>预定义标签，可以在comm/constants.py中查看，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># Predefined tags for test cases</span>
</span></span><span style="display:flex;"><span><span style="color:#000">TAG_LONG_TIME_RUN</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;LONG_TIME_RUN&#34;</span>  <span style="color:#8f5902;font-style:italic"># 运行时间长</span>
</span></span><span style="display:flex;"><span><span style="color:#000">TAG_SMOKE</span>         <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;SMOKE&#34;</span>          <span style="color:#8f5902;font-style:italic"># 冒烟测试</span>
</span></span><span style="display:flex;"><span><span style="color:#000">TAG_RARELY_USED</span>   <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;RARELY_USED&#34;</span>    <span style="color:#8f5902;font-style:italic"># 非常少用</span>
</span></span><span style="display:flex;"><span><span style="color:#000">TAG_REGRESSION</span>    <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;REGRESSION&#34;</span>     <span style="color:#8f5902;font-style:italic"># 回归测试</span>
</span></span><span style="display:flex;"><span><span style="color:#000">TAG_PERFORMANCE</span>   <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;PERFORMANCE&#34;</span>    <span style="color:#8f5902;font-style:italic"># 性能测试</span>
</span></span><span style="display:flex;"><span><span style="color:#000">TAG_STABILITY</span>     <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;STABILITY&#34;</span>      <span style="color:#8f5902;font-style:italic"># 稳定测试</span>
</span></span><span style="display:flex;"><span><span style="color:#000">TAG_SECURITY</span>      <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;SECURITY&#34;</span>       <span style="color:#8f5902;font-style:italic"># 安全测试</span>
</span></span><span style="display:flex;"><span><span style="color:#000">TAG_COMPATIBILITY</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;COMPATIBILITY&#34;</span>  <span style="color:#8f5902;font-style:italic"># 兼容测试</span>
</span></span><span style="display:flex;"><span><span style="color:#000">TAG_OTHER</span>         <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;OTHER&#34;</span>          <span style="color:#8f5902;font-style:italic"># 其他</span>
</span></span><span style="display:flex;"><span><span style="color:#000">TAG_CI</span>            <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;CI&#34;</span>             <span style="color:#8f5902;font-style:italic"># 集成测试</span>
</span></span><span style="display:flex;"><span><span style="color:#000">TAG_DEBUG</span>         <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;DEBUG&#34;</span>          <span style="color:#8f5902;font-style:italic"># 测试</span>
</span></span><span style="display:flex;"><span><span style="color:#000">TAG_DEMO</span>          <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;DEMO&#34;</span>           <span style="color:#8f5902;font-style:italic"># demo</span>
</span></span></code></pre></div><p>在默认配置中(<code>config/_default.yaml</code>)，会过滤掉：<code>LONG_TIME_RUN</code>、<code>REGRESSION</code>、<code>RARELY_USED</code>、<code>CI</code> 标记的测试。</p>
<p>可以通过<code>@pytest.mark.toffee_tags</code>可以为每个用例添加标签，也可以在模块中定义如下变量，实现对整个模块的所有测试用例添加标签。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000">toffee_tags_default_tag</span>     <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">[]</span>   <span style="color:#8f5902;font-style:italic"># 对应 tag 参数</span>
</span></span><span style="display:flex;"><span><span style="color:#000">toffee_tags_default_version</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">[]</span>   <span style="color:#8f5902;font-style:italic"># 对应 version 参数</span>
</span></span><span style="display:flex;"><span><span style="color:#000">toffee_tags_default_skip</span>    <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">None</span> <span style="color:#8f5902;font-style:italic"># 对应 skip 参数</span>
</span></span></code></pre></div><p>*注：本环境中的版本号会自动过滤掉git标记，例如下载的RTL名称为<code>openxiangshan-kmh-97e37a2237-24092701.tar.gz</code>，则其版本号在本项目中为：<code>openxiangshan-kmh-24092701</code>, 可通过<code>cfg.rtl.version</code>或者<code>comm.get_config().rtl.version</code>获得。</p>
<h2 id="版本检查">版本检查</h2>
<p>除了可以用标签<code>toffee_tags</code>自动检查版本外，还可以通过<code>get_version_checker</code>主动进行检查。一个单元测试通常由测试环境（Test Env）和测试用例组成（Test Case），Env对RTL引脚和功能进行封装，然后向Case提供稳定API，因此在Env中需要进行RTL版本判断，判断是否需要跳过使用本环境的所有测试用例。例如在Env中：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">...</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">from</span> <span style="color:#000">comm</span> <span style="color:#204a87;font-weight:bold">import</span> <span style="color:#000">get_version_checker</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000">version_check</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">get_version_checker</span><span style="color:#000;font-weight:bold">(</span><span style="color:#4e9a06">&#34;openxiangshan-kmh-*&#34;</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic"># 获取RTL版本检查器，同toffee_tags中的veriosn参数</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#5c35cc;font-weight:bold">@pytest.fixture</span><span style="color:#000;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">my_fixture</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">request</span><span style="color:#000;font-weight:bold">):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">version_check</span><span style="color:#000;font-weight:bold">()</span>                                        <span style="color:#8f5902;font-style:italic"># 在 fixture 中主动检查</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">....</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">yield</span> <span style="color:#000">dut</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">...</span>
</span></span></code></pre></div><p>在上述例子中，Env在名称为<code>my_fixture</code>的<a href="https://docs.pytest.org/en/stable/explanation/fixtures.html">fixture</a>中主动进行了版本检查。因此，在测试用例每次调用它时都会进行版本检查，如果检查不满足要求，则会跳过该用例的执行。</p>
<h2 id="仓库目录说明">仓库目录说明</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>UnityChipForXiangShan
</span></span><span style="display:flex;"><span>├── LICENSE            <span style="color:#8f5902;font-style:italic"># 开源协议</span>
</span></span><span style="display:flex;"><span>├── Makefile           <span style="color:#8f5902;font-style:italic"># Makefile主文件</span>
</span></span><span style="display:flex;"><span>├── README.en.md       <span style="color:#8f5902;font-style:italic"># 英文readme</span>
</span></span><span style="display:flex;"><span>├── README.zh.md       <span style="color:#8f5902;font-style:italic"># 中文readme</span>
</span></span><span style="display:flex;"><span>├── __init__.py        <span style="color:#8f5902;font-style:italic"># Python模块文件，可以把整个UnityChipForXiangShan当成一个模块进行import</span>
</span></span><span style="display:flex;"><span>├── pytest.ini         <span style="color:#8f5902;font-style:italic"># PyTest 配置文件</span>
</span></span><span style="display:flex;"><span>├── comm               <span style="color:#8f5902;font-style:italic"># 公用组件：日志，函数，配置等</span>
</span></span><span style="display:flex;"><span>├── configs            <span style="color:#8f5902;font-style:italic"># 配置文件目录</span>
</span></span><span style="display:flex;"><span>├── documents          <span style="color:#8f5902;font-style:italic"># 文档</span>
</span></span><span style="display:flex;"><span>├── dut                <span style="color:#8f5902;font-style:italic"># dut生成目录</span>
</span></span><span style="display:flex;"><span>├── out                <span style="color:#8f5902;font-style:italic"># log，report等生成目录</span>
</span></span><span style="display:flex;"><span>├── requirements.txt   <span style="color:#8f5902;font-style:italic"># python依赖</span>
</span></span><span style="display:flex;"><span>├── rtl                <span style="color:#8f5902;font-style:italic"># rtl缓存</span>
</span></span><span style="display:flex;"><span>├── run.py             <span style="color:#8f5902;font-style:italic"># 主python入口文件</span>
</span></span><span style="display:flex;"><span>├── scripts            <span style="color:#8f5902;font-style:italic"># dut编译脚本</span>
</span></span><span style="display:flex;"><span>├── tools              <span style="color:#8f5902;font-style:italic"># 公共工具模块</span>
</span></span><span style="display:flex;"><span>├── ut_backend         <span style="color:#8f5902;font-style:italic"># 后端测试用例</span>
</span></span><span style="display:flex;"><span>├── ut_frontend        <span style="color:#8f5902;font-style:italic"># 前端测试用例</span>
</span></span><span style="display:flex;"><span>├── ut_mem_block       <span style="color:#8f5902;font-style:italic"># 访存测试用例</span>
</span></span><span style="display:flex;"><span>└── ut_misc            <span style="color:#8f5902;font-style:italic"># 其他测试用例</span>
</span></span></code></pre></div><h2 id="配置文件说明">配置文件说明</h2>
<p>默认配置与说明如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 默认配置文件</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#8f5902;font-style:italic"># 配置加载顺序: _default.yaml -&gt; 用户指定的 *.yaml -&gt; 命令行参数 eg: log.term-level=&#39;debug&#39;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#8f5902;font-style:italic"># RTL 配置</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#204a87;font-weight:bold">rtl</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># RLT下载地址，从该地址获取所有*.gz.tar文件当成目标RTL</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">base-url</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000">https://&lt;your_rtl_download_address&gt;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 需要下载的RTL版本 eg: openxiangshan-kmh-97e37a2237-24092701</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">version</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000">latest</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 需要存储RTL的目录，相对于当前配置文件的路径</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">cache-dir</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;../rtl&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#8f5902;font-style:italic"># 测试用例配置（tag和case支持通配符）</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#204a87;font-weight:bold">test</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 跳过标签，所有带有该标签的测试用例都会被跳过</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">skip-tags</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000;font-weight:bold">[</span><span style="color:#4e9a06">&#34;LONG_TIME_RUN&#34;</span><span style="color:#000;font-weight:bold">,</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;RARELY_USED&#34;</span><span style="color:#000;font-weight:bold">,</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;REGRESSION&#34;</span><span style="color:#000;font-weight:bold">,</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;CI&#34;</span><span style="color:#000;font-weight:bold">]</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 目标标签，只有带有该标签的测试用例才会被执行（skip-tags会覆盖run-tags）</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">run-tags</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000;font-weight:bold">[]</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 跳过的测试用例，所有带有该名字（或者模块名）的测试用例都会被跳过。</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">skip-cases</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000;font-weight:bold">[]</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 目标测试用例，只有带有该名字（或者模块名）的测试用例才会被执行（skip-cases会覆盖run-cases）。</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">run-cases</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000;font-weight:bold">[]</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 跳过异常，所有抛出该异常的测试用例都会被跳过</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">skip-exceptions</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#000;font-weight:bold">[]</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#8f5902;font-style:italic"># 输出配置</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#204a87;font-weight:bold">output</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 输出目录，相对于当前配置文件的路径</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">out-dir</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;../out&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#8f5902;font-style:italic"># 测试报告配置</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#204a87;font-weight:bold">report</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 报告生成目录，相对于output.out-dir</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">report-dir</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;report&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 报告名称，支持变量替换：%{host} 主机名，%{pid} 进程ID，%{time} 当前时间</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">report-name</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;%{host}-%{pid}-%{time}/index.html&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 报告内容</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">information</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">    </span><span style="color:#8f5902;font-style:italic"># 报告标题</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">    </span><span style="color:#204a87;font-weight:bold">title</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;XiangShan KMH Test Report&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">    </span><span style="color:#8f5902;font-style:italic"># 报告用户信息</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">    </span><span style="color:#204a87;font-weight:bold">user</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">      </span><span style="color:#204a87;font-weight:bold">name</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;User&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">      </span><span style="color:#204a87;font-weight:bold">email</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;User@example.email.com&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">    </span><span style="color:#8f5902;font-style:italic"># 目标行覆盖率 eg: 90 表示 90%</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">    </span><span style="color:#204a87;font-weight:bold">line_grate</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#0000cf;font-weight:bold">99</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">    </span><span style="color:#8f5902;font-style:italic"># 其他需要展示的信息，key为标题，value为内容</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">    </span><span style="color:#204a87;font-weight:bold">meta</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">      </span><span style="color:#204a87;font-weight:bold">Version</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;1.0&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#8f5902;font-style:italic"># 日志配置</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#204a87;font-weight:bold">log</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 根输出级别</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">root-level</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;debug&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 终端输出级别</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">term-level</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;info&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 文件日志输出级别</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">file-dir</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;log&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 文件日志名称，支持变量替换：%{host} 主机名，%{pid} 进程ID，%{time} 当前时间</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">file-name</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;%{host}-%{pid}-%{time}.log&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 文件日志输出级别</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">file-level</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;info&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#8f5902;font-style:italic"># 测试结果配置（该数据用于填充documents中的统计图等，原始数据来源于toffee-test生成的report）</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#8f5902;font-style:italic">#  运行完测试后，可通过 `make doc` 查看结果</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline"></span><span style="color:#204a87;font-weight:bold">doc-result</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 是否开测试结果后处理</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">disable</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#204a87;font-weight:bold">False</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 目标DUT的组织结构配置</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">dutree</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;%{root}/configs/dutree/xiangshan-kmh.yaml&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 结果名称，将会保存到输出的report目录</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">result-name</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;ut_data_progress.json&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#8f5902;font-style:italic"># 创建的测试报告的软连接到 hugo</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span><span style="display:flex;"><span><span style="color:#f8f8f8;text-decoration:underline">  </span><span style="color:#204a87;font-weight:bold">report-link</span><span style="color:#000;font-weight:bold">:</span><span style="color:#f8f8f8;text-decoration:underline"> </span><span style="color:#4e9a06">&#34;%{root}/documents/static/data/reports&#34;</span><span style="color:#f8f8f8;text-decoration:underline">
</span></span></span></code></pre></div><p>可在上述配置文件中添加自定义参数，通过<code>cfg = comm.get_config()</code>获取全局配置信息，然后通过<code>cfg.your_key</code>进行访问。<code>cfg</code>信息为只读信息，默认情况下不能进行修改。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-69941129f79fb8261f7f1fe7b92e7c0a">11 - 必要规范</h1>
    
	<p>为了方便将所有人的贡献集合在一起，需要在编码、环境、文档编写等方面采用相同的“规范”。</p>
<h3 id="环境要求">环境要求</h3>
<ul>
<li><strong>python：</strong> 在python编码过程中，尽可能的采用标准库，采用兼容Python3大部分版本的通用语法（尽可能的在Python3.6 - Python3.12中通用），不要使用过旧或者过新的语法。</li>
<li><strong>操作系统：</strong> 建议Ubuntu 22.04，windows下，建议使用WSL2环境。</li>
<li><strong>hugo</strong> 建议版本 0.124.1（版本过旧不支持软连接）</li>
<li><strong>少依赖</strong> 尽可能少的使用第三方C++/C库</li>
<li><strong>picker</strong> 建议使用wheel安装picker工具和xspcomm库</li>
</ul>
<h3 id="测试用例">测试用例</h3>
<ul>
<li><strong>代码风格</strong> 建议采用 <a href="https://peps.python.org/pep-0008/">PEP 8 规范</a></li>
<li><strong>build脚本</strong> 需要按DUT的命名结构进行规范命名，不然无法正确收集验证结果。例如<code>backend.ctrl_block.decode</code>UT在scripts目录中对应的build文件名称应该为<code>build_ut_backend_ctrl_block_decode.py</code>(以固定前缀<code>build_ut_</code>开始，点<code>.</code>用下划线<code>_</code>进行替换)。在脚本中实现 <code>build(cfg) -&gt; bool</code> 和 <code>line_coverage_files(cfg) -&gt; list[str]</code> 方法。<code>build</code>用于编译DUT为<code>python</code>模块，<code>line_coverage_files</code>方法用于返回需要统计的代码行覆盖率文件。</li>
<li><strong>用例标签</strong> 如果用例无法做到版本通用，需要用<code>pytest.mark.toffee_tags</code>标记支持的版本。</li>
<li><strong>用例抽象</strong> 编写的测试用例输入不能出现DUT的具体引脚等强耦合内容，只能调用基于DUT之上的函数封装。例如对于加法器 adder，需要把dut的目标功能封装为 <code>dut_wrapper.add(a: int, b: int) -&gt; int, bool</code>，在test_case中仅仅调用 <code>sum, c = add(a, b)</code>进行测试。</li>
<li><strong>覆盖抽象</strong> 在编写功能覆盖率时，其检查点函数的输入也不能有DUT引脚。</li>
<li><strong>环境抽象</strong> 对于一个验证，通常分为2部分：Test Case 和 Env （用例以外的都统一称为Env，它包含DUT、驱动、监控等），其中Env需要提供对外的功能抽象接口，不能对外呈现出太多细节。</li>
<li><strong>测试说明</strong> 在每个DUT的验证环境中，需要通过<code>README.md</code>对该环境进行说明，例如需要对Env提供给Case的接口进行说明，目录结构说明等。</li>
</ul>
<h3 id="pr编写">PR编写</h3>
<ul>
<li><strong>标题</strong> 简洁明了，能概括PR的主要内容。</li>
<li><strong>详细描述</strong> 详细说明PR的目的，修改的内容以及相关背景信息。入解决已有的问题需要给出链接（例如Issue）。</li>
<li><strong>关联问题</strong> 在描述中关联相关问题，例如 <code>Fixes #123</code>，以便在合并PR时关闭关联问题。</li>
<li><strong>测试</strong> 需要进行测试，并对测试结果进行描述</li>
<li><strong>文档</strong> PR涉及到的文档需要同步修改</li>
<li><strong>分解</strong> 当PR涉及到的修改很多时，需要判断是否拆分成多个PR</li>
<li><strong>检查清单</strong> 检查编译是否通过、代码风格是否合理、是否测试通过、是否有必要的注释等</li>
<li><strong>模板</strong> 以及提供的PR模块请<a href="08_pr_template/">参考链接</a>。</li>
</ul>
<h3 id="issue编写">ISSUE编写</h3>
<p>要求同上</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a8a5b9eb9136a6246521abc3abcc6fe5">12 - 验证文档</h1>
    
	
</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-896ce137500976f8efacd0b63e691b2b">12.1 - 验证文档规范</h1>
    
	

<div class="pageinfo pageinfo-primary">
<p>本规范规定了“万众一芯”验证文档的必要形式和结构（不是验证报告的模板），已发布和将来将要发布的文档都需要遵循这一规范。</p>

</div>

<h1 id="万众一芯验证文档格式规范">万众一芯验证文档格式规范</h1>
<p>验证文档标题请用一号标题格式（一个#），以加法器验证文档为例，其标题可以为：进位加法器设计与验证。</p>
<h2 id="文档概述">文档概述</h2>
<p>文档概述标题请用二号标题格式（两个#）。</p>
<p><strong>【必填项】</strong> 在该部分对整个文档进行简约描述，例如内容概述，待验证模块的基本功能、特殊需求、特定规格、目标读者、知识前置等。目的是通过对该部分，读者便了解是否具有其感兴趣的内容。例如本文档是对验证文档的编写要求进行描述，便于多文档协作，规范验证的数据输入，特定数据标签等。</p>
<h2 id="术语说明">术语说明</h2>
<p>术语说明标题请用二号标题格式（两个#）。</p>
<p><strong>【必填项】</strong> 该部分需要列出术语和关键概念解释，方便读者参考。</p>
<ol>
<li>优先解释模块专有缩写（如TLB， FIFO等），且用<code>缩写（全名）</code>的格式填写在“名称”一栏中。</li>
<li>对容易混淆的概念请务必明确（如虚拟地址和物理地址等）</li>
<li>示例格式如下：</li>
</ol>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>定义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>TLB（Translation Lookaside Buffer）</td>
          <td>地址转换的缓存单元，用于加速虚拟地址到物理的转换</td>
      </tr>
      <tr>
          <td>FIFO（First In First Out）</td>
          <td>先进先出队列</td>
      </tr>
      <tr>
          <td>写回</td>
          <td>发生在Cache替换时，如果被替换块为脏块，需要将缓存行写回对应内存位置</td>
      </tr>
  </tbody>
</table>
<p>如果有其他补充情况请在此说明，例如：上述命名描述仅针对香山处理器，不代表RISC-V标准或者其他处理器。</p>
<h2 id="前置知识">前置知识</h2>
<p>前置知识标题请用二号标题格式（两个#）。</p>
<p><strong>【可选项】</strong> 在阅读文档或进行验证之前，建议掌握一些关键前置知识，以便更深入理解相关内容。例如，在撰写LoadStoreQueue（LSQ）文档时，讲述RAW（Read After Write）违例有助于理解操作之间的依赖关系。在撰写Icache或L2Cache文档时，介绍缓存层级、替换策略和一致性模型等基本概念也有助于读者理解。如果涉及复杂算法，也应对其进行简要描述。</p>
<p>基本要求：</p>
<ol>
<li>该部分内容应简洁，易于理解。如篇幅较长，可将内容移至附录。</li>
<li>针对较为复杂的内容，可以通过图像、伪代码和案例进行解释，以降低理解难度。</li>
</ol>
<p>下面是一个举例：</p>
<h3 id="st-ld违例">st-ld违例</h3>
<p>在现代处理器中，Load 和 Store 指令通常采用乱序执行的方式进行处理。这种执行策略旨在提高处理器的并行性和整体性能。然而，由于 Load 和 Store 指令在流水线中的乱序执行，常常会出现 Load 指令越过更早的相同地址的 Store 指令的情况。这意味着，Load 指令本应通过前递（forwarding）机制从 Store 指令获取数据，但由于 Store 指令的地址或数据尚未准备好，导致 Load 指令未能成功前递到 Store 的数据，而 Store 指令已被提交。由此，后续依赖于该 Load 指令结果的指令可能会出现错误，这就是 st-ld 违例。</p>
<p>考虑以下伪代码示例：</p>
<pre tabindex="0"><code class="language-mips" data-lang="mips">ST R1, 0(R2)  ; 将 R1 的值存储到 R2 指向的内存地址
LD R3, 0(R2)  ; 从 R2 指向的内存地址加载值到 R3
ADD R4, R3, R5 ; 使用 R3 的值进行计算
</code></pre><p>假设在这个过程中，Store 指令由于某种原因（如缓存未命中）未能及时完成，而 Load 指令已经执行并读取了旧的数据（例如，从内存中读取到的值为 <code>0</code>）。此时，Load 指令并未获得 Store 指令更新后的值，导致后续计算的数据错误。</p>
<p>通过上述例子，可以清楚地看到 Store-to-Load 违例如何在乱序执行的环境中导致数据一致性问题。这种问题强调了在指令调度和执行过程中，确保正确的数据流动的重要性。现代处理器通过多种机制来检测和解决这种违例，以维护程序的正确性和稳定性。</p>
<h2 id="整体框图">整体框图</h2>
<p>整体框图标题请用二号标题格式（两个#）。</p>
<p><strong>【可选项】</strong> 该部分为可选章节，若模块含多个子模块或复杂数据流，需提供框图辅助说明，便于读者理解。</p>
<p>基本要求：</p>
<ol>
<li>图必须清晰，最好为矢量图，可使用Visio/Draw.io等工具绘制，导出为PNG/SVG格式；</li>
<li>图中需标注关键信号流向；</li>
<li>框图中子模块命名需与“子模块列表”章节严格一致；</li>
<li>图像和图表标题的位置需要居中；</li>
<li>如果有多个图表，图表题目需要添加相应标号，如图1、图2等；</li>
</ol>
<p>示例：</p>
<p align="center">
  <img src="https://raw.githubusercontent.com/XS-MLVP/XiangShan-Design-Doc/master/docs/frontend/figure/IFU/IFU/structure.png" alt="示例图像">
</p>
<p align="center">示例图1：IFU 整体框图</p>
<h2 id="流水级示意图">流水级示意图</h2>
<p>流水级示意图标题请用二号标题格式（两个#）。</p>
<p><strong>【可选项】</strong> 若为流水线型模块，需说明各级流水功能与时序关系。</p>
<p><strong>编写要求</strong>：</p>
<ol>
<li>图必须清晰，最好为矢量图，可使用Visio/Draw.io等工具绘制，导出为PNG/SVG格式；</li>
<li>涉及到的模块名称需要与上下文保持一致；</li>
<li>重要信号除了列出信号名称以外，还需要标明位宽等信息；</li>
<li>图像和图表标题的位置需要居中；</li>
<li>如果有多个图表，图表题目需要添加相应标号，如图1、图2等。</li>
</ol>
<p>示例：</p>
<p align="center">
  <img src="https://raw.githubusercontent.com/XS-MLVP/XiangShan-Design-Doc/master/docs/memblock/LSU/figure/LSU-LoadUnit.svg" alt="示例图像">
</p>
<p align="center">示例图2：LSU-LoadUnit 流水线架构图</p>
<h2 id="子模块列表">子模块列表</h2>
<p>子模块列表标题请用二号标题格式（两个#）。</p>
<p><strong>【可选项】</strong> 如果一个模块由多个子模块组成，则需要在此处列出所有相关的子模块，并进行简要说明。这有助于清晰地展示模块的结构和功能，便于读者理解各个子模块之间的关系及其在整体系统中的作用。</p>
<p>以下是IFU top文档中的一个示例：</p>
<table>
  <thead>
      <tr>
          <th>子模块</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="01_predecode.md">PreDecoder</a></td>
          <td>预译码模块，用于生成有效指令标识和类型信息</td>
      </tr>
      <tr>
          <td><a href="02_f3predecoder.md">F3Predecoder</a></td>
          <td>F3阶段预译码模块，从PreDecoder中时序优化出来的模块，负责判定CFI指令的类型</td>
      </tr>
      <tr>
          <td><a href="03_ifu_rvc_exp.md">RVCExpander</a></td>
          <td>RVC指令扩展模块，负责对传入的指令进行指令扩展，并解码计算非法信息</td>
      </tr>
      <tr>
          <td><a href="04_pred_checker.md">PredChecker</a></td>
          <td>预检查模块，校验并修正预测信息</td>
      </tr>
      <tr>
          <td><a href="05_frontend_trigger.md">FrontendTrigger</a></td>
          <td>前端断点模块，用于在前端设置硬件断点和检查</td>
      </tr>
  </tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<p>模块功能说明标题请用二号标题格式（两个#）。</p>
<p><strong>【必填项】</strong> 需采用功能树形式逐级分解DUT的各项功能，并对所有功能进行描述，确保每个功能点都对应相应的测试点。这种结构化的方法不仅有助于全面覆盖所有功能，还便于后续文档的维护和更新。</p>
<p><strong>编写规则：</strong></p>
<ol>
<li>请使用 <code>&lt;mrs-functions&gt;``&lt;/mrs-functions&gt;</code> 标签包裹整个“模块功能说明”部分；</li>
<li>采用 X.Y.Z 多级编号（如 1.2.3 表示主功能 1 → 子功能 2 → 测试点 3，且可进一步细分）；</li>
<li>多级编号的标题格式按照级别增加，例如：“1. 读FIFO操作”应为三号标题格式 “1.1. 常规读取”应为四号标题格式；</li>
<li>功能描述应清晰列出输入条件、处理过程和输出结果。</li>
<li>针对每个功能进行测试点分解，应详细列出每个测试点，明确其目的和预期结果。</li>
<li>如果测试点较多可以先列一个小表格。</li>
</ol>
<p>具体来说，可以按照如下的格式写作（示例内容仅供参考，并不代表实际逻辑或内容）：</p>
<mrs-functions>
<h2 id="示例fifo模块功能说明">示例：FIFO模块功能说明</h2>
<h3 id="示例1-读fifo操作">示例1. 读FIFO操作</h3>
<h4 id="示例11-常规读取">示例1.1. 常规读取</h4>
<p><strong>功能描述</strong>：当rd_en=1且empty=0时，在时钟上升沿输出rdata</p>
<p><strong>建议观测点</strong>：</p>
<ul>
<li>读指针递增逻辑</li>
<li>rdata与预期数据匹配</li>
</ul>
<h3 id="示例2-写fifo操作">示例2. 写FIFO操作</h3>
<h4 id="示例21-常规写入">示例2.1. 常规写入</h4>
<p><strong>功能描述</strong>：当wr_en=1且full=0时，在时钟上升沿存储wdata</p>
<p><strong>观测点</strong>：</p>
<ul>
<li>写指针递增逻辑</li>
<li>存储阵列数据更新</li>
</ul>
<h3 id="示例3-接收ftq取指令请求f0流水级">示例3. 接收FTQ取指令请求（F0流水级）</h3>
<p>​在F0流水级，IFU接收来自FTQ以预测块为单位的取指令请求。请求内容包括预测块起始地址、起始地址所在cache line的下一个cache line开始地址、下一个预测块的起始地址、该预测块在FTQ里的队列指针、该预测块有无taken的CFI指令（控制流指令）和该taken的CFI指令在预测块里的位置以及请求控制信号（请求是否有效和IFU是否ready）。每个预测块最多包含32字节指令码，最多为16条指令。IFU需要置位ready驱动FTQ向ICache发送请求。</p>
<h4 id="示例31-f0流水级接收请求">示例3.1. F0流水级接收请求</h4>
<p>IFU应当能向FTQ报告自己已ready。</p>
<p>所以，对于这一测试点我们只需要在发送请求后检查和ftq相关的的ready情况即可。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>IFU_RCV_REQ</td>
          <td>READY</td>
          <td>IFU接收FTQ请求后，设置ready</td>
      </tr>
  </tbody>
</table>
</mrs-functions>
<h2 id="常量说明">常量说明</h2>
<p>常量说明标题请用二号标题格式（两个#）。</p>
<p><strong>【可选项】</strong> 需要列出模块中所有可配置参数及其物理意义，以便于用户理解各参数的作用和影响。</p>
<p><strong>示例：</strong></p>
<table>
  <thead>
      <tr>
          <th>常量名</th>
          <th>常量值</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ADDR_WIDTH</td>
          <td>64</td>
          <td>地址总线位宽</td>
      </tr>
      <tr>
          <td>FIFO_DEPTH</td>
          <td>8</td>
          <td>深度配置</td>
      </tr>
  </tbody>
</table>
<h2 id="接口说明">接口说明</h2>
<p>接口说明标题请用二号标题格式（两个#）。</p>
<p><strong>【必填项】</strong> 详细解释各种接口的含义和来源，包括接口的功能、用途。这有助于用户理解各接口的工作原理和应用场景，从而更有效地使用这些接口。</p>
<p><strong>编写规则</strong></p>
<ol>
<li>信号按功能（如时钟复位、数据输入、控制信号等）或来源（其他模块）分组；</li>
<li>可以将一些同质的信号一起解释；</li>
<li>特殊协议信号需注明时序要求（如AXI的VALID/READY握手）。</li>
</ol>
<h2 id="接口时序">接口时序</h2>
<p>接口时序标题请用二号标题格式（两个#）。</p>
<p><strong>【可选项】</strong> 针对复杂接口，可以提供波形图案例，以直观展示信号变化和时间关系。</p>
<p>以下是节选自IFU top文档的一个例子：</p>
<h2 id="接口时序-1">接口时序</h2>
<h3 id="ftq-请求接口时序示例">FTQ 请求接口时序示例</h3>
<p align="center">
    <img src="port1.png" alt="port1" />
</p>
<p>上图示意了三个 FTQ 请求的示例，req1 只请求缓存行 line0，紧接着 req2 请求 line1 和 line2，当到 req3 时，由于指令缓存 SRAM 写优先，此时指令缓存的读请求 ready 被指低，req3 请求的 valid 和地址保持直到请求被接收。</p>
<h3 id="icache-返回接口以及到-ibuffer-和写回-ftq-接口时序示例">ICache 返回接口以及到 Ibuffer 和写回 FTQ 接口时序示例</h3>
<p align="center">
    <img src="port2.png" alt="port2" />
</p>
<p>上图展示了指令缓存返回数据到 IFU 发现误预测直到 FTQ 发送正确地址的时序，group0 对应的请求在 f2 阶段了两个缓存行 line0 和 line1，下一拍 IFU 做误预测检查并同时把指令给 Ibuffer，但此时后端流水线阻塞导致 Ibuffer 满，Ibuffer 接收端的 ready 置低，goup0 相关信号保持直到请求被 Ibuffer 接收。但是 IFU 到 FTQ 的写回在 tio_toIbuffer_valid 有效的下一拍就拉高，因为此时请求已经无阻塞地进入 wb 阶段，这个阶段锁存的了 PredChecker 的检查结果，报告 group0 第 4（从 0 开始）个 2 字节位置对应的指令发生了错误预测，应该重定向到 vaddrA，之后经过 4 拍（冲刷和重新走预测器流水线），FTQ 重新发送给 IFU 以 vaddrA 为起始地址的预测块。</p>
<h2 id="测试点总表">测试点总表</h2>
<p>测试点总表标题请用二号标题格式（两个#）。</p>
<p><strong>【必填项】</strong> 对模块功能说明中细分的测试点进行综合整理，采用表格形式列出，便于用户快速查阅和理解。</p>
<p><strong>表格规范</strong>：</p>
<ol>
<li>请用<code>&lt;mrs-testpoints&gt;&lt;/mrs-testpoints&gt;</code>标签包裹测试点总表，方便我们后续使用脚本提取测试点</li>
<li>表格共列四项，序号，功能名称，测试点名称和解释
<ol>
<li><strong>序号</strong>：测试点的序号格式和功能点类似。即，即测试点1.2.3.4 可能是功能点1.2.3的第4个测试点</li>
<li><strong>功能名称</strong>：用英文大写命名，可用下划线分割单词，可以使用markdown语法为功能名称添加到具体功能点解释的链接，即形如<code>[文本](跳转目标)</code></li>
<li><strong>测试点名称</strong>：用英文大写命名，可用下划线分割单词</li>
<li><strong>解释</strong>：简单描述测试点所需的输入和输出需求，明确判断条件</li>
</ol>
</li>
</ol>
<p><strong>表格示例</strong>：</p>
<p>以下是节选自IFU top文档的一个例子:</p>
<mrs-testpoints>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>IFU_RCV_REQ</td>
          <td>READY</td>
          <td>IFU接收FTQ请求后，设置ready</td>
      </tr>
      <tr>
          <td>2.1.1</td>
          <td>IFU_F1_INFOS</td>
          <td>PC</td>
          <td>IFU接收FTQ请求后，在F1流水级生成PC</td>
      </tr>
      <tr>
          <td>2.1.2</td>
          <td>IFU_F1_INFOS</td>
          <td>CUT_PTR</td>
          <td>IFU接收FTQ请求后，在F1流水级生成后续切取缓存行的指针</td>
      </tr>
      <tr>
          <td>2.2.1</td>
          <td>IFU_F2_INFOS</td>
          <td>EXCP_VEC</td>
          <td>IFU接收ICache内容后，会根据ICache的结果生成属于每个指令的异常向量</td>
      </tr>
  </tbody>
</table>
</mrs-testpoints>
<h2 id="附录">附录</h2>
<p>附录标题请用二号标题格式（两个#）。</p>
<p><strong>【可选项】</strong> 此部分用于存放正文的补充内容，以便进行扩展和详细说明，旨在使文档格式更加清晰，排版更加合理。</p>
<p>以下是节选自IFU RVCExpander文档的一个例子:</p>
<h2 id="rvc扩展辅助阅读材料">RVC扩展辅助阅读材料</h2>
<p>为方便参考模型的书写，在这里根据20240411版本的手册内容整理了部分指令扩展的思路。</p>
<p>对于RVC指令来说，op = instr(1, 0)；funct = instr(15, 13)</p>
<table>
  <thead>
      <tr>
          <th>op\funct</th>
          <th>000</th>
          <th>001</th>
          <th>010</th>
          <th>011</th>
          <th>100</th>
          <th>101</th>
          <th>110</th>
          <th>111</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>00</td>
          <td>addi4spn</td>
          <td>fld</td>
          <td>lw</td>
          <td>ld</td>
          <td>lbu<br>lhu;lh<br>sb;sh</td>
          <td>fsd</td>
          <td>sw</td>
          <td>sd</td>
      </tr>
      <tr>
          <td>01</td>
          <td>addi</td>
          <td>addiw</td>
          <td>li</td>
          <td>lui<br>addi16sp<br>zcmop</td>
          <td>ARITHs<br>zcb</td>
          <td>j</td>
          <td>beqz</td>
          <td>bnez</td>
      </tr>
      <tr>
          <td>10</td>
          <td>slli</td>
          <td>fldsp</td>
          <td>lwsp</td>
          <td>ldsp</td>
          <td>jr;mv<br>ebreak<br>jalr;add</td>
          <td>fsdsp</td>
          <td>fwsp</td>
          <td>sdsp</td>
      </tr>
  </tbody>
</table>
<p>在开始阅读各指令的扩展规则时，需要了解一些RVC扩展的前置知识，比如：</p>
<p>rd&rsquo;, rs1&rsquo;和rs2&rsquo;寄存器：受限于16位指令的位宽限制，这几个寄存器只有3位来表示，他们对应到x8~x15寄存器。</p>
<h3 id="op--b00">op = b'00'</h3>
<h4 id="funct--b000-addi4spn">funct = b'000&rsquo;: ADDI4SPN</h4>
<p align="center">
    <img src="Caddi4spn.png" alt="addi4spn" />
</p>
<p>该指令将一个0扩展的非0立即数加到栈指针寄存器x2上，并将结果写入rd'</p>
<p>其中，nzuimm[5:4|9:6|2|3]的含义是：
···</p>
<p>下方展示了模板和两个验证案例：</p>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2764f80f939ebbd5618718ed34996a4c">12.1.1 - 文档模板</h1>
    
	<p>以下是一份验证文档的完整模板（请一定同提交的验证报告区分开来）</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold"># 验证文档各部分说明
</span></span></span><span style="display:flex;"><span><span style="color:#000080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 文档概述【必填项】 
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>在该部分对整个文档进行简约描述，例如内容概述，待验证模块的基本功能、特殊需求、特定规格、目标读者、知识前置等。目的是通过对该部分，读者便了解是否具有其感兴趣的内容。例如本文档是对验证文档的编写要求进行描述，便于多文档协作，规范验证的数据输入，特定数据标签等。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 术语说明 【必填项】 列出术语和关键概念解释，方便读者参考
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>优先解释模块专有缩写（如TLB， FIFO等），如果有缩写，请用<span style="color:#4e9a06">`缩写（全称）的方式填在表格的“名称”栏目中`</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>对容易混淆的概念请务必明确（如虚拟地址和物理地址等）
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>| 名称 | 定义 |
</span></span><span style="display:flex;"><span>| ------- | ---|
</span></span><span style="display:flex;"><span>| 缩写1（FULL_NAME_1）	| 描述1 |
</span></span><span style="display:flex;"><span>| 缩写2（FULL_NAME_2）	| 描述2 |
</span></span><span style="display:flex;"><span>| 概念名1	| 描述3 |
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 前置知识【可选项】
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>在阅读文档或进行验证之前，建议掌握一些关键前置知识，以便更深入理解相关内容。例如，在撰写LoadStoreQueue（LSQ）文档时，讲述RAW（Read After Write）违例有助于理解操作之间的依赖关系。在撰写Icache或L2Cache文档时，介绍缓存层级、替换策略和一致性模型等基本概念也有助于读者理解。如果涉及复杂算法，也应对其进行简要描述。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>基本要求：
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">1.</span> 该部分内容应简洁，易于理解。如篇幅较长，可将内容移至附录。
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">2.</span> 针对较为复杂的内容，可以通过图像、伪代码和案例进行解释，以降低理解难度。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 整体框图 【可选项】 若模块含多个子模块或复杂数据流，需提供框图辅助说明
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>可使用Visio/Draw.io等工具绘制，导出为PNG/SVG格式；
</span></span><span style="display:flex;"><span>需标注关键信号流向；
</span></span><span style="display:flex;"><span>框图中子模块命名需与“子模块列表”章节严格一致。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 流水级示意图 【可选项】 若为复杂流水线型模块，需说明各级流水功能与时序关系
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>可使用Visio/Draw.io等工具绘制，导出为PNG/SVG格式；
</span></span><span style="display:flex;"><span>涉及到的模块名称需要保持一致性
</span></span><span style="display:flex;"><span>重要数据除了列出名称以外，还需要标明位宽等信息
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 子模块列表 【可选项】 若模块由多个子模块组成，需在此列出
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>以下是IFU top文档中的一个示例：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>| 子模块                 | 描述                |
</span></span><span style="display:flex;"><span>| ---------------------- | ------------------- |
</span></span><span style="display:flex;"><span>| [<span style="color:#204a87;font-weight:bold">子模块1</span>](<span style="color:#c4a000">子模块1文档位置</span>) | 子模块1描述       |
</span></span><span style="display:flex;"><span>| [<span style="color:#204a87;font-weight:bold">子模块2</span>](<span style="color:#c4a000">子模块2文档位置</span>) | 子模块2描述       |
</span></span><span style="display:flex;"><span>| [<span style="color:#204a87;font-weight:bold">子模块3</span>](<span style="color:#c4a000">子模块3文档位置</span>) | 子模块3描述       |
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#204a87;font-weight:bold">mrs-functions</span><span style="color:#000;font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 模块功能说明 【必填项】 需按功能树形式逐级分解，每个功能点需对应后续测试点。
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>请用<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#204a87;font-weight:bold">mrs-functions</span><span style="color:#000;font-weight:bold">&gt;&lt;/</span><span style="color:#204a87;font-weight:bold">functions</span><span style="color:#000;font-weight:bold">&gt;</span>包裹整个“模块功能说明”部分。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>采用X.Y.Z多级编号（如1.2.3表示主功能1→子功能2→测试点3，也可以继续细分）
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>功能描述需明确输入条件、处理过程、输出结果
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">### 1. 功能A说明
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>针对功能A分解测试点
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>如果测试点较多可以先列一个小表格
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">### 2. 功能B说明
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>针对功能B分解测试点
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>如果测试点较多可以先列一个小表格
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">### 3. 功能C说明
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>针对功能C分解测试点
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>如果测试点较多可以先列一个小表格；针对每个测试点，给出设置cov_group的建议
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">&lt;/</span><span style="color:#204a87;font-weight:bold">mrs-functions</span><span style="color:#000;font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 常量说明 【可选项】 需列出模块中所有可配置参数及其物理意义
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>| 常量名 | 常量值 | 解释 |
</span></span><span style="display:flex;"><span>| ---- | ---- | ---- |
</span></span><span style="display:flex;"><span>| 常量1 | 64 | 常量1解释 |
</span></span><span style="display:flex;"><span>| 常量2 | 8 | 常量2解释 |
</span></span><span style="display:flex;"><span>| 常量3 | 16 | 常量3解释 |
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 接口说明 【必填项】 详细解释各种接口的含义、来源
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>信号按功能（如时钟复位、数据输入、控制信号等）或来源（其他模块）分组；
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>可以将一些同质的信号一起解释；
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>特殊协议信号需注明时序要求（如AXI的VALID/READY握手）。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>使用时，请将下面的接口组名称和说明替换为符合您模块实际意义的内容
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">### 接口组1说明
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>请在这里填充接口组1的说明
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">#### 接口组1_1说明
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>请在这里填充接口组1_1的说明
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>如果不能细分，请进一步说明该组中所有接口
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">### 接口组2说明
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>请在这里填充接口组2的说明
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>如果不能细分，请进一步说明该组中所有接口
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 接口时序 【可选项】 对复杂接口，提供波形图的案例
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">### 案例1
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>请在这里填充时序案例1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">### 案例2
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>请在这里填充时序案例2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 测试点总表 (【必填项】针对细分的测试点，列出表格)
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>实际使用下面的表格时，请用有意义的英文大写的功能名称和测试点名称替换下面表格中的名称
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#204a87;font-weight:bold">mrs-testpoints</span><span style="color:#000;font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>| 序号 |  功能名称 | 测试点名称      | 描述                  |
</span></span><span style="display:flex;"><span>| ----- |-----------------|---------------------|------------------------------------|
</span></span><span style="display:flex;"><span>| 1\.1\.1 | FUNCTION_1_1 | TESTPOINT_A | 功能1\.1的测试点A，使用时请替换为您的测试点的输入输出和判断方法 | 
</span></span><span style="display:flex;"><span>| 1\.1\.2 | FUNCTION_1_1 | TESTPOINT_B | 功能1\.1的测试点B，使用时请替换为您的测试点的输入输出和判断方法 | 
</span></span><span style="display:flex;"><span>| 1\.1\.3 | FUNCTION_1_1 | TESTPOINT_C | 功能1\.1的测试点C，使用时请替换为您的测试点的输入输出和判断方法 | 
</span></span><span style="display:flex;"><span>| 1\.2\.1 | FUNCTION_1_2 | TESTPOINT_X | 功能1\.2的测试点X，使用时请替换为您的测试点的输入输出和判断方法 | 
</span></span><span style="display:flex;"><span>| 1\.2\.2 | FUNCTION_1_2 | TESTPOINT_Y | 功能1\.2的测试点Y，使用时请替换为您的测试点的输入输出和判断方法 | 
</span></span><span style="display:flex;"><span>| 2\.1 | FUNCTION_2 | TESTPOINT_2A | 功能2的测试点2A，使用时请替换为您的测试点的输入输出和判断方法 | 
</span></span><span style="display:flex;"><span>| 2\.2 | FUNCTION_2 | TESTPOINT_2B | 功能2的测试点2B，使用时请替换为您的测试点的输入输出和判断方法 | 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">&lt;/</span><span style="color:#204a87;font-weight:bold">mrs-testpoints</span><span style="color:#000;font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold">## 附录【可选项】 
</span></span></span><span style="display:flex;"><span><span style="color:#800080;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>此部分用于存放正文的补充内容，以便进行扩展和详细说明，旨在使文档格式更加清晰，排版更加合理。
</span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7a9ca318935b3c19c5a8b79dbfbdeb2b">12.1.2 - FIFO文档案例</h1>
    
	<p>以下以FIFO为例，展示了一个简单的文档案例</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#000">`timescale</span> <span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000">ns</span> <span style="color:#ce5c00;font-weight:bold">/</span> <span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000">ps</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">module</span> <span style="color:#000">FIFO</span> <span style="color:#000;font-weight:bold">(</span> <span style="color:#8f5902;font-style:italic">//data_width = 8  data depth =8
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">input</span> <span style="color:#000">clk</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">input</span> <span style="color:#000">rst_n</span><span style="color:#000;font-weight:bold">,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">input</span> <span style="color:#000">wr_en</span><span style="color:#000;font-weight:bold">,</span>          <span style="color:#8f5902;font-style:italic">//写使能
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">input</span> <span style="color:#000">rd_en</span><span style="color:#000;font-weight:bold">,</span>          <span style="color:#8f5902;font-style:italic">//读使能
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">input</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">7</span><span style="color:#ce5c00;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">]</span><span style="color:#000">wdata</span><span style="color:#000;font-weight:bold">,</span>     <span style="color:#8f5902;font-style:italic">//写入数据输入
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">output</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">7</span><span style="color:#ce5c00;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">]</span><span style="color:#000">rdata</span><span style="color:#000;font-weight:bold">,</span>    <span style="color:#8f5902;font-style:italic">//读取数据输出
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">output</span> <span style="color:#000">empty</span><span style="color:#000;font-weight:bold">,</span>         <span style="color:#8f5902;font-style:italic">//读空标志信号
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">output</span> <span style="color:#000">full</span>           <span style="color:#8f5902;font-style:italic">//写满标志信号
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">reg</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">7</span><span style="color:#ce5c00;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">]</span> <span style="color:#000">rdata_reg</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">8</span><span style="color:#0000cf;font-weight:bold">&#39;d0</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">assign</span> <span style="color:#000">rdata</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">rdata_reg</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">reg</span>  <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">7</span><span style="color:#ce5c00;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">]</span> <span style="color:#000">data</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">7</span><span style="color:#ce5c00;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">];</span>     <span style="color:#8f5902;font-style:italic">//数据存储单元(8bit数据8个)
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">reg</span>  <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">3</span><span style="color:#ce5c00;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">]</span> <span style="color:#000">wr_ptr</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">4</span><span style="color:#0000cf;font-weight:bold">&#39;d0</span><span style="color:#000;font-weight:bold">;</span>  <span style="color:#8f5902;font-style:italic">//写指针
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">reg</span>  <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">3</span><span style="color:#ce5c00;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">]</span> <span style="color:#000">rd_ptr</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">4</span><span style="color:#0000cf;font-weight:bold">&#39;d0</span><span style="color:#000;font-weight:bold">;</span>  <span style="color:#8f5902;font-style:italic">//读指针
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">wire</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">2</span><span style="color:#ce5c00;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">]</span> <span style="color:#000">wr_addr</span><span style="color:#000;font-weight:bold">;</span>        <span style="color:#8f5902;font-style:italic">//写地址(写指针的低3位)
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">wire</span> <span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">2</span><span style="color:#ce5c00;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">]</span> <span style="color:#000">rd_addr</span><span style="color:#000;font-weight:bold">;</span>        <span style="color:#8f5902;font-style:italic">//读地址(读指针的低3位)
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">assign</span> <span style="color:#000">wr_addr</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">wr_ptr</span><span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">2</span><span style="color:#ce5c00;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">assign</span> <span style="color:#000">rd_addr</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">rd_ptr</span><span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">2</span><span style="color:#ce5c00;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">always</span><span style="color:#000;font-weight:bold">@(</span><span style="color:#204a87;font-weight:bold">posedge</span> <span style="color:#000">clk</span> <span style="color:#204a87;font-weight:bold">or</span> <span style="color:#204a87;font-weight:bold">negedge</span> <span style="color:#000">rst_n</span><span style="color:#000;font-weight:bold">)</span><span style="color:#204a87;font-weight:bold">begin</span> <span style="color:#8f5902;font-style:italic">//写数据
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">if</span><span style="color:#000;font-weight:bold">(</span><span style="color:#ce5c00;font-weight:bold">!</span><span style="color:#000">rst_n</span><span style="color:#000;font-weight:bold">)</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#000">wr_ptr</span> <span style="color:#ce5c00;font-weight:bold">&lt;=</span> <span style="color:#0000cf;font-weight:bold">4</span><span style="color:#0000cf;font-weight:bold">&#39;d0</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">else</span> <span style="color:#204a87;font-weight:bold">if</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">wr_en</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#ce5c00;font-weight:bold">!</span><span style="color:#000">full</span><span style="color:#000;font-weight:bold">)</span><span style="color:#204a87;font-weight:bold">begin</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">data</span><span style="color:#000;font-weight:bold">[</span><span style="color:#000">wr_addr</span><span style="color:#000;font-weight:bold">]</span>  <span style="color:#ce5c00;font-weight:bold">&lt;=</span> <span style="color:#000">wdata</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">wr_ptr</span> <span style="color:#ce5c00;font-weight:bold">&lt;=</span> <span style="color:#000">wr_ptr</span> <span style="color:#ce5c00;font-weight:bold">+</span> <span style="color:#0000cf;font-weight:bold">4</span><span style="color:#0000cf;font-weight:bold">&#39;d1</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">end</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">always</span><span style="color:#000;font-weight:bold">@(</span><span style="color:#204a87;font-weight:bold">posedge</span> <span style="color:#000">clk</span> <span style="color:#204a87;font-weight:bold">or</span> <span style="color:#204a87;font-weight:bold">negedge</span> <span style="color:#000">rst_n</span><span style="color:#000;font-weight:bold">)</span><span style="color:#204a87;font-weight:bold">begin</span> <span style="color:#8f5902;font-style:italic">//读数据
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#204a87;font-weight:bold">if</span><span style="color:#000;font-weight:bold">(</span><span style="color:#ce5c00;font-weight:bold">!</span><span style="color:#000">rst_n</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">rd_ptr</span> <span style="color:#ce5c00;font-weight:bold">&lt;=</span> <span style="color:#0000cf;font-weight:bold">&#39;d0</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">else</span> <span style="color:#204a87;font-weight:bold">if</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">rd_en</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#ce5c00;font-weight:bold">!</span><span style="color:#000">empty</span><span style="color:#000;font-weight:bold">)</span><span style="color:#204a87;font-weight:bold">begin</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">rdata_reg</span>  <span style="color:#ce5c00;font-weight:bold">&lt;=</span> <span style="color:#000">data</span><span style="color:#000;font-weight:bold">[</span><span style="color:#000">rd_addr</span><span style="color:#000;font-weight:bold">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">rd_ptr</span> <span style="color:#ce5c00;font-weight:bold">&lt;=</span> <span style="color:#000">rd_ptr</span> <span style="color:#ce5c00;font-weight:bold">+</span> <span style="color:#0000cf;font-weight:bold">4</span><span style="color:#0000cf;font-weight:bold">&#39;d1</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">end</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">assign</span> <span style="color:#000">empty</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">wr_ptr</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#000">rd_ptr</span><span style="color:#000;font-weight:bold">);</span> <span style="color:#8f5902;font-style:italic">//读空
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">assign</span> <span style="color:#000">full</span>  <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">wr_ptr</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">{</span><span style="color:#ce5c00;font-weight:bold">~</span><span style="color:#000">rd_ptr</span><span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">3</span><span style="color:#000;font-weight:bold">],</span><span style="color:#000">rd_ptr</span><span style="color:#000;font-weight:bold">[</span><span style="color:#0000cf;font-weight:bold">2</span><span style="color:#ce5c00;font-weight:bold">:</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">]});</span> <span style="color:#8f5902;font-style:italic">//写满
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">endmodule</span>
</span></span></code></pre></div><h1 id="fifo-模块验证文档">FIFO 模块验证文档</h1>
<h2 id="文档概述">文档概述</h2>
<p>本文档描述FIFO的功能，并根据功能给出测试点参考，方便测试的参与者理解测试需求，编写相关测试用例。</p>
<h2 id="术语说明">术语说明</h2>
<table>
  <thead>
      <tr>
          <th>缩写</th>
          <th>全称</th>
          <th>定义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>FIFO</td>
          <td>First In First Out</td>
          <td>先进先出的数据缓冲队列</td>
      </tr>
  </tbody>
</table>
<h2 id="功能说明">功能说明</h2>
<p>本次需要验证的是FIFO，一种常见的硬件缓冲模块，在硬件电路中临时存储数据，并按照数据到达的顺序进行处理。</p>
<p>本次需要验证的FIFO每次可写可读8位数据，容量为8。</p>
<h3 id="1-读fifo操作">1. 读FIFO操作</h3>
<h4 id="11-常规读取">1.1. 常规读取</h4>
<p><strong>功能描述</strong>：当rd_en=1且empty=0时，在时钟上升沿输出rdata</p>
<p><strong>建议观测点</strong>：</p>
<ul>
<li>读指针递增逻辑</li>
<li>rdata与预期数据匹配</li>
</ul>
<h4 id="12-读空栈">1.2. 读空栈</h4>
<p><strong>功能描述</strong>：当empty=1且rd_en=1时，rdata保持无效值</p>
<p><strong>建议观测点</strong>：</p>
<ul>
<li>empty信号持续为高</li>
<li>读指针无变化</li>
</ul>
<h4 id="13-无读使能不读">1.3. 无读使能不读</h4>
<p><strong>功能描述</strong>：当rd_en=0时，无论FIFO状态如何均不更新rdata</p>
<p><strong>建议观测点</strong>：</p>
<ul>
<li>连续写入后关闭读使能，验证读指针冻结</li>
</ul>
<h3 id="2-写fifo操作">2. 写FIFO操作</h3>
<h4 id="21-常规写入">2.1. 常规写入</h4>
<p><strong>功能描述</strong>：当wr_en=1且full=0时，在时钟上升沿存储wdata</p>
<p><strong>观测点</strong>：</p>
<ul>
<li>写指针递增逻辑</li>
<li>存储阵列数据更新</li>
</ul>
<h4 id="22-fifo已满无法写入">2.2. FIFO已满无法写入</h4>
<p><strong>功能描述</strong>：当full=1且wr_en=1时，wdata被丢弃</p>
<p><strong>观测点</strong>：</p>
<ul>
<li>full信号持续为高</li>
<li>存储阵列内容不变</li>
</ul>
<h4 id="23-无写使能不写">2.3. 无写使能不写</h4>
<p><strong>功能描述</strong>：当wr_en=0时，无论FIFO状态如何均不写入数据</p>
<p><strong>观测点</strong>：</p>
<ul>
<li>写指针冻结</li>
<li>存储阵列内容保持不变</li>
</ul>
<h3 id="3-复位操作">3. 复位操作</h3>
<h4 id="31-复位控制">3.1. 复位控制</h4>
<p><strong>功能描述</strong>：当rst_n=0时，清空FIFO并重置指针</p>
<p><strong>观测点</strong>：</p>
<ul>
<li>复位后empty=1且full=0</li>
<li>读写指针归零</li>
</ul>
<h2 id="常量说明">常量说明</h2>
<table>
  <thead>
      <tr>
          <th>常量名</th>
          <th>常量值</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>FIFO_DEPTH</td>
          <td>8</td>
          <td>FIFO存储单元数量</td>
      </tr>
      <tr>
          <td>DATA_WIDTH</td>
          <td>8</td>
          <td>数据总线位宽</td>
      </tr>
  </tbody>
</table>
<h2 id="接口说明">接口说明</h2>
<h3 id="输入接口">输入接口</h3>
<table>
  <thead>
      <tr>
          <th>信号名</th>
          <th>方向</th>
          <th>位宽</th>
          <th>描述</th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>clk</td>
          <td>Input</td>
          <td>1</td>
          <td>主时钟</td>
          <td></td>
      </tr>
      <tr>
          <td>rst_n</td>
          <td>Input</td>
          <td>1</td>
          <td>异步复位</td>
          <td></td>
      </tr>
      <tr>
          <td>wr_en</td>
          <td>Input</td>
          <td>1</td>
          <td>写使能</td>
          <td></td>
      </tr>
      <tr>
          <td>wdata</td>
          <td>Input</td>
          <td>8</td>
          <td>写入数据</td>
          <td></td>
      </tr>
      <tr>
          <td>rd_en</td>
          <td>Input</td>
          <td>1</td>
          <td>读使能</td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="输出接口">输出接口</h3>
<table>
  <thead>
      <tr>
          <th>信号名</th>
          <th>方向</th>
          <th>位宽</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>rdata</td>
          <td>Output</td>
          <td>8</td>
          <td>读出数据</td>
      </tr>
      <tr>
          <td>empty</td>
          <td>Output</td>
          <td>1</td>
          <td>FIFO空标志（高有效）</td>
      </tr>
      <tr>
          <td>full</td>
          <td>Output</td>
          <td>1</td>
          <td>FIFO满标志（高有效）</td>
      </tr>
  </tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<p>建议各个测试点的覆盖组使用下表描述的功能和测试点名称进行命名。</p>
<p>比如FIFO_READ的测试点NORMAL，其覆盖点建议命名为FIFO_READ_NORMAL</p>
<mrs-testpoints>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/00_standard/01_fifo/#1-%e8%af%bbfifo%e6%93%8d%e4%bd%9c">FIFO_READ</a></td>
          <td>NORMAL</td>
          <td>fifo有数据时，设置读使能，可以读出数据</td>
      </tr>
      <tr>
          <td>1.2</td>
          <td>FIFO_READ</td>
          <td>EMPTY</td>
          <td>fifo为空时，设置读使能，无法读出数据</td>
      </tr>
      <tr>
          <td>1.3</td>
          <td>FIFO_READ</td>
          <td>NO_EN</td>
          <td>fifo有数据时，不设置读使能，无法读出数据</td>
      </tr>
      <tr>
          <td>2.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/00_standard/01_fifo/#2-%e5%86%99fifo%e6%93%8d%e4%bd%9c">FIFO_WRITE</a></td>
          <td>NORMAL</td>
          <td>fifo未满时，设置写使能，可以写入数据</td>
      </tr>
      <tr>
          <td>2.2</td>
          <td>FIFO_WRITE</td>
          <td>FULL</td>
          <td>fifo已满时，设置写使能，可以写入数据</td>
      </tr>
      <tr>
          <td>2.3</td>
          <td>FIFO_WRITE</td>
          <td>NO_EN</td>
          <td>fifo未满时，不设置写使能，无法写入数据</td>
      </tr>
      <tr>
          <td>3.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/00_standard/01_fifo/#3-%e5%a4%8d%e4%bd%8d%e6%93%8d%e4%bd%9c">FIFO_RESET</a></td>
          <td>RESET</td>
          <td>重置后，栈为空</td>
      </tr>
  </tbody>
</table>
</mrs-testpoints>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-819feb66d3ed443e53bb22589b5ccde0">12.1.3 - 果壳Cache文档案例</h1>
    
	<p>本文档将以<a href="https://github.com/OSCPU/NutShell/blob/fc12171d929e7e589fab9f794ab63ce12e6c594e/src/main/scala/nutcore/mem/Cache.scala">果壳L1Cache</a>作为案例，展示一个具有相当复杂度的模块的验证说明文档例子（请一定同提交的验证报告区分开来）。</p>
<h1 id="果壳l1cache验证文档">果壳L1Cache验证文档</h1>
<h2 id="文档概述">文档概述</h2>
<p>本文档针对NutShell L1Cache的验证需求撰写，通过对其功能进行描述并依据功能给出参考测试点，从而帮助验证人员编制测试用例。</p>
<p>果壳（NutShell）是一款由5位中国科学院大学本科生设计的基于RISC-V RV64开放指令集的顺序单发射处理器(<a href="https://github.com/OSCPU/NutShell">NutShell·Github</a>), 隶属于国科大与计算所“一生一芯”项目。而果壳Cache（NutShell Cache）是其缓存模块，采用可定制化设计（L1 Cache和L2 Cache采用相同的模板生成，只需要调整参数），具体来说，L1 Cache（指令Cache和数据Cache）大小为32KB，L2 Cache大小为128KB, 在整体结构上，果壳Cache采用三级流水的结构。</p>
<p>本次验证的目标是L1 Cache，即一级缓存。</p>
<h2 id="术语说明">术语说明</h2>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>定义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>MMIO（Memory-Mapped Input/Output）</td>
          <td>内存映射IO</td>
      </tr>
      <tr>
          <td>写回</td>
          <td>Cache需要进行替换时，会将脏替换块写回内存</td>
      </tr>
      <tr>
          <td>关键字优先方案</td>
          <td>缺失发生时，系统会优先获取CPU所需要的当前指令或数据所对应的字</td>
      </tr>
  </tbody>
</table>
<h2 id="前置知识">前置知识</h2>
<h3 id="cache的层次结构">Cache的层次结构</h3>
<p>Cache有三种主要的组织方式：直接映射（Direct-Mapped）Cache、组相连（Set-Associative）Cache和全相连（Fully-Associative）Cache。对于物理内存中的一个数据，如果在Cache中只有一个位置可以存放它，这就是直接映射Cache；如果有多个位置可以存放这个数据，这就是组相连Cache；如果Cache中的任何位置都可以存放这个数据，这就是全相连Cache。</p>
<p>直接映射Cache和全相连Cache实际上是组相连Cache的两种特殊情况。现代处理器中的Cache通常属于这三种方式中的一种。例如，翻译后备缓冲区（TLB）和Victim Cache多采用全相连结构，而普通的指令缓存（I-Cache）和数据缓存（D-Cache）则采用组相连结构。当处理器需要执行一个指令时，它会首先查找该指令是否在I-Cache中。如果在，则直接从I-Cache中读取指令并执行；如果不在，则需要从内存中读取指令到I-Cache中，再执行。与I-Cache类似，当处理器需要读取或写入数据时，会首先查找D-Cache。如果数据在D-Cache中，则直接读取或写入；如果不在，则需要从内存中加载数据到D-Cache中。与I-Cache不同的是，D-Cache需要考虑数据的一致性和写回策略。为了保证数据的一致性，当数据在D-Cache中被修改后，需要同步更新到内存中。</p>
<p><img src="composition.png" alt="composition"></p>
<h3 id="cache的写入">Cache的写入</h3>
<p>在执行写数据时，如果只是向D-Cache中写入数据而不改变其下级存储器中的数据，就会导致D-Cache和下级存储器对于同一地址的数据不一致（non-consistent）。为了保持一致性，一般Cache在写命中状态下采用两种写入方式：
（1）写通（Write Through）：数据写入D-Cache的同时也写入其下级存储器。然而，由于下级存储器的访问时间较长，而存储指令的频率较高，频繁地向这种较慢的存储器中写入数据会降低处理器的执行效率。
（2）写回（Write Back）：数据写入D-Cache后，只是在Cache line上做一个标记，并不立即将数据写入更下级的存储器。只有当Cache中这个被标记的line要被替换时，才将其写入下级存储器。这种方式能够减少向较慢存储器写入数据的频率，从而获得更好的性能。然而，这种方式会导致D-Cache和下级存储器中许多地址的数据不一致，给存储器的一致性管理带来一定的负担。</p>
<p>D-Cache处理写缺失一般有两种策略：</p>
<p>（1）<strong>非写分配（Non-Write Allocate）</strong>：直接将数据写入下级存储器，而不将其写入D-Cache。这意味着当发生写缺失时，数据会直接写入到下级存储器，而不会经过D-Cache。</p>
<p>（2）<strong>写分配（Write Allocate）</strong>：在发生写缺失时，会先将相应地址的整个数据块从下级存储器中读取到D-Cache中，然后再将要写入的数据合并到这个数据块中，最终将整个数据块写回到D-Cache中。这样做的好处是可以在D-Cache中进行更多的操作，但同时也增加了对内存的访问次数和延迟。
写通（Write Through）和非写分配（Non-Write Allocate）将数据直接写入下级存储器，而写回（Write Back）和写分配（Write Allocate）则会将数据写入到D-Cache中。通常情况下，D-Cache的写策略搭配为写通+非写分配或写回+写分配。</p>
<p><strong>写通示意图</strong></p>
<div style="text-align:center">
<img src="Write-through_with_no-write-allocation.png" alt="write-through" width="400" />
<p><b>写通示意图</b></p>
</div>
<div style="text-align:center">
<img src="Write-back_with_write-allocation.png" alt="write-back" width="400" />
<p><b>写回示意图</b></p>
</div>
<h3 id="替换策略">替换策略</h3>
<p>读写D-Cache发生缺失时，需要从对应的Cache Set中找到一个cache行，来存放从下级存储器中读出的数据，如果此时这个Cache Set内的所有Cache行都已经被占用了，那么就需要替换掉其中一个，如何从这些有效的Cache行找到一个并替换它，这就是替换策略，本节介绍几种最常用的替换策略。</p>
<p><strong>近期最少使用法</strong>会选择最近被使用次数最少的Cache行，因此这个算法需要追踪每个Cache行的使用情况，这需要为每个Cache行都设置一个年龄（age）部分，每当一个Cache行被访问时，它对应的年龄部分就会增加，或者减少其他Cache行的年龄值，这样当进行替换时，年龄值最小的那个Cache行就是被使用次数最少的了，会选择它进行替换。</p>
<p><strong>随机替换算法</strong>硬件实现简单，这种方法发生缺失的频率会更高一些，但是随着Cache容量的增大，这个差距是越来越小的。在实际的设计中，很难实现严格的随机，一般采用一种称为时钟算法（clock algorithm）的方法实现近似的随机，它的工作原理本质上是一个时钟计数器，计数器的宽度由Cache的路的个数决定，当要替换时，就根据这个计数器选择相应的行进行替换。这种方法硬件复杂度较低，也不会损失较多的性能，因此是一种折中的方法。</p>
<h2 id="整体框图和流水级">整体框图和流水级</h2>
<p>以下是L1Cache的整体框图和流水级示意：</p>
<p><img src="Cache.png" alt="Cache"></p>
<h2 id="子模块列表">子模块列表</h2>
<p>以下是NutShell L1Cache的一些子模块：</p>
<table>
  <thead>
      <tr>
          <th>子模块</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>s1</td>
          <td>缓存阶段1</td>
      </tr>
      <tr>
          <td>s2</td>
          <td>缓存阶段2</td>
      </tr>
      <tr>
          <td>s3</td>
          <td>缓存阶段3</td>
      </tr>
      <tr>
          <td>metaArray</td>
          <td>以数组形式存储元数据</td>
      </tr>
      <tr>
          <td>dataArray</td>
          <td>以数组形式存储缓存数据</td>
      </tr>
      <tr>
          <td>arb</td>
          <td>总线仲裁器</td>
      </tr>
  </tbody>
</table>
<p>上下游通信总线采用SimpleBus总线，包含了req和resp两个通路，其中req通路的cmd信号表明请求的操作类型，可以通过检查该信号获得访问类型。SimpleBus总线共有七种操作类型，由于NutShell文档未涉及probe和prefetch操作，在验证中只出现五种操作：read、write、readBurst、writeBurst、writeLast，前两种为字读写，后三种为Burst读写，即一次可以操作多个字。</p>
<mrs-functions>
<h2 id="模块功能说明">模块功能说明</h2>
<p>Cache的功能是降低访存的时间开销，其功能本质上和内存是一致的。也就是说，不论是向Cache存数还是取数，其都应该和直接向内存存取的数是一样的。
因此，Cache的基础读写功能将成为我们的第一个功能点。</p>
<p>进一步，访问Cache的地址空间分为MMIO和内存。其中，访问MMIO的地址空间时，Cache一定会Miss，然后将请求转发到MMIO端口上。而访问内存的地址空间时，Cache则会根据该地址所在的Cache Line是否在Cache中而触发Hit或者Miss。Hit则直接返回响应，Miss则会将请求转发到内存端口。如果被替换的受害者行之前被写过，是dirty的，则要先将受害者行写回（write-back）内存，否则直接从内存加载缺失的Cache Line，重填（refill）回Cache。</p>
<h3 id="1-内存备份">1. 内存备份</h3>
<p>Cache的功能本质上和内存是一致的，所以，不管向Cache存或取数据，本质上都应该和从内存存取的数一样。</p>
<p>据此，我们为这一功能点安排了一个测试点：即Cache应当为内存的备份。在实际测试过程中，必须同时考虑读写两方面的一致性。</p>
<h3 id="2-mmio">2. MMIO</h3>
<p>Cache会根据地址所在的区间，判断是否发生MMIO请求。</p>
<h4 id="21-mmio读写">2.1. MMIO读写</h4>
<p>如果发生MMIO请求则会将请求转发到MMIO的端口上，而不会发生Cache行的读写。此外，MMIO请求不是Burst请求，每次只会写入或读出一个地址的数据，而不是一个Cache行的数据。因此，在MMIO端口上不应当观测到Burst的请求类型。</p>
<p>据此，我们可以设计下述两个测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.1.1</td>
          <td>CACHE_MMIO_RW</td>
          <td>FORWARD</td>
          <td>Cache接收到MMIO空间的请求时，不应发生读写，而是直接转发给MMIO端口</td>
      </tr>
      <tr>
          <td>2.1.2</td>
          <td>CACHE_MMIO_RW</td>
          <td>NO_BURST</td>
          <td>Cache接收到MMIO空间的请求时，MMIO端口接收到的Cache请求不应为BURST类型</td>
      </tr>
  </tbody>
</table>
<h3 id="22-mmio阻塞">2.2. MMIO阻塞</h3>
<p>NutShell手册指出，在检测出MMIO请求后会阻塞流水线。</p>
<p>因此，我们将设计这一测试点：当MMIO请求发出后，应当检查流水线是否阻塞。</p>
<h3 id="3-cache命中">3. Cache命中</h3>
<p>NutShell的Cache采用写回策略，因此，在写命中时，需要标记脏块，后续发生缓存行替换时再将对应的缓存行写回内存。</p>
<p>同时，因为采用写回方式，所以，即使写命中也不需要同内存进行交互，因此收到回复的周期数更少。</p>
<h4 id="31-写命中">3.1. 写命中</h4>
<p>由于果壳Cache采用写回策略，因此，在发生写命中时，需要标记脏位，后续还要写回内存中。据此，可以设置一个测试点。</p>
<h4 id="32-命中时序">3.2. 命中时序</h4>
<p>命中发生时，即使是写命中，也无需写回或者重填，因此，回复的时间会更短一些。</p>
<p>以下是本功能点的所有测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>3.2.1</td>
          <td>CACHE_HIT</td>
          <td>WRITE</td>
          <td>Cache写命中时，应设置脏位</td>
      </tr>
      <tr>
          <td>3.2.2</td>
          <td>CACHE_HIT</td>
          <td>SHORTER</td>
          <td>Cache写命中时，回复的周期应该更少</td>
      </tr>
  </tbody>
</table>
<h3 id="4-cache缺失">4. Cache缺失</h3>
<p>为了创造Cache Miss的测试环境，首先需要通过一系列的Load操作先将Cache填满。后续需要触发Cache Miss时，只需要访问上述Load覆盖范围之外的地址即可。</p>
<h4 id="41-缺失通用行为">4.1. 缺失通用行为</h4>
<p>发生Cache Miss时，会阻塞流水线，同时，NutShell Cache重填时采用<strong>关键字优先方案</strong>，即缺失发生时，系统会优先获取CPU所需要的当前指令或数据所对应的字。因此，Cache向内存请求数据时，发出的首个地址应当是向Cache发出请求时的地址。例如，假设向Cache发出0x1000地址的读请求，此时发生Cache Miss，Cache会向内存发出读请求，这个请求的首地址应当是0x1000。显然Cache缺失时，回复的时间会更长。</p>
<p>从而，我们可以划分如下的测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>4.1.1</td>
          <td>CACHE_MISS_COMMON</td>
          <td>BLOCK</td>
          <td>发生缺失时，也会阻塞流水线</td>
      </tr>
      <tr>
          <td>4.1.2</td>
          <td>CACHE_MISS_COMMON</td>
          <td>CRITICAL_WORD</td>
          <td>Cache缺失时，Cache发出请求的首个地址应当是向Cache请求的地址</td>
      </tr>
      <tr>
          <td>4.1.3</td>
          <td>CACHE_MISS_COMMON</td>
          <td>LONGER</td>
          <td>Cache缺失时，回复的时间会更长</td>
      </tr>
  </tbody>
</table>
<h4 id="42-脏块写回">4.2. 脏块写回</h4>
<p>当需要替换的Cache块是脏块时，首先会进行写回的操作。</p>
<p>在进行测试时，我们首先需要创建脏块的环境，由于NutShell Cache采用<strong>随机替换</strong>的策略，因此我们考虑将整个Cache都设置成脏块。操作也是简单的，在上述的Load的基础上，只需要在每个CacheLine的起始地址进行一次Store操作即可。</p>
<h4 id="43-干净块不写回">4.3. 干净块不写回</h4>
<p>当需要替换的Cache块是干净的时，不会写回这个Cache块。</p>
</mrs-functions>
<h2 id="常量说明">常量说明</h2>
<table>
  <thead>
      <tr>
          <th>常量名</th>
          <th>常量值</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>缓存行大小</td>
          <td>64</td>
          <td>以字节为单位的缓存行大小</td>
      </tr>
      <tr>
          <td>L1Cache大小</td>
          <td>32</td>
          <td>L1Cache的总容量，单位为千字节</td>
      </tr>
  </tbody>
</table>
<h2 id="接口说明">接口说明</h2>
<table>
  <thead>
      <tr>
          <th>信号</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>clock<br>reset</td>
          <td>时钟<br>复位信号</td>
      </tr>
      <tr>
          <td>io_flush<br>io_empty <br> io_in_*</td>
          <td><br><br> 请求总线信号(req &amp; resp)</td>
      </tr>
      <tr>
          <td>io_out_mem_* <br> io_mmio_* <br> io_out_coh_* <br>victim_way_mask</td>
          <td>cache向内存请求的总线信号<br>cache向MMIO请求的总线信号 <br> 一致性相关的信号 <br> 受害者相关信号，即被替换的cache块相关信息</td>
      </tr>
  </tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<p>实际使用下面的表格时，请用有意义的英文大写的功能名称和测试点名称替换下面表格中的名称</p>
<mrs-testpoints>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>CACHE_BACKUP</td>
          <td>BACKUP</td>
          <td>对Cache的存取应该同对内存的存取一致</td>
      </tr>
      <tr>
          <td>2.1.1</td>
          <td>CACHE_MMIO_RW</td>
          <td>FORWARD</td>
          <td>Cache接收到MMIO空间的请求时，不应发生读写，而是直接转发给MMIO端口</td>
      </tr>
      <tr>
          <td>2.1.2</td>
          <td>CACHE_MMIO_RW</td>
          <td>NO_BURST</td>
          <td></td>
      </tr>
      <tr>
          <td>2.2</td>
          <td>CACHE_MMIO</td>
          <td>BLOCK</td>
          <td>MMIO请求发生时，应当阻塞流水线</td>
      </tr>
      <tr>
          <td>3.1</td>
          <td>CACHE_HIT</td>
          <td>WRITE</td>
          <td>Cache写命中时，应设置脏位</td>
      </tr>
      <tr>
          <td>3.2</td>
          <td>CACHE_HIT</td>
          <td>SHORTER</td>
          <td>Cache写命中时，回复的周期应该更少</td>
      </tr>
      <tr>
          <td>4.1.1</td>
          <td>CACHE_MISS_COMMON</td>
          <td>BLOCK</td>
          <td>发生缺失时，也会阻塞流水线</td>
      </tr>
      <tr>
          <td>4.1.2</td>
          <td>CACHE_MISS_COMMON</td>
          <td>CRITICAL_WORD</td>
          <td>Cache缺失时，Cache发出请求的首个地址应当是向Cache请求的地址</td>
      </tr>
      <tr>
          <td>4.1.3</td>
          <td>CACHE_MISS_COMMON</td>
          <td>LONGER</td>
          <td>Cache缺失时，回复的时间会更长</td>
      </tr>
      <tr>
          <td>4.2</td>
          <td>CACHE_MISS</td>
          <td>DIRTY</td>
          <td>Cache缺失时，Cache发出请求的首个地址应当是向Cache请求的地址</td>
      </tr>
      <tr>
          <td>4.3</td>
          <td>CACHE_MISS</td>
          <td>CLEAN</td>
          <td>Cache缺失时，回复的时间会更长</td>
      </tr>
  </tbody>
</table>
</mrs-testpoints>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3f5913187fe632a6790a8f4605680463">12.2 - Frontend</h1>
    
	<p>前端模块验证文档</p>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-caf9bb86b5b54160af08befebec88eee">12.2.1 - FTQ概述</h1>
    
	<p>下文（包括所有的FTQ文档）中会提到一些关于BPU和IFU的相关知识，详情需要去查看对应的文档:</p>
<ul>
<li><a href="https://open-verify.cc/xs-bpu/docs/">BPU文档链接</a></li>
<li><a href="https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/">IFU文档链接</a></li>
</ul>
<p><em>hint：建议先从BPU基础设计中着重理解以下概念：</em></p>
<ol>
<li>什么是分支预测？</li>
<li>什么是分支预测块？一个有帮助的链接：<a href="https://docs.xiangshan.cc/zh-cn/latest/frontend/bp/#pred-block">预测块</a></li>
<li>(可选)什么是重定向，什么是预测结果重定向？</li>
<li>(可选)分支预测的流水级</li>
</ol>
<h1 id="简介">简介</h1>
<p>FTQ 是分支预测和取指单元之间的缓冲队列，它的主要职能是<strong>暂存 BPU 预测的取指目标</strong>，并根据这些取指目标<strong>给 IFU 发送取指请求</strong>。它的另一重要职能是<strong>暂存 BPU 各个预测器的预测信息</strong>，在指令提交后把这些信息送回 BPU 用作预测器的训练，因此它需要<strong>维护指令从预测到提交的完整的生命周期</strong>。另外，后端将存储来自FTQ的取指目标PC，便于自身读取。</p>
<p>![[Pasted image 20250222103931.png]]</p>
<h1 id="模块之间的中转站">模块之间的中转站</h1>
<p>从上图，FTQ很大程度上相当于一个中转站，中间人的角色，一方面，它承担着BPU和IFU之间的交互，这通常是因为BPU预测的速度快于IFU取值执行，所以使用FTQ作为缓冲。另一方面，它承担着后端与前端的交互，比如把前端将要执行的pc交给后端去执行。</p>
<p>显然，FTQ的 中转远不止这么多，下面更具体地讨论一下FTQ怎么中转各个前端或后端模块的信息的。</p>
<h2 id="bpu和ftq">BPU和FTQ</h2>
<p>BPUtoFTQ：BPU会将分支预测结果和meta数据发给FTQ。</p>
<ul>
<li>从分支预测结果中，我们可以提取出分支预测块对应的取值目标，比如，一个不跨缓存行且所有指令均为RVC指令的分支预测块对应的取值目标，是从分支预测块起始地址开始的以2B为间隔的连续16条指令。</li>
<li>meta信息则存储了各个预测器相关的预测信息，由于BPU预测有三个流水级，每个流水级都有相应的预测器，所以只有到s3阶段才有可能收集到所有预测器的预测信息，直到此时FTQ才接受到完整的meta，这些信息会在该分支预测块的全部指令被后端提交时交给BPU进行训练</li>
<li>FTBEntry：严格来说，它其实也是meta的一部分，但是因为更新的时候ftb_entry需要在原来的基础上继续修改，为了不重新读一遍ftb，另外给它存储一个副本。</li>
</ul>
<p>FTQtoBPU：FTQ会将带元数据的训练信息和重定向信息发回给BPU</p>
<ul>
<li><a href="https://open-verify.cc/xs-bpu/docs/ports/02_global_ports/">请参照BPU文档链接</a> <strong>BPU 模块整体对外接口 (PredirectIO)</strong></li>
</ul>
<h2 id="ftq和ifu">FTQ和IFU</h2>
<p>FTQtoIFU：FTQ会将存储的取值目标发往IFU进行取值译码和把后端的重定向信息也移交给IFU</p>
<ul>
<li>取值目标同时也发给：
<ul>
<li>toICache：同样的取值目标会被发给指令缓存单元，看对应的指令是否在缓存单元内存在，如果有会被直接发送给IFU加速取值效率</li>
<li>toPrefetch: prefetch是ICache的一个组件，负责预取功能</li>
</ul>
</li>
<li>转发后端重定向：
<ul>
<li>后端重定向不仅需要转发给BPU帮助其回到正确状态，也同时需要转发给IFU帮助其回到正确状态</li>
</ul>
</li>
</ul>
<p>IFUtoFTQ：IFU将预译码信息和重定向信息写回FTQ</p>
<ul>
<li>预译码信息：包含分支预测块对应的预测宽度内所有指令的预译码信息
<em><strong>预测宽度：一个指令块预测块覆盖的指令范围，香山中是16条rvc指令</strong></em></li>
<li>重定向信息其实也是根据预译码信息得到的：当预译码信息中指出预测块内某一条指令预测出错时，写回IFU重定向信息</li>
</ul>
<h2 id="后端和ftq">后端和FTQ</h2>
<p>FTQ到后端：FTQ会将存储的取值目标发往后端，后端存储 PC后，在本地即可进行读取取指目标。</p>
<ul>
<li>除了IFU，预测块的取值目标也会发给后端，但这里有一点区别：IFU空闲时才能从FTQ中获取取值目标，但是后端会一直取得最新的预测块的取指目标</li>
</ul>
<p>后端到FTQ：后端重定向和指令commit</p>
<ul>
<li>后端重定向与更新：后端是实际执行指令的单元，通过后端的执行结果，才能确认一条指令是否执行错误，产生重定向，同时，在发生重定向时，根据后端实际执行结果生成更新信息。</li>
<li>指令commit：当一个分支预测块内的所有指令都被执行，在后端提交，这标志着FTQ队列中这个分支预测块对应的FTQ项已经结束了它的生命周期，可以从队列中移除了，这时候，我们就可以把它的更新信息发给FTQ了。</li>
</ul>
<h1 id="ftq指针">FTQ指针</h1>
<p>FTQ的全名叫取值目标队列，队列中的一个项叫做FTQ项，BPU写入预测结果时是写入队列中哪个位置，IFU又是从哪个队列取FTQ项？这时候，我们需要一个FTQ指针去索引FTQ项，而由于和不同模块的交互需要索引不同的FTQ项，因此，有以下类型的FTQ指针，下面，由指令生命周期为例，大致介绍这些指针：</p>
<h2 id="指令在ftq中的生存周期">指令在 FTQ 中的生存周期</h2>
<p>指令以<a href="https://docs.xiangshan.cc/zh-cn/latest/frontend/bp/#pred-block">预测块</a>为单位，从 BPU 预测后便送进 FTQ，直到指令所在的<a href="https://docs.xiangshan.cc/zh-cn/latest/frontend/bp/#pred-block">预测块</a>中的所有指令全部在后端提交完成，FTQ 才会在存储结构中完全释放该<a href="https://docs.xiangshan.cc/zh-cn/latest/frontend/bp/#pred-block">预测块</a>所对应的项。这个过程中发生的事如下：</p>
<ol>
<li>预测块从 BPU 发出，进入 FTQ，<code>bpuPtr</code> 指针加一，初始化对应 FTQ 项的各种状态，把各种预测信息写入存储结构；如果预测块来自 BPU 覆盖预测逻辑，则恢复 <code>bpuPtr</code> 和 <code>ifuPtr</code></li>
<li>FTQ 向 IFU 发出取指请求，<code>ifuPtr</code> 指针加一，等待预译码信息写回</li>
<li>IFU 写回预译码信息，<code>ifuWbPtr</code> 指针加一，如果预译码检测出了预测错误，则给 BPU 发送相应的重定向请求，恢复 <code>bpuPtr</code> 和 <code>ifuPtr</code></li>
<li>指令进入后端执行，如果后端检测出了误预测，则通知 FTQ，给 IFU 和 BPU 发送重定向请求，恢复 <code>bpuPtr</code>、<code>ifuPtr</code> 和 <code>ifuWbPtr</code></li>
<li>指令在后端提交，通知 FTQ，等 FTQ 项中所有的有效指令都已提交，<code>commPtr</code> 指针加一，从存储结构中读出相应的信息，送给 BPU 进行训练</li>
</ol>
<p>预测块 <code>n</code> 内指令的生存周期会涉及到 FTQ 中的 <code>bpuPtr</code>、<code>ifuPtr</code>、<code>ifuWbPtr</code> 和 <code>commPtr</code> 四个指针，当 <code>bpuPtr</code> 开始指向 <code>n+1</code> 时，预测块内的指令进入生存周期，当 <code>commPtr</code> 指向 <code>n+1</code> 后，预测块内的指令完成生存周期。</p>
<h2 id="循环队列">循环队列</h2>
<p>FTQ队列实际上是一个循环队列，所有类型的FTQ指针都是同一类型，ftqPtr的value字段用来表示索引，flag字段则用来表示循环轮数，flag只有一位，进入新的循环时flag位翻转。
这样，我们就可以在一个有限的队列空间内不断更新新的项，以及正确进行比较，判断哪个项在队列中更靠前或者更靠后。</p>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7ff52559ce920632c127396bd7ec9421">12.2.1.1 - FTQ顶层</h1>
    
	<h1 id="简述">简述</h1>
<p>在FTQ概述中，我们已经知道了，FTQ的作用就是多个模块交互的中转站，大致了解了它接受其他模块的哪些信息，它如何接受并存储这些信息在FTQ中，并如何把这些存储信息传递给需要的模块。
下面我们来具体了解一下FTQ与其他模块的交互接口，我们会对这种交互有一个更具体的认识。</p>
<h1 id="io一览">IO一览</h1>
<h2 id="模块间io">模块间IO</h2>
<ul>
<li><strong>fromBpu：接受BPU预测结果的接口（BpuToFtqIO）</strong></li>
<li><strong>fromIfu：接受IFU预译码写回的接口（IfuToFtqIO）</strong></li>
<li><strong>fromBackend：接受后端执行结果和commit信号的接口（CtrlToFtqIO）</strong></li>
<li><strong>toBpu：向BPU发送训练信息和重定向信息的接口（FtqToBpuIO）</strong></li>
<li><strong>toIfu：向IFU发送取值目标和重定向信息的接口（FtqToIfuIO）</strong></li>
<li>toICache：向ICache发送取值目标的接口（FtqToICacheIO）</li>
<li><strong>toBackend：向后端发送取值目标的接口（FtqToCtrlIO）</strong></li>
<li>toPrefetch：向Prefetch发送取值目标的接口（FtqToPrefetchIO）</li>
<li>mmio</li>
</ul>
<h2 id="其他">其他</h2>
<p>上述是主要的IO接口，此外，还有一些用于性能统计的IO接口，比如对BPU预测正确和错误结果次数进行统计，并进行转发的IO, 还有转发BPU各预测器预测信息的IO。</p>
<h1 id="bputoftqio"><a href="https://open-verify.cc/xs-bpu/docs/ports/02_global_ports/">BpuToFtqIO</a></h1>
<h1 id="ifutoftqio">IfuToFtqIO</h1>
<p>我们知道从IFU，我们会得到预译码信息和重定向信息，而后者其实也是从预译码信息中生成。所以从IFU到FTQ的接口主要就是用来传递预译码信息的</p>
<ul>
<li>pdWb：IFU向FTQ写回某个FTQ项的预译码信息
<ul>
<li>接口类型：<strong>PredecodeWritebackBundle</strong></li>
<li>信号列表：
<ul>
<li>pc：一个分支预测块覆盖的预测范围内的所有pc
<ul>
<li>接口类型：Vec(PredictWidth, UInt(VAddrBits.W))</li>
</ul>
</li>
<li>pd：预测范围内所有指令的预译码信息
<ul>
<li>接口类型：Vec(PredictWidth, new PreDecodeInfo)</li>
<li>PreDecodeInfo：每条指令的预译码信息
<ul>
<li>接口类型：PreDecodeInfo</li>
<li>信号列表：
<ul>
<li>valid：预译码有效信号
<ul>
<li>接口类型：Bool</li>
</ul>
</li>
<li>isRVC：是RVC指令
<ul>
<li>接口类型：Bool</li>
</ul>
</li>
<li>brType：跳转指令类型
<ul>
<li>接口类型：UInt(2.W)</li>
<li>说明：根据brType的值判断跳转指令类型
<ul>
<li>b01：对应分支指令</li>
<li>b10：对应jal</li>
<li>b11：对应jalr</li>
<li>b00：对应非控制流指令</li>
</ul>
</li>
</ul>
</li>
<li>isCall：是Call指令
<ul>
<li>接口类型：Bool</li>
</ul>
</li>
<li>isRet：是Ret指令
<ul>
<li>接口类型：Bool</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ftqIdx：FTQ项的索引，标记写回到哪个FTQ项
<ul>
<li>接口类型：FtqPtr</li>
</ul>
</li>
<li>ftqOffset：由BPU预测结果得到的，在该指令块中指令控制流指令的位置（指令控制流指令就是实际发生跳转的指令）
<ul>
<li>接口类型：UInt(log2Ceil(PredictWidth).W)</li>
</ul>
</li>
<li>misOffset：预译码发现发生预测错误的指令在指令块中的位置
<ul>
<li>接口类型：ValidUndirectioned(UInt(log2Ceil(PredictWidth).W))</li>
<li>说明：它的valid信号拉高表示该信号有效，也就说明存在预测错误，会引发重定向</li>
</ul>
</li>
<li>cfiOffset：由预译码结果得到的，在该指令块中指令控制流指令的位置（指令控制流指令就是实际发生跳转的指令）
<ul>
<li>接口类型：ValidUndirectioned(UInt(log2Ceil(PredictWidth).W))</li>
</ul>
</li>
<li>target：该指令块的目标地址
<ul>
<li>接口类型：UInt(VAddrBits.W)</li>
<li>说明：所谓目标地址，即在指令块中有控制流指令时，控制流指令的地址，在没有控制流指令时，指令块顺序执行，该指令块最后一条指令的下一条指令</li>
</ul>
</li>
<li>jalTarget：jal指令的跳转地址
<ul>
<li>接口类型：UInt(VAddrBits.W)</li>
</ul>
</li>
<li>instrRange：有效指令范围
<ul>
<li>接口类型：Vec(PredictWidth, Bool())</li>
<li>说明：表示该条指令是不是在这个预测块的有效指令范围内（第一条有效跳转指令之前的指令）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="ctrltoftqio">CtrlToFtqIO</h1>
<p>后端控制块向FTQ发送指令提交信息，后端执行结果的接口。</p>
<ul>
<li>rob_commits：一个提交宽度内的RobCommitInfo信息。
<ul>
<li>接口类型：Vec(CommitWidth, Valid(new RobCommitInfo))</li>
<li>详情链接：RobCommitInfo</li>
</ul>
</li>
<li>redirect：后端提供重定向信息的接口。
<ul>
<li>接口类型：Valid(new Redirect)</li>
<li>详情链接：Redirect</li>
</ul>
</li>
<li>ftqIdxAhead：提前重定向的FTQ指针，将要重定向的FTQ项的指针提前发送
<ul>
<li>接口类型： Vec(BackendRedirectNum, Valid(new FtqPtr))</li>
<li>说明：虽然有三个接口，但实际上只用到了第一个接口，后面两个弃用了</li>
</ul>
</li>
<li>ftqIdxSelOH：独热码，本来是依靠该信号从提前重定向ftqIdxAhead中选择一个，但现在只有一个接口了，独热码也只有一位了。
<ul>
<li>接口类型：Valid(UInt((BackendRedirectNum).W))</li>
<li>说明：为了实现提前一拍读出在ftq中存储的重定向数据，减少redirect损失，后端会向ftq提前一拍（相对正式的后端redirect信号）传送ftqIdxAhead信号和ftqIdxSelOH信号。</li>
</ul>
</li>
</ul>
<h1 id="ftqtobpuio"><a href="https://open-verify.cc/xs-bpu/docs/ports/02_global_ports/">FtqToBpuIO</a></h1>
<h1 id="ftqtoicacheio">FtqToICacheIO</h1>
<p>FTQ向IFU发送取值目标，ICache是指令缓存，如果取值目标在ICache中命中，由ICache将指令发给IFU</p>
<ul>
<li>req：FTQ向ICache发送取值目标的请求
<ul>
<li>接口类型：Decoupled(new FtqToICacheRequestBundle)</li>
<li>信号列表：
<ul>
<li>pcMemRead：FTQ针对ICache发送的取值目标，ICache通过5个端口同时读取取指目标
<ul>
<li>接口类型：Vec(5, new FtqICacheInfo)</li>
<li>FtqICacheInfo: FTQ针对ICache发送的取值目标
<ul>
<li>信号列表：
<ul>
<li>ftqIdx：指令块在FTQ中的位置索引
<ul>
<li>接口类型：FtqPtr</li>
</ul>
</li>
<li>startAddr：预测块起始地址
<ul>
<li>接口类型：UInt(VAddrBits.W)</li>
</ul>
</li>
<li>nextlineStart：起始地址所在cacheline的下一个cacheline的开始地址
<ul>
<li>接口类型：UInt(VAddrBits.W)</li>
</ul>
</li>
<li>说明：通过startAddr(blockOffBits - 1)这一位（也就是块内偏移地址的最高位）可以判断该预读取pc地址是位于cacheline的前半块还是后半块，若是前半块，由于取值块大小为cacheline大小的一半，不会发生跨cacheline行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>readValid: 对应5个pcMemRead是否有效</li>
<li>backendException：是否有后端异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="ftqtoctrlio">FtqToCtrlIO</h1>
<p>FTQ向后端控制模块转发PC，后端将这些pc存储在本地，之后直接在本地读取这些pc
<strong>写入后端pc mem</strong></p>
<ul>
<li>pc_mem_wen：FTQ向后端pc存储单元pc_mem写使能信号
<ul>
<li>接口类型：Output(Bool())</li>
</ul>
</li>
<li>pc_mem_waddr：写入地址
<ul>
<li>接口类型：Output(UInt(log2Ceil(FtqSize).W))</li>
</ul>
</li>
<li>pc_mem_wdata：写入数据，是一个指令块的取值目标
<ul>
<li>接口类型：Output(new Ftq_RF_Components)，详见FTQ子队列相关介绍
<strong>写入最新目标</strong></li>
</ul>
</li>
<li>newest_entry_en：是否启用
<ul>
<li>接口类型：Output(Bool())</li>
</ul>
</li>
<li>newest_entry_target：最新指令块的跳转目标
<ul>
<li>接口类型：Output(UInt(VAddrBits.W))</li>
</ul>
</li>
<li>newest_entry_ptr：最新指令块的索引值
<ul>
<li>接口类型： Output(new FtqPtr)</li>
</ul>
</li>
</ul>
<h1 id="ftqtoprefetchio">FtqToPrefetchIO</h1>
<ul>
<li>req：FTQ向Prefetch发送取值目标的请求
<ul>
<li>接口类型：FtqICacheInfo</li>
</ul>
</li>
<li>flushFromBPU: 来自BPU的冲刷信息
<ul>
<li>接口类型：BpuFlushInfo</li>
<li>信号列表：
<ul>
<li>s2 ：BPU预测结果重定向（注意这种重定向是BPU自己产生的，与其他类型要做区分）发生在s2阶段时，此阶段的分支预测块的索引
<ul>
<li>接口类型：Valid(new FtqPtr)</li>
<li>说明：valid信号有效时，说明此时s2流水级分支预测结果与其s1阶段预测结果不一致，产生s2阶段重定向</li>
</ul>
</li>
<li>s3：BPU预测结果重定向（注意这种重定向是BPU自己产生的，与其他类型要做区分）发生在s3阶段时，此阶段的分支预测块的索引
<ul>
<li>接口类型：Valid(new FtqPtr)</li>
<li>说明：与s2类似</li>
</ul>
</li>
<li>说明：发生预测结果重定向的时候，预取单元和IFU都可能会被冲刷，比如，如果发生s2阶段重定向，FTQ会比较发给IFU req接口中的ftqIdx和s2阶段预测结果的ftqIdx，如果s2阶段的ftqIdx不在req的ftqIdx之后，这意味着，s2阶段产生的预测结果重定向之前的错误预测结果s1阶段预测结果被发给IFU进行取指了，为了消除这种错误，需要向IFU发送s2阶段flush信号。</li>
</ul>
</li>
</ul>
</li>
<li>backendException：后端执行发生的异常
<ul>
<li>接口类型：UInt(ExceptionType.width.W)</li>
<li>说明：表示后端执行时发生异常的类型，有这样几种类型的异常：</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">none</span><span style="color:#204a87;font-weight:bold">:</span>  <span style="color:#204a87;font-weight:bold">UInt</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;b00&#34;</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">U</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">width</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">pf</span><span style="color:#204a87;font-weight:bold">:</span>    <span style="color:#204a87;font-weight:bold">UInt</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;b01&#34;</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">U</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">width</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic">// instruction page fault
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">gpf</span><span style="color:#204a87;font-weight:bold">:</span>   <span style="color:#204a87;font-weight:bold">UInt</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;b10&#34;</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">U</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">width</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic">// instruction guest page fault
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">af</span><span style="color:#204a87;font-weight:bold">:</span>    <span style="color:#204a87;font-weight:bold">UInt</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;b11&#34;</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">U</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">width</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic">// instruction access fault
</span></span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8b82b413ea6abfeab9ebac3ba72e7b9c">12.2.1.2 - FTQ子队列</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p><em><strong>请注意：从本篇开始，就涉及待验证的功能点和测试点了</strong></em></p>
<p>在之前的介绍中，我们采用FTQ项这个术语描述描述FTQ队列中的每一个元素，实际上，这只是一种便于抽象的说法。</p>
<p>实际上的FTQ队列，是由好多个子队列共同构成的，一些子队列维护一类信息，另一些子队列维护另一类信息，相同ftqIdx索引的子队列信息共同构成一个完整的FTQ项。</p>
<p>为什么要把它们分开成多个子队列呢？因为某些模块只需要FTQ项中的某一些信息，比如IFU想要取值目标，它只需要专门存储取值目标的子队列提供的信息就行了。另外，在我们更改FTQ项的内容时，也只需要写入需要更新的子队列，比如IFU预译码写回时，只需要写回专门存储预译码信息的队列了。</p>
<p>下面来介绍一些FTQ的主要子队列，以及它们内部存储的数据结构。此外，FTQ还有一些存储中间状态的更小的队列</p>
<h2 id="术语说明">术语说明</h2>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>定义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="https://open-verify.cc/xs-bpu/docs/ports/00_ftb/">FTB项</a></td>
          <td>分支预测结果的基本组成项，包含对预测块中分支指令和跳转指令的预测</td>
      </tr>
      <tr>
          <td>取指目标</td>
          <td>一个预测块内包含的所有指令PC，当然，它不是直接发送所有PC，而是发送部分信号，接收方可由该信号推出所有PC</td>
      </tr>
  </tbody>
</table>
<h2 id="子模块列表">子模块列表</h2>
<table>
  <thead>
      <tr>
          <th>子模块</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ftq_redirect_mem<br></td>
          <td>重定向存储子队列，存储来自分支预测结果的重定向信息</td>
      </tr>
      <tr>
          <td>ftq_pd_mem</td>
          <td>预译码存储子队列，存储来自IFU的对指令块的预译码信息</td>
      </tr>
      <tr>
          <td>ftb_entry_mem</td>
          <td>FTB项存储子队列，存储自分支预测结果中的ftb项</td>
      </tr>
      <tr>
          <td>ftq_pc_mem</td>
          <td>取指目标子队列，存储来自分支预测结果的取指目标</td>
      </tr>
  </tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-ftq_redirect_mem存储重定向信息">1. ftq_redirect_mem存储重定向信息</h3>
<p>ftq_redirect_mem是香山ftq的一个子队列。它记录了重定向需要的一些信息，帮助重定向回正确状态，这些信息来自于BPU分支预测中的RAS预测器，以及顶层的分支历史指针，如果想要了解，可以参考BPU的RAS子文档了解如何通过这些信息回溯到之前的状态。</p>
<p>它是一个寄存器堆，由64（FtqSize）个表项（Ftq_Redirect_SRAMEntry）构成。支持同步读写操作。有3个读端口和1个写端口，每个读端口负责与不同的模块交互。</p>
<h4 id="11-ftq_redirect_mem读操作">1.1 ftq_redirect_mem读操作</h4>
<ul>
<li>读操作：
<ul>
<li>输入：
<ul>
<li>需要使能ren，这是一个向量，可指定任意读端口可读
<ul>
<li>对应接口：ren</li>
</ul>
</li>
<li>从任意读端口中输入要读取的元素在ftq_redirect_mem中的地址，这是一个从0到ftqsize-1的索引
<ul>
<li>对应接口：raddr</li>
</ul>
</li>
</ul>
</li>
<li>输出：
<ul>
<li>从发起输入的读端口对应的读出端口中读出Ftq_Redirect_SRAMEntry。
<ul>
<li>对应接口：rdata</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="12-ftq_redirect_mem写操作">1.2 ftq_redirect_mem写操作</h4>
<ul>
<li>写操作
<ul>
<li>输入：
<ul>
<li>需要使能wen，可指定写端口可写
<ul>
<li>对应接口：wen</li>
</ul>
</li>
<li>向写端口中输入要写入的元素在ftq_redirect_mem中的地址，这是一个从0到ftqsize-1的索引
<ul>
<li>对应接口：waddr</li>
</ul>
</li>
<li>向wdata中写入Ftq_Redirect_SRAMEntry
<ul>
<li>对应接口：wdata</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>多端口读：可以从多个读端口读取结果</li>
</ul>
<p><em>每个子队列的读写基本都是类似的，后面不再赘述</em></p>
<h3 id="ftq_redirect_sramentry">Ftq_Redirect_SRAMEntry</h3>
<p>ftq_redirect_mem存储的表项。继承自SpeculativeInfo，存储RAS预测器相关重定向信息，根据这些信息回溯到之前的状态</p>
<ul>
<li>sc_disagree：统计分支指令在sc预测器中预测是否发生错误
<ul>
<li>接口类型：Some(Vec(numBr, Bool()))</li>
<li>说明：Option 类型，表明这个值可能不存在，在非FPGA平台才有，否则为none</li>
<li>信号列表：
<ul>
<li>SpeculativeInfo：推测信息，帮助BPU在发生重定向的时候回归正常的状态
<ul>
<li>接口列表:
<ul>
<li>histPtr：重定向请求需要恢复的全局历史指针，可参见BPU顶层文档了解详情
<ul>
<li>接口类型：CGHPtr</li>
</ul>
</li>
</ul>
</li>
<li>说明：以下都属于RAS重定向信息,可参见BPU文档了解如何利用这些信息进行重定向
<ul>
<li>ssp：重定向请求指令对应的 RAS 推测栈栈顶在提交栈位置的指针
<ul>
<li>接口类型：UInt(log2Up(RasSize).W)</li>
</ul>
</li>
<li>sctr：重定向请求指令对应的 RAS 推测栈栈顶递归计数 Counter
<ul>
<li>接口类型：RasCtrSize.W</li>
</ul>
</li>
<li>TOSW：重定向请求指令对应的 RAS 推测栈（队列）写指针
<ul>
<li>接口类型：RASPtr</li>
</ul>
</li>
<li>TOSR：重定向请求指令对应的 RAS 推测栈（队列）读指针
<ul>
<li>接口类型：RASPtr</li>
</ul>
</li>
<li>NOS：重定向请求指令对应的 RAS 推测栈（队列）读指针
<ul>
<li>接口类型：RASPtr</li>
</ul>
</li>
<li>topAddr：
<ul>
<li>接口类型：UInt(VAddrBits.W)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>FTQ_REDIRECT_MEM</td>
          <td>WRITE</td>
          <td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
      </tr>
      <tr>
          <td>1.2</td>
          <td>FTQ_REDIRECT_MEM</td>
          <td>READ</td>
          <td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
      </tr>
  </tbody>
</table>
<h3 id="2-ftq_pd_mem存储预译码信息">2. ftq_pd_mem存储预译码信息</h3>
<p>由64（FtqSize）个表项（Ftq_pd_Entry）构成。支持同步读写操作。有2个读端口和1个写端口。具有读写使能信号。</p>
<p>存储来自IFU预译码的写回信息，它是一个寄存器堆，由64（FtqSize）个表项（Ftq_pd_Entry）构成。有2个读端口和1个写端口。</p>
<p>ftq_pd_mem直接接收来自IfuToFtqIO的信号，从中获取Ftq_pd_Entry，表示一个指令块对应的预译码信息表项。读取时获取预测块内某条指令的预测信息</p>
<h4 id="ftq_pd_entry">Ftq_pd_Entry</h4>
<ul>
<li>brMask：一个指令预测宽度内（16条rvc指令）的指令块中，哪些指令是分支指令
<ul>
<li>接口类型：Vec(PredictWidth, Bool())</li>
</ul>
</li>
<li>jmpInfo：jump信息，其值对应不同的jmp指令类型，表示指令块内jmp指令类型
<ul>
<li>接口类型：ValidUndirectioned(Vec(3, Bool()))</li>
<li>说明：  jumpinfo有效的时候，第0位是0，表示jal指令，第0位是1，表示jalr指令，第1位是1，表示call指令，第二位是1，表示ret指令。</li>
</ul>
</li>
<li>jmpOffset：jmp指令在指令预测块中的偏移地址
<ul>
<li>接口类型： UInt(log2Ceil(PredictWidth).W)</li>
</ul>
</li>
<li>rvcMask：一个预测块内的指令（16条rvc指令）哪些是rvc指令
<ul>
<li>接口类型：Vec(PredictWidth, Bool())</li>
</ul>
</li>
</ul>
<h3 id="21-ftq_pd_mem写操作">2.1 ftq_pd_mem写操作</h3>
<h4 id="predecodewritebackbundleifutoftqio如何写入ftq_"><strong>PredecodeWritebackBundle（IfuToFtqIO）如何写入ftq_pd_mem的一条Ftq_pd_Entry</strong></h4>
<p>Ftq_pd_Entry项的写入是通过PredecodeWritebackBundle这个接口进行写入的（其实也就是IfuToFtqIO）
<em>从fromPdWb接口中接收信号生成表项</em>：</p>
<ul>
<li>brmask：PredecodeWritebackBundle有一个预测块内的所有指令的预译码信息，当一条指令的预译码信息有效(valid)且是分支指令（is_br）时, bool序列对应位置的指令被判定为分支指令</li>
<li>jumpInfo：
<ul>
<li>valid：预测块内存在一条指令，其预译码信息有效（valid），且是jmp指令（isJal或者isJalr）时，jumpInfo有效</li>
<li>bits：预测块内的第一条有效跳转指令的info，它是一个三位序列，从低到高（拉高）对应该指令被预译码为是isJalr，isCall，isRet</li>
</ul>
</li>
<li>jmpOffset：预测块内第一条有效jmp跳转指令的偏移</li>
<li>rvcMask：原封不动接受同名信号</li>
<li>jalTarget：原封不动接收同名信号</li>
</ul>
<h3 id="22-ftq_pd_mem写操作">2.2 ftq_pd_mem写操作</h3>
<h4 id="ftq_"><strong>ftq_pd_mem的一条Ftq_pd_Entry如何以PreDecodeInfo（to pd）的形式输出</strong></h4>
<p>PreDecodeInfo是一个Ftq_pd_Entry中的一条指令的预译码，需要输入offset，指定该预译码指令在预测块内的偏移</p>
<ul>
<li>
<p>valid：直接set为1</p>
</li>
<li>
<p>isRVC：设置为rvcMask bool序列中对应偏移的值</p>
</li>
<li>
<p>isBr：设置为brMask bool序列中对应偏移的值</p>
</li>
<li>
<p>isJalr：输入的偏移量等于jumpOffset，且jumpInfo有效并指明该指令type是isJalr（jmpInfo.valid &amp;&amp; jmpInfo.bits(0)）</p>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.1</td>
          <td>FTQ_PD_MEM</td>
          <td>WRITE</td>
          <td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
      </tr>
      <tr>
          <td>2.2</td>
          <td>FTQ_PD_MEM</td>
          <td>READ</td>
          <td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
      </tr>
  </tbody>
</table>
<h3 id="3-ftb_entry_mem存储ftb项">3. ftb_entry_mem存储FTB项</h3>
<p>有两个读端口，一个写端口，FtqSize个表项，存储的数据项为FTBEntry_FtqMem，FTBEntry_FtqMem与FTBEntry基本上是一致的。</p>
<h4 id="ftbentry_ftqmem">FTBEntry_FtqMem</h4>
<ul>
<li>brSlots：分支指令槽
<ul>
<li>接口类型：Vec(numBrSlot, new FtbSlot_FtqMem)</li>
<li>FtbSlot_FtqMem：
<ul>
<li>信号列表：
<ul>
<li>offset：给分支指令在相对于指令块起始地址的偏移
<ul>
<li>接口类型：UInt(log2Ceil(PredictWidth).W)</li>
</ul>
</li>
<li>sharing：对于tailSlot来说，启用sharing表示把这个slot让给分支指令来被预测
<ul>
<li>接口类型：Bool</li>
</ul>
</li>
<li>valid：预测槽有效
<ul>
<li>接口类型：Bool</li>
<li>说明：当slot有效时，我们才能说这条指令是br指令还是jmp指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>tailSlot：跳转指令槽
<ul>
<li>接口类型：FtbSlot_FtqMem</li>
</ul>
</li>
<li>FTBEntry_part：FTBEntry_FtqMem的父类，存储部分FTB信息，记录跳转指令的类型
<ul>
<li>信号列表：
<ul>
<li>isCall：接口类型：Bool</li>
<li>isRet：接口类型：Bool</li>
<li>isJalr：接口类型：Bool</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="31-ftb_entry_mem读操作">3.1 ftb_entry_mem读操作</h4>
<p>除了读出FTB项之外，顶层还可以从FTBEntry_FtqMem获取以下有效信息，在这里我们不需要验证以下内容，但是在验证顶层的时候我们会用到以下内容，在此处提一下，此外，以下内容并不会生成具体的信号接口，而是产生相应的判断逻辑：</p>
<ul>
<li>jmpValid：预测块中jmp指令有效
<ul>
<li>说明：当tailslot有效且不分享给分支指令时，jmp有效</li>
</ul>
</li>
<li>getBrRecordedVec：三维向量，对于三个slot
<ul>
<li>说明：接收一个offset偏移，如果命中有效分支slot（或者sharing拉高的tailslot），对应slot的向量元素拉高。</li>
</ul>
</li>
<li>brIsSaved：给定offset的指令是否是分支指令
<ul>
<li>说明：采用slot预测结果来说明是不是分支指令，前提需要信号有效</li>
</ul>
</li>
<li>getBrMaskByOffset：
<ul>
<li>说明：在给定offset范围内的三个slot中的指令是否是有效分支指令，用一个三位maks表示</li>
</ul>
</li>
<li>newBrCanNotInsert：能否插入新的brSlot
<ul>
<li>说明：给定offset超过有效tailSlot对应的offset时，不能插入新的brSlot</li>
</ul>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>3.1</td>
          <td>FTQ_ENTRY_MEM</td>
          <td>WRITE</td>
          <td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
      </tr>
      <tr>
          <td>3.2</td>
          <td>FTQ_ENTRY_MEM</td>
          <td>READ</td>
          <td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
      </tr>
  </tbody>
</table>
<h3 id="4-ftq_pc_mem存储取指目标">4. ftq_pc_mem存储取指目标</h3>
<p>pc存储子队列。存储项为Ftq_RF_Components，用来读取取指信息，取值信息交给IFU进行取指。</p>
<h4 id="ftq_rf_components">Ftq_RF_Components</h4>
<p><strong>信号含义</strong></p>
<ul>
<li>startAddr: 预测块的起始地址</li>
<li>nexLineAddr: 预测块下一个缓存行的起始地址
<ul>
<li>startAddr加上64个字节，一个缓存行的大小是64字节</li>
</ul>
</li>
<li>isNextMask: 一个预测宽度内的16条指令各自是否属于下一个预测块(在最新版本rtl中已被编译优化掉)
<ul>
<li>通过计算某条指令相对于预测块起始地址的偏移量（每条指令两个字节）得到偏移地址，该偏移地址的第4位（从0开始）为1，表示该指令属于下一个预测块。</li>
<li>进一步说，其实也就可以根据它判断该指令是否在预测块跨缓存行的时候判断该指令是否属于下一个cacheline了</li>
</ul>
</li>
<li>fallThruError ：预测出的下一个顺序取指地址是否存在错误</li>
</ul>
<h5 id="41-ftq_pc_mem写操作">4.1 ftq_pc_mem写操作</h5>
<p><strong>信息获取：上述信息都可以从一个单流水级分支预测结果 (BranchPredictionBundle)中获取</strong>。
获取方式：startAddr直接获取BranchPredictonBundle中的pc，fallThruError直接获取BranchPredictionBundle中的fallThruError。</p>
<h5 id="42-ftq_pc_mem读操作">4.2 ftq_pc_mem读操作</h5>
<p><strong>多端口读</strong>：ftq_pc_mem的每个读端口的读地址被直接连到各个FTQ指针的写入信号，这样做的目的，是可以及时的读取，从pc存储子队列读出的项一定是此时FTQ指针指向的项</p>
<h5 id="读写时机">读写时机</h5>
<p><strong>写入时机</strong>：BPU流水级的S1阶段，创建新的预测entry时写入
<strong>读出时机</strong>： 读数据每个时钟周期都会存进Reg。如果IFU不需要从bypass中读取数据，Reg数据直连给Icache和IFU，如果IFU不需要从bypass中读取数据，Reg数据直连给Icache和IFU</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>4.1</td>
          <td>FTQ_PC_MEM</td>
          <td>WRITE</td>
          <td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
      </tr>
      <tr>
          <td>4.2</td>
          <td>FTQ_PC_MEM</td>
          <td>READ</td>
          <td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
      </tr>
  </tbody>
</table>
<h3 id="5-ftq_meta_1r_sram存储meta信息">5. ftq_meta_1r_sram存储meta信息</h3>
<p>存储的数据为Ftq_1R_SRAMEntry，同样有FtqSize项
Ftq_1R_SRAMEntry接口列表</p>
<ul>
<li>meta：分支预测的meta数据</li>
<li>ftb_entry：分支预测的FTB项
<strong>写入时机</strong>：在 BPU的s3阶段接收信息，因为对于一个指令预测块，只有在其s3阶段才能获取完整的mata信息，同样被接收的还有最后阶段ftqentry信息</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>5.1</td>
          <td>FTQ_META_1R_SRAM</td>
          <td>WRITE</td>
          <td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
      </tr>
      <tr>
          <td>5.2</td>
          <td>FTQ_META_1R_SRAM</td>
          <td>READ</td>
          <td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
      </tr>
  </tbody>
</table>
<h2 id="接口说明">接口说明</h2>
<h3 id="ftq_redirect_sramentry-1">Ftq_Redirect_SRAMEntry</h3>
<p>ftq_redirect_mem存储的表项。继承自SpeculativeInfo，存储RAS预测器相关重定向信息，根据这些信息回溯到之前的状态</p>
<ul>
<li>sc_disagree：统计分支指令在sc预测器中预测是否发生错误
<ul>
<li>接口类型：Some(Vec(numBr, Bool()))</li>
<li>说明：Option 类型，表明这个值可能不存在，在非FPGA平台才有，否则为none</li>
<li>信号列表：
<ul>
<li>SpeculativeInfo：推测信息，帮助BPU在发生重定向的时候回归正常的状态
<ul>
<li>接口列表:
<ul>
<li>histPtr：重定向请求需要恢复的全局历史指针，可参见BPU顶层文档了解详情
<ul>
<li>接口类型：CGHPtr</li>
</ul>
</li>
</ul>
</li>
<li>说明：以下都属于RAS重定向信息,可参见BPU文档了解如何利用这些信息进行重定向
<ul>
<li>ssp：重定向请求指令对应的 RAS 推测栈栈顶在提交栈位置的指针
<ul>
<li>接口类型：UInt(log2Up(RasSize).W)</li>
</ul>
</li>
<li>sctr：重定向请求指令对应的 RAS 推测栈栈顶递归计数 Counter
<ul>
<li>接口类型：RasCtrSize.W</li>
</ul>
</li>
<li>TOSW：重定向请求指令对应的 RAS 推测栈（队列）写指针
<ul>
<li>接口类型：RASPtr</li>
</ul>
</li>
<li>TOSR：重定向请求指令对应的 RAS 推测栈（队列）读指针
<ul>
<li>接口类型：RASPtr</li>
</ul>
</li>
<li>NOS：重定向请求指令对应的 RAS 推测栈（队列）读指针
<ul>
<li>接口类型：RASPtr</li>
</ul>
</li>
<li>topAddr：
<ul>
<li>接口类型：UInt(VAddrBits.W)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ftq_pd_entry-1">Ftq_pd_Entry</h3>
<ul>
<li>brMask：一个指令预测宽度内（16条rvc指令）的指令块中，哪些指令是分支指令
<ul>
<li>接口类型：Vec(PredictWidth, Bool())</li>
</ul>
</li>
<li>jmpInfo：jump信息，其值对应不同的jmp指令类型，表示指令块内jmp指令类型
<ul>
<li>接口类型：ValidUndirectioned(Vec(3, Bool()))</li>
<li>说明：  jumpinfo有效的时候，第0位是0，表示jal指令，第0位是1，表示jalr指令，第1位是1，表示call指令，第二位是1，表示ret指令。</li>
</ul>
</li>
<li>jmpOffset：jmp指令在指令预测块中的偏移地址
<ul>
<li>接口类型： UInt(log2Ceil(PredictWidth).W)</li>
</ul>
</li>
<li>rvcMask：一个预测块内的指令（16条rvc指令）哪些是rvc指令
<ul>
<li>接口类型：Vec(PredictWidth, Bool())</li>
</ul>
</li>
</ul>
<h2 id="测试点总表">测试点总表</h2>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>FTQ_REDIRECT_MEM</td>
          <td>WRITE</td>
          <td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
      </tr>
      <tr>
          <td>1.2</td>
          <td>FTQ_REDIRECT_MEM</td>
          <td>READ</td>
          <td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
      </tr>
      <tr>
          <td>2.1</td>
          <td>FTQ_PD_MEM</td>
          <td>WRITE</td>
          <td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
      </tr>
      <tr>
          <td>2.2</td>
          <td>FTQ_PD_MEM</td>
          <td>READ</td>
          <td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
      </tr>
      <tr>
          <td>3.1</td>
          <td>FTQ_ENTRY_MEM</td>
          <td>WRITE</td>
          <td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
      </tr>
      <tr>
          <td>3.2</td>
          <td>FTQ_ENTRY_MEM</td>
          <td>READ</td>
          <td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
      </tr>
      <tr>
          <td>4.1</td>
          <td>FTQ_PC_MEM</td>
          <td>WRITE</td>
          <td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
      </tr>
      <tr>
          <td>4.2</td>
          <td>FTQ_PC_MEM</td>
          <td>READ</td>
          <td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
      </tr>
      <tr>
          <td>5.1</td>
          <td>FTQ_META_1R_SRAM</td>
          <td>WRITE</td>
          <td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
      </tr>
      <tr>
          <td>5.2</td>
          <td>FTQ_META_1R_SRAM</td>
          <td>READ</td>
          <td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
      </tr>
  </tbody>
</table>
<h2 id="附录">附录</h2>
<p><em><strong>虽然列在附录，但实际上这段内容依然十分重要，当你需要的时候请一定要查看。</strong></em></p>
<h3 id="其余状态子队列">其余状态子队列</h3>
<p>上述存储结构是FTQ中比较核心的存储结构，实际上，还有一些子队列用来存储一些状态信息，也同样都是存储ftqsize个（64）元素。主要有以下：</p>
<p>update_target：记录每个FTQ项的跳转目标，跳转目标有两种，一种是当该FTQ项对应的分支预测结果中指明的该分支预测块中执行跳转的分支指令将要跳转到的地址，另一种则是分支预测块中不发生跳转，跳转目标为分支预测块中指令顺序执行的下一条指令地址。</p>
<ul>
<li>此外，与之配套的还有newest_entry_target，newest_entry_ptr用来指示新写入的跳转目标地址，和它对应的指令预测块或者说FTQ项的在FTQ中的位置，同时，有辅助信号newest_entry_target_modified和newest_entry_ptr_modified用来标识该地址的FTQ项跳转地址是否被修改。</li>
</ul>
<p>写入时机：上一个周期的bpu_in_fire有效的时候，或者说相对于bpu_in_fire有效时延迟一个周期写入。</p>
<p>newest_entry_ptr，newest_entry_target：这几个内部信号，表明我们当前最新的有效FTQ项。BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，在相应的文档中，对其生成方式做具体的描述。</p>
<p>cfiIndex_vec：记录每个FTQ项的发生跳转的指令cfi（control flow instruction）指令在其分支预测块中的位置
写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</p>
<p>mispredict_vec：记录每个FTQ项的分支预测结果是否有误，初始化为false</p>
<p>pred_stage：记录每个FTQ项的分支预测结果是来自于哪个阶段
写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</p>
<p>pred_s1_cycle：记录每个FTQ项的分支预测结果对应的s1阶段的分支预测结果生成的时间（cycle数）
写入时机：相对于bpu_in_fire有效时延迟两个周期写入。</p>
<p>commitStateQueueReg：记录每个FTQ项中对应的分支预测块中每条指令（一般是16条rvc指令，对应一个预测宽度）的提交状态，提交状态有c_empty ，c_toCommit ，c_committed ，c_flushed，依次用从0开始的从小到大的枚举量表示，初始化为c_empty状态
写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</p>
<p>entry_fetch_status：记录每个FTQ项的分支预测结果是否被送到ifu中，该状态由两个枚举量f_to_send ， f_sent来表示, 初始化为f_sent状态。
写入时机：上一个周期的bpu_in_fire有效的时候，相对于bpu_in_fire有效时延迟一个周期写入。
写入数据：写入f_to_send</p>
<p>entry_hit_status：记录每个FTQ项拿到的分支预测结果是否是ftb entry hit的，即生成该分支预测结果的时候是否是从FTB ( <a href="https://open-verify.cc/xs-bpu/docs/modules/03_ftb/">预测结果生成：hit</a>)(非必须了解)中，读取到了对应的记录表项。初始化为not_hit状态。
写入时机：当来自BPU的全局分支预测信息中s2阶段的分支预测结果有效时，写入s2阶段分支预测结果中指名的hit状态，因为FTB预测器是分支预测s2阶段开始生效的，在此时判断预测项是否在FTB缓存中命中</p>
<p>newest_entry_ptr，newest_entry_target这几个内部信号，它们不是队列，但是它们很重要，表明我们当前应该关注的最新的FTQ项及对应的跳转目标。BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，在涉及到修改该信号的相应的文档中，对其生成方式做具体的描述。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a08c000e80bb83d7987b168d3f0ac2f5">12.2.1.3 - FTQ接收BPU分支预测结果</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>BPU会将分支预测结果和meta数据发给FTQ。</p>
<ul>
<li>从分支预测结果中，我们可以提取出分支预测块对应的取值目标，比如，一个不跨缓存行且所有指令均为RVC指令的分支预测块对应的取值目标，是从分支预测块起始地址开始的以2B为间隔的连续16条指令。</li>
<li>meta信息则存储了各个预测器相关的预测信息，由于BPU预测有三个流水级，每个流水级都有相应的预测器，所以只有到s3阶段才有可能收集到所有预测器的预测信息，直到此时FTQ才接受到完整的meta，这些信息会在该分支预测块的全部指令被后端提交时交给BPU进行训练</li>
<li>FTBEntry：严格来说，它其实也是meta的一部分，但是因为更新的时候ftb_entry需要在原来的基础上继续修改，为了不重新读一遍ftb，另外给它存储一个副本。</li>
</ul>
<h2 id="术语说明">术语说明</h2>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>定义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>BPU (Branch Prediction Unit)</td>
          <td>分支预测单元</td>
      </tr>
      <tr>
          <td>FTQ (Fetch Target Queue)</td>
          <td>采集目标队列</td>
      </tr>
      <tr>
          <td>IFU (Instruction Fetch Unit)</td>
          <td>指令采集单元</td>
      </tr>
      <tr>
          <td>RAS (Return Address Stack)</td>
          <td>返回地址堆</td>
      </tr>
      <tr>
          <td>FTQ Entry</td>
          <td>FTQ队列中的单个表项</td>
      </tr>
  </tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-新的预测块进队条件">1. 新的预测块进队条件</h3>
<h4 id="11-成功接收数据"><strong>1.1 成功接收数据</strong></h4>
<h5 id="111-ftq准备好接收信号">1.1.1 FTQ准备好接收信号</h5>
<ul>
<li>FTQ准备好接收信号：
     当FTQ队列中元素小于FtqSize或者可以提交指令块（canCommit拉高，说明可以提交指令块，在后面的文档: FTQ向BPU发送更新信息中介绍怎么判断是否可以提交指令块）的时候，来自BPU的新的指令预测块可以进入FTQ队列，队列准备好接收新的预测块，fromBpu的resp接口ready信号拉高。</li>
</ul>
<h5 id="112-bpu准备好要发送的信号">1.1.2 BPU准备好要发送的信号</h5>
<ul>
<li>BPU准备好要发送的信号：
     当BPU发往FTQ的接口vaid信号拉高，表示发送信号准备好</li>
</ul>
<p>满足以上两个条件时,fromBpu的resp接口fire，表示接口数据被成功发送到FTQ中。</p>
<h4 id="12-允许bpu入队allowbpuin"><strong>1.2 允许BPU入队allowBpuIn</strong></h4>
<ul>
<li>重定向发生时，会回滚到之前的状态，新发送的BPU预测信息自然就不需要了。<strong>允许BPU入队</strong>时不能发生重定向</li>
</ul>
<h5 id="121-后端重定向发生">1.2.1 后端重定向发生</h5>
<ol>
<li>后端重定向发生：
<ul>
<li>标志：接收后端写回信息的接口fromBackend的重定向接口redirect有效，则该周期不允许入队，如果没有发生真实提前重定向realAhdValid(参见FTQ接收后端重定向一文)，则下一个周期也不允许入队。</li>
</ul>
</li>
</ol>
<h5 id="122-ifu重定向发生">1.2.2 IFU重定向发生</h5>
<ol start="2">
<li>IFU重定向发生：
<ul>
<li>标志：IFU重定向信息生成的两个周期，均不许入队（参见FTQ接收IFU重定向一文了解IFU重定向信息的生成）</li>
</ul>
</li>
</ol>
<p>只要避免上述两种重定向出现的情况，就可以允许BPU入队,即可以把发送到FTQ的数据，写入FTQ项</p>
<h4 id="13-以bpu预测结果重定向的方式入队">1.3 以BPU预测结果重定向的方式入队</h4>
<p>上述的BPU入队方式是一个全新的预测块进队，即BPU分支预测的s1阶段结果入队，此时未发生预测结果重定向。</p>
<p>当BPU发生预测结果重定向时，只要<strong>允许BPU入队allowBpuIn</strong>，也可以看作预测结果入队，不过这种入队是覆写队列中已有的FTQ项，没有写入新的指令块。</p>
<ul>
<li>BPU预测结果发生重定向的具体标志：fromBpu的resp接口的s2（s2阶段的预测信息）有效，且s2的hasRedirect拉高，表示在s2阶段发生了重定向，s3阶段重定向是一样的。</li>
</ul>
<p><em><strong>综合两种形式的BPU入队，这里称之为广义BPU入队方便区分，记为bpu_in_fire，该信号拉高，表明发生广义BPU入队。</strong></em></p>
<h3 id="2-写入ftq项">2. 写入FTQ项</h3>
<p>之前已经说明过了，FTQ项只是一个抽象的概念，FTQ有很多个子队列组成，它们的项共同构成一个FTQ项，所以，向FTQ中写入FTQ项，实际上就是就是把BPU的预测信息写到对应的FTQ子队列中。</p>
<p>FTQ主要获取以下信息作为bpu_in_resp</p>
<ul>
<li>bpu_in_resp：BPU交给FTQ的resp详见BPU文档，resp中含有s1,s2,s3三个阶段的指令预测信息，bpu_in_resp将获取其中某一阶段预测信息selectedResp作为其值。未发生重定向时，使用s1作为预测结果，s2或者s3发生重定向信息时，优先s3的预测信息作为selectedResp。某阶段发生重定向的标志与上文讲述的一样一样。
从selectedResp（bpu_in_resp）中，我们还可以获取以下目标信息帮助我们写入子队列：ftq_idx，帮助我们索引写入子队列的地址</li>
</ul>
<h4 id="21-写入ftq子队列">2.1 写入FTQ子队列：</h4>
<h5 id="211-写入ftq_pc_mem">2.1.1 写入ftq_pc_mem</h5>
<ul>
<li>ftq_pc_mem: 来自BPU的selectedResp预测信息被写入ftq_pc_mem, 该存储结构有ftqsize个表项，对应队列中的所有ftq表项，每个存储元素可以推出对应的ftq表项中每条指令的pc地址
接收信号列表：
<ul>
<li>wen：接收bpu_in_fire作为写使能信号</li>
<li>waddr：接收selectedResp的ftq_idx</li>
<li>wdata：selectedResp的相应信号</li>
</ul>
</li>
</ul>
<h5 id="212-写入ftq_redirect_mem">2.1.2 写入ftq_redirect_mem</h5>
<ul>
<li>ftq_redirect_mem: 在BPU的s3（也就是最终阶段）接收信息，因为重定向信息只有在s3阶段才能得到。里面存储了RAS重定向相关的信息帮助BPU进行重定向。
接收信号列表：
<ul>
<li>wen：从BPU（fromBpu）回应（resp）的lastStage有效信号</li>
<li>waddr：从BPU回应的lastStage的ftq_idx.value</li>
<li>wdata：从BPU回应的last_stage_spec_info</li>
</ul>
</li>
</ul>
<h5 id="213-写入ftq_meta_1r_sram">2.1.3 写入ftq_meta_1r_sram</h5>
<ul>
<li>ftq_meta_1r_sram：在 BPU的s3阶段接收信息，同样是因为对于一个指令预测块，只有在其s3阶段才能获取完整的mata信息，同样被接收的还有最后阶段ftqentry信息
接收信号列表：
<ul>
<li>wen：从BPU（fromBpu）回应（resp）的lastStage有效信号</li>
<li>waddr：从BPU回应的lastStage的ftq_idx的value</li>
<li>wdata：
<ul>
<li>meta：从BPU回应的last_stage_meta</li>
<li>ftb_entry：从BPU回应的last_stage_ftb_entry</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="214-写入ftb_entry_mem">2.1.4 写入ftb_entry_mem</h5>
<ul>
<li>ftb_entry_mem：虽然ftq_meta_1r_sram中存储有最后阶段ftbentry，但此处出于更高效率读取专门把它存在ftb_entry_mem中。
接收信号列表：
<ul>
<li>wen：从BPU（fromBpu）回应（resp）的lastStage有效信号</li>
<li>waddr：从BPU回应的lastStage的ftq_idx的value字段</li>
<li>wdata：从BPU回应的last_stage_ftb_entry
从中可以看到，FTQ虽然名字上听起来是一个队列，<strong>实际上内部却是由数个队列组成</strong>，他们共同构成了FTQ这个大队列</li>
</ul>
</li>
</ul>
<h4 id="22-写入状态队列">2.2 写入状态队列</h4>
<p>上述存储结构是FTQ中比较核心的存储结构，实际上，还有一些子队列用来存储一些状态信息，也同样都是存储ftqsize个（64）元素，需要被写入，写入时机是在发生bpu_in_fire的下一个周期，或者再下一个周期 。主要有以下：</p>
<h5 id="221-写入update_target">2.2.1 写入update_target</h5>
<p>update_target：记录每个FTQ项的跳转目标，跳转目标有两种，一种是当该FTQ项对应的分支预测结果中指明的该分支预测块中执行跳转的分支指令将要跳转到的地址，另一种则是分支预测块中不发生跳转，跳转目标为分支预测块中指令顺序执行的下一条指令地址。</p>
<ul>
<li>此外，与之配套的还有newest_entry_target，newest_entry_ptr用来指示bpu_in_resp推出的跳转目标地址，表示下一次预测时开始的目标地址，和它对应的bpu_in_resp指令预测块在FTQ中的位置。
<ul>
<li>同时，有辅助信号newest_entry_target_modified和newest_entry_ptr_modified用来标识该这两个字段是否被修改。</li>
</ul>
</li>
<li>写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
<li>写入数据：bpu_in_resp.getTarget</li>
</ul>
<h5 id="222-写入cfiindex_vec">2.2.2 写入cfiIndex_vec</h5>
<p>cfiIndex_vec：记录每个FTQ项的发生跳转的指令cfi（control flow instruction）指令在其分支预测块中的位置</p>
<ul>
<li>写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
<li>写入数据：bpu_in_resp推断出的跳转目标</li>
</ul>
<h5 id="223-写入mispredict_vec">2.2.3 写入mispredict_vec</h5>
<p>mispredict_vec：记录每个FTQ项的所有指令的预测结果是否有误，初始化为false</p>
<ul>
<li>写入时机：相对于bpu_in_fire有效时延迟两个周期写入。</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
<li>写入数据：将该指令块的所有预测结果对应的值设置为false</li>
</ul>
<h5 id="224-写入pred_stage">2.2.4 写入pred_stage</h5>
<p>pred_stage：记录每个FTQ项的分支预测结果是来自于哪个阶段</p>
<ul>
<li>写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
</ul>
<h5 id="写入pred_s1_cycle不需要测试">写入pred_s1_cycle（不需要测试）</h5>
<p>pred_s1_cycle：记录每个FTQ项的分支预测结果对应的s1阶段的分支预测结果生成的时间（cycle数）</p>
<ul>
<li>写入时机：相对于bpu_in_fire有效时延迟两个周期写入。</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
</ul>
<h5 id="225-写入commitstatequeuereg">2.2.5 写入commitStateQueueReg</h5>
<p>commitStateQueueReg：记录每个FTQ项中对应的分支预测块中每条指令（一般是16条rvc指令，对应一个预测宽度）的提交状态，提交状态有c_empty ，c_toCommit ，c_committed ，c_flushed，依次用从小到大的枚举量表示，初始化为c_empty状态</p>
<ul>
<li>写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</li>
<li>写入数据：写入c_empty</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
</ul>
<h5 id="226-写入entry_fetch_status">2.2.6 写入entry_fetch_status</h5>
<p>entry_fetch_status：记录每个FTQ项的分支预测结果是否被送到ifu中，该状态由两个枚举量f_to_send ， f_sent来表示, 初始化为f_sent状态。</p>
<ul>
<li>写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</li>
<li>写入数据：写入f_to_send</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
</ul>
<h5 id="227-写入entry_hit_status">2.2.7 写入entry_hit_status</h5>
<p>entry_hit_status：记录每个FTQ项拿到的分支预测结果是否是ftb entry hit的，即生成该分支预测结果的时候是否是从ftb中，读取到了对应的记录表项。初始化为not_hit状态。</p>
<ul>
<li>写入时机：当来自BPU的全局分支预测信息中s2阶段的分支预测结果有效时，写入s2阶段分支预测结果中指名的hit状态</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
<li>写入数据：f_to_send</li>
</ul>
<p>注：之所以延迟时钟周期写入，是为了缩短关键路径，以及帮助减少扇出</p>
<h3 id="3-转发分支预测重定向"><strong>3 转发分支预测重定向</strong>：</h3>
<h4 id="31-转发给ifu">3.1 转发给IFU</h4>
<ul>
<li>s2以及s3阶段的预测重定向信息通过FTQ与Ifu的接口toIfu的flushFromBpu发送给IFU，当完整分支预测结果中的s2阶段分支预测结果发生预测结果重定向时，flushFromBpu.s2.valid拉高，flushFromBpu.s2.bits接收s2阶段分支预测结果中指明的该分支预测结果在FTQ中的位置ftq_idx。</li>
</ul>
<h4 id="32-转发给预取">3.2 <strong>转发给预取</strong></h4>
<ul>
<li>该重定向信号同样会通过toPrefetch.flushFromBpu接口以相同的方式传递给Prefetch
s3阶段向IFU以及Prefetch的重定向传递与s2阶段的重定向信号传递一样。该阶段的重定向信号传递会覆盖可能的s2阶段重定向信号传递结果</li>
</ul>
<h3 id="4-修正ftq指针">4 修正FTQ指针</h3>
<p>此外，分支预测结果重定向也会影响ifuPtr与pfPtr两个指针信号的写入信号。</p>
<h4 id="41-正常修改">4.1 正常修改</h4>
<ul>
<li>正常情况下，allowToIfu（条件和allowToBpu一样），同时BPU向Ifu发送FTQ项的io接口toIfu.req发生fire的时候，ifuPtr寄存器中写入ifuPtr+1。同样发生修改的还有pfPtr，当allowToIfu，同时BPU向Prefetch发送FTQ项的io接口totoPrefetch.req发生fire的时候。</li>
</ul>
<h4 id="42-发生重定向时修改">4.2 发生重定向时修改</h4>
<ul>
<li>而如果是发生重定向的时候，比如s2阶段预测结果发生重定向，此时，若ifuPtr不在s2阶段预测结果中指明的ftq_idx之前，ifuPtr写入该ftq_idx，pfPtr_write同样如此</li>
</ul>
<p><strong>bpuptr</strong>：
由FTQ交给BPU用于指示新的指令预测块应该放到FTQ队列中的位置，上述存储结构，ftq_pc_mem，ftq_redirect_mem，ftq_meta_1r_sram，ftb_entry_mem基本上也是通过与该指针相关的信号得知信息应该存储的addr（bpuptr交给BPU，BPU基于此获知每个阶段预测结果的ftq_idx）。</p>
<p>bpuptr寄存器的输出值直接连到FTQ发往BPU的接口toBpu的enq_ptr字段中，当然，再次之前，bpuptr的值会根据实际情况修改。</p>
<p>在enq from bpu的过程中，正常情况下，发生enq的时候，也就是新的预测块进队时，bpuptr+1，BPU将要向FTQ中写入的位置前进一位</p>
<p>但是，如果发生重定向的时候，比如，如果s2阶段预测结果发生重定向，bpuptr被更新为s2阶段分支预测结果的ftq_idx+1，表示BPU将要向FTQ中写入的位置为s2阶段预测结果在FTQ中位置的后一位，因为此时新的全局预测结果会基于s2的预测结果展开下一轮预测（即以s2分支预测块的下一块展开预测，自然会被写入），该结果会覆盖enq_fire发生时的结果，此外s3阶段的分支预测重定向时，会覆盖可能的s2阶段重定向修改的bpuptr</p>
<p>其他的ftq指针也是类似的，用于指示写入FTQ的地址</p>
<h2 id="接口说明">接口说明</h2>
<p>FTQ接收BPU分支预测结果工程中涉及到的IO接口如下，在FTQ顶层IO一文中有详细说明</p>
<table>
  <thead>
      <tr>
          <th>接口</th>
          <th>作用</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>fromBackend</td>
          <td>根据是否有重定向确认是否允许BPU预测结果入队</td>
      </tr>
      <tr>
          <td>fromBPU</td>
          <td>接收BPU预测结果</td>
      </tr>
      <tr>
          <td>toIfu</td>
          <td>发送更新的IFU指针，转发BPU预测结果重定向</td>
      </tr>
      <tr>
          <td>toPrefetch</td>
          <td>发送更新的Prefetch指针，转发BPU预测结果重定向</td>
      </tr>
      <tr>
          <td>toBpu</td>
          <td>发送更新的BPU指针</td>
      </tr>
  </tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1.1</td>
          <td>BPU_IN_RECEIVE</td>
          <td>FTQ_READY</td>
          <td>当FTQ队列中元素小于FtqSize或者可以提交指令块的时候，队列准备好接收新的预测块</td>
      </tr>
      <tr>
          <td>1.1.2</td>
          <td>BPU_IN_RECEIVE</td>
          <td>BPU_VALID</td>
          <td>BPU准备好要发送的信号</td>
      </tr>
      <tr>
          <td>1.2.1</td>
          <td>BPU_IN_ALLOW</td>
          <td>BACKEND</td>
          <td>接收后端写回信息的接口fromBackend的重定向接口redirect有效，则该周期不允许入队，如果没有发生真实提前重定向，则下一个周期也不允许入队</td>
      </tr>
      <tr>
          <td>1.2.2</td>
          <td>BPU_IN_ALLOW</td>
          <td>IFU</td>
          <td>IFU重定向信息生成的两个周期，均不许入队</td>
      </tr>
      <tr>
          <td>1.3.1</td>
          <td>BPU_IN_BY_REDIRECT</td>
          <td>REDIRECT</td>
          <td>当BPU发生预测结果重定向时，只要<strong>允许BPU入队allowBpuIn</strong>，也可以看作预测结果入队</td>
      </tr>
      <tr>
          <td>2.1.1</td>
          <td>WRITE_FTQ_SUBQUEUE</td>
          <td>FTQ_PC</td>
          <td>根据BPU预测结果写入ftq_pc_mem</td>
      </tr>
      <tr>
          <td>2.1.2</td>
          <td>WRITE_FTQ_SUBQUEUE</td>
          <td>FTQ_REDIRECT</td>
          <td>根据BPU预测结果写入ftq_redirect_mem</td>
      </tr>
      <tr>
          <td>2.1.3</td>
          <td>WRITE_FTQ_SUBQUEUE</td>
          <td>FTQ_MATA</td>
          <td>根据BPU预测结果写入ftq_meta_1r_sram</td>
      </tr>
      <tr>
          <td>2.1.4</td>
          <td>WRITE_FTQ_SUBQUEUE</td>
          <td>FTQ_ENTRY</td>
          <td>根据BPU预测结果写入ftb_entry_mem</td>
      </tr>
      <tr>
          <td>2.2.1</td>
          <td>WRITE_FTQ_STATEQUEUE</td>
          <td>UPDATED_TARGET</td>
          <td>根据BPU预测结果写入update_target</td>
      </tr>
      <tr>
          <td>2.2.2</td>
          <td>WRITE_FTQ_STATEQUEUE</td>
          <td>CFIINDEX</td>
          <td>根据BPU预测结果写入cfiIndex_vec</td>
      </tr>
      <tr>
          <td>2.2.3</td>
          <td>WRITE_FTQ_STATEQUEUE</td>
          <td>MISPREDICT</td>
          <td>根据BPU预测结果写入mispredict_vec</td>
      </tr>
      <tr>
          <td>2.2.4</td>
          <td>WRITE_FTQ_STATEQUEUE</td>
          <td>PRED_STAGE</td>
          <td>根据BPU预测结果写入pred_stage</td>
      </tr>
      <tr>
          <td>2.2.5</td>
          <td>WRITE_FTQ_STATEQUEUE</td>
          <td>COMMITSTATE</td>
          <td>根据BPU预测结果写入commitStateQueueReg</td>
      </tr>
      <tr>
          <td>2.2.6</td>
          <td>WRITE_FTQ_STATEQUEUE</td>
          <td>ENTRY_FETCH_STATU</td>
          <td>根据BPU预测结果写入entry_fetch_status</td>
      </tr>
      <tr>
          <td>2.2.7</td>
          <td>WRITE_FTQ_STATEQUEUE</td>
          <td>ENTRY_HIT_STATU</td>
          <td>根据BPU预测结果写入entry_hit_status</td>
      </tr>
      <tr>
          <td>3.1</td>
          <td>TRANSFER_BPU_REDIRECT</td>
          <td>IFU</td>
          <td>转发分支预测重定向给IFU</td>
      </tr>
      <tr>
          <td>3.2</td>
          <td>TRANSFER_BPU_REDIRECT</td>
          <td>PREFETCH</td>
          <td>转发分支预测重定向给PREFETCH</td>
      </tr>
      <tr>
          <td>4.1</td>
          <td>UPDATE_FTQ_PTR</td>
          <td>NORMAL</td>
          <td>正常情况下修改FTQ指针</td>
      </tr>
      <tr>
          <td>4.2</td>
          <td>UPDATE_FTQ_PTR</td>
          <td>REDIRECT</td>
          <td>发生重定向时修改FTQ指针</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bbc889120c17b68caa4f605372b47a0e">12.2.1.4 - FTQ向IFU发送取指目标</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>IFU需要取FTQ中的项进行取指令操作，同时也会简单地对指令进行解析，并写回错误的指令
FTQ发送给IFU的信号同时也需发送给ICache一份，ICache是指令缓存，帮助快速读取指令。</p>
<h2 id="术语说明">术语说明</h2>
<ul>
<li>ifuPtr：该寄存器信号指示了当前FTQ中需要读取的项的指针。直接发送给io.toIfu.req接口的ftqIdx。</li>
<li>entry_is_to_send：entry_fetch_status存储每个FTQ项的发送状态，初始化并默认为当前ifuptr指向的项对应的发送状态，后续可能因为旁路逻辑等改变</li>
<li>entry_ftq_offset: 从cfiIndex_vec中初始化并默认为当前ifuptr指向项的跳转指令在预测块中的偏移，后续可能因为旁路逻辑等改变</li>
<li>entry_next：本次取指结束后下一次取值的开始地址</li>
<li>pc_mem_ifu_ptr_rdata：获取ifuptr指向FTQ项的取指信息（从ftq_pc_mem的读取接口ifuPtr_rdata中获取）</li>
<li>pc_mem_ifu_plus1_rdata：获取ifuptr+1指向FTQ项的pc相关信息（从ftq_pc_mem的读取接口ifuPtrPlus1_rdata中）</li>
<li>copied_ifu_plus1_to_send：多个相同的复制信号，entry_fetch_status中指向ifuPtrPlus1的项是f_to_send状态或者上一周期bpu_in_fire,同时旁路bpu指针bpu_in_bypass_ptr等于ifuptr+1时，信号copied_ifu_plus1_to_send在一周期后拉高</li>
<li>copied_ifu_ptr_to_send：同理，只是把ifuptr+1改成了ifuptr</li>
</ul>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-获取取指目标信息">1. 获取取指目标信息</h3>
<p>获取取指目标有两个来源，一个是BPU写入信息时，直接将取指目标旁路出来，一种则是从存储取指目标的队列ftq_pc_mem中读取。使用前一种方式的前提，是刚好ifuPtr指向的读取项刚好就是旁路指针信号bpu_in_resp_ptr（BPU入队时写入项的ftqIdx）</p>
<ul>
<li>旁路逻辑：pc信号在被写入存储子队列时就被旁路一份，写入信号ftq_pc_mem.io.wdata在bpu_in_fire信号拉高时被旁路到旁路信号寄存器bpu_in_bypass_buf中。同时被旁路的还有指针信号bpu_in_resp_ptr，在同样的条件下被旁路到寄存器bpu_in_bypass_ptr中</li>
<li>读取ftq_pc_mem: 存储pc相关的取指目标，该存储队列有多个读接口，对所有ftqptr的写入信号（比如ifuPtr_write, ifuPtrPlus1_write等）被直接连接到存储队列的读取接口，这样，在ftqPtr寄存器正式被更新时，就可以同时直接从对应的读取接口中返回对应指针的读取结果，比如ftq_pc_mem.io.ifuPtr_rdata</li>
</ul>
<h4 id="11-准备发往icache的取指目标">1.1 准备发往ICache的取指目标</h4>
<p>有以下三种情况，分别对应<strong>测试点1.1.1，1.1.2，1.1.3</strong></p>
<ol>
<li>旁路生效，即旁路bpu指针等于ifuptr，且上一周期bpu输入有效结果（last_cycle_bpu_in表示上一周期bpu_in_fire）有效（也就相当于该旁路指针是有效的），此时，直接向toICache接口输入旁路pc信息bpu_in_bypass_buf</li>
<li>不满足情况1，但是上一周期发生ifu_fire（即FTQ发往IFU的接口发生fire），成功传输信号，此toICache中被写入pc存储子队列ftq_pc_mem中ifuptr+1对应项的结果，这是因为此时发生了ifu_fire，新的ifuptr还未来得及更新（即加1），所以直接从后一项中获取新的发送数据</li>
<li>前两种情况都不满足，此时toICache接口中被写入pc存储队列中ifuptr对应项的结果</li>
</ol>
<h4 id="12-提前一周期准备发往prefetch的取指目标">1.2 提前一周期准备发往Prefetch的取指目标</h4>
<p>有以下三种情况，分别对应<strong>测试点1.2.1，1.2.2，1.2.3</strong>
同样有三种情况：</p>
<ol>
<li>bpu有信号写入（bpu_in_fire），同时bpu_in_resp_ptr等于pfptr的写入信号pfptr_write, （此时pfptr_write还没有正式被写入pfptr中），读取bpu向pc存储队列的写入信号wdata，下一周期写入ToPrefetch
     <em>xxxptr_write：是相应FTQptr寄存器的write信号，连接到寄存器的写端口，寄存器在时钟上升沿成功写入write信号</em></li>
<li>不满足情况1，且由bpu到prefetch的接口发生fire，即bpu向预取单元成功发送信号，pc存储单元的pfPtrPlus1_rdata下一周期写入ToPrefetch接口，选择指针加1对应项的原因与toICache类似。</li>
<li>不满足以上两种情况：pc存储单元的pfPtr_rdata在下一周期被写入ToPrefetch接口</li>
</ol>
<h4 id="13-设置下一个发送的指令块的起始地址">1.3 设置下一个发送的指令块的起始地址</h4>
<p>有以下三种情况，分别对应<strong>测试点1.3.1，1.3.2，1.3.3</strong></p>
<p><strong>target（entry_next_addr）旁路逻辑：</strong>
有三种情况：</p>
<ol>
<li>上一周期bpu写入信号，且旁路指针等于ifuptr：
<ul>
<li>toIfu：写入旁路pc信息bpu_in_bypass_buf</li>
<li>entry_is_to_send ：拉高</li>
<li>entry_next_addr ：bpu预测结果中跳转地址last_cycle_bpu_target</li>
<li>entry_ftq_offset ：bpu预测结果中跳转指令在预测块中的偏移last_cycle_cfiIndex</li>
</ul>
</li>
<li>不满足情况1，bpu到ifu的接口发生fire，信号成功写入
<ul>
<li>toIfu：写入pc存储队列的读出信号ifuPtrPlus1_rdata，这同样是因为ifuptr还没来得及更改，所以直接使用ifuptr+1对应项的rdata</li>
<li>entry_is_to_send ：发送状态队列中ifuPtrPlus1对应项为f_to_send或者在上一周期bpu有写入时旁路bpu指针等于ifuptr加1，entry_is_to_send拉高。</li>
<li>entry_next_addr ：
<ul>
<li>如果上一周期bpu有写入且bpu旁路指针等于ifuptr+1，写入bpu旁路pc信号的startAddr字段，而这个项的pc信息还没有写入，正在pc旁路信号中，这是因为ifuptr+1对应下一个指令预测块，它的起始地址实际上就是ifuptr对应指令的预测块的跳转目标。</li>
<li>如果不满足该条件，
<ol>
<li>ifuptr等于newest_entry_ptr: 使用newest_entry_target作为entry_next_addr，newest_entry_ptr，newest_entry_target这几个内部信号，表明我们当前队列中最新的有效的FTQ项。如之前所说，BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，在相应的文档中，对其生成方式做具体的描述。</li>
<li>不满足条件1：使用pc存储队列的ifuPtrPlus2_rdata.startAddr</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>不满足情况1，2：</li>
</ol>
<ul>
<li>toIfu：写入pc存储队列的读出信号ifuPtr_rdata</li>
<li>entry_is_to_send ：发送状态队列中ifuPtr对应项为f_to_send或者在上一周期bpu有写入时旁路bpu指针等于ifuptr</li>
<li>entry_next_addr ：</li>
<li>如果上一周期bpu有写入且bpu旁路指针等于ifuptr+1，写入bpu旁路pc信号的startAddr字段。</li>
<li>如果不满足该条件，
         1. ifuptr等于newest_entry_ptr: 使用newest_entry_target作为entry_next_addr。
         2. 不满足上面的条件1：使用pc存储队列的ifuPtrPlus1_rdata.startAddr，为什么条件2和条件3，一个使用ifuPtrPlus2_rdata.startAddr作为entry_next_addr ，一个使用ifuPtrPlus1_rdata.startAddr作为，这也是出于时序的考虑：
因为要获得实际上的ifuptr+1对应项的start值作为结果，而因为第一处那里因为ifuptr还没来得及更新（加1）同步到当前实际的ifuptr，所以要加2来达到实际上的ifuptr+1对应的值，而第二处的ifuptr已经更新了，所以只用加1就行了。</li>
</ul>
<h3 id="2-发送取指信息">2. 发送取指信息</h3>
<h4 id="21-发送取指目标">2.1 发送取指目标</h4>
<h5 id="211-发送给ifu">2.1.1 发送给IFU</h5>
<p><strong>toIfu接口的req接口：</strong>
FTQ通过该接口向IFU发送取指信号：</p>
<ul>
<li>valid：要发送的FTQ项处于将发送状态entry_is_to_send且ifuptr不等于bpuptr</li>
<li>nextStartAddr：递交最终的entry_next_addr</li>
<li>ftqOffset：递交最终的entry_ftq_offset</li>
<li>toIfu：递交pc信息</li>
</ul>
<h5 id="212-发送给icache">2.1.2 发送给ICache</h5>
<p><strong>toICache的req接口：</strong>
FTQ通过该接口向ICache发送取指信号：</p>
<ul>
<li>valid：FTQ项处于将发送状态entry_is_to_send且ifuptr不等于bpuptr</li>
<li>readValid：ICache的有多个read接口，readVlid是一个向量，表示这几个read接口是否有效，readVlid中的每个元素的写入值与valid一样</li>
<li>pcMemRead：同样是一个向量，对应readVlid向量的ICache的多个pc信号read接口，从toIfu接口中将pc信息结果写入向量中各接口，接口的ftqIdx字段被写入ifuPtr</li>
<li>backendException：后端出现异常，同时后端pc错误指针等于ifuPtr</li>
</ul>
<h4 id="213-发送给prefetch">2.1.3 发送给Prefetch</h4>
<p><strong>toPrefetch的req接口：</strong></p>
<ul>
<li>valid：传给预取模块的项的状体toPrefetchEntryToSend为1，（toPrefetchEntryToSend会玩一个周期存储nextCycleToPrefetchEntryToSend的值），且pfptr不等于bpuptr，</li>
<li>toPrefetch：递交pc</li>
<li>ftqIdx字段被设置为pfptr寄存器的值</li>
<li>backendException：在后端pc错误指针等于pfptr的时候，传入后端异常信号，否则传入无异常信号</li>
</ul>
<h4 id="22-错误命中">2.2 错误命中</h4>
<p><strong>错误命中falsehit：</strong>
当发往Ifu的pc接口toIfu中发生fallThruError（预测块的fall through地址小于预测的起始地址时），且hit状态队列entry_hit_status中ifuPtr对应项显示命中的话，进行如下判断：</p>
<p>当发往ifu的接口toIfu的req接口发生fire，且bpu的预测结果不发生满足以下条件的重定向: s2或者s3的重定向的预测块对应的FTQ项索引号ftq_idx等于ifuptr, 此时，hit状态队列中ifuptr对应项被设置为false_hit。</p>
<h4 id="23-bpu冲刷">2.3 BPU冲刷</h4>
<p><strong>bpu向ifu的req请求的flush：</strong>
发往ifu的flushfrombpu(来自bpu的冲刷)接口中，记录有s2，s3阶段的指针，如果其中一条指针不大于发往ifu的req接口的ftqIdx的时候，表示应该被冲刷掉req信号，即冲刷掉新的发送给FTQ的预测信息。</p>
<h4 id="24-更新发送状态">2.4 更新发送状态</h4>
<p><strong>成功发送：</strong>
发往ifu的req接口发生fire，且req不被来自bpu的flush给冲刷掉时：
entry_fetch_status状态队列中ifuptr对应项的发送状态置为f_sent。表示该ftq项被成功发送 了</p>
<h2 id="接口说明">接口说明</h2>
<table>
  <thead>
      <tr>
          <th>顶层IO</th>
          <th>子接口</th>
          <th>作用</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>toIFU</td>
          <td>req</td>
          <td>发送取指目标</td>
      </tr>
      <tr>
          <td>toIFU</td>
          <td>flushfrombpu</td>
          <td>冲刷掉发送给IFU的取指目标</td>
      </tr>
      <tr>
          <td>toICache</td>
          <td>req</td>
          <td>发送取指目标</td>
      </tr>
      <tr>
          <td>toPrefetch</td>
          <td>req</td>
          <td>发送取指目标</td>
      </tr>
  </tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1.1</td>
          <td>GET_PC_FOR_ICACHE</td>
          <td>COND1</td>
          <td>旁路生效，即旁路bpu指针等于ifuptr，且上一周期bpu输入有效结果有效，直接向toICache接口输入旁路pc信息bpu_in_bypass_buf</td>
      </tr>
      <tr>
          <td>1.1.2</td>
          <td>GET_PC_FOR_ICACHE</td>
          <td>COND2</td>
          <td>不满足情况1，但是上一周期发生ifu_fire，成功传输信号，此时toICache中被写入pc存储子队列ftq_pc_mem中ifuptr+1对应项的结果</td>
      </tr>
      <tr>
          <td>1.1.3</td>
          <td>GET_PC_FOR_ICACHE</td>
          <td>COND3</td>
          <td>前两种情况都不满足，此时toICache中被写入pc存储队列中ifuptr对应项的结果</td>
      </tr>
      <tr>
          <td>1.2.1</td>
          <td>GET_PC_FOR_PREFETCH</td>
          <td>COND1</td>
          <td>bpu有信号写入，同时bpu_in_resp_ptr等于pfptr的写入信号pfptr_write, 读取bpu向pc存储队列的写入信号wdata，下一周期写入ToPrefetch</td>
      </tr>
      <tr>
          <td>1.2.2</td>
          <td>GET_PC_FOR_PREFETCH</td>
          <td>COND2</td>
          <td>不满足情况1，且由bpu到prefetch的接口发生fire，即bpu向预取单元成功发送信号，pc存储单元的pfPtrPlus1_rdata下一周期写入ToPrefetch接口</td>
      </tr>
      <tr>
          <td>1.2.3</td>
          <td>GET_PC_FOR_PREFETCH</td>
          <td>COND3</td>
          <td>不满足以上两种情况：pc存储单元的pfPtr_rdata在下一周期被写入ToPrefetch接口</td>
      </tr>
      <tr>
          <td>1.3.1</td>
          <td>SET_NEXT_ADDR</td>
          <td>COND1</td>
          <td>上一周期bpu写入信号，且旁路指针等于ifuptr时设置下一个发送的指令块的起始地址</td>
      </tr>
      <tr>
          <td>1.3.2</td>
          <td>SET_NEXT_ADDR</td>
          <td>COND2</td>
          <td>不满足情况1，bpu到ifu的接口发生fire时设置下一个发送的指令块的起始地址</td>
      </tr>
      <tr>
          <td>1.3.3</td>
          <td>SET_NEXT_ADDR</td>
          <td>COND3</td>
          <td>不满足情况1，2时设置下一个发送的指令块的起始地址</td>
      </tr>
      <tr>
          <td>2.1.1</td>
          <td>SEND_PC</td>
          <td>IFU</td>
          <td>向IFU发送取指目标</td>
      </tr>
      <tr>
          <td>2.1.2</td>
          <td>SEND_PC</td>
          <td>ICACHE</td>
          <td>向ICache发送取指目标</td>
      </tr>
      <tr>
          <td>2.1.3</td>
          <td>SEND_PC</td>
          <td>PREFETCH</td>
          <td>向Prefetch发送取指目标</td>
      </tr>
      <tr>
          <td>2.2</td>
          <td>FALSE_HIT</td>
          <td>FALSE_HIT</td>
          <td>当发往Ifu的pc接口toIfu中发生fallThruError，且FTB项命中时判断是否是错误命中</td>
      </tr>
      <tr>
          <td>2.3</td>
          <td>FLUSH_FROM_BPU</td>
          <td>FLUSH_FROM_BPU</td>
          <td>发往ifu的flushfrombpu(来自bpu的冲刷)接口中的s2，s3阶段的指针其中一条指针不大于发往ifu的req接口的ftqIdx的时候，应该冲刷掉新的发送给FTQ的预测信息</td>
      </tr>
      <tr>
          <td>2.4</td>
          <td>UPDATE_SEND_STATU</td>
          <td>UPDATE_SEND_STATU</td>
          <td>发往ifu的req接口发生fire，且req不被来自bpu的flush给冲刷掉时：<br>entry_fetch_status状态队列中ifuptr对应项的发送状态置为f_sent</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-902c9098c896a3c8e9e6f1dff8bed38e">12.2.1.5 - IFU向FTQ写回预译码信息</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>IFU获取来自BPU的预测信息之后，会执行预译码，并将FTQ项写回FTQ中去。我们会比对FTQ中原BPU预测项和预译码的结果，判断是否有预测错误</p>
<h3 id="基本流程">基本流程</h3>
<p>预译码写回ftq_pd_mem：</p>
<ul>
<li>FTQ从pdWb接口中获取IFU的写回信息，FTQ首先将预译码写回信息写回到ftq_pd_mem,</li>
</ul>
<p>更新提交状态队列commitStateQueue：</p>
<ul>
<li>然后根据写回信息中指令的有效情况更新提交状态队列commitStateQueue。</li>
</ul>
<p>比对错误：</p>
<ul>
<li>同时，从ftb_entry_mem读出ifu_Wb_idx所指的FTB项，将该FTB项的预测结果与预译码写回结果进行对比，看两者对分支的预测结果是否有所不同。</li>
</ul>
<p>综合错误：</p>
<ul>
<li>之后就综合根据预译码信息可能得到的错误：有前面说的比对BPU的预测结果和预译码结果得到的错误，也有直接根据预译码得到的错误预测信息。根据错误预测结果更新命中状态队列。</li>
</ul>
<p>更新写回指针</p>
<ul>
<li>最后，如果IFU成功写回，ifu_Wb_idx更新加1。</li>
</ul>
<h2 id="术语说明">术语说明</h2>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>定义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>预译码</td>
          <td>IFU会对取指目标进预译码，之后写回FTQ</td>
      </tr>
      <tr>
          <td>ifuWbPtr</td>
          <td>IFU写回指针，知识IFU预译码要写入FTQ的位置</td>
      </tr>
  </tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-预译码写回ftq_pd_mem">1. 预译码写回ftq_pd_mem</h3>
<p>写回有效：预译码信息pdWb有效时，写有效
写回地址：pdWb的ftqIdx的value
写回值：解析整个pdWb的结果</p>
<h3 id="2-更新提交状态队列">2. 更新提交状态队列</h3>
<p>当预译码信息pdWb有效时，相当于写回有效，此时，根据预译码信息中每条指令的有效情况和该指令是否在有效范围内，判断指令的提交状态是否可以修改，若可以修改，则将提交状态队列，写回项中的指令状态修改</p>
<h4 id="详细信号表示">详细信号表示</h4>
<p>pdWb有效时，ifu_wb_valid拉高。
此时，对于预译码信息中每一条指令的预译码结果pd做判断：
如果预译码结果valid，且指令在有效范围内（根据insrtRange的bool数组指示），则提交状态队列commitStateQueue中，写回项中的指令状态修改为c_toCommit，表示可以提交，这是因为只有在FTQ项被预译码写回后，才能根据后端提交信息提交该FTQ项，之后会把预译码信息一并发往更新通道。</p>
<h3 id="3-比对预测结果与预译码结果">3. 比对预测结果与预译码结果</h3>
<p>从ftb存储队列ftb_entry_mem中的读取ifu写回指针ifuwbptr的对应项：</p>
<ul>
<li>pdWb有效的时候，读有效，读取地址为预译码信息中指示的ftqIdx。
当命中状态队列指示待比对项ftb命中，且回写有效时，读取出FTB存储队列中对应的项，与预译码信息进行比对，当BPU预测的FTB项指示指令是有效分支指令，而预译码信息中则指示不是有效分支指令时，发生分支预测错误，当BPU预测的FTB项指示指令是有效jmp指令，而预译码信息中则指示不是有效jmp指令时，发生跳转预测错误</li>
</ul>
<h4 id="详细信号表示-1">详细信号表示：</h4>
<p>ifu_wb_valid回写有效时，ftb_entry_mem回写指针对应读使能端口ren有效，读取地址为ifu_wb_idx预测译码信息中指示的ftqIdx的value值。
回写项命中且回写有效，hit_pd_valid信号有效，此时，读取ftb存储队列中的FTB项，读出brSlots与tailSlot，并进行比对：</p>
<h4 id="31-判断是否有分支预测错误br_false_hit">3.1 判断是否有分支预测错误br_false_hit</h4>
<h5 id="测试点311和312对应以下两种条件导致的br_false_hit">测试点3.1.1和3.1.2对应以下两种条件导致的br_false_hit</h5>
<ul>
<li>判断是否有分支预测错误br_false_hit：
<ol>
<li>brSlots的任意一项有效，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高表明是分支指令，</li>
<li>taiSlot有效且sharing字段拉高表明该slot为分支slot，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高表明是分支指令
满足任意条件可判断发生分支预测错误br_false_hit，该信号拉高</li>
</ol>
</li>
</ul>
<h4 id="32-判断是否发生jmp预测错误jal_false_hit">3.2 判断是否发生jmp预测错误jal_false_hit</h4>
<ul>
<li>判断是否发生jmp预测错误jal_false_hit：
<ul>
<li>预测结果中必须指明指令预测有效，且其中isJal拉高表面是jal指令或者指明是isjalr指令</li>
</ul>
</li>
</ul>
<h3 id="4-预译码错误">4. 预译码错误</h3>
<p>直接从预测结果中获取错误预测相关信息，如果回写项ftb命中且missoffset字段有效表明有错误预测的指令，hit_pd_mispred信号拉高，表示预译码结果中直接指明有预测错误的指令。</p>
<h3 id="5-综合错误">5. 综合错误</h3>
<p>综合比对预测结果与预译码结果得到的错误信息，与预译码错误直接获得的预测错误，任意一种发生时has_false_hit拉高表示有预测错误，此时，命中状态队列entry_hit_status中写回项的状态置为h_false_hit</p>
<h3 id="6-更新写回指针">6. 更新写回指针</h3>
<p>ifu_wb_valid拉高，表示写回有效，将ifuWbPtr更新为原值加1。</p>
<h2 id="接口说明">接口说明</h2>
<table>
  <thead>
      <tr>
          <th>顶层IO</th>
          <th>子接口</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>fromIfu</td>
          <td>pdWb</td>
      </tr>
  </tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>WB_PD</td>
          <td>WB_PD</td>
          <td>向ftq_pd_mem中写回预译码信息</td>
      </tr>
      <tr>
          <td>2</td>
          <td>UPDATE_COMMITSTATE</td>
          <td>UPDATE_COMMITSTATE</td>
          <td>当预译码信息pdWb有效时，根据预译码信息中每条指令的有效情况和该指令是否在有效范围内，判断指令的提交状态是否可以修改，若可以修改，则将提交状态队列，写回项中的指令状态修改</td>
      </tr>
      <tr>
          <td>3.1.1</td>
          <td>BR_FALSE_HIT</td>
          <td>COND1</td>
          <td>brSlots的任意一项有效，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高</td>
      </tr>
      <tr>
          <td>3.1.2</td>
          <td>BR_FALSE_HIT</td>
          <td>COND2</td>
          <td>taiSlot有效且sharing字段拉高表明该slot为分支slot，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高</td>
      </tr>
      <tr>
          <td>3.2</td>
          <td>JAL_FALSE_HIT</td>
          <td>JAL_FALSE_HIT</td>
          <td>指令预测有效，且其中isJal拉高或者指明是isjalr指令</td>
      </tr>
      <tr>
          <td>4</td>
          <td>PD_MISS</td>
          <td>PD_MISS</td>
          <td>如果回写项ftb命中且missoffset字段有效表明有错误预测的指令，hit_pd_mispred信号拉高</td>
      </tr>
      <tr>
          <td>5</td>
          <td>FALSE_HIT</td>
          <td>FALSE_HIT</td>
          <td>综合比对预测结果与预译码结果得到的错误信息，与预译码错误直接获得的预测错误，任意一种发生时has_false_hit拉高表示有预测错误，此时，命中状态队列entry_hit_status中写回项的状态置为h_false_hit</td>
      </tr>
      <tr>
          <td>6</td>
          <td>UPDATE_IFU_WB_PTR</td>
          <td>UPDATE_IFU_WB_PTR</td>
          <td>ifu_wb_valid拉高，将ifuWbPtr更新为原值加1</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9c89ab197585abfab0c8084355d958c0">12.2.1.6 - FTQ接收后端重定向</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>FTQ重定向信息有两个来源，分别是IFU 和 后端。两者的 重定向接口大致相似，但重定向的过程有一定区别。</p>
<p>对于重定向，后端有提前重定向机制，为了实现提前一拍读出在ftq中存储的重定向数据，减少redirect损失，后端会向ftq提前一拍（相对正式的后端redirect信号）传送ftqIdxAhead信号和ftqIdxSelOH信号。ftqIdxSelOH信号出现的原因，是早期版本要读多个ftqIdxAhead信号，以独热码的形式选其中一路作为最终确认的提前索引值，但现在只需要从一个端口获取ftqIdx信号了，ftqIdxAhead只能确认这一个端口了。</p>
<h2 id="术语说明">术语说明</h2>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>定义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>sc_disagree</td>
          <td>统计SC预测错误用的性能计数器中需要用到的值，SC预测器是BPU子预测器TAGE-SC预测器的一个部分</td>
      </tr>
  </tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-接收后端重定向信号">1. 接收后端重定向信号</h3>
<h3 id="时序">时序</h3>
<h4 id="11-提前重定向">1.1 提前重定向</h4>
<p>第一个周期：</p>
<ul>
<li>后端重定向写回时，首先会从后端到FTQ的IO接口（CtrltoFtqIO）中，看ftqIdx是不是有效信号，且此时后端正式重定向信号redirect无效(因为提前重定向会比正式重定向提前一拍，所以此时正式重定向无效)，这时，提前重定向信号aheadValid有效, 将使用提前获取的重定向ftqIdx，</li>
</ul>
<h4 id="12-真实提前重定向">1.2 真实提前重定向</h4>
<p>第二个周期：</p>
<ul>
<li>如果此时后端正式重定向信号有效了，且ftqIdxSelOH拉高，说明在正式重定向阶段成功对ftqIdxAhead信号进行选中，同时上一周期重定向信号aheadValid是有效的，则真实提前重定向信号realAhdValid拉高，在此时读取</li>
</ul>
<h4 id="13-存储后端重定向信号">1.3 存储后端重定向信号</h4>
<p>第三个周期：</p>
<ul>
<li>该周期会把来自后端的重定向信息的存储一份在寄存器backendRedirectReg中，具体的来说，当上一个周期后端重定向有效时，将后端重定向bits字段（存储实际内容）被写入寄存器的bits字段。</li>
<li>而实际决定信号是否有效的valid字段（决定该信号是否有效）则在上一周期真实提前重定向信号有效（表示确实使用了提前重定向的ftqIdx进行重定向）的情况下，被写入false，因为提前重定向发生时，我们直接使用当前的后端重定向信号交给FTQ就可以了。而不需要多保存一个周期。</li>
<li>真实提前重定向信号无效时，则由上一周期后端正式重定向的有效值决定，只有信号有效时，我们才需要把它存下来，之后交给FTQ。</li>
</ul>
<h3 id="2-选择重定向信号">2. 选择重定向信号</h3>
<p><strong>信号抉择</strong>：
是提前获取后端重定向信息还是延迟一个周期从寄存器内读取？
真实重定向有效时，直接将后端重定向信息传递给FTQ，否则，取重定向寄存器内的信号作为重定向信息传递给FTQ，相当于晚一个周期发送重定向信息。最后被选择的重定向信息作为<strong>后端重定向结果fromBackendRedirect</strong>发送给FTQ</p>
<p>接下来讲讲后端重定向在这三个周期到底通过ftqIdx到底读了哪些FTQ子队列中的信息，以及怎么使用它们。</p>
<h3 id="3-整合子队列信号">3. 整合子队列信号</h3>
<h4 id="31-读取子队列">3.1 读取子队列</h4>
<p>接下来讲讲后端重定向在这三个周期到底通过ftqIdx到底读了哪些FTQ子队列中的信息，以及怎么使用它们。</p>
<p><strong>后端重定向读取的子队列：</strong></p>
<ul>
<li>ftq_redirect_mem：FTQ会根据后端重定向提供的ftqIdx读出ftq_Redirect_SRAMEntry，借助它提供的信息重定向到之前的状态。</li>
<li>ftq_entry_mem：读出重定向指令块对应的FTB项</li>
<li>ftq_pd_mem：读出重定向指令块的预译码信息</li>
</ul>
<h4 id="311-发生提前重定向时读取子队列需要两个周期">3.1.1 发生提前重定向时，读取子队列需要两个周期</h4>
<h4 id="312-未发生提前重定向时读取子队列需要三个周期">3.1.2 未发生提前重定向时，读取子队列需要三个周期</h4>
<p><strong>读子队列时序：</strong>
第一个周期：</p>
<ul>
<li>提前重定向信号有效时，将子队列的读端口，读有效信号拉高，输入ftqIdxAhead的value字段作为读地址，发起读取请求。</li>
</ul>
<p>第二个周期：</p>
<ul>
<li>case1. 如果第一周期的提前重定向无效，而现在正式重定向有效，则在此时才拉高读有效信号，使用正式重定向接口的ftqIdx作为读取地址，发起读取请求。</li>
<li>case2. 真实提前重定向有效了，此时因为前一个周期已经发起读取请求，此时可以直接从子队列的读端口读出了</li>
</ul>
<p>第三个周期</p>
<ul>
<li>真实提前重定向无效，但至少前一个周期正式重定向发起的读取请求能保证在当前周期从子队列中读出。</li>
</ul>
<h4 id="32-将子队列信息整合到后端重定向信号">3.2 将子队列信息整合到后端重定向信号</h4>
<p><strong>处理读取信息</strong>
<em>FTQ会将从子队列中读出的信息整合到fromBackendRedirect中。</em>
具体来说：</p>
<ul>
<li>重定向redirect接口的CfiUpdateInfo接口直接接收ftq_Redirect_SRAMEntry中的同名信号。</li>
<li>利用fromBackendRedirect中指示的ftqOffset读取指令块预译码信息中实际跳转指令的预译码信息，该ftqOffset为后端执行过后确定的控制流指令在指令块内的偏移。
<ul>
<li>得到的预译码信息被直接连接到CfiUpdateInfo接口的pd接口中</li>
</ul>
</li>
<li>对于读出的指令块对应的FTB项，我们可以从中得知实际执行时得到的跳转指令，是否在FTB项被预测为跳转指令，或者是被预测为jmp指令，如果是，则cfiUpdateInfo的br_hit接口或者jr_hit接口被拉高，表示对应的分支预测结果正确了。
<ul>
<li>具体来说：通过发送ftqOffset，ftb项以brIsSaved的方式判断是否br_hit，判断是否jr_hit的方式也是类似的（r_ftb_entry.isJalr &amp;&amp; r_ftb_entry.tailSlot.offset === r_ftqOffset）。</li>
<li>在CfiUpdateInfo接口设置为br_hit的时候，还会根据这条发生跳转的分支指令是哪个槽从ftq_Redirect_SRAMEntry重定向接口的sc_disagree统计SC预测错误用的性能计数器中，获取对应值，最后整合到后端重定向接口中（如果没有br_hit，对应计数器的两个值都为0）。</li>
</ul>
</li>
</ul>
<h2 id="接口说明">接口说明</h2>
<table>
  <thead>
      <tr>
          <th>顶层IO</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>fromBackend</td>
          <td>接收后端重定向信息</td>
      </tr>
  </tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>RECERIVE_BACKEND_REDIRECT</td>
          <td>REDIRECT_AHEAD</td>
          <td>后端重定向写回时，首先会从后端到FTQ的IO接口（CtrltoFtqIO）中，看ftqIdx是不是有效信号，且此时后端正式重定向信号redirect无效，这时，提前重定向信号aheadValid有效</td>
      </tr>
      <tr>
          <td>1.2</td>
          <td>RECERIVE_BACKEND_REDIRECT</td>
          <td>REAL_REDIRECT_AHEAD</td>
          <td>如果此时后端正式重定向信号有效了，且ftqIdxSelOH拉高，同时上一周期重定向信号aheadValid是有效的，则真实提前重定向信号realAhdValid拉高</td>
      </tr>
      <tr>
          <td>1.3</td>
          <td>RECERIVE_BACKEND_REDIRECT</td>
          <td>STORE_REDIRECT</td>
          <td>后端真实重定向无效时写入寄存器</td>
      </tr>
      <tr>
          <td>2</td>
          <td>CHOOSE_AHEAD</td>
          <td>CHOOSE_AHEAD</td>
          <td>真实重定向有效时，直接将后端重定向信息传递给FTQ，否则，取重定向寄存器内的信号作为重定向信息传递给FTQ</td>
      </tr>
      <tr>
          <td>3.1.1</td>
          <td>READ_FTQ_SUBQUEUE</td>
          <td>READ_AHEAD</td>
          <td>发生提前重定向时，读取子队列需要两个周期</td>
      </tr>
      <tr>
          <td>3.1.2</td>
          <td>READ_FTQ_SUBQUEUE</td>
          <td>READ_NO_AHEAD</td>
          <td>未发生提前重定向时，读取子队列需要三个周期</td>
      </tr>
      <tr>
          <td>3.2</td>
          <td>ADD_SUBQUEUE_INFO</td>
          <td>ADD_SUBQUEUE_INFO</td>
          <td>将子队列信息整合到后端重定向信号</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a21c8d5c61630fe55cf5e4227e97c8f6">12.2.1.7 - FTQ接收IFU重定向</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>除了后端，IFU也会发送重定向相关消息，和后端不同，IFU的重定向信息来自于预译码写回信息。相同的是，它们都是通过BranchPredictionRedirect的接口传递重定向信息。</p>
<h2 id="术语说明">术语说明</h2>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>定义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>RedirectLevel</td>
          <td>重定向等级，重定向请求是否包括本位置，低表示在本位置后重定向，高表示在本位置重定向。它在之后决定了由重定向导致的冲刷信号是否会影响到发生重定向的指令</td>
      </tr>
  </tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-ifu重定向信号生成">1. IFU重定向信号生成</h3>
<h4 id="流程">流程</h4>
<p>IFU重定向是通过这个BranchPredictionRedirect接口传递的，下面来讲述IFU重定向怎么生成IFU的BranchPredictionRedirect内相应信号的，这个过程需要两个周期
信号列表：
<strong>第一个周期</strong></p>
<h4 id="11-ifu-重定向触发条件">1.1 IFU 重定向触发条件</h4>
<ul>
<li>valid：当预译码写回pdWb有效，且pdWb的missOffset字段有效表明存在预测错误的指令，同时后端冲刷信号backendFlush无效时，valid信号有效。</li>
</ul>
<h4 id="12-ifu生成重定向信号">1.2 IFU生成重定向信号</h4>
<ul>
<li>ftqIdx：接收pdWb指定的ftqIdx</li>
<li>ftqOffset：接收pdWb的missOffset的bits字段</li>
<li>level：RedirectLevel.flushAfter，将重定向等级设置为flushAfter</li>
<li>BTBMissBubble：true</li>
<li>debugIsMemVio：false</li>
<li>debugIsCtrl：false</li>
<li>cfiUpdate：
信号列表:
<ul>
<li>pc：pdWb中记录的指令块中所有指令pc中，missOffset对应的pc</li>
<li>pd：pdWb中记录的指令块中所有指令的pd中，missOffset对应的pd</li>
<li>predTaken：从cfiIndex_vec子队列中读取pdWb中ftqIdx索引的项是否valid，有效说明指令块内被预测为有控制流指令。</li>
<li>target：pdWb中的target</li>
<li>taken：pdWb中cfiOffset的valid字段，有效时表明预译码认为指令块中存在指令控制流指令</li>
<li>isMisPred：pdWb中missOffset的valid字段，有效时表明预译码认为指令块中存在预测错误的指令</li>
</ul>
</li>
</ul>
<p><strong>第二个周期：</strong>
该周期进行的信号生成是在第一周期valid字段有效的情况下才继续的</p>
<ul>
<li>cifUpdate：
信号列表：
<ul>
<li>重定向RAS相关信号：通过ftqIdx索引从 ftq_redirect_mem读出ftq_Redirect_SRAMEntry，把其中的所有信号直接传递给cfiUpdate的同名信号中。</li>
<li>target：已在第一周期写入cfiUpdate的pd有效，且isRet字段拉高，指明发生预测错误的指令本是一条Ret指令，此时，将target设置为cfiUpdate的topAddr，帮助回到发生错误之前的状态。</li>
</ul>
</li>
</ul>
<h3 id="2-重定向结果生效">2. 重定向结果生效</h3>
<p>两个周期生成完整的重定向信息后，IFU重定向信息才有效，有可能被FTQ采取，完整的<strong>IFU重定向结果记为ifuRedirectToBpu</strong></p>
<h3 id="3-ifu-冲刷信号-ifuflush">3. IFU 冲刷信号 (<code>ifuFlush</code>)</h3>
<p><strong>指令流控制信号</strong>：
ifuFlush：来自IFU的冲刷信号，主要是由IFU重定向造成的，生成IFU重定向信息的两个周期内，该信号都拉高</p>
<ul>
<li>标志：IFU重定向信息产生接口BranchPredictionRedirect中valid有效，表示开始生成重定向信息，该周期以及下一个周期，ifuFlush拉高</li>
</ul>
<h2 id="接口说明">接口说明</h2>
<table>
  <thead>
      <tr>
          <th>顶层IO</th>
          <th>作用</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>fromIFU</td>
          <td>接收来自IFU的预译码信息</td>
      </tr>
  </tbody>
</table>
<h2 id="接口时序">接口时序</h2>
<h2 id="测试点总表">测试点总表</h2>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>IFU_REDIRECT</td>
          <td>IFU_REDIRECT_GRN_VALID</td>
          <td>当预译码写回pdWb有效，且pdWb的missOffset字段有效表明存在预测错误的指令，同时后端冲刷信号backendFlush无效时，valid信号有效</td>
      </tr>
      <tr>
          <td>1.2</td>
          <td>IFU_REDIRECT</td>
          <td>IFU_REDIRECT_GEN</td>
          <td>允许生成IFU重定向时，在两周期内生成具体信号</td>
      </tr>
      <tr>
          <td>2</td>
          <td>IFU_REDIRECT_TO_BPU</td>
          <td>IFU_REDIRECT_TO_BPU</td>
          <td>IFU重定向生成后，IFU重定向结果生效</td>
      </tr>
      <tr>
          <td>3</td>
          <td>IFU_FLUSH</td>
          <td>IFU_FLUSH</td>
          <td>生成IFU重定向信息的两个周期内，ifuFlush信号都拉高</td>
      </tr>
  </tbody>
</table>
</mrs-testpoints>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d5eaae05e615ad48e9d4009fee393d14">12.2.1.8 - FTQ向后端发送取指目标</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>pc取值目标会发给后端pc mem让他自己进行存储，之后从自己的pc mem取指，此外，最新的FTQ项和对应的跳转目标也会发给后端。</p>
<p>怎样算是一个最新的FTQ项，BPU最新发送的预测块可以是最新的FTQ项，其次，重定向发生时，需要回滚到发生错误预测之前的状态，从指定的FTQ项开始重新开始预测，预译码等等，这也可以是被更新的最新的FTQ项。</p>
<h2 id="术语说明">术语说明</h2>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>定义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>暂无</td>
          <td>暂无</td>
      </tr>
  </tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h4 id="流程">流程</h4>
<h4 id="1发送取值目标到pc-mem">1.发送取值目标到pc mem</h4>
<ul>
<li>发送时机：bpu_in_fire，即BPU向前端发送有效预测信息，或者重定向信息的时候。以此为基础之后的第二个周期，进行发送，通过将toBackend接口的pc_mem_wen设置为true的方式指明开始发送</li>
<li>接口信号列表：
<ul>
<li>pc_mem_wen：设置为true</li>
<li>pc_mem_waddr：接收bpu_in_fire那个周期BPU发送的ftqIdx</li>
<li>pc_mem_wdata：接收bpu_in_fire那个周期，FTQ读取的ftq_pc_mem中的取指目标</li>
</ul>
</li>
</ul>
<h4 id="2更新最新的ftq项">2.更新最新的FTQ项</h4>
<ul>
<li>发送时机：
<ul>
<li>最新的FTQ项可能是由BPU写入最新预测信息造成的，<strong>发送取值目标到pc mem</strong>也是因为BPU写入最新预测信息才写入的，如果是这种情况造成的，更新FTQ项和写入pc mem的时机是一致的。</li>
<li>此外发生重定向时，也会进行状态回滚更新FTQ项，标志是后端接口fromBackend的重定向redirect信号有效，或者写入BPU的接口toBPU的redirctFromIFU拉高说明当前有来自IFU的重定向
<ul>
<li><em>（注释（可忽略）IFU重定向信号生成有两个周期，可以认为第一个周期预译码信息中missoffset有效说明IFU重定向发生，也可以认为第二个周期redirctFromIFU拉高说明重定向发生，此处取后者）。</em></li>
</ul>
</li>
<li>同样是向toBackend中写入</li>
</ul>
</li>
<li>接口信号列表：
<ul>
<li>newest_entry_en：前面说的发送时机到来时，再延迟一个周期达到真正的写入时机，这时才拉高信号</li>
<li>newest_entry_ptr：发送时机到来时的newest_entry_ptr，在真正的写入时机写入</li>
<li>newest_entry_target：发送时机到来时的newest_entry_target
newest_entry_ptr，newest_entry_target这几个都是同名的内部信号，如之前所说，BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，在相应的文档中，对其生成方式做具体的描述。</li>
</ul>
</li>
</ul>
<h2 id="接口说明">接口说明</h2>
<table>
  <thead>
      <tr>
          <th>顶层IO</th>
          <th>作用</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>toBackend</td>
          <td>发送取指令目标，让后端进行储存</td>
      </tr>
  </tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>SEND_PC_TO_BACKEND</td>
          <td>SEND_PC</td>
          <td>发送取值目标到pc mem</td>
      </tr>
      <tr>
          <td>2</td>
          <td>SEND_PC_TO_BACKEND</td>
          <td>UPDATE_NEWEST</td>
          <td>更新最新的FTQ项</td>
      </tr>
  </tbody>
</table>
</mrs-testpoints>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-060cd9108a272839369f1158228bfaa9">12.2.1.9 - 执行单元修改FTQ状态队列</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>后端的写回信息，包括重定向信息和更新信息，实际上都是执行之后，由实际执行单元根据结果发回的</p>
<h2 id="术语说明">术语说明</h2>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>定义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>cfiIndex_vec</td>
          <td>控制流指令索引队列，记录每个指令块中控制流指令的索引</td>
      </tr>
      <tr>
          <td>update_target</td>
          <td>更新目标队列，记录每个指令块的跳转目标</td>
      </tr>
      <tr>
          <td>FTQ最新项</td>
          <td>BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，表明我们当前关注的最新FTQ项。</td>
      </tr>
  </tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-由后端的写回信号修改ftq状态">1. 由后端的写回信号修改FTQ状态</h3>
<h4 id="11-修改ftq状态队列">1.1 修改FTQ状态队列</h4>
<p>从后端写回FTQ接口fromBackend中的redirect接口中，我们可以读出valid，ftqPtr，ftqOffset（后端实际执行时确认的控制流指令的偏移），taken，mispred字段，依靠它们来判断，如何修改FTQ的状态队列和相关的变量</p>
<p><strong>后端执行单元写回时被修改的队列</strong>：</p>
<h4 id="111-修改cfiindex_vec">1.1.1 修改cfiIndex_vec</h4>
<ul>
<li>cfiIndex_vec：
修改方式：执行写回修改队列中ftqPtr那一项
<ul>
<li>valid：fromBackend中的redirect接口中，valid有效，taken有效，且ftqOffset小于或者等于cfiIndex_vec中ftqPtr那一项指定的偏移：这说明重定向发生，实际执行结果判断ftqPtr索引的指令块确实会发生跳转，且实际执行跳转的指令在被预测为发生跳转的指令之前或等于它。所以这时指令块是会发生跳转的，控制流索引队列的ftqPtr项valid</li>
<li>bits：fromBackend中的redirect接口中，valid有效，taken有效，且ftqOffset小于cfiIndex_vec中ftqPtr那一项指定的偏移，偏移量被更新为更小值ftqOffset。</li>
</ul>
</li>
</ul>
<h4 id="112-修改update_target">1.1.2 修改update_target</h4>
<ul>
<li>update_target：
<ul>
<li>ftqPtr索引项的跳转目标修改为fromBackend的redirect接口中的cifUpdate中指定的target</li>
</ul>
</li>
</ul>
<h4 id="113-修改mispredict_vec">1.1.3 修改mispredict_vec</h4>
<ul>
<li>mispredict_vec：
<ul>
<li>如果该重定向指令是来自后端的重定向指令， ftqPtr索引项的ftqOffset偏移指令被设置为fromBackend的redirect接口中的cifUpdate中指定的isMisPred</li>
</ul>
</li>
</ul>
<h4 id="12-修改ftq最新项">1.2 修改FTQ最新项</h4>
<ul>
<li>newest_entry_target：
<ul>
<li>被修改为重定向接口中cfiUpdate指定的target</li>
<li>辅助信号newest_entry_target_modified被指定为true</li>
</ul>
</li>
<li>newest_entry_ptr：
<ul>
<li>修改为重定向接口指定的ftqIdx</li>
<li>辅助信号newest_entry_ptr_modified被指定为true</li>
</ul>
</li>
</ul>
<h3 id="2-由ifu的写回信号修改ftq状态">2. 由IFU的写回信号修改FTQ状态</h3>
<p>IFU既然也能和后端一样生成重定向信息，那么他也能在产生重定向信息的时候修改这些状态队列和FTQ最新项，区别：</p>
<ul>
<li>但是，由于IFU没有真的执行，所以它的预译码结果并不能作为决定指令块是不是真的被错误预测了，所以它不能修改mispredict_vec的状态</li>
<li>其次，后端重定向优先级永远高于IFU重定向，两者同时发生时只采用后端重定向。</li>
</ul>
<p>所以这个部分也有以下测试点：</p>
<h4 id="211-修改cfiindex_vec">2.1.1 修改cfiIndex_vec</h4>
<h4 id="212-修改update_target">2.1.2 修改update_target</h4>
<h4 id="22-修改ftq最新项">2.2 修改FTQ最新项</h4>
<h2 id="常量说明">常量说明</h2>
<table>
  <thead>
      <tr>
          <th>常量名</th>
          <th>常量值</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>常量1</td>
          <td>64</td>
          <td>常量1解释</td>
      </tr>
      <tr>
          <td>常量2</td>
          <td>8</td>
          <td>常量2解释</td>
      </tr>
      <tr>
          <td>常量3</td>
          <td>16</td>
          <td>常量3解释</td>
      </tr>
  </tbody>
</table>
<h2 id="接口说明">接口说明</h2>
<table>
  <thead>
      <tr>
          <th>顶层IO</th>
          <th>子接口</th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>fromBackend</td>
          <td>redirect</td>
          <td></td>
      </tr>
  </tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<p>实际使用下面的表格时，请用有意义的英文大写的功能名称和测试点名称替换下面表格中的名称</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1.1</td>
          <td>BACKEDN_REDIRECT_UPDATE_STATE</td>
          <td>UPDATE_CFIINDEXVEC</td>
          <td>后端重定向修改cfiinedex状态队列</td>
      </tr>
      <tr>
          <td>1.1.2</td>
          <td>BACKEDN_REDIRECT_UPDATE_STATE</td>
          <td>UPDATE_UPDATE_TARGET</td>
          <td>后端重定向修改update_target状态队列</td>
      </tr>
      <tr>
          <td>1.1.3</td>
          <td>BACKEDN_REDIRECT_UPDATE_STATE</td>
          <td>UPDATE_MISPREDICTVEC</td>
          <td>后端重定向修改mispredict状态队列</td>
      </tr>
      <tr>
          <td>1.2</td>
          <td>BACKEDN_REDIRECT_UPDATE_NEWEST</td>
          <td>BACKEDN_REDIRECT_UPDATE_NEWEST</td>
          <td>后端重定向修改FTQ最新项</td>
      </tr>
      <tr>
          <td>2.1.1</td>
          <td>IFU_REDIRECT_UPDATE_STATE</td>
          <td>UPDATE_CFIINDEXVEC</td>
          <td>IFU重定向修改cfiinedex状态队列</td>
      </tr>
      <tr>
          <td>2.1.2</td>
          <td>IFU_REDIRECT_UPDATE_STATE</td>
          <td>UPDATE_UPDATE_TARGET</td>
          <td>IFU重定向修改update_target状态队列</td>
      </tr>
      <tr>
          <td>2.2</td>
          <td>IFU_REDIRECT_UPDATE_NEWEST</td>
          <td>IFU_REDIRECT_UPDATE_NEWEST</td>
          <td>IFU重定向修改FTQ最新项</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-63ebff3aa1d2952064b973785cdcbf35">12.2.1.10 - 冲刷指针和状态队列</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>之前讲了，后端和IFU重定向写回会修改一些状态队列。此外，FtqPtr也是一种比较重要的维护信息。由后端或者IFU引起的重定向，需要恢复各种类型用来索引FTQ项的FtqPtr。而当重定向是由后端发起的时候，还要修改提交状态队列，说明指令已经被执行。</p>
<h2 id="术语说明">术语说明</h2>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>定义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>FTQ指针</td>
          <td>用来索引FTQ项，有不同类型的FTQ指针，比如bpuPtr，ifuPtr</td>
      </tr>
      <tr>
          <td>flush</td>
          <td>冲刷，发生时需要重置FTQ指针，以及重置其他状态</td>
      </tr>
      <tr>
          <td>融合指令</td>
          <td>一条指令可以和其他指令融合，形成融合指令</td>
      </tr>
  </tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-冲刷ftq指针及提交状态队列">1. 冲刷FTQ指针及提交状态队列</h3>
<h4 id="流程">流程</h4>
<p>后端和IFU的重定向信号都会冲刷指针，更具体的来说：</p>
<h4 id="11-冲刷条件">1.1 冲刷条件</h4>
<ul>
<li>后端写回接口fromBackend有效，或者IFU重定向有效：（当预译码写回pdWb有效，且pdWb的missOffset字段有效表明存在预测错误的指令，同时后端冲刷信号backendFlush无效）。（参考：从IFU重定向的第一个周期，重定向valid值有效条件）</li>
</ul>
<h4 id="12-冲刷指针">1.2 冲刷指针</h4>
<p>第一个周期：</p>
<ul>
<li>冲刷指针：确认后端和IFU的重定向信号可能冲刷指针时，从两个重定向来源的redirect接口读出重定向信息，包括ftqIdx，ftqOffset，重定向等级RedirectLevel。有两个来源时，优先后端的重定向信息。
冲刷指针列表：
<ul>
<li>bpuPtr：ftqIdx+1</li>
<li>ifuPtr：ftqIdx+1</li>
<li>ifuWbPtr：ftqIdx+1</li>
<li>pfPtr：ftqIdx+1
<em>注：只是在当前周期向指针寄存器写入更新信息，实际生效是在下一个周期。</em>
这样一来，所有类型指针当前指向的都是发生重定向的指令块的下一项了，我们从这一项开始重新进行分支预测，预译码，等等。</li>
</ul>
</li>
</ul>
<h4 id="13-冲刷提交状态队列">1.3 冲刷提交状态队列</h4>
<p>第二个周期：
如果上一个周期的重定向来源是后端，FTQ会进一步更改提交状态队列</p>
<ul>
<li>提交状态队列中，对于重定向的指令块（通过ftqIdx索引），位于ftqOffset后面的指令的状态被设置为c_empty</li>
<li>对于正好处于ftqOffset的指令，判断RedirectLevel，低表示在本位置后flush，高表示在本位置flush，所以level为高时，对于的指令提交状态被设置为flush。</li>
</ul>
<h3 id="2-转发到顶层io">2 转发到顶层IO</h3>
<p>实际上，在发生重定向的时候，还涉及一些将重定向信息通过FTQ顶层IO接口转发给其他模块的操作，比如ICache需要flush信号取进行冲刷，IFU也需要后端的重定向信号对它进行重定向，具体来说：
在<strong>流程</strong>的第一个周期：</p>
<h4 id="21-flush转发到icacheflush">2.1 flush转发到icacheFlush</h4>
<ul>
<li>flush信号顶层IO转发（icacheFlush）：
<ul>
<li>确认后端和IFU的重定向信号可能冲刷指针时，拉高FTQ顶层IO接口中的icacheFlush信号，把重定向产生的flush信号转发给ICache</li>
</ul>
</li>
</ul>
<h4 id="22-重定向信号转发到ifu">2.2 重定向信号转发到IFU</h4>
<ul>
<li>重定向信号顶层IO转发（toIFU）：
<ul>
<li>redirect：
<ul>
<li>bits：接收来自后端的重定向信号</li>
<li>valid：后端的重定向信号有效时有效，保持有效，直到下个周期依然有效</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-重排序缓冲区提交">3 重排序缓冲区提交</h3>
<p>其实，除了后端重定向会更新提交状态队列，最直接的更新提交状态队列的方式是通过FTQ顶层IO中frombackend里提供的提交信息，rob_commits告知我们哪些指令需要被提交。</p>
<p>rob_commits的valid字段有效，可以根据其中信息对指令进行提交，修改状态队列。对于被执行的指令，是如何提交的，如何对应地修改提交状态队列，有两种情况：</p>
<h4 id="31-提交普通指令">3.1 提交普通指令</h4>
<ul>
<li>对于普通指令，根据rob_commits的ftqIdx和ftqOffset索引提交状态队列中的某条指令，将对应的提交状态设置为c_commited</li>
</ul>
<h3 id="32-提交融合指令">3.2 提交融合指令</h3>
<ul>
<li>对于融合指令，根据提交类型commitType对被索引的指令和另一与之融合的指令进行提交，将对应的提交状态设置为c_commited
<ol>
<li>commitType = 4：同时把被索引指令的下一条指令设为c_commited</li>
<li>commitType = 5：同时把被索引指令的之后的第二条指令设为c_commited</li>
<li>commitType = 6：同时把被指令块的下一个指令块的第0条指令设为c_commited</li>
<li>commitType = 7：同时把被指令块的下一个指令块的第1条指令设为c_commited</li>
</ol>
</li>
</ul>
<h2 id="接口说明">接口说明</h2>
<table>
  <thead>
      <tr>
          <th>顶层IO</th>
          <th>作用</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>fromBackend</td>
          <td>接收后端重定向和指令提交</td>
      </tr>
      <tr>
          <td>fromIfu</td>
          <td>接收IFU重定向</td>
      </tr>
      <tr>
          <td>icacheFlush</td>
          <td>将flush信号转发到icache</td>
      </tr>
      <tr>
          <td>toIFU</td>
          <td>将后端重定向转发到IFU</td>
      </tr>
  </tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>FLUSH_FTQPTR_AND_COMMITSTATE</td>
          <td>FLUSH_COND</td>
          <td>后端写回接口fromBackend有效，或者IFU重定向有效时，进行冲刷</td>
      </tr>
      <tr>
          <td>1.2</td>
          <td>FLUSH_FTQPTR_AND_COMMITSTATE</td>
          <td>FLUSH_FTQ_PTR</td>
          <td>优先采用后端重定向信息冲刷FTQ指针</td>
      </tr>
      <tr>
          <td>1.3</td>
          <td>FLUSH_FTQPTR_AND_COMMITSTATE</td>
          <td>FLUSH_COMMIT_STATE</td>
          <td>发生后端重定向时，进一步修改提交状态队列</td>
      </tr>
      <tr>
          <td>2.1</td>
          <td>TRANSFER_TO_TOP</td>
          <td>FLUSH</td>
          <td>后端和IFU的重定向信号可能冲刷指针，拉高FTQ顶层IO接口中的icacheFlush信号</td>
      </tr>
      <tr>
          <td>2.2</td>
          <td>TRANSFER_TO_TOP</td>
          <td>IFU</td>
          <td>将重定向信号转发到IFU</td>
      </tr>
      <tr>
          <td>3.1</td>
          <td>COMMIT_BY_ROB</td>
          <td>NORMAL</td>
          <td>对于普通指令，根据rob_commits的ftqIdx和ftqOffset索引提交状态队列中的某条指令，将对应的提交状态设置为c_commited</td>
      </tr>
      <tr>
          <td>3.2</td>
          <td>COMMIT_BY_ROB</td>
          <td>FUSION</td>
          <td>对于融合指令，根据提交类型commitType对被索引的指令和另一与之融合的指令进行提交，将对应的提交状态设置为c_commited</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5a73ff17101ad6634015b300133e5fb2">12.2.1.11 - FTQ向BPU发送更新与重定向信息</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>FTQ将已提交指令的更新信息发往BPU进行训练，同时转发重定向信息。</p>
<h2 id="术语说明">术语说明</h2>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>定义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>暂无</td>
          <td>暂无</td>
      </tr>
  </tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-转发重定向">1. 转发重定向</h3>
<p>向toBPU接口进行转发：</p>
<h4 id="11-ifu重定向结果有效">1.1 IFU重定向结果有效</h4>
<ul>
<li>redirctFromIFU：IFU重定向结果有效时，拉高该信号（注意：IFU重定向有效的时机有两种说法，因为IFU重定向结果生成需要两个周期，此处取后者，即，IFU重定向生成过程的第二个周期有效，也是IFU生成完整重定向结果的周期）</li>
</ul>
<h4 id="12-选择后端重定向或者ifu重定向">1.2 选择后端重定向或者IFU重定向</h4>
<ul>
<li>redirect：如果后端重定向结果fromBackendRedirect有效，选用fromBackendRedirect，否则选用IFU重定向结果ifuRedirectToBpu</li>
</ul>
<h3 id="2-bpu更新暂停">2 BPU更新暂停</h3>
<p>BPU的更新需要两个周期，故需要三种状态去表明我们当前的更新状态：更新的第一个周期，第二个周期，更新完成。
当发生更新的时候，会暂停FTQ对指令块的提交以及发送更新信息。</p>
<h3 id="3-提交指令块">3 提交指令块</h3>
<p>FTQ需要对当前comPtr指向的当前提交指令块，进行判断是否能够提交。
这个过程比较复杂。
由于 香山V2版本 的后端会在 ROB 中重新压缩 FTQ entry，因此并不能保证提交一个 entry 中的每条指令，甚至不能保证每一个 entry 都有指令提交。</p>
<p><strong>判断一个 entry 是否被提交有如下几种可能</strong>：</p>
<ul>
<li>robCommPtr 在 commPtr 之后（ptr更大）。也就是说，后端已经开始提交之后 entry 的指令，在 robCommPtr 指向的 entry 之前的 entry 一定都已经提交完成</li>
<li>commitStateQueue 中的某个指令块内最后一条有效范围内指令被提交。FTQ项中该指令被提交意味着这FTQ项内的指令已经全部被提交</li>
</ul>
<p>在此以外，还必须要考虑到，后端存在 flush itself 的 redirect 请求，这意味着这条指令自身也需要重新执行，这包括异常、load replay 等情况。在这种情况下，这一FTQ项不应当被提交以更新 BPU，否则会导致 BPU 准确率显著下降。</p>
<h4 id="31-cancommit">3.1 canCommit</h4>
<p>具体来看，判断commPtr指向的指令块能否提交，如果可以提交记为canCommit。</p>
<p>canCommit的设置条件如下：</p>
<h4 id="311-cond1">3.1.1 COND1</h4>
<ul>
<li>当commPtr不等于ifuWbPtr，且没有因为BPU更新而暂停，同时robCommPtr在commPtr之后。之所以要求commPtr不等于ifuWbPtr是因为，前面说过了必须先预译码写回FTQ项才能提交</li>
</ul>
<h4 id="312-cond2">3.1.2 COND2</h4>
<ul>
<li>commitStateQueue 中commPtr对应指令块有指令处于c_toCommit 或c_committed状态。且指令块中最后一条处于c_toCommit 或c_committed状态的指令是c_committed的。</li>
</ul>
<p>这两种情况下，canCommit拉高，说明可以提交该指令块</p>
<h3 id="32-canmovecommptr">3.2 canMoveCommPtr</h3>
<h4 id="321-提交指令块更新提交指针">3.2.1 提交指令块更新提交指针</h4>
<p>在commPtr指向的指令块如果能提交，那么我们自然可以移动CommPtr指向下一个FTQ项了。</p>
<h4 id="322-指令冲刷更新提交指针">3.2.2 指令冲刷更新提交指针</h4>
<p>但除此之外，commitStateQueue 中commPtr对应指令块的第一条指令被后端重定向冲刷掉了时，这表明该指令需要重新执行，这一FTQ项不应被提交，但是却可以更新CommPtr指针，因为该指令块内已经没有可以提交的指令了。</p>
<ul>
<li>CanMoveCommPtr时，commPtr指针更新加1（一周期后成功写入）。</li>
</ul>
<h3 id="33-robcommptr更新">3.3 robCommPtr更新</h3>
<p>有几种情况</p>
<h4 id="331-cond1">3.3.1 COND1</h4>
<ul>
<li>当来自后端接口fromBackend的rob_commits信息中，有信息有效时，取最后一条有效交割信息的ftqIdx作为robCommPtr</li>
</ul>
<h4 id="332-cond2">3.3.2 COND2</h4>
<ul>
<li>不满足情况1，选取commPtr, robCommPtr中较大的那个</li>
</ul>
<h3 id="34-mmio提交">3.4 mmio提交</h3>
<p>发往mmioCommitRead接口</p>
<ul>
<li>mmioLastCommit：</li>
</ul>
<h4 id="341-cond1">3.4.1 COND1</h4>
<ul>
<li>当commPtr比来自mmioCommitRead接口的mmioFtqPtr大时，</li>
</ul>
<h4 id="342-cond2">3.4.2 COND2</h4>
<ul>
<li>或者两者正好相等，且commPtr指向的指令块中有c_toCommit 或c_committed状态的指令，最后一条处于c_toCommit 或c_committed状态的指令是c_committed的</li>
</ul>
<p>在这两种情况下，mmioLastCommit信号在下一个周期被拉高</p>
<h3 id="4-发送bpu更新信息">4 发送BPU更新信息</h3>
<p>FTQ需要从FTQ子队列中，读取提交项的预测信息，重定向信息，meta信息，用这些信息来对BPU发送更新信息。</p>
<p>当canCommit时，可以提交commPtr指向的指令块时，从ftq_pd_mem，ftq_redirect_mem,ftq_meta_1r_sram_mem这些子队列，以及一些小的状态队列中读出对应指令块的相应信息，这些信息需要专门花一个周期才能读取到。具体来说：</p>
<ul>
<li>从预译码信息子队列ftq_pd_mem中读取提交提交指令块（commptr所指）的预译码信息</li>
<li>从取指目标子队列ftq_pc_mem中读取取指信息</li>
<li>从分支预测重定向信息子队列ftq_redirect_mem中读取提交指令块的重定向信息。</li>
<li>从预测阶段状态队列中读取提交块来自BPU的哪个预测阶段</li>
<li>从meta信息子队列ftq_meta_1r_sram中读取提交指令块的meta，和相应的ftb_entry。</li>
<li>从提交状态队列commitStateQueueReg中读取提交状态，并确认指令块中哪些指令为c_committed,用bool数组表示</li>
<li>从控制流索引状态队列cfiIndex_vec中读取指令控制流指令在块中索引</li>
<li>结合错误预测状态队列mispredict_vec，和提交状态队列信息确认指令块中的提交错误指令。(即提交状态指示为c_commited 同时错误预测指示为预测错误)</li>
<li>从表项命中状态队列entry_hit_status中读取提交指令块是否命中</li>
</ul>
<p>根据相关信息进行判断：</p>
<ul>
<li>获取提交块的目标，如果commPtr等于newest_entry_ptr，则取newest_entry_target_modified拉高时记录下的newest_entry_target，否则取ftq_pc_mem.io.commPtrPlus1_rdata.startAddr，获取到的提交块目标将会被用来辅助新FTB项的生成</li>
</ul>
<h4 id="41-将子队列读取信息发向更新通道">4.1 将子队列读取信息发向更新通道</h4>
<p>整合完上述信息后，FTQ会向toBpu的update接口发送更新请求，具体如下：</p>
<ul>
<li>valid：canCommit 且 指令块满足命中或者存在cfi指令，valid接口有效，表明可以发送更新请求</li>
<li>bits：
<ul>
<li>false_hit：提交块命中状态指示为h_false_hit时，该信号拉高</li>
<li>pc：提交块的取指信息中的startAddr</li>
<li>meta：提交块的meta</li>
<li>cfi_idx：提交块中cfi指令的index</li>
<li>full_target：提交块的目标</li>
<li>from_stage：提交块来自哪个预测阶段</li>
<li>spec_info：提交块的meta</li>
<li>pred_hit：提交块的命中状态为hit或者false_hit</li>
</ul>
</li>
</ul>
<p>另外，被更新的FTB表项也会<strong>同时</strong>被转发到更新接口，但是新的FTB表项生成方式相对复杂，下一节专门展开叙述</p>
<h4 id="42-修正ftb项">4.2 修正FTB项</h4>
<p>更新结果会基于旧的FTB项进行更新，然后直接转发给更新接口。你可能需要先阅读<a href="https://open-verify.cc/xs-bpu/docs/ports/00_ftb/">FTB项相关文档</a>了解FTB项的结构和相关信号生成方式</p>
<p>commit表项的相关信息会被发送给一个名为FTBEntryGen的接口，经过一系列组合电路处理，输出更新后的FTB表项信息。</p>
<p>为了更新FTB项，提交项如下信息会被读取：</p>
<ul>
<li>取值目标中的起始地址 startAddr</li>
<li>meta中旧FTB项 old_entry</li>
<li>包含FTQ项内32Byte内所有分支指令的预译码信息 pd</li>
<li>此FTQ项内有效指令的真实跳转结果 cfiIndex，包括是否跳转，以及跳转指令相对startAddr的偏移</li>
<li>此FTQ项内分支指令（如跳转）的跳转地址（执行结果）</li>
<li>预测时FTB是否真正命中（旧FTB项是否有效）</li>
<li>对应FTQ项内所有可能指令的误预测 mask</li>
</ul>
<p>接下来介绍如何通过这些信息更新FTB。
FTB项生成逻辑：</p>
<h5 id="421-情况1ftb未命中则创建一个新的ftb项">4.2.1 <strong>情况1：FTB未命中，则创建一个新的FTB项</strong></h5>
<p><em>我们会根据预译码信息进行判断，预译码会告诉我们，指令块中cfi指令是否是br指令，jmp指令信息（以及是哪种类型的jmp指令）</em></p>
<ol>
<li>无条件跳转指令处理：
<ul>
<li>不论是否被执行，都一定会被写入新FTB项的tailSlot</li>
<li>如果最终FTQ项内跳转的指令是条件分支指令，写入新FTB项的第一个brSlot（目前也只有这一个），对应的strongbias被设置为1作为初始化</li>
</ul>
</li>
<li>pftAddr设置：
<ul>
<li>存在无条件跳转指令时：以无条件跳转指令的结束地址设置</li>
<li>无无条件跳转指令时：以startAddr+取指宽度（32B）设置</li>
<li>特殊情况：当4Byte宽度的无条件跳转指令起始地址位于startAddr+30时，虽然结束地址超出取指宽度范围，仍按startAddr+32设置</li>
</ul>
</li>
<li>carry位根据pftAddr的条件同时设置</li>
<li>设置分支类型标志：
<ul>
<li>isJalr、isCall、isRet按照无条件跳转指令的类型设置</li>
<li>特殊标志：当且仅当4Byte宽度的无条件跳转指令起始地址位于startAddr+30时，置last_may_be_rvi_call位</li>
</ul>
</li>
</ol>
<p><em>详细信号说明</em>：</p>
<ul>
<li>
<p>cfiIndex有效（说明指令块存在跳转指令），且pd的brmask指明该指令是br指令。则判断控制流指令是br指令</p>
</li>
<li>
<p>pd的jmpinfo有效，且cifIndx有效。则进一步根据jmpinfo判断是那种类型的jmp指令</p>
<ol>
<li>第零位为0：jal</li>
<li>第零位为1：jalr</li>
<li>第一位为1：call</li>
<li>第二位为1：ret</li>
</ol>
</li>
<li>
<p>判断最后一条指令是否是rvi（4byte）的jmp指令：jmpinfo有效，pd中jmpOffset等于15，且pd的rvcMask指明最后一条指令不是rvc指令</p>
</li>
<li>
<p>判断cfi指令是否是jal指令：cfiindx = jmpOffset，且根据之前的判断确认jmp指令是jal指令</p>
</li>
<li>
<p>判断cfi指令是jalr指令也是同理的。</p>
</li>
<li>
<p>FTB生成：valid被初始化为true</p>
<ul>
<li>brslot：在判断控制流指令是br指令时，进行填充
<ul>
<li>valid：初始化为true</li>
<li>offset：cfiindx</li>
<li>lower和stat：根据startaddr和提交块指定的target计算</li>
<li>对应的strongbias：被初始化为true</li>
</ul>
</li>
<li>tailslot：pd的jmpinfo有效时，进行填充
<ul>
<li>valid：根据之前的判断确认jmp指令是jal指令或者是jalr指令时，valid有效</li>
<li>offset：pd的jmpoffset</li>
<li>lower和stat：根据startaddr和target计算，如果cfi指令是jalr指令，使用提交块指定的target，否则用pd预测的jalTarget</li>
<li>对应的strongbias：根据之前的判断确认jmp指令是jalr指令时，拉高。strongbias是针对于BPU的ittage预测器的，该预测器基于一些统计信息工作，strongbias用来指向指令跳转偏好的强弱，其中jal指令不需要记录strongbias。</li>
</ul>
</li>
<li>pftAddr：上方介绍已经够详细了</li>
<li>carry：上方介绍已经足够</li>
<li>isJalr/isCall/isRet</li>
<li>last_may_be_rvi_call</li>
</ul>
</li>
</ul>
<h4 id="422-情况2ftb命中修改旧的ftb项">4.2.2 情况2：FTB命中，修改旧的FTB项</h4>
<h5 id="4221-插入brslot的ftb项">4.2.2.1 插入brslot的FTB项</h5>
<p><em>在原来的基础上改动即可，比如插入新的slot，注意，只针对新的brslot</em></p>
<ol>
<li><strong>修改条件</strong>：首先根据oldftbentry判断在旧entry中，cfi指令是否被记录为br指令，如果不是，<strong>则说明这是一个新的br指令</strong>。</li>
<li>接着从旧FTB中判断哪些slot可以被插入slot：
<ul>
<li>brslot：如果旧FTB的brslot无效，表示该slot空闲，此时可以在此位置插入新的brslot，此外，如果新slot在旧slot之前（新的br指令在旧slotbr指令之前执行，或者说在指令块之前的位置），即使不空也能插入</li>
<li>tailslot：当不能在brslot插入时，才考虑tailslot，同样，在该slot空闲或者新slot在旧slot之前，可以插入此位置</li>
</ul>
</li>
<li>插入slot：
<ol>
<li>brslot：能插入时则在这里插入，不能的时候，把对应的strongbias拉低，因为这说明新slot一定在旧slot之后（如果不想要详细了解ittage的原理可以不用理解原因）。</li>
<li>tailslot：能插入时则在这里插入，不能的时候，如果新slot在旧slot之后，把对应的strongbias拉低，如果不在之后，当原brslot有效（即不空闲），则用插入前的brslot代替该tailslot。对应的strongbias维持不变。</li>
</ol>
</li>
</ol>
<p><em>注：tailslot不能插入且新slot在其之前，其实就已经说明brslot一定是可以插入的，所以才有后面的替代</em></p>
<p><em><strong>pftaddr</strong></em>
出现新的br指令，同时旧的FTB项内没有空闲的slot，这说明确实发生了在FTB项内确实发生了FTB项的替换，pftaddr也需要做相应的调整。</p>
<ul>
<li>如果没有能插入的位置，使用新的br指令的偏移作为pftaddr对应的偏移，因为此时，新br指令一定在两个slot之后。否则，使用旧FTB项的最后一个slot的offset。将ptfoffset结合startAddr得到最后的pftAddr，carry也进行相应的设置。</li>
<li>last_may_be_rvi_call，isCall，isRet ，isJalr全部置false。</li>
</ul>
<h5 id="4222-修改jmp-target的ftb项">4.2.2.2 修改jmp target的FTB项</h5>
<p><strong>修改条件</strong>：<strong>当cfi指令是一个jalr指令</strong>，且旧的tailslot对应的是一个jump的指令，但tailslot指示的target与提交项指示的target不同时，说明需要对跳转目标进行修改。</p>
<ul>
<li>根据正确的跳转目标对lower和stat进行修改</li>
<li>两位strongbias设置成0</li>
</ul>
<h5 id="4223-修改bias的ftb项">4.2.2.3 修改bias的FTB项</h5>
<p><strong>当cfi指令就是原FTB项的条件跳转指令</strong>，只需要根据跳转情况设置跳转的强弱</p>
<ul>
<li>brslot：旧的brslot有发生跳转时，bias在原bias拉高，发生跳转的cfiindex等于该slot的offset，brslot有效时，保持拉高，其余情况拉低。</li>
<li>tailslot：旧的brslot没有跳转，而tailslot有分支指令且发生跳转，把brslot的bias置为false，tailslot保持bias的方式与上面的brslot一致。</li>
</ul>
<p><strong>修改条件</strong>：当旧的bias拉高且对应的旧的FTB项中的slot中有分支指令，同时修改后的bias拉低。任何一个slot出现这种情况都需要进行修改。</p>
<p>最后，需要抉择出一个修改的FTB项</p>
<ul>
<li>如果cfi是一个新的分支指令，我们采用插入新的slot的FTB项。</li>
<li>如果是cfi是一个jalr指令，且跳转目标发生修改，我们采用修改jmp跳转目标的FTB项</li>
<li>如cfi指令就是原FTB项的条件跳转指令，采用修改bias的FTB项</li>
</ul>
<h4 id="43-发送新ftb项及相关信号">4.3 发送新FTB项及相关信号</h4>
<p>此时，根据是否hit，我们已经得到更新后的FTB项了，在这个基础上我们继续更新一些相关信号以发送到FTQ更新接口。</p>
<ul>
<li>new_br_insert_pos：使用之前我们判断的FTB项中可插入位置的bool数组</li>
<li>taken_mask：根据cfi指令在更新后FTB项的位置判断，只有分支指令才做此计算，若是jmp指令置为0。</li>
<li>jump_taken: cfi指令在更新后FTB项的taislot，且jmpValid。</li>
<li>mispred_mask的最后一项：更新后的FTB项jumpValid，且预译码推断的jmp指令在提交项的错误预测信息中指示错误。
<ul>
<li><strong>mispred_mask</strong> 预测块内预测错误的掩码。第一、二位分别代表两个条件分支指令是否预测错误，第三位指示无条件跳转指令是否预测错误。
<ul>
<li>接口类型：<code>Vec(numBr+1, Bool())</code></li>
</ul>
</li>
</ul>
</li>
<li>old_entry：如果hit，且FTB项不做任何修改，即不满足上述三种修改FTB项的条件，拉高该信号，说明更新后的FTB项是旧的FTB项。</li>
</ul>
<h5 id="发送处理后的更新信息">发送处理后的更新信息</h5>
<p>此时，我们就可以向BPU发送处理好的更新信息了，下面是update的接口接收的信号</p>
<ul>
<li>ftb_entry：更新后的FTB项</li>
<li>new_br_insert_pos：上一小节已述</li>
<li>mispred_mask：上一小节已述</li>
<li>old_entry：上一小节已述</li>
<li>br_taken_mask: 上一小节已述</li>
<li>br_committed：根据提交项的提交状态信息判断新FTB项中的有效分支指令是否已经提交</li>
<li>jmp_taken：上一小节已述</li>
</ul>
<h2 id="接口说明">接口说明</h2>
<table>
  <thead>
      <tr>
          <th>顶层IO</th>
          <th></th>
          <th>作用</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>toBpu</td>
          <td></td>
          <td>向BPU发送重定向信息与更新信息</td>
      </tr>
      <tr>
          <td>fromBackend</td>
          <td></td>
          <td>获取指令交割信息，判断指令块是否被提交</td>
      </tr>
      <tr>
          <td>mmioCommiRead</td>
          <td></td>
          <td>发送mmio指令的提交信息</td>
      </tr>
  </tbody>
</table>
<h2 id="测试点总表-必填项针对细分的测试点列出表格">测试点总表 (【必填项】针对细分的测试点，列出表格)</h2>
<p>实际使用下面的表格时，请用有意义的英文大写的功能名称和测试点名称替换下面表格中的名称</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>TRANSFER_REDIRECT</td>
          <td>REDIRECT_FROM_FLUSH</td>
          <td>IFU重定向结果有效时，拉高该信号</td>
      </tr>
      <tr>
          <td>1.2</td>
          <td>TRANSFER_REDIRECT</td>
          <td>CHOOSE_REDIRECT</td>
          <td>如果后端重定向结果fromBackendRedirect有效，选用fromBackendRedirect，否则选用IFU重定向结果ifuRedirectToBpu</td>
      </tr>
      <tr>
          <td>2</td>
          <td>UPDATE_STALL</td>
          <td>UPDATE_STALL</td>
          <td>当发生BPU的更新时候，会暂停FTQ对指令块的提交以及发送更新信息</td>
      </tr>
      <tr>
          <td>3.1.1</td>
          <td>CAN_COMMIT_ENTRY</td>
          <td>COND1</td>
          <td>当commPtr不等于ifuWbPtr，且没有因为BPU更新而暂停，同时robCommPtr在commPtr之后,canCommit拉高</td>
      </tr>
      <tr>
          <td>3.1.2</td>
          <td>CAN_COMMIT_ENTRY</td>
          <td>COND2</td>
          <td>commitStateQueue 中commPtr对应指令块有指令处于c_toCommit 或c_committed状态。且指令块中最后一条处于c_toCommit 或c_committed状态的指令是c_committed的,canCommit拉高</td>
      </tr>
      <tr>
          <td>3.2.1</td>
          <td>MOVECOMMPTR</td>
          <td>BY_ROB_COMMIT</td>
          <td>在commPtr指向的指令块如果能提交,可以移动CommPtr</td>
      </tr>
      <tr>
          <td>3.2.2</td>
          <td>MOVECOMMPTR</td>
          <td>BY_FLUSH</td>
          <td>commitStateQueue 中commPtr对应指令块的第一条指令被后端重定向冲刷掉,可以移动CommPtr</td>
      </tr>
      <tr>
          <td>3.3.1</td>
          <td>UPDATE_ROB_COMM_PTR</td>
          <td>COND1</td>
          <td>当来自后端接口fromBackend的rob_commits信息中，有信息有效时，取最后一条有效交割信息的ftqIdx作为robCommPtr</td>
      </tr>
      <tr>
          <td>3.3.2</td>
          <td>UPDATE_ROB_COMM_PTR</td>
          <td>COND2</td>
          <td>不满足情况1，选取commPtr, robCommPtr中较大的那个</td>
      </tr>
      <tr>
          <td>3.4.1</td>
          <td>MMIO_LAST_COMMIT</td>
          <td>COND1</td>
          <td>当commPtr比来自mmioCommitRead接口的mmioFtqPtr大时,mmioLastCommit信号在下一个周期被拉高</td>
      </tr>
      <tr>
          <td>3.4.2</td>
          <td>MMIO_LAST_COMMIT</td>
          <td>COND2</td>
          <td>两者正好相等，且commPtr指向的指令块中有c_toCommit 或c_committed状态的指令，最后一条处于c_toCommit 或c_committed状态的指令是c_committed的,mmioLastCommit信号在下一个周期被拉高</td>
      </tr>
      <tr>
          <td>4.1</td>
          <td>SEND_UPDATE_TO_BPU</td>
          <td>SEND_SUBQUEUE_INFO_TO_UPDATE</td>
          <td>将提交项的子队列读取信息发向更新通道</td>
      </tr>
      <tr>
          <td>4.2.1</td>
          <td>UPDATE_FTB_ENTRY</td>
          <td>CREATE_NEW</td>
          <td>FTB未命中，创建一个新的FTB项</td>
      </tr>
      <tr>
          <td>4.2.2.1</td>
          <td>CREATE_NEW_FTB_ENTRY</td>
          <td>INSERT</td>
          <td>FTB未命中，创建一个新的FTB项,在原来的基础上改动即可，插入新的slot</td>
      </tr>
      <tr>
          <td>4.2.2.2</td>
          <td>CREATE_NEW_FTB_ENTRY</td>
          <td>jmp target</td>
          <td>FTB未命中，创建一个新的FTB项,在原来的基础上改动即可，<strong>当cfi指令是一个jalr指令</strong>，且旧的tailslot对应的是一个jump的指令，但tailslot指示的target与提交项指示的target不同时，说明需要对跳转目标进行修改</td>
      </tr>
      <tr>
          <td>4.2.2.3</td>
          <td>CREATE_NEW_FTB_ENTRY</td>
          <td>bias</td>
          <td>FTB未命中，创建一个新的FTB项,在原来的基础上改动即可，<strong>当cfi指令就是原FTB项的条件跳转指令</strong>，只需要根据跳转情况设置跳转的强弱</td>
      </tr>
      <tr>
          <td>4.3</td>
          <td>SEND_UPDATE_TO_BPU</td>
          <td>SEND_NEW_FTB_RELATED</td>
          <td>根据是否hit，我们已经得到更新后的FTB项了，在这个基础上我们继续更新一些相关信号以发送到FTQ更新接口。</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-67bdf4e7d2ffbf4ef76d0613f5caefbf">12.2.2 - ICache</h1>
    
	<p><strong>本文档参考<a href="https://github.com/OpenXiangShan/XiangShan-Design-Doc/blob/master/docs/frontend/ICache/index.md">香山 ICache 设计文档</a>写成</strong></p>
<p>本次验证对象是昆明湖前端指令缓存（ICache）的模块。验证的代码版本为<a href="https://github.com/OpenXiangShan/XiangShan/tree/4b2c87ba1d7965f6f2b0a396be707a6e2f6fb345">XiangShan_20250307_4b2c87ba</a></p>
<p>请注意，本文档撰写的测试点仅供参考，部分测试点需要修改，如能补充或修改测试点，最终获得的奖励可能更高！</p>
<h1 id="icache-说明文档"><strong>ICache 说明文档</strong></h1>
<div class="icache-ctx">
<h2 id="文档概述">文档概述</h2>
<p>本文档描述 ICache 的模块列表、设计规格、参数列表、功能概述和详述。
<br>
功能概述部分提供 ICache 整体数据流向图和过程。</p>
<h2 id="术语说明">术语说明</h2>
<table>
  <thead>
      <tr>
          <th>缩写</th>
          <th>全称</th>
          <th>中文名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ICache</td>
          <td>Instruction Cache</td>
          <td>L1 指令缓存</td>
          <td>用于存储最近访问过的指令，以减少对主内存的访问次数，从而提高处理速度。</td>
      </tr>
      <tr>
          <td>DCache</td>
          <td>Data Cache</td>
          <td>L1 数据缓存</td>
          <td>用于存储最近访问过的数据，以减少对主内存的访问次数，从而提高处理速度。</td>
      </tr>
      <tr>
          <td>L2 Cache</td>
          <td>Level Two Cache</td>
          <td>L2 缓存</td>
          <td>从主内存中预取指令和数据,作为 iCache 和主内存之间的缓冲区。</td>
      </tr>
      <tr>
          <td>ITLB</td>
          <td>Instruction TLB</td>
          <td>指令地址转换缓冲</td>
          <td>用于将虚拟地址转换为物理地址的缓冲。</td>
      </tr>
      <tr>
          <td>BPU</td>
          <td>Branch Prediction Unit</td>
          <td>分支预测单元</td>
          <td>预测程序中的条件分支，以便提前获取和解码后续指令，这样可以减少等待分支结果的时间。</td>
      </tr>
      <tr>
          <td>FTQ</td>
          <td>Fetch Target Queue</td>
          <td>取指目标队列</td>
          <td>暂存 BPU 预测的取指目标，并根据这些取指目标给 IFU 发送取指请求。</td>
      </tr>
      <tr>
          <td>IFU</td>
          <td>Instruction Fetch Unit</td>
          <td>取指单元</td>
          <td>进行取指，预译码，分支预测检查，指令扩展和非法检查。</td>
      </tr>
      <tr>
          <td>BEU</td>
          <td>Bus Error Unit</td>
          <td>总线错误单元</td>
          <td>总线错误可以使用总线错误单元 (BEU) 对 hart 产生中断。</td>
      </tr>
      <tr>
          <td>PF</td>
          <td>Page Fault</td>
          <td>缺页异常</td>
          <td>当 CPU 访问的内存地址不在物理内存中时，会触发缺页异常。</td>
      </tr>
      <tr>
          <td>GPF</td>
          <td>Guest Page Fault</td>
          <td>虚拟机缺页异常</td>
          <td>是在虚拟化环境中，客户机（guest）操作系统尝试访问的虚拟地址未能成功映射到物理地址时产生的异常。</td>
      </tr>
      <tr>
          <td>AF</td>
          <td>Access Fault</td>
          <td>访问错误</td>
          <td>当 CPU 试图访问一个不允许的物理地址时，会触发访问错误。</td>
      </tr>
      <tr>
          <td>PMP</td>
          <td>Physical Memory Protection</td>
          <td>物理内存保护模块</td>
          <td>RISC-V 架构中提供的一种硬件机制，用于控制不同内存区域的读、写和执行权限，主要目的是提供对物理内存的保护和隔离。</td>
      </tr>
      <tr>
          <td>PMA</td>
          <td>Physical Memory Attribute</td>
          <td>物理内存属性模块（PMP 的一部分）</td>
          <td>RISC-V 系统中，机器物理地址空间的每个区域的这些属性和能力称为物理内存属性。</td>
      </tr>
      <tr>
          <td>PBMT</td>
          <td>Page-Base Memory Type</td>
          <td>基于页面的内存类型</td>
          <td>一种内存管理机制，它使用分页（paging）技术来管理虚拟内存。见特权手册 Svpbmt 扩展。</td>
      </tr>
      <tr>
          <td>MMIO</td>
          <td>Memory-Mapped Input/Output</td>
          <td>内存映射输入/输出</td>
          <td>在 MMIO 中，外设的寄存器和内存被映射到同一个地址空间。</td>
      </tr>
      <tr>
          <td>cacheline</td>
          <td>cacheline</td>
          <td>缓存行</td>
          <td>缓存中的最小存储单位。</td>
      </tr>
      <tr>
          <td>MetaArray</td>
          <td>MetaArray</td>
          <td>元数据数组</td>
          <td>用于存储指令的元数据信息，包括指令的地址、访问权限、是否有效等。</td>
      </tr>
      <tr>
          <td>DataArray</td>
          <td>DataArray</td>
          <td>数据数组</td>
          <td>用于存储指令数据的数组。</td>
      </tr>
      <tr>
          <td>SRAM</td>
          <td>Static Random Access Memory</td>
          <td>静态随机存取存储器</td>
          <td>一种用于存储数据的存储器，具有随机访问特性。</td>
      </tr>
      <tr>
          <td>MSHR</td>
          <td>Miss Status Holding Register</td>
          <td>缺失状态保持寄存器</td>
          <td>用来处理非阻塞缓存（non-blocking cache）中的缓存未命中（cache miss）情况 。</td>
      </tr>
      <tr>
          <td>SATP</td>
          <td>Supervisor Address Translation and Protection</td>
          <td>监管者地址转换和保护单元</td>
          <td>管理地址转换和保护机制，它决定了虚拟地址到物理地址的转换方式以及访问权限的控制。</td>
      </tr>
      <tr>
          <td>VS</td>
          <td>Virtual Supervisor</td>
          <td>虚拟监管者</td>
          <td>是 H 扩展引入的一种特权模式，用于运行虚拟机中的操作系统。包括两级地址翻译，虚拟 CSR 和异常和中断虚拟化等机制。</td>
      </tr>
      <tr>
          <td>hartID</td>
          <td>hardware thread ID</td>
          <td>硬件线程标识</td>
          <td>RISC-V 硬件线程 ID。在 RISC-V 架构中，每个处理器核心都有一个唯一的 hart ID，用于区分同一处理器中运行的多个硬件线程。</td>
      </tr>
      <tr>
          <td>SFENCE.VMA</td>
          <td>Supervisor Memory-Management Fence Instruction</td>
          <td>监管者内存管理屏障指令</td>
          <td>同步对内存中内存管理数据结构的更新与当前执行的指令。</td>
      </tr>
      <tr>
          <td>fence.i</td>
          <td>fence.i</td>
          <td>屏障指令</td>
          <td>用于同步指令流与数据流，确保在指令之前的存储操作对后续取指可见。</td>
      </tr>
      <tr>
          <td>FDIP</td>
          <td>Fetch-directed instruction prefetching</td>
          <td>取指导向指令预取</td>
          <td>通过在分支预测单元和取指单元之间引入一个取指目标队列（Fetch Target Queue，FTQ），将两者解耦。分支预测单元会预测未来的控制流，并将预测的分支目标地址存入FTQ。取指单元则根据FTQ中的地址信息，提前从更高级别的缓存或内存中获取指令块，并将其放入一个全相联的缓冲区中，以便与L1指令缓存并行访问。</td>
      </tr>
  </tbody>
</table>
<h2 id="icache-和-dcache-区别">ICache 和 DCache 区别</h2>
<h3 id="功能用途">功能用途</h3>
<p>ICache 专门用于存储指令。当 CPU 从内存中读取指令时，这些指令会先被存储在 ICache 中。这样，当 CPU 需要再次执行相同的指令时，可以直接从 ICache 中读取，而无需再次访问速度较慢的内存，从而提高指令的读取速度，加快程序的执行效率。</p>
<p>DCache 用于存储数据。程序运行过程中，CPU 需要频繁地读取和写入数据。DCache 的作用就是缓存这些数据，使得 CPU 对数据的访问速度更快。当 CPU 访问内存中的数据时，如果数据已经在 DCache 中，就可以直接从 DCache 中读取或写入，减少了访问内存的次数，提高了数据访问的效率。</p>
<h3 id="数据一致性问题">数据一致性问题</h3>
<p>ICache 通常不需要考虑数据一致性问题。因为<strong>指令是只读的</strong>，一旦程序开始运行，指令的内容一般不会改变。所以，ICache 中的指令可以一直使用，直到程序结束或者新的指令被加载进来。即使内存中的指令被修改了，也不会影响 ICache 中已经缓存的指令的执行。</p>
<p>DCache 数据一致性是一个重要的问题。因为数据可能会被多个处理器或者设备访问和修改。如果一个处理器修改了 DCache 中的数据，而其他处理器或者设备仍然使用旧的数据，就会导致数据不一致的问题。为了保证数据一致性，需要采用一些机制，如缓存一致性协议（如 MESI 协议等），来确保所有处理器和设备看到的数据是一致的。</p>
<p>为什么我们需要区分数据和指令呢？原因之一是出于性能的考量。CPU 在执行程序时，可以同时获取指令和数据，做到硬件上的并行，提升性能。另外，指令和数据有很大的不同。例如，指令一般不会被修改，所以 iCache 在硬件设计上是可以是只读的，这在一定程度上降低硬件设计的成本。所以硬件设计上，系统中一般存在 L1 dCache 和 L1 iCache，L2 Cache 和 L3 Cache。</p>
<h3 id="区分原因">区分原因</h3>
<p>指令访问模式是：通常按照程序的顺序依次执行，具有较高的局部性。并且在程序运行过程中通常是只读的，不会被修改。
数据访问模式是：数据的访问通常较为随机，可能涉及频繁的读写操作。数据需要支持读写操作，这意味着 DCache 需要处理数据的写入和一致性问题。</p>
<p>将数据和指令分开存储到 DCache 和 ICache，有利于提高命中率和减少冲突，提升性能（CPU 在执行程序时，可以同时获取指令和数据，做到硬件上的并行），简化设计（ICache 可以专注读指令，而 DCache 需要数据的读写操作，还需要考虑数据一致性问题）。</p>
<h2 id="为什么需要预取">为什么需要预取</h2>
<p>预取是 CPU 用来提高执行性能的一种技术，它在实际需要之前将指令或数据从原来存储在较慢内存中的位置取到较快的本地内存中（因此称为 &ldquo;预取&rdquo;）。</p>
<div>			
    <center>	
    <img src="difference between cpu and memory.png"
         alt="CPU 和内存的性能差异"
         style="zoom:40%"/>
    <br>		<!--换行-->
    CPU 和内存的性能差异	<!--标题-->
    </center>
</div>
<br>
<p>由处理器和内存之前的性能差异越来大，所以我们需要预取。<br>
从上图可以看出，1980年至2015年间，CPU的性能提升了将近一万倍，可是内存相关的性能只提升了十倍。如果等CPU需要执行相关指令或者需要修改数据的时候再从内存中去读取，那么大部分时间都会花费在等待数据上，这是不可容忍的。这时预取的重要性就体现了，把将要访问的内容提前从内存搬移到Cache中，CPU就可以即时拿到所需的内容，避免了等待。当然，如果预取做得不好，是有可能导致性能下降的，由于Cache的大小是很宝贵的，如果预取判断出错，预取的是无用的数据，然后反而把Cache中后续有可能还会用到的数据给Evict了，那么会增加系统的功耗，减低性能。</p>
<h2 id="模块列表">模块列表</h2>
<table>
  <thead>
      <tr>
          <th>子模块</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/02_mainpipe/">MainPipe</a></td>
          <td>主流水线</td>
      </tr>
      <tr>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/01_iprefetchpipe/">IPrefetchPipe</a></td>
          <td>预取流水线</td>
      </tr>
      <tr>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/03_waylookup/">WayLookup</a></td>
          <td>元数据缓冲队列</td>
      </tr>
      <tr>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/06_icache/">MetaArray</a></td>
          <td>元数据 SRAM</td>
      </tr>
      <tr>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/06_icache/">DataArray</a></td>
          <td>数据 SRAM</td>
      </tr>
      <tr>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/04_missunit/">MissUnit</a></td>
          <td>缺失处理单元</td>
      </tr>
      <tr>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/06_icache/">Replacer</a></td>
          <td>替换策略单元</td>
      </tr>
      <tr>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/05_ctrlunit/">CtrlUnit</a></td>
          <td>控制单元，目前仅用于控制错误校验/错误注入功能</td>
      </tr>
      <tr>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/06_icache/">ICache</a></td>
          <td>ICache 顶层模块</td>
      </tr>
      <tr>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/04_missunit/">FIFO</a></td>
          <td>先入先出循环队列，在 MissUnit 中有使用</td>
      </tr>
  </tbody>
</table>
<h2 id="设计规格">设计规格</h2>
<ul>
<li>缓存指令数据</li>
<li>缺失时通过 tilelink 总线向 L2 请求数据</li>
<li>软件维护 L1 I/D Cache 一致性（<code>fence.i</code>）</li>
<li>支持跨 cacheline （预）取指请求</li>
<li>支持冲刷（bpu redirect、backend redirect、<code>fence.i</code>）</li>
<li>支持预取指请求
<ul>
<li>硬件预取为 FDIP 预取算法</li>
<li>软件预取为 Zicbop 扩展<code>prefetch.i</code>指令</li>
</ul>
</li>
<li>支持可配置的替换算法</li>
<li>支持可配置的缺失状态寄存器数量</li>
<li>支持检查地址翻译错误、物理内存保护错误</li>
<li>支持错误检查 &amp; 错误恢复 &amp; 错误注入<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>
<ul>
<li>默认采用 parity code</li>
<li>通过从 L2 重取实现错误恢复</li>
<li>软件可通过 MMIO 空间访问的错误注入控制寄存器</li>
</ul>
</li>
<li>DataArray 支持分 bank 存储，细存储粒度实现低功耗</li>
</ul>
<h2 id="参数列表">参数列表</h2>
<p>若和 chisel 代码不一致，以 chisel 代码为准。</p>
<table>
  <thead>
      <tr>
          <th>参数</th>
          <th>默认值</th>
          <th>描述</th>
          <th>要求</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>nSets</td>
          <td>256</td>
          <td>SRAM set 数量</td>
          <td>2 的幂次</td>
      </tr>
      <tr>
          <td>nWays</td>
          <td>4</td>
          <td>SRAM way 数量</td>
          <td></td>
      </tr>
      <tr>
          <td>nFetchMshr</td>
          <td>4</td>
          <td>取指 MSHR 的数量</td>
          <td></td>
      </tr>
      <tr>
          <td>nPrefetchMshr</td>
          <td>10</td>
          <td>预取 MSHR 的数量</td>
          <td></td>
      </tr>
      <tr>
          <td>nWayLookupSize</td>
          <td>32</td>
          <td>WayLookup 深度，同时可以反压限制预取最大距离</td>
          <td></td>
      </tr>
      <tr>
          <td>DataCodeUnit</td>
          <td>64</td>
          <td>校验单元大小，单位为 bit，每 64bit 对应 1bit 的校验位</td>
          <td></td>
      </tr>
      <tr>
          <td>ICacheDataBanks</td>
          <td>8</td>
          <td>cacheline 划分 bank 数量</td>
          <td></td>
      </tr>
      <tr>
          <td>ICacheDataSRAMWidth</td>
          <td>66</td>
          <td>DataArray 基本 SRAM 的宽度</td>
          <td>大于每 bank 的 data 和 code 宽度之和</td>
      </tr>
  </tbody>
</table>
<h2 id="功能概述">功能概述</h2>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="ftq_pointer.png"
         alt="FTQ 指针示意"
         style="zoom:10%"/>
    <br>		<!--换行-->
    FTQ 指针示意	<!--标题-->
    </center>
</div>
<br>
<p>FTQ 中存储着 BPU 生成的预测块，fetchPtr 指向取指预测块，prefetchPtr 指向预取预测块，当复位时 prefetchPtr 与 fetchPtr 相同，每成功发送一次取指请求时 fetchPtr++，每成功发送一次预取请求时 prefetchPtr++。详细说明见<a href="https://github.com/OpenXiangShan/XiangShan-Design-Doc/blob/master/docs/frontend/FTQ/index.md">FTQ 设计文档</a>。</p>
<div>			
    <center>	
    <img src="icache_structure.png"
         alt="ICache整体数据流向图"
         style="zoom:25%"/>
    <br>		
    ICache整体数据流向图	
    </center>
</div>
<br>
<p>ICache 结构如上图所示，有 MainPipe 和 IPrefetchPipe 两个流水线，MainPipe 接收来自 FTQ 的取指请求，IPrefetchPipe 接收来自 FTQ/MemBlock 的硬/软件预取请求。</p>
<ul>
<li>
<p>对于预取请求，IPrefetch 对 MetaArray 进行查询，将元数据（在哪一路命中、ECC 校验码、是否发生异常等）存储到 WayLookup 中，如果该请求缺失，就发送至 MissUnit 进行预取。</p>
</li>
<li>
<p>对于取指请求，MainPipe 首先从 WayLookup 中读取命中信息，如果 WayLookup 中没有可用信息，MainPipe 就会阻塞，直至 IPrefetchPipe 将信息写入 WayLookup 中，该方案将 MetaArray 和 DataArray 的访问分离，一次只访问 DataArray 单路，代价是产生了一个周期的重定向延迟。</p>
</li>
<li>
<p>MissUnit 处理来自 MainPipe 的取指请求和来自 IPrefetchPipe 的预取请求，通过 MSHR 进行管理，所有 MSHR 公用一组数据寄存器以减少面积。</p>
</li>
<li>
<p>CtrlUnit 主要负责 ECC 校验使能/错误注入等功能。从 MetaArray 读取元数据，之后向 MetaArray 写入毒化的标签，向 DataArray 写入毒化的数据。Tilelink 用于外部配置和状态监控，通过 eccctrl 和 ecciaddr 寄存器实现读写交互。</p>
</li>
<li>
<p>Replacer 为替换器，采用 PLRU 替换策略，接收来自 MainPipe 的命中更新，向 MissUnit 提供写入的 waymask。</p>
</li>
<li>
<p>MetaArray 分为奇偶两个 bank，用于支持跨 cacheline 的双行访问。</p>
</li>
<li>
<p>DataArray 中的 cacheline 分为 8 个 bank 存储，每个 bank 中存储的有效数据为 64bit，另外对于每 64bit 还需要 1bit 的校验位，由于 65bit 宽度的 SRAM 表现不好，所以选用深度 256*宽度 66bit 的 SRAM 作为基本单元，一共有 32 个这样的基本单元。一次访问需要 34Byte 的指令数据，每次需要访问 5 个 bank($8\times 5 &gt; 34$)，根据起始地址进行选择。</p>
</li>
</ul>
<h2 id="功能详述">功能详述</h2>
<h3 id="取指预取指请求">取指/预取指请求</h3>
<div>			
    <center>	
    <img src="icache_stages.png"
         alt="ICache 两条流水线的关系"
         style="zoom:80%"/>
    <br>		
    ICache 两条流水线的关系	
    </center>
</div>
<br>
<p>FTQ 分别把取指/预取指请求发送到对应的取指/预取指流水线进行处理。如前所述，由 IPrefetch 对 MetaArray 和 ITLB 进行查询，将元数据（在哪一路命中、ECC 校验码、是否发生异常等）在 IPrefetchPipe s1 流水级存储到 WayLookup 中，以供 MainPipe s0 流水级读取。</p>
<p>在上电解复位/重定向时，由于 WayLookup 为空，而 FTQ 的 prefetchPtr、fetchPtr 复位到同一位置，MainPipe s0 流水级不得不阻塞等待 IPrefetchPipe s1 流水级的写入，这引入了一拍的额外重定向延迟。但随着 BPU 向 FTQ 填充预测块的进行和 MainPipe/IFU 因各种原因阻塞（e.g. miss、IBuffer 满），IPrefetchPipe 将工作在 MainPipe 前（<code>prefetchPtr &gt; fetchPtr</code>），而 WayLookup 中也会有足够的元数据，此时 MainPipe s0 级和 IPrefetchPipe s0 级的工作将是并行的。</p>
<p>详细的取指过程见<a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/02_mainpipe/">MainPipe</a>、<a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/01_iprefetchpipe/">IPrefetchPipe</a>和<a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/03_waylookup/">WayLookup</a>。</p>
<h4 id="硬件预取与软件预取">硬件预取与软件预取</h4>
<p>V2R2 后，ICache 可能接受两个来源的预取请求：</p>
<ol>
<li>来自 Ftq 的硬件预取请求，基于 FDIP 算法。</li>
<li>来自 Memblock 中 LoadUint 的软件预取请求，其本质是 Zicbop 扩展中的 prefetch.i 指令，请参考 RISC-V CMO 手册。</li>
</ol>
<p>然而，PrefetchPipe 每周期仅可以处理一个预取请求，故需要进行仲裁。ICache 顶层负责缓存软件预取请求，并与来自 Ftq 的硬件预取请求二选一送往 PrefetchPipe，软件预取请求的优先级高于硬件预取请求。</p>
<p>逻辑上来说，每个 LoadUnit 都有可能发出软件预取请求，因此每周期至多会有 LoadUnit 数量（目前默认参数为 LduCnt=3）个软件预取请求。但出于实现成本和性能收益考量，ICache 每周期至多仅接收并处理一个，多余的会被丢弃，端口下标最小的优先。此外，若 PrefetchPipe 阻塞，而 ICache 内已经缓存了一个软件预取请求，那么原先的软件预取请求将被覆盖。</p>
<div>			
    <center>	
    <img src="prefetch_mux.png"
         alt="ICache 预取请求接收与仲裁"
         style="zoom:100%"/>
    <br>		
    ICache 预取请求接收与仲裁	
    </center>
</div>
<br>
发送到 PrefetchPipe 后，软件预取请求的处理和硬件预取请求的处理几乎是一致的，除了：
<ul>
<li>软件预取请求不会影响控制流，即<strong>不会</strong>发送到 MainPipe（和后续的 Ifu、IBuffer 等环节），仅做：1) 判断是否 miss 或异常；2) 若 miss 且无异常，发送到 MissUnit 做预取指并重填 SRAM。</li>
</ul>
<p>关于 PrefetchPipe 的细节请查看子模块文档。</p>
<h3 id="异常传递特殊情况处理">异常传递/特殊情况处理</h3>
<p>ICache 负责对取指请求的地址进行权限检查（通过 ITLB 和 PMP），可能的异常和特殊情况有：</p>
<table>
  <thead>
      <tr>
          <th>来源</th>
          <th>异常</th>
          <th>描述</th>
          <th>处理</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ITLB</td>
          <td>af</td>
          <td>虚拟地址翻译过程出现访问错误</td>
          <td>禁止取指，标记取指块为 af，经 IFU、IBuffer 发送到后端处理</td>
      </tr>
      <tr>
          <td>ITLB</td>
          <td>gpf</td>
          <td>客户机页错误</td>
          <td>禁止取指，标记取指块为 gpf，经 IFU、IBuffer 发送到后端处理，将有效的 <code>gpaddr</code> 和 <code>isForNonLeafPTE</code>发送到后端的 GPAMem 以备使用</td>
      </tr>
      <tr>
          <td>ITLB</td>
          <td>pf</td>
          <td>页错误</td>
          <td>禁止取指，标记取指块为 pf，经 IFU、IBuffer 发送到后端处理</td>
      </tr>
      <tr>
          <td>backend</td>
          <td>af/pf/gpf</td>
          <td>同 ITLB 的 af/pf/gpf</td>
          <td>同 ITLB 的 af/pf/gpf</td>
      </tr>
      <tr>
          <td>PMP</td>
          <td>af</td>
          <td>物理地址无权限访问</td>
          <td>同 ITLB af</td>
      </tr>
      <tr>
          <td>MissUnit</td>
          <td>L2 corrupt</td>
          <td>L2 cache 响应 corrupt</td>
          <td>标记取指块为 af，经 IFU、IBuffer 发送到后端处理</td>
      </tr>
  </tbody>
</table>
<p>需要指出，对于一般的取指流程来说，并不存在 backend 异常这一项。但 XiangShan 出于节省硬件资源的考虑，在前端传递的 pc 只有 41 / 50 bit（Sv39<em>4 / Sv48</em>4），而对于 <code>jr</code>、<code>jalr</code> 等指令，跳转目标来源于 64 bit 寄存器。根据 RISC-V 规范，高位非全 0 或全 1 时的地址不合法，需要引发异常，这一检查只能由后端完成，并随同后端重定向信号一起发送到 Ftq，进而随同取指请求一起发送到 ICache。其本质是一种 ITLB 异常，因此解释描述和处理方式与 ITLB 相同。</p>
<p>另外，L2 cache 通过 tilelink 总线响应 corrupt 可能是 L2 ECC 错误（<code>d.corrupt</code>），亦可能是无权限访问总线地址空间导致拒绝访问（<code>d.denied</code>）。tilelink 手册规定，当拉高 <code>d.denied</code> 时必须同时拉高 <code>d.corrupt</code>。而这两种情况都需要将取指块标记为 access fault，因此目前在 ICache 中无需区分这两种情况（即无需关注 <code>d.denied</code>，其可能被 chisel 自动优化掉而导致 verilog 中看不到）。</p>
<p>这些异常间存在优先级：backend 异常 &gt; ITLB 异常 &gt; PMP 异常 &gt; MissUnit 异常。这是自然的：</p>
<ol>
<li>当出现 backend 异常时，发送到前端的 vaddr 不完整且不合法，故 ITLB 地址翻译过程无意义，检查出的异常无效；</li>
<li>当出现 ITLB 异常时，翻译得到的 paddr 无效，故 PMP 检查过程无意义，检查出的异常无效；</li>
<li>当出现 PMP 异常时，paddr 无权限访问，不会发送（预）取指请求，故不会从 MissUnit 得到响应。</li>
</ol>
<p>而对于 backend 的三种异常、ITLB 的三种异常，由 backend 和 ITLB 内部进行有优先级的选择，保证同时至多只有一种拉高。</p>
<p>此外，一些机制还会引发一些特殊情况，在旧版文档/代码中也称为异常，但其实际上并不引发 RISC-V 手册定义的 <code>exception</code>，为了避免混淆，此后将称为特殊情况：</p>
<table>
  <thead>
      <tr>
          <th>来源</th>
          <th>特殊情况</th>
          <th>描述</th>
          <th>处理</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>PMP</td>
          <td>mmio</td>
          <td>物理地址为 mmio 空间</td>
          <td>禁止取指，标记取指块为 mmio，由 IFU 进行<strong>非推测性</strong>取指</td>
      </tr>
      <tr>
          <td>ITLB</td>
          <td>pbmt.NC</td>
          <td>页属性为不可缓存、幂等</td>
          <td>禁止取指，由 IFU 进行<strong>推测性</strong>取指</td>
      </tr>
      <tr>
          <td>ITLB</td>
          <td>pbmt.IO</td>
          <td>页属性为不可缓存、非幂等</td>
          <td>同 pmp mmio</td>
      </tr>
      <tr>
          <td>MainPipe</td>
          <td>ECC error</td>
          <td>主流水检查发现 MetaArray/DataArray ECC 错误</td>
          <td>见<a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#ecc">ECC 一节</a>，旧版同 ITLB af，新版做自动重取</td>
      </tr>
  </tbody>
</table>
<h3 id="dataarray-分-bank-的低功耗设计">DataArray 分 bank 的低功耗设计</h3>
<p>目前，ICache 中每个 cacheline 分为 8 个 bank，bank0-7。一个取指块需要 34B 指令数据，故一次访问连续的 5 个 bank。存在两种情况：</p>
<ol>
<li>这 5 个 bank 位于单个 cacheline 中（起始地址位于 bank0-3）。假设起始地址位于 bank2，则所需数据位于 bank2-6。如下图 a。</li>
<li>跨 cacheline（起始地址位于 bank4-7）。假设起始地址位于 bank6，则数据位于 cacheline0 的 bank6-7、cacheline1 的 bank0-2。有些类似于环形缓冲区。如下图 b。</li>
</ol>
<div>			
    <center>	
    <img src="dataarray_bank.png"
         alt="DataArray 分 bank 示意图"
         style="zoom:20%"/>
    <br>		
    DataArray 分 bank 示意图	
    </center>
</div>
<br>
<p>当从 SRAM 或 MSHR 中获取 cacheline 时，根据地址将数据放入对应的 bank。</p>
<p>由于每次访问只需要 5 个 bank 的数据，因此 ICache 到 IFU 的端口实际上只需要一个 64B 的端口，将两个 cacheline 各自的 bank 选择出来并拼接在一起返回给 IFU（在 DataArray 模块内完成）；IFU 将这一个 64B 的数据复制一份拼接在一起，即可直接根据取指块起始地址选择出取指块的数据。不跨行/跨行两种情况的示意图如下：</p>
<div>			
    <center>	
    <img src="dataarray_bank_read_singleline.png"
         alt="DataArray 单行数据返回示意图"
         style="zoom:100%"/>
    <br>		
    DataArray 单行数据返回示意图	
    </center>
</div>
<br>
<div>			
    <center>	
    <img src="dataarray_bank_read_multiline.png"
         alt="DataArray 双行数据返回示意图"
         style="zoom:100%"/>
    <br>		
    DataArray 双行数据返回示意图	
    </center>
</div>
<br>
<p>亦可参考 <a href="https://github.com/OpenXiangShan/XiangShan/blob/fad7803d97ed4a987a743036cec42d1c07b48e2e/src/main/scala/xiangshan/frontend/IFU.scala#L474-L502">IFU.scala 中的注释</a>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>NOTE: the following <span style="color:#4e9a06">`Cat(_data, _data)`</span> <span style="color:#000;font-style:italic">_is_</span> intentional.
</span></span><span style="display:flex;"><span>Explanation:
</span></span><span style="display:flex;"><span>In the old design, IFU is responsible for selecting requested data from two adjacent cachelines,
</span></span><span style="display:flex;"><span>so IFU has to receive 2*64B (2cacheline * 64B) data from ICache, and do <span style="color:#4e9a06">`Cat(_data(1), _data(0))`</span> here.
</span></span><span style="display:flex;"><span>However, a fetch block is 34B at max, sending 2*64B is quiet a waste of power.
</span></span><span style="display:flex;"><span>In current design (2024.06~), ICacheDataArray is responsible for selecting data from two adjacent cachelines,
</span></span><span style="display:flex;"><span>so IFU only need to receive 40B (5bank * 8B) valid data, and use only one port is enough.
</span></span><span style="display:flex;"><span>For example, when pc falls on the 6th bank in cacheline0(so this is a doubleline request):
</span></span><span style="display:flex;"><span>MSB LSB
</span></span><span style="display:flex;"><span>cacheline 1 || 1-7 | 1-6 | 1-5 | 1-4 | 1-3 | 1-2 | 1-1 | 1-0 ||
</span></span><span style="display:flex;"><span>cacheline 0 || 0-7 | 0-6 | 0-5 | 0-4 | 0-3 | 0-2 | 0-1 | 0-0 ||
</span></span><span style="display:flex;"><span>and ICacheDataArray will respond:
</span></span><span style="display:flex;"><span>fromICache.bits.data || 0-7 | 0-6 | xxx | xxx | xxx | 1-2 | 1-1 | 1-0 ||
</span></span><span style="display:flex;"><span>therefore simply make a copy of the response and <span style="color:#4e9a06">`Cat`</span> together, and obtain the requested data from centre:
</span></span><span style="display:flex;"><span>f2_data_2_cacheline || 0-7 | 0-6 | xxx | xxx | xxx | 1-2 | 1-1 | 1-0 | 0-7 | 0-6 | xxx | xxx | xxx | 1-2 | 1-1 | 1-0 ||
</span></span><span style="display:flex;"><span>requested data: ^-----------------------------^
</span></span><span style="display:flex;"><span>For another example, pc falls on the 1st bank in cacheline 0, we have:
</span></span><span style="display:flex;"><span>fromICache.bits.data || xxx | xxx | 0-5 | 0-4 | 0-3 | 0-2 | 0-1 | xxx ||
</span></span><span style="display:flex;"><span>f2_data_2_cacheline || xxx | xxx | 0-5 | 0-4 | 0-3 | 0-2 | 0-1 | xxx | xxx | xxx | 0-5 | 0-4 | 0-3 | 0-2 | 0-1 | xxx ||
</span></span><span style="display:flex;"><span>requested data: ^-----------------------------^
</span></span><span style="display:flex;"><span>Each &#34;| x-y |&#34; block is a 8B bank from cacheline(x).bank(y)
</span></span><span style="display:flex;"><span>Please also refer to:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">-</span> DataArray selects data:
</span></span><span style="display:flex;"><span>  https://github.com/OpenXiangShan/XiangShan/blob/d4078d6edbfb4611ba58c8b0d1d8236c9115dbfc/src/main/scala/xiangshan/frontend/icache/ICache.scala<span style="color:#ce5c00">#L355</span>-L381
</span></span><span style="display:flex;"><span>  https://github.com/OpenXiangShan/XiangShan/blob/d4078d6edbfb4611ba58c8b0d1d8236c9115dbfc/src/main/scala/xiangshan/frontend/icache/ICache.scala<span style="color:#ce5c00">#L149</span>-L161
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">-</span> ICache respond to IFU:
</span></span><span style="display:flex;"><span>  https://github.com/OpenXiangShan/XiangShan/blob/d4078d6edbfb4611ba58c8b0d1d8236c9115dbfc/src/main/scala/xiangshan/frontend/icache/ICacheMainPipe.scala<span style="color:#ce5c00">#L473</span>
</span></span></code></pre></div><h3 id="冲刷">冲刷</h3>
<p>在后端/IFU 重定向、BPU 重定向、<code>fence.i</code> 指令执行时，需要视情况对 ICache 内的存储结构和流水级进行冲刷。可能的冲刷目标/动作有：</p>
<ol>
<li>MainPipe、IPrefetchPipe 所有流水级
<ul>
<li>冲刷时直接将 <code>s0/1/2_valid</code> 置为 <code>false.B</code> 即可</li>
</ul>
</li>
<li>MetaArray 中的 valid
<ul>
<li>冲刷时直接将 <code>valid</code> 置为 <code>false.B</code> 即可</li>
<li><code>tag</code>、<code>code</code>不需要冲刷，因为它们的有效性由 <code>valid</code> 控制</li>
<li>DataArray 中的数据不需要冲刷，因为它们的有效性由 MetaArray 中的 <code>valid</code> 控制</li>
</ul>
</li>
<li>WayLookup
<ul>
<li>读写指针复位</li>
<li><code>gpf_entry.valid</code> 置为 <code>false.B</code></li>
</ul>
</li>
<li>MissUnit 中所有 MSHR
<ul>
<li>若 MSHR 尚未向总线发出请求，请求和预取请求直接置无效（<code>valid === false.B</code>）</li>
<li>若 MSHR 已经向总线发出请求，记录待冲刷（<code>flush === true.B</code> 或 <code>fencei === true.B</code>），等到 d 通道收到 grant 响应时再置无效，同时不把 grant 的数据回复给 MainPipe/PrefetchPipe，也不写入 SRAM
    - 需要留意，当 d 通道收到 grant 响应的同时收到冲刷（<code>io.flush === true.B</code> 或 <code>io.fencei === true.B</code>）时，MissUnit 同样不写入 SRAM，但<strong>会</strong>将数据回复给 MainPipe/PrefetchPipe，避免将端口的延时引入响应逻辑中，此时 MainPipe/PrefetchPipe 也同步收到了冲刷请求，因此会将数据丢弃</li>
</ul>
</li>
</ol>
<p>每种冲刷原因需要执行的冲刷目标：</p>
<table>
  <thead>
      <tr>
          <th>冲刷原因</th>
          <th>1</th>
          <th>2</th>
          <th>3</th>
          <th>4</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>后端/IFU 重定向</td>
          <td>Y</td>
          <td></td>
          <td>Y</td>
          <td>Y</td>
      </tr>
      <tr>
          <td>BPU 重定向</td>
          <td>Y<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td><code>fence.i</code></td>
          <td>Y<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></td>
          <td>Y</td>
          <td>Y<sup id="fnref1:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></td>
          <td>Y</td>
      </tr>
  </tbody>
</table>
<p>ICache 进行冲刷时不接收取指/预取请求（<code>io.req.ready === false.B</code>）</p>
<h4 id="对-itlb-的冲刷">对 ITLB 的冲刷</h4>
<p>ITLB 的冲刷比较特殊，其缓存的页表项仅需要在执行 <code>sfence.vma</code> 指令时冲刷，而这条冲刷通路由后端负责，因此前端或 ICache 一般不需要管理 ITLB 的冲刷。只有一个特例：目前 ITLB 为了节省资源，不会存储 <code>gpaddr</code>，而是在 <code>gpf</code> 发生时去 L2TLB 重取，重取状态由一个 <code>gpf</code> 缓存控制，这要求 ICache 在收到 <code>ITLB.resp.excp.gpf_instr</code> 时保证下面两个条件之一：</p>
<ol>
<li>重发相同的 <code>ITLB.req.vaddr</code>，直到 <code>ITLB.resp.miss</code> 拉低（此时<code>gpf</code>、<code>gpaddr</code>均有效，正常发往后端处理即可），ITLB 此时会冲刷 <code>gpf</code> 缓存。</li>
<li>给 <code>ITLB.flushPipe</code>，ITLB 在收到该信号时会冲刷 <code>gpf</code> 缓存。</li>
</ol>
<p>若 ITLB 的 <code>gpf</code> 缓存未被冲刷，就收到了不同 <code>ITLB.req.vaddr</code> 的请求，且再次发生 <code>gpf</code>，将导致核卡死。</p>
<p>因此，每当冲刷 IPrefetchPipe 的 s1 流水级时，无论冲刷原因为何，都需要同步冲刷 ITLB 的 <code>gpf</code> 缓存（即拉高 <code>ITLB.flushPipe</code>）。</p>
<h3 id="ecc">ECC</h3>
<p>首先需要指出，ICache 在默认参数下使用 parity code，其仅具备 1 bit 错误检测能力，不具备错误恢复能力，严格意义上不能算是 ECC（Error Correction Code）。但一方面，其可以配置为使用 secded code；另一方面，我们在代码中大量使用 ECC 来命名错误检测与错误恢复相关的功能（<code>ecc_error</code>、<code>ecc_inject</code>等）。因此本文档仍将使用 ECC 一词来指代错误检测、错误恢复、错误注入相关功能以保证与代码的一致性。</p>
<p>ICache 支持错误检测、错误恢复、错误注入功能，是 RAS<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup> 能力的一部分，可以参考 RISC-V RERI<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup> 手册，由 CtrlUnit 进行控制。</p>
<h4 id="错误检测">错误检测</h4>
<p>在 MissUnit 向 MetaArray 和 DataArray 重填数据时，会计算 meta 和 data 的校验码，前者和 meta 一起存储在 Meta SRAM 中，后者存储在单独的 Data Code SRAM 中。</p>
<p>当取指请求读取 SRAM 时，会同步读取出校验码，在 MainPipe 的 s1/s2 流水级中分别对 meta/data 进行校验。软件可以通过向 mmio-mapped CSR 中相应位置写入特定的值来使能/关闭这一功能，详见 <a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/05_ctrlunit/">CtrlUnit 文档</a>。</p>
<p>在校验码设计方面，ICache 使用的校验码可由参数控制，默认使用的是 parity code，即校验码为对数据做规约异或 $code = \oplus data$。检查时只需将校验码和数据一起做规约异或 $error = (\oplus data) \oplus code$，结果为 1 则发生错误，反之<strong>认为没有</strong>错误（可能出现偶数个错误，但此处检查不出来）。</p>
<p>ICache 支持错误注入，这要求 ICache 支持向 MetaArray/DataArray 写入错误的校验码。因此实现了一个<code>poison</code>位，当其拉高时，翻转写入的 code，即 $code = (\oplus data) \oplus poison$。</p>
<p>为了减少检查不出的情况，目前将 data 划分成 DataCodeUnit（默认为 64bit）的单元分别进行奇偶校验，因此对每个 64B 的缓存行，总计会计算 $8(data) + 1(meta) = 9$ 个校验码。</p>
<p>当 MainPipe 的 s1/s2 流水级检查到错误时，会进行以下处理：</p>
<p>在 6 月至 11 月的版本中：</p>
<ol>
<li>错误处理：引起 access fault 异常，由软件处理。</li>
<li>错误报告：向 BEU 报告错误，后者会引起中断向软件报告错误。</li>
<li>取消请求：当 MetaArray 被检查出错误时，其读出的 ptag 不可靠，进而对 hit 与否的判断不可靠，因此无论是否 hit 都不向 L2 Cache 发送请求，而是直接将异常传递到 IFU、进而传递到后端处理。</li>
</ol>
<p>在后续版本（<a href="https://github.com/OpenXiangShan/XiangShan/pull/3899">#3899</a> 后）实现了错误自动恢复机制，故只需进行以下处理：</p>
<ol>
<li>错误处理：从 L2 Cache 重新取指，见<a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#%e9%94%99%e8%af%af%e8%87%aa%e5%8a%a8%e6%81%a2%e5%a4%8d">错误自动恢复</a>。</li>
<li>错误报告：拉高 erros.valid 向顶层报告错误。</li>
</ol>
<h4 id="错误自动恢复">错误自动恢复</h4>
<p>注意到，ICache 与 DCache 不同，是只读的，因此其数据必然不是 dirty 的，这意味着我们总是可以从下级存储结构（L2/3 Cache、memory）中重新获取正确的数据。因此，ICache 可以通过向 L2 Cache 重新发起 miss 请求来实现错误自动恢复。</p>
<p>实现重取功能本身只需要复用现有的 miss 取指路径，走 MainPipe -&gt; MissUnit -&gt; MSHR &ndash;tilelink-&gt; L2 Cache 的请求路径。MissUnit 向 SRAM 重填数据时会自然地计算新的校验码并存储，因此在重取后会回到无错误的状态而不需要额外的处理。</p>
<p>6-11 月和后续代码行为差异的伪代码示意如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#a40000">- exception = itlb_exception || pmp_exception || ecc_error
</span></span></span><span style="display:flex;"><span><span style="color:#a40000"></span><span style="color:#00a000">+ exception = itlb_exception || pmp_exception
</span></span></span><span style="display:flex;"><span><span style="color:#00a000"></span>
</span></span><span style="display:flex;"><span><span style="color:#a40000">- should_fetch = !hit &amp;&amp; !exception
</span></span></span><span style="display:flex;"><span><span style="color:#a40000"></span><span style="color:#00a000">+ should_fetch = (!hit || ecc_error) &amp;&amp; !exception
</span></span></span></code></pre></div><p>需要留意的是：为了避免重取后出现 multi-hit（即，同一个 set 内存在多个 way 的 ptag 相同），需要在重取前将 metaArray 对应位置的 valid 清空：</p>
<ul>
<li>若 MetaArray 错误：meta 保存的 ptag 本身可能出错，命中结果（one-hot 的 waymask）不可靠，“对应位置”指该 set 的所有 way</li>
<li>若 DataArray 错误：命中结果可靠，“对应位置”指该 set 中 waymask 拉高的那一 way</li>
</ul>
<h4 id="错误注入">错误注入</h4>
<p>根据 RERI 手册<sup id="fnref1:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>的说明，为了使软件能够测试 ECC 功能，进而更好地判断硬件功能是否正常，需要提供错误注入功能，即主动地触发 ECC 错误。</p>
<p>ICache 的错误注入功能由 CtrlUnit 控制，通过向 mmio-mapped CSR 中相应位置写入特定的值来触发。详见 <a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/05_ctrlunit/">CtrlUnit 文档</a>。</p>
<p>目前 ICache 支持：</p>
<ul>
<li>向特定 paddr 注入，当请求注入的 paddr 未命中时，注入失败</li>
<li>向 MetaArray 或 DataArray 注入</li>
<li>当 ECC 校验功能本身未使能时，注入失败</li>
</ul>
<p>软件注入流程示意如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#f57900">inject_target:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#8f5902;font-style:italic"># maybe do something
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">ret</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f57900">test:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000">la</span> <span style="color:#000">t0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">$BASE_ADDR</span>     <span style="color:#8f5902;font-style:italic"># 载入 mmio-mapped CSR 基地址
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">la</span> <span style="color:#000">t1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">inject_target</span>  <span style="color:#8f5902;font-style:italic"># 载入注入目标地址
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">jalr</span> <span style="color:#000">ra</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">t1</span><span style="color:#000;font-weight:bold">)</span>        <span style="color:#8f5902;font-style:italic"># 跳转到注入目标以保证其加载到 ICache
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">sd</span> <span style="color:#000">t1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">8</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">t0</span><span style="color:#000;font-weight:bold">)</span>          <span style="color:#8f5902;font-style:italic"># 向 CSR 写入注入目标地址
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">la</span> <span style="color:#000">t2</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">$TARGET</span> <span style="color:#a40000">&lt;&lt;</span> <span style="color:#0000cf;font-weight:bold">2</span> <span style="color:#a40000">|</span> <span style="color:#0000cf;font-weight:bold">1</span> <span style="color:#a40000">&lt;&lt;</span> <span style="color:#0000cf;font-weight:bold">1</span> <span style="color:#a40000">|</span> <span style="color:#0000cf;font-weight:bold">1</span> <span style="color:#a40000">&lt;&lt;</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">)</span>  <span style="color:#8f5902;font-style:italic"># 设置注入目标、注入使能、校验使能
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">sd</span> <span style="color:#000">t1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">t0</span><span style="color:#000;font-weight:bold">)</span>          <span style="color:#8f5902;font-style:italic"># 向 CSR 写入注入请求
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#f57900">loop:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000">ld</span> <span style="color:#000">t1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">t0</span><span style="color:#000;font-weight:bold">)</span>          <span style="color:#8f5902;font-style:italic"># 读取 CSR
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">andi</span> <span style="color:#000">t1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">t1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000">b11</span> <span style="color:#a40000">&lt;&lt;</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#0000cf;font-weight:bold">4</span><span style="color:#a40000">+</span><span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000;font-weight:bold">))</span> <span style="color:#8f5902;font-style:italic"># 读取注入状态
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">beqz</span> <span style="color:#000">t1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">loop</span>         <span style="color:#8f5902;font-style:italic"># 如果注入未完成，继续等待
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#000">addi</span> <span style="color:#000">t1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">t1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#0000cf;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#000">bnez</span> <span style="color:#000">t1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">error</span>        <span style="color:#8f5902;font-style:italic"># 如果注入失败，跳转到错误处理
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#000">jalr</span> <span style="color:#000">ra</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">t1</span><span style="color:#000;font-weight:bold">)</span>        <span style="color:#8f5902;font-style:italic"># 注入成功，跳转到注入目标地址以触发错误
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>  <span style="color:#000">j</span>    <span style="color:#000">finish</span>           <span style="color:#8f5902;font-style:italic"># 结束
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f57900">error:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#8f5902;font-style:italic"># handle error
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#f57900">finish:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#8f5902;font-style:italic"># finish
</span></span></span></code></pre></div><p>我们编写了一个测试用例，见<a href="https://github.com/OpenXiangShan/nexus-am/pull/48">此仓库</a>，其测试了如下情况：</p>
<ol>
<li>正常注入 MetaArray</li>
<li>正常注入 DataArray</li>
<li>注入无效的目标</li>
<li>注入但 ECC 校验未使能</li>
<li>注入未命中的地址</li>
<li>尝试写入只读的 CSR 域</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<ol>
<li>Glenn Reinman, Brad Calder, and Todd Austin. &ldquo;<a href="https://doi.org/10.1109/MICRO.1999.809439">Fetch directed instruction prefetching.</a>&rdquo; 32nd Annual ACM/IEEE International Symposium on Microarchitecture (MICRO). 1999.</li>
</ol>
<mrs-functions>
<h2 id="icache-模块功能说明">ICache 模块功能说明</h2>
<hr>
<p>以下是<strong>IPrefetchPipe</strong>模块的功能</p>
<h3 id="1-接收预取请求">1. 接收预取请求</h3>
<p>从 FTQ 接收预取请求，请求可能有效（ io.req.valid 为高），可能无效； IPrefetchPipe 可能处于空闲（ io.req.ready 为高），可能处于非空闲状态。
只有在请求有效且 IPrefetchPipe 处于空闲状态时，预取请求才会被接收（这里暂不考虑 s0 的刷新信号 s0_flush ，默认其为低）。
预取请求分为不同类型，包括硬件预取请求 (isSoftPrefetch = false)和软件预取请求 (isSoftPrefetch = true)。
cacheline 也分为单 cacheline 和双 cacheline。</p>
<h4 id="11-硬件预取请求">1.1 硬件预取请求：</h4>
<p>预取请求为硬件 (isSoftPrefetch = false)</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1.1</td>
          <td>预取请求可以继续</td>
          <td>当预取请求有效且 IPrefetchPipe 处于空闲状态时，预取请求应该被接收。<br> s0_fire 信号在没有 s0 的刷新信号（ s0_flush 为低）时，应该被置为高。</td>
      </tr>
      <tr>
          <td>1.1.2</td>
          <td>预取请求被拒绝&ndash;预取请求无效</td>
          <td>当预取请求无效时，预取请求应该被拒绝。<br> s0_fire 信号应该被置为低。</td>
      </tr>
      <tr>
          <td>1.1.3</td>
          <td>预取请求被拒绝&ndash;IPrefetchPipe 非空闲</td>
          <td>当 IPrefetchPipe 非空闲时，预取请求应该被拒绝。<br> s0_fire 信号应该被置为低。</td>
      </tr>
      <tr>
          <td>1.1.4</td>
          <td>预取请求被拒绝&ndash;预取请求无效且 IPrefetchPipe 非空闲</td>
          <td>当预取请求无效且 IPrefetchPipe 非空闲时，预取请求应该被拒绝。<br>s0_fire 信号应该被置为低。</td>
      </tr>
      <tr>
          <td>1.1.5</td>
          <td>预取请求有效且为单 cacheline</td>
          <td>当预取请求有效且为单 cacheline 时，预取请求应该被接收。<br>s0_fire 为高，s0_doubleline 应该被置低（false）。</td>
      </tr>
      <tr>
          <td>1.1.6</td>
          <td>预取请求有效且为双 cacheline</td>
          <td>当预取请求有效且为双 cacheline 时，预取请求应该被接收。<br> s0_fire 为高，s0_doubleline 应该被置高（true）。</td>
      </tr>
  </tbody>
</table>
<h4 id="12-软件预取请求">1.2 软件预取请求：</h4>
<p>预取请求为软件 (isSoftPrefetch = true)</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.2.1</td>
          <td>软件预取请求可以继续</td>
          <td>当预取请求有效且 IPrefetchPipe 处于空闲状态时，软件预取请求应该被接收。<br>当预取请求有效且 IPrefetchPipe 处于空闲状态时，软件预取请求应该被接收。</td>
      </tr>
      <tr>
          <td>1.2.2</td>
          <td>软件预取请求被拒绝&ndash;预取请求无效</td>
          <td>当预取请求无效时，软件预取请求应该被拒绝。<br>s0_fire 信号应该被置为低。</td>
      </tr>
      <tr>
          <td>1.2.3</td>
          <td>软件预取请求被拒绝&ndash;IPrefetchPipe 非空闲</td>
          <td>当 IPrefetchPipe 非空闲时，软件预取请求应该被拒绝。<br>s0_fire 信号应该被置为低。</td>
      </tr>
      <tr>
          <td>1.2.4</td>
          <td>软件预取请求被拒绝&ndash;预取请求无效且 IPrefetchPipe 非空闲</td>
          <td>当预取请求无效且 IPrefetchPipe 非空闲时，软件预取请求应该被拒绝。<br> s0_fire 信号应该被置为低。</td>
      </tr>
      <tr>
          <td>1.2.5</td>
          <td>软件预取请求有效且为单 cacheline</td>
          <td>当软件预取请求有效且为单 cacheline 时，软件预取请求应该被接收。<br>s0_fire 为高，s0_doubleline 应该被置低（false）。</td>
      </tr>
      <tr>
          <td>1.2.6</td>
          <td>软件预取请求有效且为双 cacheline</td>
          <td>当软件预取请求有效且为双 cacheline 时，软件预取请求应该被接收。<br> s0_fire 为高，s0_doubleline 应该被置高（true）。</td>
      </tr>
  </tbody>
</table>
<h3 id="2-接收来自-itlb-的响应并处理结果">2. 接收来自 ITLB 的响应并处理结果</h3>
<p>接收 ITLB 的响应，完成虚拟地址到物理地址的转换。
当 ITLB 发生缺失（miss）时，保存请求信息，等待 ITLB 完成后再继续处理。</p>
<h4 id="21-地址转换完成">2.1 地址转换完成</h4>
<ul>
<li>根据 ITLB 的响应，接收物理地址（paddr），并完成地址转换。</li>
<li>处理 ITLB 响应可能在不同周期到达的情况，管理有效信号和数据保持机制，确保正确使用物理地址。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.1.1</td>
          <td>ITLB 正常返回物理地址</td>
          <td>ITLB 在一个周期内成功返回物理地址 paddr，s1_valid 为高。<br> 确认 s1 阶段正确接收到 paddr。</td>
      </tr>
      <tr>
          <td>2.1.2</td>
          <td>ITLB 发生 TLB 缺失，需要重试</td>
          <td>fromITLB(PortNumber).bits.miss 为高，表示对应通道的 ITLB 发生了 TLB 缺失，需要重发。<br> 重发完成后，后续步骤继续进行，fromITLB(PortNumber).bits.miss 为低。</td>
      </tr>
  </tbody>
</table>
<h4 id="22-处理-itlb-异常">2.2 处理 ITLB 异常</h4>
<ul>
<li>根据 ITLB 的异常信息，处理可能的异常。pf 缺页、pgf 虚拟机缺页、af 访问错误。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.2.1</td>
          <td>ITLB 发生页错误异常</td>
          <td>s1_itlb_exception 返回的页错误。<br> iTLB 返回的物理地址有效（fromITLB(PortNumber).bits.miss 为低），s1_itlb_exception 指示页错误 pf。</td>
      </tr>
      <tr>
          <td>2.2.2</td>
          <td>ITLB 发生虚拟机页错误异常</td>
          <td>s1_itlb_exception 返回的虚拟机页错误。<br> iTLB 返回的物理地址有效（fromITLB(PortNumber).bits.miss 为低），s1_itlb_exception 指示虚拟机页错误 pgf。</td>
      </tr>
      <tr>
          <td>2.2.3</td>
          <td>ITLB 发生访问错误异常</td>
          <td>s1_itlb_exception 返回的访问错误。<br> iTLB 返回的物理地址有效（fromITLB(PortNumber).bits.miss 为低），s1_itlb_exception 指示访问错误 af。</td>
      </tr>
  </tbody>
</table>
<h4 id="23-处理虚拟机物理地址用于虚拟化">2.3 处理虚拟机物理地址（用于虚拟化）</h4>
<ul>
<li>在虚拟化环境下，处理虚拟机物理地址（gpaddr），确定访问是否针对二级虚拟机的非叶子页表项（isForVSnonLeafPTE）。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.3.1</td>
          <td>发生虚拟机页错误异常返回虚拟机物理地址（gpaddr）</td>
          <td>发生 pgf 后，需要返回对应的 gpaddr。<br> 只有一个通道发生 pgf 时，返回对应通道的 gpaddr 即可；多个通道发生 pgf 时，返回第一个通道的 gpaddr。</td>
      </tr>
      <tr>
          <td>2.3.2</td>
          <td>ITLB 发生虚拟机页错误异常</td>
          <td>发生 gpf 后，如果是访问二级虚拟机的非叶子页表项时，需要返回对应的 gpaddr。<br> 只有一个通道发生 pgf 时，返回对应通道的 gpaddr 即可；多个通道发生 pgf 时，返回第一个通道的 gpaddr。</td>
      </tr>
  </tbody>
</table>
<h4 id="24-返回基于页面的内存类型-pbmt-信息">2.4 返回基于页面的内存类型 pbmt 信息</h4>
<ul>
<li>TLB 有效时，返回 pbmt 信息。</li>
</ul>
<h3 id="3-接收来自-imeta缓存元数据的响应并检查缓存命中">3. 接收来自 IMeta（缓存元数据）的响应并检查缓存命中</h3>
<p>从 Meta SRAM 中读取缓存标签和有效位。
将物理地址的标签部分与缓存元数据中的标签比较，确定是否命中。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>3.1</td>
          <td>缓存标签比较和有效位检查：</td>
          <td>从物理地址中提取物理标签（ptag），将其与缓存元数据中的标签进行比较，检查所有缓存路（Way）。检查有效位，确保只考虑有效的缓存行。</td>
      </tr>
      <tr>
          <td>3.1</td>
          <td>缓存未命中（标签不匹配或有效位为假）：</td>
          <td>当标签不匹配或者标签匹配，但是有效位为假时，表示缓存未命中。 <br>s1_meta_ptags(PortNumber)(nWays) 不等于 ptags(PortNumber) 或者它们相等，但是对应的 s1_meta_valids 为低时，总之返回的 waymasks 为全 0。</td>
      </tr>
      <tr>
          <td>3.2</td>
          <td>单路缓存命中（标签匹配且有效位为真）：</td>
          <td>当标签匹配，且有效位为真时，表示缓存命中。 <br>waymasks 对应的位为 1。</td>
      </tr>
  </tbody>
</table>
<h3 id="4-pmp物理内存保护权限检查">4. PMP（物理内存保护）权限检查</h3>
<p>对物理地址进行 PMP 权限检查，确保预取操作的合法性。
处理 PMP 返回的异常和 MMIO 信息</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>4.1</td>
          <td>访问被允许的内存区域</td>
          <td>itlb 返回的物理地址在 PMP 允许的范围内。 <br>s1_pmp_exception(i) 为 none。</td>
      </tr>
      <tr>
          <td>4.2</td>
          <td>访问被禁止的内存区域</td>
          <td>s1_req_paddr(i) 对应的地址在 PMP 禁止的范围内。 <br>s1_pmp_exception(i) 为 af。</td>
      </tr>
      <tr>
          <td>4.3</td>
          <td>访问 MMIO 区域</td>
          <td>itlb 返回的物理地址在 MMIO 区域。 <br>s1_pmp_mmio 为高。</td>
      </tr>
  </tbody>
</table>
<h3 id="5-异常处理和合并">5. 异常处理和合并</h3>
<p>backend 优先级最高，merge 方法里的异常越靠前优先级越高
合并来自后端、ITLB、PMP 的异常信息，按照优先级确定最终的异常类型。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>5.1</td>
          <td>仅 ITLB 产生异常</td>
          <td>s1_itlb_exception(i) 为非零，s1_pmp_exception(i) 为零。 <br>s1_exception_out(i) 正确包含 ITLB 异常。</td>
      </tr>
      <tr>
          <td>5.2</td>
          <td>仅 PMP 产生异常</td>
          <td>s1_itlb_exception(i) 为零，s1_pmp_exception(i) 为非零。 <br>s1_exception_out(i) 正确包含 PMP 异常。</td>
      </tr>
      <tr>
          <td>5.3</td>
          <td>仅 后端 产生异常</td>
          <td>s1_itlb_exception(i) 为零，s1_pmp_exception(i) 为零。 <br>s1_exception_out(i) 正确包含 后端 异常。</td>
      </tr>
      <tr>
          <td>5.4</td>
          <td>ITLB 和 PMP 都产生异常</td>
          <td>s1_itlb_exception(i) 和 s1_pmp_exception(i) 都为非零。 <br>s1_exception_out(i) 包含 ITLB 异常（优先级更高）。</td>
      </tr>
      <tr>
          <td>5.5</td>
          <td>ITLB 和 后端 都产生异常</td>
          <td>s1_itlb_exception(i) 和 s1_backendException(i) 都为非零。 <br>s1_exception_out(i) 包含 后端 异常（优先级更高）。</td>
      </tr>
      <tr>
          <td>5.6</td>
          <td>PMP 和 后端 都产生异常</td>
          <td>s1_pmp_exception(i) 和 s1_backendException(i) 都为非零。 <br>s1_exception_out(i) 包含 后端 异常（优先级更高）。</td>
      </tr>
      <tr>
          <td>5.7</td>
          <td>ITLB、PMP 和 后端 都产生异常</td>
          <td>s1_itlb_exception(i)、s1_pmp_exception(i) 和 s1_backendException(i) 都为非零。 <br>s1_exception_out(i) 包含 后端 异常（优先级更高）。</td>
      </tr>
      <tr>
          <td>5.8</td>
          <td>无任何异常</td>
          <td>s1_itlb_exception(i)、s1_pmp_exception(i)、s1_backendException(i) 都为零。 <br>s1_exception_out(i) 指示无异常。</td>
      </tr>
  </tbody>
</table>
<h3 id="6-发送请求到-waylookup-模块">6. 发送请求到 WayLookup 模块</h3>
<p>当条件满足时，将请求发送到 WayLookup 模块，以进行后续的缓存访问。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>6.1</td>
          <td>正常发送请求到 WayLookup</td>
          <td>toWayLookup.valid 为高，toWayLookup.ready 为高，s1_isSoftPrefetch 为假。 <br>请求成功发送，包含正确的地址、标签、waymask 和异常信息。</td>
      </tr>
      <tr>
          <td>6.2</td>
          <td>WayLookup 无法接收请求</td>
          <td>toWayLookup.valid 为高，toWayLookup.ready 为假。 <br>状态机等待 WayLookup 准备好，不会错误地推进。</td>
      </tr>
      <tr>
          <td>6.3</td>
          <td>软件预取请求不发送到 WayLookup</td>
          <td>s1_isSoftPrefetch 为真。 <br>toWayLookup.valid 为假，不会发送预取请求到 WayLookup。</td>
      </tr>
  </tbody>
</table>
<h3 id="7-状态机控制和请求处理流程">7. 状态机控制和请求处理流程</h3>
<p>使用状态机管理 s1 阶段的请求处理流程。
包括处理 ITLB 重发、Meta 重发、进入 WayLookup、等待 s2 准备等状态</p>
<h4 id="71-初始为-m_idle-状态">7.1 初始为 m_idle 状态</h4>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>7.1.1</td>
          <td>正常流程推进，保持 m_idle 状态</td>
          <td>s1_valid 为高，itlb_finish 为真，toWayLookup.fire 为真，s2_ready 为真。 <br>状态机保持在 m_idle 状态，s1 阶段顺利推进。</td>
      </tr>
      <tr>
          <td>7.1.2</td>
          <td>ITLB 未完成，需要重发</td>
          <td>s1_valid 为高，itlb_finish 为假。 <br>状态机进入 m_itlbResend 状态，等待 ITLB 完成。</td>
      </tr>
      <tr>
          <td>7.1.3</td>
          <td>ITLB 完成，WayLookup 未命中</td>
          <td>s1_valid 为高，itlb_finish 为真，toWayLookup.fire 为假。 <br>状态机进入 m_enqWay 状态，等待 WayLookup 入队。</td>
      </tr>
  </tbody>
</table>
<h4 id="72-初始为-m_itlbresend-状态">7.2 初始为 m_itlbResend 状态</h4>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>7.2.1</td>
          <td>ITLB 命中, MetaArray 空闲，需要 WayLookup 入队</td>
          <td>itlb_finish 为假，toMeta.ready 为真。 <br>状态机进入 m_enqWay 状态，等待 WayLookup 入队。</td>
      </tr>
      <tr>
          <td>7.2.2</td>
          <td>ITLB 命中, MetaArray 繁忙，等待 MetaArray 读请求</td>
          <td>itlb_finish 为假，toMeta.ready 为假。 <br>状态机进入 m_metaResend 状态，MetaArray 读请求</td>
      </tr>
  </tbody>
</table>
<h4 id="73-初始为-m_metaresend-状态">7.3 初始为 m_metaResend 状态</h4>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>7.3</td>
          <td>MetaArray 空闲 ，需要 WayLookup 入队</td>
          <td>toMeta.ready 为真。 <br>状态机进入 m_enqWay 状态，等待 WayLookup 入队。</td>
      </tr>
  </tbody>
</table>
<h4 id="74-初始为-m_enqway-状态">7.4 初始为 m_enqWay 状态</h4>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>7.4.1</td>
          <td>WayLookup 入队完成或者为软件预取, S2 空闲, 重新进入空闲状态</td>
          <td>toWayLookup.fire 或 s1_isSoftPrefetch 为真，s2_ready 为假。 <br>状态机进入空闲状态 m_idle。</td>
      </tr>
      <tr>
          <td>7.4.2</td>
          <td>WayLookup 入队完成或者为软件预取, S2 繁忙，需要 enterS2 状态</td>
          <td>toWayLookup.fire 或 s1_isSoftPrefetch 为真，s2_ready 为真。 <br>状态机进入 m_enterS2 状态，等待 s2 阶段准备好。</td>
      </tr>
  </tbody>
</table>
<h4 id="75-初始为-m_enters2-状态">7.5 初始为 m_enterS2 状态</h4>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>7.5</td>
          <td>s2 阶段准备好，请求进入下流水级，流入后进入 m_idle 状态</td>
          <td>s2_ready 为真。 <br>状态机进入空闲状态 m_idle。</td>
      </tr>
  </tbody>
</table>
<h3 id="8-监控-missunit-的请求">8. 监控 missUnit 的请求</h3>
<p>检查 missUnit 的响应，更新缓存的命中状态和 MSHR 的匹配状态。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>8.1</td>
          <td>请求与 MSHR 匹配且有效：</td>
          <td>s2_req_vSetIdx 和 s2_req_ptags 与 fromMSHR 中的数据匹配，且 fromMSHR.valid 为高，fromMSHR.bits.corrupt 为假。 <br>s2_MSHR_match(PortNumber) 为真, s2_MSHR_hits(PortNumber) 应保持为真</td>
      </tr>
      <tr>
          <td>8.2</td>
          <td>请求在 SRAM 中命中：</td>
          <td>s2_waymasks(PortNumber) 中有一位为高，表示在缓存中命中。 <br>s2_SRAM_hits(PortNumber) 为真,s2_hits(PortNumber) 应为真。</td>
      </tr>
      <tr>
          <td>8.3</td>
          <td>请求未命中 MSHR 和 SRAM：</td>
          <td>请求未匹配 MSHR，且 s2_waymasks(PortNumber) 为空。 <br>s2_MSHR_hits(PortNumber)、s2_SRAM_hits(PortNumber) 均为假, s2_hits(PortNumber) 为假。</td>
      </tr>
  </tbody>
</table>
<h3 id="9-发送请求到-missunit">9. 发送请求到 missUnit</h3>
<p>对于未命中的预取请求，向 missUnit 发送请求，以获取缺失的数据。</p>
<h4 id="91-确定需要发送给-missunit-的请求">9.1 确定需要发送给 missUnit 的请求</h4>
<p>根据命中状态、异常信息、MMIO 信息等，确定哪些请求需要发送到 missUnit（即 s2_miss）。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>9.1.1</td>
          <td>请求未命中且无异常，需要发送到 missUnit：</td>
          <td>s2_hits(PortNumber) 为假(未命中缓存)，s2_exception 无异常，s2_mmio 为假(不是 MMIO 或不可缓存的内存)。 <br>s2_miss(PortNumber) 为真，表示需要发送请求到 missUnit。</td>
      </tr>
      <tr>
          <td>9.1.2</td>
          <td>请求命中或有异常，不需要发送到 missUnit：</td>
          <td>s2_hits(i) 为真（已命中）或者 s2_exception 有异常 或者 s2_mmio 为真（MMIO 访问）。 <br>s2_miss(i) 为假，不会发送请求到 missUnit。</td>
      </tr>
      <tr>
          <td>9.1.3</td>
          <td>双行预取时，处理第二个请求的条件：</td>
          <td>s2_doubleline 为真，处理第二个请求。 <br>如果第一个请求有异常或 MMIO，s2_miss(1) 应为假，后续请求被取消或处理。</td>
      </tr>
  </tbody>
</table>
<h4 id="92-避免发送重复请求发送请求到-missunit">9.2 避免发送重复请求，发送请求到 missUnit</h4>
<ul>
<li>使用寄存器 has_send 记录每个端口是否已发送请求，避免重复发送。</li>
<li>将需要发送的请求通过仲裁器 toMSHRArbiter 发送到 missUnit。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>9.2.1</td>
          <td>在 s1_real_fire 时，复位 has_send：</td>
          <td>s1_real_fire 为高。 <br>has_send(PortNumber) 应被复位为假，表示新的请求周期开始。</td>
      </tr>
      <tr>
          <td>9.2.2</td>
          <td>当请求成功发送时，更新 has_send：</td>
          <td>toMSHRArbiter.io.in(PortNumber).fire 为高（请求已发送）。 <br>has_send(PortNumber) 被设置为真，表示该端口已发送请求。</td>
      </tr>
      <tr>
          <td>9.2.3</td>
          <td>避免重复发送请求：</td>
          <td>同一请求周期内，has_send(PortNumber) 为真，s2_miss(PortNumber) 为真。 <br>toMSHRArbiter.io.in(PortNumber).valid 为假，不会再次发送请求。</td>
      </tr>
      <tr>
          <td>9.2.4</td>
          <td>正确发送需要的请求到 missUnit：</td>
          <td>s2_valid 为高，s2_miss(i) 为真，has_send(i) 为假。 <br>toMSHRArbiter.io.in(i).valid 为高，请求被成功发送。</td>
      </tr>
      <tr>
          <td>9.2.5</td>
          <td>仲裁器正确仲裁多个请求：</td>
          <td>多个端口同时需要发送请求。 <br>仲裁器按照优先级或设计要求选择请求发送到 missUnit,未被选中的请求在下个周期继续尝试发送。</td>
      </tr>
  </tbody>
</table>
<h3 id="10-刷新机制">10. 刷新机制</h3>
<ul>
<li>io.flush: 全局刷新信号，当该信号为高时，所有请求都需要刷新。</li>
<li>from_bpu_s0_flush：当请求不是软件预取（!s0_isSoftPrefetch, 软件预取请求是由特定的指令触发的，与指令流中的分支预测无关。因此，在处理刷新信号时，对于软件预取请求，通常不受来自 BPU 的刷新信号影响。），且 BPU 指示需要在 Stage 2 或 Stage 3 刷新的请求，由于该请求尚未进入 s1 阶段，因此在 s0 阶段也需要刷新。</li>
<li>s0_flush：综合考虑全局刷新信号、来自 BPU 的刷新信号，以及 s1 阶段的刷新信号</li>
<li>from_bpu_s1_flush：当 s1 阶段的请求有效且不是软件预取，且 BPU 指示在 Stage 3 需要刷新，则在 s1 阶段需要刷新。</li>
<li>io.itlbFlushPipe：当 s1 阶段需要刷新时，该信号用于通知 ITLB 刷新其流水线，以保持一致性。</li>
<li>s1_flush：综合考虑全局刷新信号和来自 BPU 的刷新信号。</li>
<li>s2_flush：用于控制 s2 阶段是否需要刷新。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>10.1</td>
          <td>发生全局刷新</td>
          <td>io.flush 为高。 <br>s0_flush、s1_flush、s2_flush 分别为高，所有阶段的请求被正确清除。</td>
      </tr>
      <tr>
          <td>10.2</td>
          <td>来自 BPU 的刷新</td>
          <td>io.flushFromBpu.shouldFlushByStageX 为真（X 为 2 或 3），且请求不是软件预取。 <br>对应阶段的 from_bpu_sX_flush 为高，sX_flush 为高，阶段请求被刷新。</td>
      </tr>
      <tr>
          <td>10.3</td>
          <td>刷新时状态机复位</td>
          <td>s1_flush 为高。 <br>状态机 state 被重置为 m_idle 状态。</td>
      </tr>
      <tr>
          <td>10.4</td>
          <td>ITLB 管道同步刷新</td>
          <td>s1_flush 为高。 <br>io.itlbFlushPipe 为高，ITLB 被同步刷新。</td>
      </tr>
  </tbody>
</table>
<hr>
<p>以下是<strong>MainPipe</strong>模块的功能</p>
<h3 id="11-访问-dataarray-的单路">11. 访问 DataArray 的单路</h3>
<p>根据从 WayLookup 获取信息，包括路命中信息和 ITLB 查询结果还有 DataArray 当前的情况，决定是否需要从 DataArray 中读取数据。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>11.1</td>
          <td>访问 DataArray 的单路</td>
          <td>当 WayLookup 中的信息表明路命中时，ITLB 查询成功，并且 DataArray 当前没有写时，MainPipe 会向 DataArray 发送读取请求，以获取数据。 <br>s0_hits 为高（一路命中），s0_itlb_exception 信号为零（ITLB 查询成功），toData.last.ready 为高（DataArray 没有正在进行的写操作）。 <br>toData.valid 信号为高，表示 MainPipe 向 DataArray 发出了读取请求。</td>
      </tr>
      <tr>
          <td>11.2</td>
          <td>不访问 DataArray（Way 未命中） ==会访问，但是返回数据无效==</td>
          <td>当 WayLookup 中的信息表明路未命中时，MainPipe 不会向 DataArray 发送读取请求。 <br>s0_hits 为低表示缓存未命中 <br>toData.valid 信号为低，表示 MainPipe 未向 DataArray 发出读取请求。</td>
      </tr>
      <tr>
          <td>11.3</td>
          <td>不访问 DataArray（ITLB 查询失败）==会访问，但是返回数据无效==</td>
          <td>当 ITLB 查询失败时，MainPipe 不会向 DataArray 发送读取请求。 <br>s0_itlb_exception 信号不为零（ITLB 查询失败）。 <br>toData.valid 信号为低，表示 MainPipe 未向 DataArray 发出读取请求。</td>
      </tr>
      <tr>
          <td>11.4</td>
          <td>不访问 DataArray（DataArray 正在进行写操作）</td>
          <td>当 DataArray 正在进行写操作时，MainPipe 不会向 DataArray 发送读取请求。 <br>toData.last.ready 信号为低，表示 DataArray 正在进行写操作。 <br>toData.valid 信号为低，表示 MainPipe 未向 DataArray 发出读取请求。</td>
      </tr>
  </tbody>
</table>
<h3 id="12-meta-ecc-校验">12. Meta ECC 校验</h3>
<p>将物理地址的标签部分与对应的 Meta 进行 ECC 校验，以确保 Meta 的完整性。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>12.1</td>
          <td>无 ECC 错误</td>
          <td>当 waymask 全为 0（没有命中），则 hit_num 为 0 或 waymask 有一位为 1（一路命中），hit_num 为 1 且 ECC 对比通过（encodeMetaECC(meta) == code） <br>s1_meta_corrupt 为假。</td>
      </tr>
      <tr>
          <td>12.2</td>
          <td>单路命中的 ECC 错误</td>
          <td>当 waymask 有一位为 1（一路命中），ECC 对比失败（encodeMetaECC(meta) != code） <br>s1_data_corrupt(i)， io.errors(i).valid， io.errors(i).bits.report_to_beu， io.errors(i).bits.source.data 为 true。</td>
      </tr>
      <tr>
          <td>12.3</td>
          <td>多路命中</td>
          <td>&gt; hit multi-way, must be an ECC failure <br>当 waymask 有两位及以上为 1（多路命中），视为 ECC 错误。 <br>s1_data_corrupt(i)， io.errors(i).valid， io.errors(i).bits.report_to_beu， io.errors(i).bits.source.data 为 true。</td>
      </tr>
      <tr>
          <td>12.4</td>
          <td>ECC 功能关闭</td>
          <td>当奇偶校验关闭时（ecc_enable 为低），强制清除 s1_meta_corrupt 信号置位。 <br>不管是否发生 ECC 错误，s1_meta_corrupt 都为假。</td>
      </tr>
  </tbody>
</table>
<h3 id="13-pmp-检查">13. PMP 检查</h3>
<ul>
<li>将 S1 的物理地址 s1_req_paddr(i) 和指令 TlbCmd.exec 发往 PMP，判断取指是否合法。</li>
<li>防止非法地址，区分普通内存和 MMIO 内存。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>13.1</td>
          <td>没有异常</td>
          <td>s1_pmp_exception 为全零，表示没有 PMP 异常。</td>
      </tr>
      <tr>
          <td>13.2</td>
          <td>通道 0 有 PMP 异常</td>
          <td>s1_pmp_exception(0) 为真，表示通道 0 有 PMP 异常。</td>
      </tr>
      <tr>
          <td>13.3</td>
          <td>通道 1 有 PMP 异常</td>
          <td>s1_pmp_exception(1) 为真，表示通道 1 有 PMP 异常。</td>
      </tr>
      <tr>
          <td>13.4</td>
          <td>通道 0 和通道 1 都有 PMP 异常</td>
          <td>s1_pmp_exception(0) 和 s1_pmp_exception(1) 都为真，表示通道 0 和通道 1 都有 PMP 异常。</td>
      </tr>
      <tr>
          <td>13.5</td>
          <td>没有映射到 MMIO 区域</td>
          <td>s1_pmp_mmio（0） 和 s1_pmp_mergemmio（1） 都为假，表示没有映射到 MMIO 区域。</td>
      </tr>
      <tr>
          <td>13.6</td>
          <td>通道 0 映射到了 MMIO 区域</td>
          <td>s1_pmp_mmio（0） 为真，表示映射到了 MMIO 区域。</td>
      </tr>
      <tr>
          <td>13.7</td>
          <td>通道 1 映射到了 MMIO 区域</td>
          <td>s1_pmp_mmio（1） 为真，表示映射到了 MMIO 区域。</td>
      </tr>
      <tr>
          <td>13.8</td>
          <td>通道 0 和通道 1 都映射到了 MMIO 区域</td>
          <td>s1_pmp_mmio（0） 和 s1_pmp_mmio（1） 都为真，表示通道 0 和通道 1 都映射到了 MMIO 区域。</td>
      </tr>
  </tbody>
</table>
<h3 id="14-异常合并">14. 异常合并</h3>
<ul>
<li>将 s1_itlbmergeption 与 s1_pmp_exception 合并生成 s1_exception_out。</li>
<li>ITLB 异常通常优先于 PMP 异常。merge</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>14.1</td>
          <td>没有异常</td>
          <td>s1_exception_out 为全零，表示没有异常。</td>
      </tr>
      <tr>
          <td>14.2</td>
          <td>只有 ITLB 异常</td>
          <td>s1_exception_out 和 s1_itlb_exception 一致</td>
      </tr>
      <tr>
          <td>14.3</td>
          <td>只有 PMP 异常</td>
          <td>s1_exception_out 和 s1_pmp_exception 一致</td>
      </tr>
      <tr>
          <td>14.4</td>
          <td>ITLB 与 PMP 异常同时出现</td>
          <td>&gt; itlb has the highest priority, pmp next <br>s1_exception_out 和 s1_itlb_exception 一致</td>
      </tr>
  </tbody>
</table>
<h3 id="15-mshr-匹配和数据选择">15. MSHR 匹配和数据选择</h3>
<ul>
<li>检查当前的请求是否与 MSHR 中正在处理的缺失请求匹配。</li>
<li>判断 缓存组索引相同(s1_req_vSetIdx(i) == fromMSHR.bits.vSetIdx) ，物理标签相同 (s1_req_ptags(i) == fromMSHR.bits.blkPaddr)；若匹配 MSHR 有效且没有错误（fromMSHR.valid &amp;&amp; !fromMSHR.bits.corrupt），则优先使用 MSHR 中的数据</li>
<li>避免重复访问 Data SRAM，提升性能；当 MSHR 中已有重填结果时，可立即命中。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>15.1</td>
          <td>命中 MSHR</td>
          <td>MSHR 中已有正确数据时，S1 阶段能直接拿到 <br>s1_MSHR_hits(i) 为 true 时，s1_datas(i) 为 s1_bankMSHRHit(i)，s1_data_is_from_MSHR(i) 为 true</td>
      </tr>
      <tr>
          <td>15.2</td>
          <td>未命中 MSHR</td>
          <td>MSHR 中存放的地址与当前请求不同，那么应该读取 SRAM 的数据 <br>s1_MSHR_hits(i) 为 true 时，s1_datas(i) 为 fromData.datas(i)，s1_data_is_from_MSHR(i) 为 false</td>
      </tr>
      <tr>
          <td>15.3</td>
          <td>MSHR 数据 corrupt</td>
          <td>fromMSHR.bits.corrupt = true，那么 MSHR 将不匹配，应该读取 SRAM 的数据 <br>s1_datas(i) 为 fromData.datas(i)，s1_data_is_from_MSHR(i) 为 false</td>
      </tr>
  </tbody>
</table>
<h3 id="16-data-ecc-校验">16. Data ECC 校验</h3>
<p>在 S2 阶段，对从 S1 或 MSHR 获得的数据（如 s2_datas）进行 ECC 校验：</p>
<ul>
<li>若 ECC 校验失败，则标记 s2_data_corrupt(i) = true。</li>
<li>若数据来自 MSHR，则不重复进行 ECC 校验（或忽略 corrupt）</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>16.1</td>
          <td>无 ECC 错误</td>
          <td>s2_bank 全部没有损坏，bank 也选对了对应的端口和 bank，数据不来自 MSHR <br>s2_data_corrupt(i) 为 false，没有 ECC 错误。</td>
      </tr>
      <tr>
          <td>16.2</td>
          <td>单 Bank ECC 错误</td>
          <td>s2_bank_corrupt(bank) 有一个为 true ,即对应的 bank 有损坏；同时 bank 也选对了对应的端口和 bank，数据不来自 MSHR <br>s2_data_corrupt(i)， io.errors(i).valid， io.errors(i).bits.report_to_beu， io.errors(i).bits.source.data 为 true。</td>
      </tr>
      <tr>
          <td>16.3</td>
          <td>多 Bank ECC 错误</td>
          <td>s2_bank_corrupt(bank) 有两个或以上为 true,即对应的 bank 有损坏；同时 bank 也选对了对应的端口和 bank，数据不来自 MSHR <br>s2_data_corrupt(i)， io.errors(i).valid， io.errors(i).bits.report_to_beu， io.errors(i).bits.source.data 为 true。</td>
      </tr>
      <tr>
          <td>16.4</td>
          <td>ECC 功能关闭</td>
          <td>当奇偶校验关闭时（ecc_enable 为低），强制清除 s2_data_corrupt 信号置位。 <br>不管是否发生 ECC 错误，s2_data_corrupt 都为假。</td>
      </tr>
  </tbody>
</table>
<h3 id="17-冲刷-metaarray">17. 冲刷 MetaArray</h3>
<p>Meta 或者 Data ECC 校验错误时，会冲刷 MetaArray，为重取做准备。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>17.1</td>
          <td>只有 Meta ECC 校验错误</td>
          <td>&gt; if is meta corrupt, clear all way (since waymask may be unreliable) <br>当 s1_meta_corrupt 为真时，MetaArray 的所有路都会被冲刷。 <br>toMetaFlush(i).valid 为真，toMetaFlush(i).bits.waymask 对应端口的所有路置位。</td>
      </tr>
      <tr>
          <td>17.2</td>
          <td>只有 Data ECC 校验错误</td>
          <td>&gt; if is data corrupt, only clear the way that has error <br>当 s2_data_corrupt 为真时，只有对应路会被冲刷。 <br>toMetaFlush(i).valid 为真，toMetaFlush(i).bits.waymask 对应端口的对应路置位。</td>
      </tr>
      <tr>
          <td>17.3</td>
          <td>同时有 Meta ECC 校验错误和 Data ECC 校验错误</td>
          <td>处理 Meta ECC 的优先级更高， 将 MetaArray 的所有路冲刷。 <br>toMetaFlush(i).valid 为真，toMetaFlush(i).bits.waymask 对应端口的所有路置位。</td>
      </tr>
  </tbody>
</table>
<h3 id="18-监控-mshr-匹配与数据更新">18. 监控 MSHR 匹配与数据更新</h3>
<ul>
<li>判断是否命中 MSHR</li>
<li>根据 MSHR 是否命中和 s1 阶段是否发射来更新 s2 的数据，s2 的命中状态和 l2 是否损坏</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>18.1</td>
          <td>MSHR 命中（匹配且本阶段有效）</td>
          <td>MSHR 的 vSetIdx / blkPaddr 与 S2 请求一致， fromMSHR.valid 有效，s2_valid 也有效 <br>s2_MSHR_match，s2_MSHR_hits 为高，s2_bankMSHRHit 对应 bank 为高 <br>s1_fire 无效时，s2_datas 更新为 MSHR 的数据，将 s2_data_is_from_MSHR 对应位置位，s2_hits 置位，清除 s2_data_corrupt，l2 的 corrupt 更新为 fromMSHR.bits.corrupt <br>s1_fire 有效时，s2_datas 为 s1_datas 的数据，将 s2_data_is_from_MSHR 对应位置为 s1 的 s1_data_is_from_MSHR，s2_hits 置为 s1_hits，清除 s2_data_corrupt，l2 的 corrupt 为 false</td>
      </tr>
      <tr>
          <td>18.2</td>
          <td>MSHR 未命中</td>
          <td>MSHR 的 vSetIdx / blkPaddr 与 S2 请求一致， fromMSHR.valid 有效，s2_valid 也有效，至少有一个未达成 <br>s2_MSHR_hits(i) = false，S2 不会更新 s2_datas，继续保持原先 SRAM 数据或进入 Miss 流程。</td>
      </tr>
  </tbody>
</table>
<h3 id="19-miss-请求发送逻辑和合并异常">19. Miss 请求发送逻辑和合并异常</h3>
<ul>
<li>通过计算 s2_should_fetch(i) 判断是否需要向 MSHR 发送 Miss 请求：
<ul>
<li>当出现未命中 (!s2_hits(i)) 或 ECC 错误(s2_meta_corrupt(i) || s2_data_corrupt(i)) 时，需要请求重新获取。</li>
<li>若端口存在异常或处于 MMIO 区域，则不发送 Miss 请求。</li>
</ul>
</li>
<li>使用 Arbiter 将多个端口的请求合并后发送至 MSHR。</li>
<li>通过 s2_has_send(i) 避免重复请求。</li>
<li>将 S2 阶段已有的 ITLB/PMP 异常（s2_exception）与 L2 Cache 报告的 s2_l2_corrupt(i)（封装后为 s2_l2_exception(i)）进行合并。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
          <th></th>
          <th></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>19.1</td>
          <td>未发生 Miss</td>
          <td>当 s2_hits(i) 为高（s2 已经命中），s2 的 meta 和 data 都没有错误，s2 异常，处于 mmio 区域 <br>以上条件至少满足一个时，s2_should_fetch(i) 为低，表示不发送 Miss 请求。</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>19.2</td>
          <td>单口 Miss</td>
          <td>当出现未命中 (!s2_hits(i)) 或 ECC 错误(s2_meta_corrupt(i) <br>s2_data_corrupt(i))，端口不存在异常且未处于 MMIO 区域时，会向 MSHR 发送 Miss 请求。 <br>toMSHRArbiter.io.in(i).valid = true ，Arbiter 只发送一条 Miss 请求。</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>19.3</td>
          <td>双口都需要 Miss</td>
          <td>同上，但是两个端口都满足 s2_should_fetch 为高的条件。 <br>toMSHRArbiter.io.in(0).valid、toMSHRArbiter.io.in(1).valid 均为 true，Arbiter 根据仲裁顺序依次发出请求。</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>19.4</td>
          <td>重复请求屏蔽</td>
          <td>当 s1_fire 为高，表示可以进入 s2 阶段,那么 s2 还没有发送 s2_has_send(i) := false.B <br>如果已经有请求发送了，那么对应的 toMSHRArbiter.io.in(i).fire 为高，表示对应的请求可以发送，s2_has_send(i) := true。 <br>此时再次发送，toMSHRArbiter.io.in(i).valid 为低，表示发送失败。</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>19.5</td>
          <td>仅 ITLB/PMP 异常</td>
          <td>S1 阶段已记录了 ITLB 或 PMP 异常，L2 corrupt = false。 <br>2_exception_out 仅保留 ITLB/PMP 异常标记，无新增 AF 异常。</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>19.6</td>
          <td>仅 L2 异常</td>
          <td>S2 阶段 s2_l2_corrupt(i) = true，且无 ITLB/PMP 异常。 <br>s2_exception_out(i) 表示 L2 访问错误(AF)。</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>19.7</td>
          <td>ITLB + L2 同时出现</td>
          <td>同时触发 ITLB 异常和 L2 corrupt。 <br>s2_exception_out 优先保留 ITLB 异常类型，不被 L2 覆盖。</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>19.8</td>
          <td>s2 阶段取指完成</td>
          <td>s2_should_fetch 的所有端口都为低，表示需要取指，那么取指完成 <br>s2_fetch_finish 为高</td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="20-响应-ifu">20. 响应 IFU</h3>
<ul>
<li>若当前周期 S2 成功发射（s2_fire = true）且数据获取完毕（s2_fetch_finish），则把数据、异常信息、物理地址等打包到 toIFU.bits 输出。</li>
<li>若为双行请求（s2_doubleline = true），也会向 IFU 发送第二路的信息（地址、异常）。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>20.1</td>
          <td>正常命中并返回</td>
          <td>不存在任何异常或 Miss，s2 命中，s2 阶段取指完成，外部的 respStall 停止信号也为低 。 <br>toIFU.valid = true，toIFU.bits.data 为正确的 Cacheline 数据，toIFU.bits.exception、pmp_mmio、itlb_pbmt = none。</td>
      </tr>
      <tr>
          <td>20.2</td>
          <td>异常返回</td>
          <td>设置 ITLB、PMP、或 L2 corrupt 异常。 <br>toIFU.bits.exception(i) = 对应异常类型，pmp_mmio、itlb_pbmt 根据是否有对应的异常设置为 true。</td>
      </tr>
      <tr>
          <td>20.3</td>
          <td>跨行取指</td>
          <td>s2_doubleline = true，同时检查第一路、第二路返回情况。 <br>toIFU.bits.doubleline = true。 <br>若第二路正常，toIFU.bits.exception(1) = none；若第二路异常，则 exception(1) 标记相应类型。 <br>pmp_mmio、itlb_pbmt 类似。</td>
      </tr>
      <tr>
          <td>20.4</td>
          <td>RespStall</td>
          <td>外部 io.respStall = true，导致 S2 阶段无法发射到 IFU。 <br>s2_fire = false，toIFU.valid 也不拉高，S2 保持原状态等待下一拍（或直到 respStall 解除）。</td>
      </tr>
  </tbody>
</table>
<h3 id="21-l2-corrupt-报告">21. L2 Corrupt 报告</h3>
<ul>
<li>当检测到 L2 Cache 返回的 corrupt 标记时（s2_l2_corrupt(i) = true），在 S2 完成发射后额外向外部错误接口 io.errors(i) 报告。</li>
<li>与 Data ECC 或 Meta ECC 不同，L2 corrupt 由 L2 自己报告给 BEU，这里不需要再次报告给 beu。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>21.1</td>
          <td>L2 Corrupt 单路</td>
          <td>s2 阶段准备完成可以发射（s2_fire 为高），s2_MSHR_hits(0)和 fromMSHR.bits.corrupt 为高 <br>s2_l2_corrupt(0) = true，io.errors(0).valid = true，io.errors(0).bits.source.l2 = true。</td>
      </tr>
      <tr>
          <td>21.2</td>
          <td>双路同时 corrupt</td>
          <td>端口 0 和端口 1 都从 L2 corrupt 数据中获取。 <br>s2_l2_corrupt 均为 true，发射后分别报告到 io.errors(0) 和 io.errors(1)。</td>
      </tr>
  </tbody>
</table>
<h3 id="22-刷新机制">22. 刷新机制</h3>
<ul>
<li>io.flush：外部的全局刷新信号，它用于指示整个流水线需要被冲刷（清空）。</li>
<li>s0_flush： S0 阶段内部的刷新信号，它由 io.flush 传递而来，用于控制 S0 阶段的刷新操作。</li>
<li>s1_flush： S1 阶段内部的刷新信号，它由 io.flush 传递而来，用于控制 S1 阶段的刷新操作。</li>
<li>s2_flush： S2 阶段内部的刷新信号，它由 io.flush 传递而来，用于控制 S2 阶段的刷新操作。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>22.1</td>
          <td>全局刷新</td>
          <td>io.flush 被激活时，流水线的各个阶段（S0, S1 和 S2）都能正确响应并执行刷新操作。 <br>io.flush = true。 <br>s0_flush, s1_flush, s2_flush = true。</td>
      </tr>
      <tr>
          <td>22.2</td>
          <td>S0 阶段刷新</td>
          <td>s0_flush = true。 <br>s0_fire = false。</td>
      </tr>
      <tr>
          <td>22.3</td>
          <td>S1 阶段刷新</td>
          <td>s1_flush = true。 <br>s1_valid， s1_fire = false。</td>
      </tr>
      <tr>
          <td>22.4</td>
          <td>S2 阶段刷新</td>
          <td>s2_flush = true。 <br>s2_valid， toMSHRArbiter.io.in(i).valid ， s2_fire = false</td>
      </tr>
  </tbody>
</table>
<hr>
<p>以下是<strong>WayLookup</strong>模块的功能</p>
<h3 id="23-刷新操作">23. 刷新操作</h3>
<ul>
<li>接收到全局刷新刷新信号 io.flush 后，读、写指针和 GPF 信息都被重置。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>23.1</td>
          <td>刷新读指针</td>
          <td>io.flush 为高时，重置读指针。 <br>readPtr.value 为 0， readPtr.flag 为 false。</td>
      </tr>
      <tr>
          <td>23.2</td>
          <td>刷新写指针</td>
          <td>io.flush 为高时，重置写指针。 <br>writePtr.value 为 0， writePtr.flag 为 false。</td>
      </tr>
      <tr>
          <td>23.3</td>
          <td>刷新 GPF 信息</td>
          <td>io.flush 为高时，重置 GPF 信息。 <br>gpf_entry.valid 为 0， gpf_entry.bits 为 0。</td>
      </tr>
  </tbody>
</table>
<h3 id="24-读写指针更新">24. 读写指针更新</h3>
<ul>
<li>读写信号握手完毕之后（io.read.fire/io.write.fire 为高），对应指针加一。</li>
<li>因为是在环形队列上，所以超过队列大小后，指针会回到队列头部。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>24.1</td>
          <td>读指针更新</td>
          <td>当 io.read.fire 为高时，读指针加一。 <br>readPtr.value 加一。 <br>如果 readPtr.value 超过环形队列的大小，readPtr.flag 会翻转。</td>
      </tr>
      <tr>
          <td>24.2</td>
          <td>写指针更新</td>
          <td>当 io.write.fire 为高时，写指针加一。 <br>writePtr.value 加一。 <br>如果 writePtr.value 超过环形队列的大小，writePtr.flag 会翻转。</td>
      </tr>
  </tbody>
</table>
<h3 id="25-更新操作">25. 更新操作</h3>
<ul>
<li>MissUnit 处理完 Cache miss 后，向 WayLookup 写入命中信息，也就是 update 操作。</li>
<li>情况分为两种：
<ul>
<li>命中：更新 waymask 和 meta_codes。</li>
<li>未命中：重置 waymask。</li>
</ul>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>25.1</td>
          <td>命中更新</td>
          <td>MissUnit 返回的更新信息和 WayLookup 的信息相同时，更新 waymask 和 meta_codes。 <br>vset_same 和 ptag_same 为真。 <br>waymask 和 meta_codes 更新。 <br>hits 对应位为高。</td>
      </tr>
      <tr>
          <td>25.2</td>
          <td>未命中更新</td>
          <td>vset_same 和 way_same 为真。 <br>waymask 清零。 <br>hit 对应位为高。</td>
      </tr>
      <tr>
          <td>25.3</td>
          <td>不更新</td>
          <td>其他情况下不更新。 <br>vset_same 为假或者 ptag_same 和 way_same 都为假。 <br>hits 对应位为低。</td>
      </tr>
  </tbody>
</table>
<h3 id="26-读操作">26. 读操作</h3>
<ul>
<li>读操作会根据读指针从环形队列中读取信息。</li>
<li>如果达成了绕过条件，优先绕过。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>26.1</td>
          <td>Bypass 读</td>
          <td>队列为空，并且 io.write.valid 写有效时，可以直接读取，而不经过队列。 <br>empty 和 io.write.valid 都为真。 <br>io.read.bits = io.write.bits</td>
      </tr>
      <tr>
          <td>26.2</td>
          <td>读信号无效</td>
          <td>队列为空（readPtr === writePtr）且写信号 io.write.valid 为低。 <br>io.read.valid 为低，读信号无效。</td>
      </tr>
      <tr>
          <td>26.3</td>
          <td>正常读</td>
          <td>未达成绕过条件（empty 和 io.write.valid 至少有一个为假）且 io.read.valid 为高。 <br>从环形队列中读取信息。 <br>io.read.bits.entry = entries(readPtr.value)</td>
      </tr>
      <tr>
          <td>26.4</td>
          <td>gpf 命中</td>
          <td>io.read.valid 为高，可以读。 <br>当 gpf_hits 为高时，从 GPF 队列中读取信息。 <br>io.read.bits.gpf = gpf_entry.bits</td>
      </tr>
      <tr>
          <td>26.5</td>
          <td>gpf 命中且被读取</td>
          <td>io.read.valid 为高，可以读。 <br>&gt; also clear gpf_entry.valid when it&rsquo;s read <br>当 gpf 命中且被读取其时（io.read.fire 为高），gpf_entry.valid 会被置为 0。</td>
      </tr>
      <tr>
          <td>26.6</td>
          <td>gpf 未命中</td>
          <td>io.read.valid 为高，可以读。 <br>io.read.bits.gpf 清零。</td>
      </tr>
  </tbody>
</table>
<h3 id="27-写操作">27. 写操作</h3>
<ul>
<li>写操作会根据写指针从环形队列中读取信息。</li>
<li>如果有 gpf 停止，就会停止写。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>27.1</td>
          <td>gpf 停止</td>
          <td>&gt; if there is a valid gpf to be read, we should stall write <br>gpf 队列数据有效，并且没有被读取或者没有命中，就会产生 gpf 停止，此时写操作会被停止。 <br>gpf_entry.valid &amp;&amp; !(io.read.fire &amp;&amp; gpf_hit) 为高时，写操作会被停止（io.write.ready 为低）。</td>
      </tr>
      <tr>
          <td>27.2</td>
          <td>写就绪无效</td>
          <td>当队列为满（(readPtr.value === writePtr.value) &amp;&amp; (readPtr.flag ^ writePtr.flag)）或者 gpf 停止时，写操作会被停止。 <br>（io.write.ready 为低）</td>
      </tr>
      <tr>
          <td>27.3</td>
          <td>正常写</td>
          <td>当 io.write.valid 为高时（没满且没有 gpf 停止），写操作会被执行。 <br>正常握手完毕 io.write.fire 为高。 <br>写信息会被写入环形队列。 <br>entries(writePtr.value) = io.write.bits.entry。</td>
      </tr>
  </tbody>
</table>
<h4 id="274-有-itlb-异常的写">27.4 有 ITLB 异常的写</h4>
<ul>
<li>前面与正常写相同，只不过当写信息中存在 ITLB 异常时，会更新 gpf 队列和 gpf 指针。</li>
<li>此时如果已经被绕过直接读取了，那么就不需要存储它了。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>27.4.1</td>
          <td>被绕过直接读取了</td>
          <td>can_bypass 和 io.read.fire 都为高。 <br>gpf_entry.valid 为 false。 <br>gpf_entry.bits = io.write.bits.gpf <br>gpfPtr = writePtr <br></td>
      </tr>
      <tr>
          <td>27.4.2</td>
          <td>没有被绕过直接读取</td>
          <td>can_bypass 为低。 <br>gpf_entry.valid 为 true。 <br>gpf_entry.bits = io.write.bits.gpf <br>gpfPtr = writePtr</td>
      </tr>
  </tbody>
</table>
<hr>
<p>以下是<strong>FIFO</strong>模块的功能</p>
<h3 id="28-入队操作">28. 入队操作</h3>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>28.1</td>
          <td>队未满，正常入队</td>
          <td>当队列未满，且空位不小于一时，可以正常入队，如果从零号位开始入队到最大容量，入队指针的 flag 不会翻转。 <br>io.enq.fire 为高有效，regFiles(enq_ptr.value) = io.enq.bits，enq_ptr.value+1 入队指针移动，入队指针标记位不翻转。 <br>重复以上操作至队满。</td>
      </tr>
      <tr>
          <td>28.2</td>
          <td>队未满，入队后标记位翻转</td>
          <td>当队未满，但是空位却是靠近队尾时，入队一位后就到达了队头，入队指针的 flag 会翻转。 <br>队列的容量为 10，入队指针指向 9，队未满。此时如果 io.enq.fire 为高，则 regFiles(9) = io.enq.bits，enq_ptr.value+1（循环队列，加完后 enq_ptr.value=0）入队指针移动，入队指针标记位翻转。</td>
      </tr>
      <tr>
          <td>28.3</td>
          <td>队满，入队就绪信号为低，无法入队</td>
          <td>当队满时，(enq_ptr.value === deq_ptr.value) &amp;&amp; (enq_ptr.flag ^ deq_ptr.flag) 为高，io.enq.ready 为低，io.enq.fire 为低无效。 <br>此时入队，入队指针的 value 和 flag 不变。</td>
      </tr>
  </tbody>
</table>
<h3 id="29-出队操作">29. 出队操作</h3>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>29.1</td>
          <td>队非空，正常出队</td>
          <td>当队列非空时，可以正常出队，如果出队指针不经过最大容量位置，出队指针的 flag 不会翻转。 <br>io.deq.fire 为高有效，io.deq.bits = regFiles(deq_ptr.value)，deq_ptr.value+1 出队指针移动，出队指针标记位不翻转。</td>
      </tr>
      <tr>
          <td>29.2</td>
          <td>队非空，出队后标记位翻转</td>
          <td>当队非空，但是出队指针是靠近队尾时，出队一位后就到达了队头，出队指针的 flag 会翻转。 <br>队列的容量为 10，出队指针指向 9，队非空。此时如果 io.deq.fire 为高，则 io.deq.bits = regFiles(9)，deq_ptr.value+1（循环队列，加完后 deq_ptr.value=0）出队指针移动，出队指针标记位翻转。</td>
      </tr>
      <tr>
          <td>29.3</td>
          <td>队空，出队有效信号为低，无法出队</td>
          <td>当队空时，enq_ptr === deq_ptr 为高，io.deq.valid 为低，io.deq.fire 为低无效。 <br>此时出队，出队指针的 value 和 flag 不变。</td>
      </tr>
  </tbody>
</table>
<h3 id="30-刷新清空操作">30. 刷新清空操作</h3>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>30.1</td>
          <td>flush 清空</td>
          <td>当刷新信号有效时，重置出队和入队的指针和标记位，清空队列。 <br>当 flush 为高时，deq_ptr.value=0，enq_ptr.value=0，deq_ptr.flag=false，enq_ptr.flag=false，empty=true,full=false。</td>
      </tr>
  </tbody>
</table>
<hr>
<p>以下是<strong>MissUnit</strong>模块的功能</p>
<h3 id="31-处理取指缺失请求">31. 处理取指缺失请求</h3>
<p>处理来自 MainPipe 的取指单元的缓存缺失请求，将缺失请求分发到多个 Fetch MSHR 中的一个，避免重复请求。
低索引的请求优先处理。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>31.1</td>
          <td>接受新的取指请求</td>
          <td>当新的 fetch miss 与 MSHR 中的已有请求不重复时（通过 io.fetch_req.bits.blkPaddr / vSetIdx 给出具体地址），MissUnit 会将请求分配到一个空闲的 Fetch MSHR 中。 <br>当有新的取指缺失请求到达时（io.fetch_req.valid 为高），且没有命中已有的 MSHR（fetchHit 为低），io.fetch_req.ready 应为高，表示可以接受请求。 <br>io.fetch_req.fire 成功握手后，该 MSHR 处于 valid = true 状态，并记录地址。</td>
      </tr>
      <tr>
          <td>31.2</td>
          <td>处理已有的取指请求</td>
          <td>当已有取指缺失请求到达时（io.fetch_req.valid 为高），且命中已有的 MSHR（fetchHit 为高），io.fetch_req.ready 应为高，虽然不接受请求，但是表现出来为已经接收请求。 <br>fetchDemux.io.in.valid 应为低，fetchDemux.io.in.fire 为低，表示没有新的请求被分发到 MSHR。</td>
      </tr>
      <tr>
          <td>31.3</td>
          <td>低索引的请求优先进入 MSHR</td>
          <td>Fetch 的请求会通过 fetchDemux 分配到多个 Fetch MSHR，fetchDemux 的实现中，低索引的 MSHR 会优先被分配请求。 <br>当取指请求有多个 io.out(i).read 时，选择其中的第一个，也就是低索引的写入 MSHR，io.chose 为对应的索引。</td>
      </tr>
  </tbody>
</table>
<h3 id="32-处理预取缺失请求">32. 处理预取缺失请求</h3>
<p>与 Fetch Miss 类似，但走另一些 MSHR（Prefetch MSHR）。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>32.1</td>
          <td>接受新的预取请求</td>
          <td>当新的 prefetch miss 与 MSHR 中的已有请求不重复时（通过 io.prefetch_req.bits.blkPaddr / vSetIdx 给出具体地址），MissUnit 会将请求分配到一个空闲的 Prefetch MSHR 中。 <br>当有新的预取缺失请求到达时（io.prefetch_req.valid 为高），且没有命中已有的 MSHR（prefetchHit 为低），io.prefetch_req.ready 应为高，表示可以接受请求。 <br>io.prefetch_req.fire 成功握手后，该 MSHR 处于 valid = true 状态，并记录地址。</td>
      </tr>
      <tr>
          <td>32.2</td>
          <td>处理已有的预取请求</td>
          <td>当已有预取缺失请求到达时（io.prefetch_req.valid 为高），且命中已有的 MSHR（prefetchHit 为高），io.prefetch_req.ready 应为高，虽然不接受请求，但是表现出来为已经接收请求。 <br>prefetchDemux.io.in.valid 应为低，prefetchDemux.io.in.fire 为低，表示请求被接受但未分发到新的 MSHR。</td>
      </tr>
      <tr>
          <td>32.3</td>
          <td>低索引的请求优先进入 MSHR</td>
          <td>Prefetch 的请求会通过 prefetchDemux 分配到多个 Prefetch MSHR，prefetchDemux 的实现中，低索引的 MSHR 会优先被分配请求。 <br>当取指请求有多个 io.out(i).read 时，选择其中的第一个，也就是低索引的写入 MSHR，io.chose 为对应的索引。</td>
      </tr>
      <tr>
          <td>32.4</td>
          <td>先进入 MSHR 的优先进入 prefetchArb</td>
          <td>从 prefetchDemux 离开后，请求的编号会进入 priorityFIFO，priorityFIFO 会根据进入队列的顺序排序，先进入队列的请求会先进入 prefetchArb。 <br>prefetchDemux.io.in.fire 为高，并且 prefetchDemux.io.chosen 有数据时，将其编号写入 priorityFIFO。 <br>在 priorityFIFO 中有多个编号时，出队的顺序和入队顺序一致。 <br>检查 priorityFIFO.io.deq.bit 中的数据即可。</td>
      </tr>
  </tbody>
</table>
<h3 id="33-mshr-管理与查找">33. MSHR 管理与查找</h3>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>33.1</td>
          <td>MSHR 查找命中逻辑</td>
          <td>当新的请求到来时，能够正确查找所有 MSHR，判断请求是否命中已有 MSHR。 <br>当新的请求（取指或预取）到来时，系统遍历所有 MSHR，根据所有 MSHR 的查找信号 allMSHRs(i).io.lookUps(j).hit，检查请求是否已经存在于某个 MSHR 中。 <br>如果命中，则对应的 fetchHit 或 prefetchHit 为高。 <br>对于 prefetchHit 为高，还有一种情况：预取的物理块地址和组索引与取指的相等（(io.prefetch_req.bits.blkPaddr === io.fetch_req.bits.blkPaddr) &amp;&amp; (io.prefetch_req.bits.vSetIdx === io.fetch_req.bits.vSetIdx)）并且有取指请求 io.fetch_req.valid 有效时，也算命中</td>
      </tr>
      <tr>
          <td>33.2</td>
          <td>MSHR 状态的更新与释放</td>
          <td>当请求完成后，也就是来自内存总线的响应完成（D 通道接收完所有节拍），MSHR 能够正确地释放（清除其有效位），以便接收新的请求。 <br>TileLink D 通道返回的 source ID ，即 io.mem_grant.bits.source。 <br>无效化信号 allMSHRs(i).io.invalid 为高，对应的 MSHR 的有效位 allMSHRs(i).valid 变为低</td>
      </tr>
  </tbody>
</table>
<h3 id="34-acquirearb-仲裁">34. acquireArb 仲裁</h3>
<p>预取和取指的 acquire 都会发送给 acquireArb，acquireArb 会选择一个 acquire 发送给 mem_acquire。
acquireArb 使用 chisel 自带的 Arbiter 实现,Arbiter 使用固定优先级仲裁，优先级从编号 0 开始，编号越小优先级越高。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>34.1</td>
          <td>acquireArb 仲裁</td>
          <td>acquireArb 会选择一个 acquire 发送给 mem_acquire。 <br>当有多个 MSHR 同时发出请求时，acquireArb 会根据优先级进行仲裁，选择优先级最高的 MSHR 发送请求。 <br>取指请求总是在 0-3 号，预取请求直接在最后一号，所以取指请求优先级高于预取请求。 <br>当取指 acquire 和预取 acquire 同时发出时，fetchMSHRs(i).io.acquire 和 prefetchMSHRs(i).io.acquire 都有效，仲裁结果 acquireArb.io.out 应该和 fetchMSHRs(i).io.acquire 一致。</td>
      </tr>
  </tbody>
</table>
<h3 id="35-grant-数据接收与-refill">35. Grant 数据接收与 Refill</h3>
<p>在收到 TileLink D 通道数据时收集整行</p>
<ul>
<li>累计 beat 数（readBeatCnt），直到完成一整行 (last_fire)</li>
<li>记录 corrupt 标志</li>
<li>将完成的请求映射回对应的 MSHR (id_r = mem_grant.bits.source)</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>35.1</td>
          <td>正常完整 Grant 流程，readBeatCnt 为 0 时</td>
          <td>readBeatCnt 初始为 0，refillCycles - 1 也为 0。 <br>io.mem_grant.valid 为高（因为 io.mem_grant.ready 默认为高，所以 io.mem_grant.fire 为高只需要 io.mem_grant.valid 为高）且 io.mem_grant.bits.opcpde(0)为高。 <br>此时 respDataReg(0)= io.mem_grant.bits.data <br>readBeatCnt 加一为 1。</td>
      </tr>
      <tr>
          <td>35.2</td>
          <td>正常完整 Grant 流程，readBeatCnt 为 1 时</td>
          <td>io.mem_grant.valid 为高且 io.mem_grant.bits.opcpde(0)为高。 <br>此时 respDataReg(1)= io.mem_grant.bits.data <br>readBeatCnt 重置回 0。 <br>last_fire 为高。 <br>下一拍 last_fire_r 为高，id_r=io.mem_grant.bits.source。</td>
      </tr>
      <tr>
          <td>35.3</td>
          <td>正常完整 Grant 流程，last_fire_r 为高</td>
          <td>last_fire_r 为高，并且 id_r 为 0-13 中的一个。 <br>对应的 fetchMSHRs 或者 prefetchMSHRs 会被无效，也就是 fetchMSHRs_i 或 prefetchMSHRs_i-4 的 io_invalid 会被置高。</td>
      </tr>
      <tr>
          <td>35.4</td>
          <td>Grant 带有 corrupt 标志</td>
          <td>io.mem_grant.valid 为高且 io.mem_grant.bits.opcpde(0)为高，io.mem_grant.bits.corrupt 为高，则 corrupt_r 应为高。 <br>如果 io.mem_grant.valid 为高且 io.mem_grant.bits.opcpde(0)为高，io.mem_grant.bits.corrupt 为高中有一个不满足，且此时 last_fire_r 为高，则 corrupt_r 重置为低。</td>
      </tr>
  </tbody>
</table>
<h3 id="36-替换策略更新-replacer">36. 替换策略更新 (Replacer)</h3>
<p>MissUnit 在发出 Acquire 请求时，还会将本次选中的 victim way 对应的索引告诉 io.victim，让替换策略更新其记录（替换策略采用 PLRU）
只有当 Acquire 真正“fire”时，才说明成功替换，replacer 需要更新状态</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>36.1</td>
          <td>正常替换更新</td>
          <td>当 io.mem.acquire.ready &amp; acquireArb.io.out.valid 同时为高，也就是 acquireArb.io.out.fir 为高时，io.victim.vSetIdx.valid 也为高。 <br>io.victim.vSetIdx.bits = 当前 MSHR 请求的 acquireArb.io.out.bits.vSetIdx。</td>
      </tr>
      <tr>
          <td>36.2</td>
          <td>生成 waymask</td>
          <td>根据从 L2 返回的 mshr_resp 中 mshr_resp.bits.way 生成 waymask 信息。 <br>返回的 mshr_resp.bits.way 有 16 位，通过独热码生成一位掩码信息，waymask 表示其中哪一路被替换。 <br>生成的 waymask 应该和 mshr_resp.bits.way 一致。</td>
      </tr>
  </tbody>
</table>
<h3 id="37-写回-sram-meta--data">37. 写回 SRAM (Meta / Data)</h3>
<p>在一条 Miss Request refill 完成时，将新得到的 Cache line 写到 ICache。
生成 io.meta_write 和 io.data_write 的请求，带上 waymask, tag, idx, data 。
生成 io.meta_write.valid 和 io.data_write.valid 信号。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>37.1</td>
          <td>生成 io.meta_write.valid 和 io.data_write.valid 信号</td>
          <td>当 grant 传输完成后，经过一拍后，即 last_fire_r 为高，且从 TileLink 返回的 mshr_resp 中的 mshr_resp.valid 为高。 <br>并且此时没有硬件刷新信号和软件刷新信号，也就是 io.flush 和 io.fencei 为低。 在等待 l2 响应的过程中，没有刷新信号 <br>也没有数据 corrupt，即 corrupt_r 为低。 <br>那么 io.meta_write.valid 和 io.data_write.valid 均为高。</td>
      </tr>
      <tr>
          <td>37.2</td>
          <td>正常写 SRAM</td>
          <td>io.meta_write.bits 的 virIdx、phyTag、waymask、bankIdx、poison 应该正常更新 <br>io.data_write.bits 的 virIdx、data、waymask、bankIdx、poison 应该正常更新</td>
      </tr>
  </tbody>
</table>
<h3 id="38-向-mainpipeprefetchpipe-发出-miss-完成响应fetch_resp">38. 向 mainPipe/prefetchPipe 发出 Miss 完成响应（fetch_resp）</h3>
<p>在完成 refill 后，无论是否要真正写阵列，都会向取指端发送“Miss 请求完成”
更新 io.fetch_resp.valid 和 fetch_resp.bits。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>38.1</td>
          <td>正常 Miss 完成响应</td>
          <td>当 grant 传输完成后，经过一拍后，即 last_fire_r 为高，且从 TileLink 返回的 mshr_resp 中的 mshr_resp.valid 为高。 <br>无论此时是否有硬件刷新信号和软件刷新信号， io.fetch_resp.valid 都为高，说明可向取指端发送响应。 <br>io.fetch_resp.bits 中的数据更新： <br>io.fetch_resp.bits.blkPaddr = mshr_resp.bits.blkPaddr <br>io.fetch_resp.bits.vSetIdx = mshr_resp.bits.vSetIdx <br>io.fetch_resp.bits.waymask = waymask <br>io.fetch_resp.bits.data = respDataReg.asUInt <br>io.fetch_resp.bits.corrupt = corrupt_r</td>
      </tr>
  </tbody>
</table>
<h3 id="39-处理-flush--fencei">39. 处理 flush / fencei</h3>
<p>一旦收到 io.flush 或 io.fencei 时，对未发射的请求可立即取消，对已经发射的请求在拿到数据后也不写 SRAM。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>39.1</td>
          <td>MSHR 未发射前 fencei</td>
          <td>如果 MSHR 还没有通过 io.acquire.fire 发出请求，就应立即取消该 MSHR（mshr_resp.valid= false），既不发出请求，也不要写 SRAM。 <br>当 io.fencei 为高时，fetchMSHRs 和 prefetchMSHRs 的 io.req.ready 和 io.acquire.valid 均为低，表示请求不发射。</td>
      </tr>
      <tr>
          <td>39.2</td>
          <td>MSHR 未发射前 flush</td>
          <td>由于 fetchMSHRs 的 io.flush 被直接设置为 false，所以 io.flush 对 fetchMSHRs 无效，但是对 prefetchMSHRs 有效。 <br>当 io.flush 为高时，只能发射 fetchMSHRs 的请求。</td>
      </tr>
      <tr>
          <td>39.3</td>
          <td>MSHR 已发射后 flush/fencei</td>
          <td>已经发射了请求，之后再有刷新信号，那么等数据回来了但不写 SRAM。 <br>在发射后，io.flush/io.fencei 为高时，等待数据回来，但是写 SRAM 的信号，write_sram_valid、io.meta_write.valid 和 io.data_write.valid 均为低，表示不写 SRAM。 <br>对于 response fetch 无影响。</td>
      </tr>
  </tbody>
</table>
<hr>
<p>以下是<strong>CtrlUnit</strong>模块的功能</p>
<h3 id="40-ecc-启用禁用">40. ECC 启用/禁用</h3>
<p>控制 eccctrl.enable 字段来启用或禁用 ECC 功能。外部系统可以通过写寄存器 eccctrl 来控制 ECC 是否启用。</p>
<ul>
<li>通过寄存器写入控制信号 enable，当 enable 为 true 时，ECC 功能启用；为 false 时，ECC 功能禁用。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>40.1</td>
          <td>启用 ECC</td>
          <td>向 eccctrl.enable 寄存器写入 true，验证模块内部 eccctrl.enable 设置为 true，并确保后续的错误注入操作能够成功进行。此测试确保 eccctrl.enable 写操作被执行。 <br>确保 eccctrl.enable 被正确设置为 true，并触发 eccctrlRegWriteFn 中的写操作逻辑。</td>
      </tr>
      <tr>
          <td>40.2</td>
          <td>禁用 ECC</td>
          <td>向 eccctrl.enable 寄存器写入 false，验证模块内部 eccctrl.enable 设置为 false，并确保在后续的错误注入过程中，ECC 功能被禁用，不允许进行错误注入。此测试确保 eccctrl.enable 写操作被正确设置为 false。 <br>验证禁用 ECC 时 eccctrl.enable 为 false，并触发 eccctrlRegWriteFn 中的错误处理分支。x.istatus = eccctrlInjStatus.error 和 x.ierror = eccctrlInjError.notEnabled</td>
      </tr>
  </tbody>
</table>
<h3 id="41-状态机转换">41. 状态机转换</h3>
<p>根据状态机的状态，验证错误注入的流程是否正确。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>41.1</td>
          <td>is_idle 状态</td>
          <td>初始为 is_idle 状态。 <br>当 eccctrl.istatus 为 working 时，验证此时的状态为 is_readMetaReq。</td>
      </tr>
      <tr>
          <td>41.2</td>
          <td>is_readMetaReq 状态</td>
          <td>当握手成功后（io.metaRead.ready 和 io.metaRead.valid 都为高），验证此时的状态为 is_readMetaResp。</td>
      </tr>
  </tbody>
</table>
<h4 id="413-is_readmetaresp-状态">41.3 is_readMetaResp 状态</h4>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>41.3.1</td>
          <td>未命中</td>
          <td>当 waymask 全零的时候，表示没有命中，会进入 is_idle 状态，并且设置错误错误注入状态和错误原因。 <br>验证此时的状态为 is_idle， eccctrl.istatus = error 和 eccctrl.ierror = notFound。</td>
      </tr>
      <tr>
          <td>41.3.2</td>
          <td>命中</td>
          <td>当 waymask 不全零的时候，表示命中，会根据错误注入目标来判断是向元数据还是数据阵列写入错误。 <br>当 eccctrl.itarget=metaArray 时，验证此时的状态为 is_writeMeta ；当 eccctrl.itarget！=metaArray 时，验证此时的状态为 is_writeData。</td>
      </tr>
  </tbody>
</table>
<h4 id="414-is_writemeta-状态">41.4 is_writeMeta 状态</h4>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>41.4.1</td>
          <td>RegWriteFn</td>
          <td>此状态进入后，io.dataWrite.valid 会为高 <br>x.itarget = req.itarget <br>当 req.inject 为高并且 x.istatus = idle 时： <br>1. 如果 ecc 的 req.enable = false，则验证 x.istatus = error 且 x.ierror = notEnabled <br>2. 否则，如果 req.itarget ！= metaArray 和 dataArray，则验证 x.istatus = error 且 x.ierror = targetInvalid <br>3. 如果都不满足，则验证 x.istatus = working</td>
      </tr>
      <tr>
          <td>41.4.2</td>
          <td>状态转换</td>
          <td>当 io.metaWrite.fire 为高， 验证下一个状态为 is_idle，并且 eccctrl.istatus = injected。</td>
      </tr>
  </tbody>
</table>
<h4 id="415-is_writedata-状态">41.5 is_writeData 状态</h4>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>41.5.1</td>
          <td>RegWriteFn</td>
          <td>此状态进入后，io.dataWrite.valid 会为高 <br>res.inject = false <br>当 ready 为高，且 x.istatus = injected 或 x.istatus = error 时，验证 x.istatus = idle 和 x.ierror = notEnabled</td>
      </tr>
      <tr>
          <td>41.5.2</td>
          <td>状态转换</td>
          <td>当 io.dataWrite.fire 为高， 验证下一个状态为 is_idle，并且 eccctrl.istatus = injected。</td>
      </tr>
  </tbody>
</table>
<h3 id="42-寄存器映射和外部访问">42. 寄存器映射和外部访问</h3>
<p>通过 TileLink 总线将寄存器映射到特定地址，使外部模块可以读写 ECC 控制寄存器和注入地址寄存器。</p>
<ul>
<li>使用 TLRegisterNode 实现寄存器的映射，使得外部系统可以通过地址访问寄存器。寄存器的读写操作通过 TileLink 协议进行。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>42.1</td>
          <td>外部读取和写入 ECC 控制寄存器</td>
          <td>验证外部模块可以通过 TileLink 协议正确读取和写入 eccctrl 和 ecciaddr 寄存器，并对模块内部的状态产生影响，确保读写操作完全覆盖。</td>
      </tr>
      <tr>
          <td>42.2</td>
          <td>外部模块触发错误注入</td>
          <td>通过外部模块经 TileLink 总线向 eccctrl.inject 寄存器写入 true，触发错误注入，验证内部状态是否按 RegWriteFn 内部过程执行。</td>
      </tr>
  </tbody>
</table>
<hr>
<p>以下是<strong>ICache 顶层</strong>模块的功能</p>
<h3 id="43-ftq-预取请求处理">43. FTQ 预取请求处理</h3>
<p>接收来自 FTQ 的预取请求，经 IPrefetchPipe 请求过滤（查询 ITLB 地址，是否命中 MetaArry，PMP 检查），（有异常则由 MissUnit 处理）后进入 WayLookup。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>43.1</td>
          <td>预取地址命中，无异常</td>
          <td>io.ftqPrefetch.req.bits 的 startAddr 和 nextlineStart 在正常地址范围内，itlb 命中无异常，itlb 查询到的地址与 MetaArry 的 ptag 匹配，pmp 检查通过。 <br>如果没有监听到 MSHR 同样的位置发生了其它 cacheline 的写入，那么验证 wayLookup.io.write 的内容应该命中的取指数据。 <br>如果监听到 MSHR 同样的位置发生了其它 cacheline 的写入，那么验证 wayLookup.io.write 的内容应该是未命中的取指数据。</td>
      </tr>
      <tr>
          <td>43.2</td>
          <td>预取地址未命中，无异常</td>
          <td>io.ftqPrefetch.req.bits 的 startAddr 和 nextlineStart 在正常地址范围内，itlb 命中无异常，itlb 查询到的地址与 MetaArry 的 ptag 不匹配，pmp 检查通过。 <br>如果监听到 MSHR 将该请求对应的 cacheline 写入了 SRAM，那么验证 wayLookup.io.write 的内容应该命中的取指数据。 <br>如果监听到 MSHR 没有将该请求对应的 cacheline 写入了 SRAM，那么验证 wayLookup.io.write 的内容应该未命中的取指数据。</td>
      </tr>
      <tr>
          <td>43.3</td>
          <td>预取地址 TLB 异常，无其他异常</td>
          <td>io.ftqPrefetch.req.bits 的 startAddr 和 nextlineStart 在正常地址范围内，itlb 异常。 <br>验证 wayLookup.io.write 的 itlb_exception 内容中，其有对应的异常类型编号（pf:01;gpf:10;af:11）。</td>
      </tr>
      <tr>
          <td>43.4</td>
          <td>预取地址 PMP 异常，无其他异常</td>
          <td>io.ftqPrefetch.req.bits 的 startAddr 和 nextlineStart 在正常地址范围内，itlb 命中无异常，itlb 查询到的地址与 MetaArry 的 ptag 匹配，pmp 检查未通过。 <br>验证 wayLookup.io.write 的 tlb_pbmt 内容中，其有对应的异常类型编号（nc:01;io:10）。</td>
      </tr>
  </tbody>
</table>
<h3 id="44-ftq-取指请求处理">44. FTQ 取指请求处理</h3>
<p>io.fetch.resp &lt;&gt; mainPipe.io.fetch.resp 发送回 IFU 的数据是在 io.fetch.resp。
接收来自 FTQ 的取指请求，从 WayLookup 获取路命中信息和 ITLB 查询结果，再访问 DataArray，监控 MSHR 的响应。更新 replacer，做 pmp 检查。后做 DataArray 和 MetaArray 的 ECC 校验。最后将数据发送给 IFU。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>44.1</td>
          <td>取指请求命中，无异常</td>
          <td>io.fetch.req.bits.pcMemRead 的 0-4 的 startAddr 和 nextlineStart 在正常地址范围内，从 WayLookup 获取信息，命中，pmp 检查正常，DataArray 和 MetaArray 的 ECC 校验正常。 <br>验证 replacer.io.touch 的 vSetIdx 和 way 和 ftq 的 fetch 一致，missUnit.io.victim 的 vSetIdx 和 way 是按照制定的算法生成的。 <br>验证 io.fetch.resp 的数据应该是取指的数据。</td>
      </tr>
      <tr>
          <td>44.2</td>
          <td>取指请求未命中，MSHR 返回的响应命中，无异常</td>
          <td>io.fetch.req.bits.pcMemRead 的 0-4 的 startAddr 和 nextlineStart 在正常地址范围内，从 WayLookup 获取信息，未命中，pmp 检查正常，DataArray 和 MetaArray 的 ECC 校验正常。 <br>请求在 MSHR 返回的响应命中。 <br>验证 missUnit.io.victim 的 vSetIdx 和 way 是按照制定的算法生成的。 <br>验证 io.fetch.resp 的数据应该是取指的数据。</td>
      </tr>
      <tr>
          <td>44.3</td>
          <td>取指请求命中,ECC 校验错误，无其他异常</td>
          <td>io.fetch.req.bits.pcMemRead 的 0-4 的 startAddr 和 nextlineStart 在正常地址范围内，从 WayLookup 获取信息，命中，pmp 检查正常，DataArray 或 MetaArray 的 ECC 校验错误。 <br>验证 io.error.valid 为高，且 io.error.bits 内容为对应的错误源和错误类型。 <br>先刷 MetaArray 的 ValidArray,给 MissUnit 发请求，由其在 L2 重填，阻塞至数据返回。 <br>验证 replacer.io.touch 的 vSetIdx 和 way 和 ftq 的 fetch 一致，missUnit.io.victim 的 vSetIdx 和 way 是按照制定的算法生成的。 <br>验证 io.fetch.resp 的数据应该是取指的数据。</td>
      </tr>
      <tr>
          <td>44.4</td>
          <td>取指请求未命中，但是 exception 非 0（af、gpf、pf），无其他异常</td>
          <td>io.fetch.req.bits.pcMemRead 的 0-4 的 startAddr 和 nextlineStart 在正常地址范围内，从 WayLookup 获取信息，命中，pmp 检查未通过，DataArray 和 MetaArray 的 ECC 校验正常。 <br>验证 io.fetch.resp 为对应的错误源和错误类型。 <br>验证 io.fetch.resp 的数据无效，里面有异常类型。</td>
      </tr>
      <tr>
          <td>44.5</td>
          <td>取指请求未命中，通过 WayLookup 中读取到的预取过来的 itlb 中返回 pbmt。</td>
          <td>有 itlb_pbmt 和 pmp_mmio 时，他们合成 s1_mmio，传递到 s2_mmio,生成 s2_miss,有特殊情况就不会取指。 <br>io.fetch.req.bits.pcMemRead 的 0-4 的 startAddr 和 nextlineStart 在正常地址范围内，从 WayLookup 获取信息，命中，pmp 检查通过，DataArray 和 MetaArray 的 ECC 校验正常。 <br>验证 io.fetch.resp 为对应的错误源和错误类型。 <br>验证 io.fetch.resp 的数据无效，里面有特殊情况类型类型。</td>
      </tr>
      <tr>
          <td>44.6</td>
          <td>取指请求未命中，pmp 返回 mmio 。</td>
          <td>处理同 5。</td>
      </tr>
  </tbody>
</table>
<h3 id="45-metaarray-功能">45. MetaArray 功能</h3>
<p>在 IPrefetchPipe 的 S0，接收来自 IPrefetchPipe 的读请求 read，返回对应路和组的响应 readResp。
在 miss 的时候，MissUnit 会将会应的数据写入 write 到 MetaArray。
MetaArray 主要存储了每个 Cache 行的标签和 ECC 校验码。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>45.1</td>
          <td>元数据写入操作（对应的 Set 已满）: ICacheMetaArray 应当能够正确地将元数据（标签和有效位）写入到指定的 Set 和 Way 。</td>
          <td>从 MissUnit 返回的请求都是未命中的请求（已命中不会向 MissUnit 请求，那么 MissUnit 自然也不会向 MetaArray 写入）。 <br>发送一个写请求 write 到 ICacheMetaArray，ICacheReplacer 根据 PLRU 替换策略指定 way，替换路被写入 waymask，最后指定 virIdx、phyTag、waymask、bankIdx、poison。 <br>写入操作后，发起一个对相同虚拟索引的读请求。验证 readResp 的 metas 和 codes 分别包含写入的 ptag 和 ecc code，并且对于写入的路，readResp.entryValid 信号被置为有效。</td>
      </tr>
      <tr>
          <td>45.2</td>
          <td>元数据读取操作 (命中): 当一个读请求在 ICacheMetaArray 中命中时（存在有效的条目），它应该返回正确的元数据（标签和有效位）。</td>
          <td>首先，向特定的虚拟索引（组和路）写入元数据（参照上面的写入操作）。然后，向相同的虚拟索引发送一个读请求。 <br>验证 readResp.metas 包含之前写入的物理标签，并且对于相应的路，readResp.entryValid 信号被置为有效。</td>
      </tr>
      <tr>
          <td>45.3</td>
          <td>元数据读取操作 (未命中): 当读取一个尚未被写入的地址时，ICacheMetaArray 应当指示未命中（条目无效）。</td>
          <td>向 ICacheMetaArray 发送一个读请求，请求的虚拟索引在复位后从未被写入过。 <br>验证对于任何路，readResp.entryValid 信号都没有被置为有效。 对应的 readResp.metas 和 codes 的内容是 DontCare 也就是 0。</td>
      </tr>
      <tr>
          <td>45.4</td>
          <td>独立的缓存组刷新：在第 i 个端口是有效的刷新请求，并且该请求的 waymask 指定了当前正在处理的第 w 路时，应该使第 i 个端口的条目无效。</td>
          <td>先向 ICacheMetaArray 写入指定一个或多个端口的元数据，然后再给对应的端口的路发送刷新请求 io.flush，其包含虚拟索引 virIdx 和路掩码 waymask。 <br>验证 valid_array 对应的路中的 virIdx 被置为无效，io.readResp.entryValid 对应路的对应端口为无效。</td>
      </tr>
      <tr>
          <td>45.5</td>
          <td>全部刷新操作: ICacheMetaArray 应当能够在接收到全部刷新请求时，使所有条目无效。</td>
          <td>先向多个不同的虚拟索引写入元数据。然后置位 io.flushAll 信号。 <br>验证步骤: 在 io.flushAll 信号置位后，发起对所有之前写入过的虚拟索引的读请求。验证在所有的读取响应中，对于任何路，readResp.entryValid 信号都没有被置为有效。</td>
      </tr>
  </tbody>
</table>
<h3 id="46-dataarray-功能">46. DataArray 功能</h3>
<p>与 MetaArray 类似，在 MainPipe 的 S0，接收来自 MainPipe 的读请求 read，返回对应路和组的响应 readResp。
在 miss 的时候，MissUnit 会将会应的数据写入 write 到 DataArray。
DataArray 主要存储了每个 Cache 行的标签和 ECC 校验码。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>46.1</td>
          <td>数据写入操作（对应的 Set 已满）: ICacheDataArray 应当能够正确地将数据写入到指定的 Set (组)、Way (路) 和数据 Bank (存储体)。</td>
          <td>发送一个写请求 write 到 ICacheDataArray，ICacheReplacer 根据 PLRU 替换策略指定 way，替换路被写入 waymask，最终指定虚拟索引、数据、路掩码、存储体索引 bankIdx 和毒化位。写入的数据模式应跨越多个数据存储体。 <br>写入操作后，发起一个对相同虚拟索引和块偏移量的读请求。验证 readResp.datas 与写入的数据相匹配。</td>
      </tr>
      <tr>
          <td>46.2</td>
          <td>数据读取操作 (命中): 当一个读请求命中时（相应的元数据有效），它应该从相应的组、路和数据存储体返回正确的数据。</td>
          <td>首先，向特定的虚拟索引和块偏移量写入数据。然后，向相同的虚拟索引和块偏移量发送一个读请求。使用不同的块偏移量进行测试，以覆盖存储体的选择逻辑。 <br>验证 readResp.datas 包含之前写入的数据。</td>
      </tr>
      <tr>
          <td>46.3</td>
          <td>数据读取操作 (未命中): 当读取一个尚未被写入的地址时，ICacheDataArray 的输出应该是默认值或无关值。</td>
          <td>向 ICacheDataArray 发送一个读请求，请求的虚拟索引在复位后从未被写入过。 <br>验证 readResp.datas 为 0。</td>
      </tr>
  </tbody>
</table>
<hr>
</mrs-functions>
<h2 id="icache-接口说明">ICache 接口说明</h2>
<p>为方便测试开展，需要对 ICache 的接口进行进一步的说明，以明确各个接口的含义。</p>
<p>*注意：源文件编译成 verilog/system verilog 后，部分接口会被优化，实际接口以编译后的为准。</p>
<h3 id="iprefetch-模块接口">IPrefetch 模块接口</h3>
<h4 id="控制接口">控制接口</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>csr_pf_enable</td>
          <td>控制 s1_real_fire，软件控制预取开关</td>
      </tr>
      <tr>
          <td>ecc_enable</td>
          <td>编译后被优化 ，控制 ecc 开启</td>
      </tr>
      <tr>
          <td>flush</td>
          <td>刷新信号</td>
      </tr>
  </tbody>
</table>
<h4 id="reqftq-预取请求">req:FTQ 预取请求</h4>
<p>由于 BPU 基本无阻塞，它经常能走到 IFU 的前面，于是 BPU 提供的这些还没发到 IFU 的取指请求就可以用作指令预取，FTQ 中实现了这部分逻辑，直接给 ICache 发送预取请求。
预取请求来自 FTQ，在 S0 流水级传入。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ready</td>
          <td>指示 s0 能否继续</td>
      </tr>
      <tr>
          <td>valid</td>
          <td>指示软件预取或者硬件预取是否有效。</td>
      </tr>
      <tr>
          <td>startAddr</td>
          <td>预测块起始地址。</td>
      </tr>
      <tr>
          <td>nextlineStart</td>
          <td>预测块下一个缓存行的起始地址。</td>
      </tr>
      <tr>
          <td>ftqIdx</td>
          <td>指示当前预测块在 FTQ 中的位置，包含 flag 和 value 两个量。</td>
      </tr>
      <tr>
          <td>isSoftPrefetch</td>
          <td>是否为软件预取(来自 Memblock 中 LoadUint 的软件预取请求)。</td>
      </tr>
      <tr>
          <td>backendException</td>
          <td>ICache 向 IFU 报告后端存在的异常类型。</td>
      </tr>
  </tbody>
</table>
<h4 id="flushfrombpu来自-bpu-的刷新信息">flushFromBpu:来自 BPU 的刷新信息</h4>
<p>由 FTQ 传递而来的 BPU 刷新信息，在 S0 流水级传入。
这是预测错误引起的，包括 s2 和 s3 两个同构成员，指示是否在 BPU 的 s2 和 s3 流水级发现了问题。
s2 的详细结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>valid</td>
          <td>指示 s2 是否有效。</td>
      </tr>
      <tr>
          <td>ftqIdx</td>
          <td>指示 s2 流水级请求冲刷的预测块在 FTQ 中的位置，包含 flag 和 value 两个量。</td>
      </tr>
  </tbody>
</table>
<h4 id="itlb请求和响应-itlb-的信息">itlb:请求和响应 itlb 的信息</h4>
<p>在 s0 流水级，发送 itlb_req；在 s1 流水级，如果 itlb 命中则直接接收 itlb_resp，否则重发 itlb_req。</p>
<p>req 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>valid</td>
          <td>指示 req 请求是否有效。</td>
      </tr>
      <tr>
          <td>Tlbreq</td>
          <td>有多个子结构，这里我们只用上了 vaddr,即 req 请求的虚拟地址</td>
      </tr>
  </tbody>
</table>
<p>resp 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>paddr</td>
          <td>指令物理地址。</td>
      </tr>
      <tr>
          <td>gpaddr</td>
          <td>客户页地址。</td>
      </tr>
      <tr>
          <td>pbmt</td>
          <td>基于页面的内存类型。</td>
      </tr>
      <tr>
          <td>miss</td>
          <td>指示 itlb 是否未命中。</td>
      </tr>
      <tr>
          <td>isForVSnonLeafPTE</td>
          <td>指示是否为非叶 PTE。</td>
      </tr>
      <tr>
          <td>excp</td>
          <td>ITLB 可能产生的异常，包括：访问异常指令 af_instr、客户页错误指令 gpf_instr、页错误指令 pf_instr。见<a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#%e5%bc%82%e5%b8%b8%e4%bc%a0%e9%80%92%e7%89%b9%e6%ae%8a%e6%83%85%e5%86%b5%e5%a4%84%e7%90%86">异常传递/特殊情况处理</a></td>
      </tr>
  </tbody>
</table>
<h4 id="itlbflushpipeitlb-刷新信号">itlbFlushPipe:itlb 刷新信号</h4>
<p>在 itlb 中，如果出现 gpf 的取指请求处于推测路径上，且发现出现错误的推测，则会通过 flushPipe 信号进行刷新（包括后端 redirect、或前端多级分支预测器出现后级预测器的预测结果更新前级预测器的预测结果等）。
当 iprefetchpipe 的 s1 被刷新时，itlb 也应该被刷新，该信号会在 s1 流水被置位。</p>
<h4 id="pmp-物理内存保护相关的信息">pmp: 物理内存保护相关的信息</h4>
<p>在 s1 流水级做 pmp 检查。
pmp 包含 req 和 resp 两个子结构。</p>
<p>req 的结构如下（编译后）：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>addr</td>
          <td>pmp 检查的地址。</td>
      </tr>
  </tbody>
</table>
<p>resp 的结构如下（编译后）：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>instr</td>
          <td>指示物理地址是否有权限访问，没有则会引起 pmp 的 af 异常。</td>
      </tr>
      <tr>
          <td>mmio</td>
          <td>地址在 mmio 空间。</td>
      </tr>
  </tbody>
</table>
<h4 id="metaread-和-metaarray-交互的读请求和读响应">metaRead： 和 MetaArray 交互的读请求和读响应</h4>
<p>在 s1 流水级读 meta。</p>
<p>metaRead 包含 toIMeta 和 fromIMeta 两个子结构，即读请求和读响应。</p>
<p>toIMeta 的结构如下（编译后）：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引（Virtual Set Index）。</td>
      </tr>
      <tr>
          <td>isDoubleLine</td>
          <td>预测块是否跨缓存行。</td>
      </tr>
  </tbody>
</table>
<p>fromIMeta 的结构如下（编译后）：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>metas</td>
          <td>MetaArray 的本身，包含 tag 量。tag，即 cache 的标签。</td>
      </tr>
      <tr>
          <td>codes</td>
          <td>ptag 的 ecc 校验码。</td>
      </tr>
      <tr>
          <td>entryValid</td>
          <td>指示 meta 是否有效。</td>
      </tr>
  </tbody>
</table>
<h4 id="mshrreq-mshr-请求">MSHRReq： MSHR 请求</h4>
<p>预取逻辑检测到未命中时，在 s2 流水级，向 MissUnit 发送请求。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>blkPaddr</td>
          <td>要从 tilelink 获取的缓存行的物理地址。</td>
      </tr>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引。</td>
      </tr>
  </tbody>
</table>
<h4 id="mshrresp-mshr-响应">MSHRResp: MSHR 响应</h4>
<p>用于在 s1 流水级更新 waymasks 和 meta_codes 以及 s2 流水级判断返回的响应是否命中。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>blkPaddr</td>
          <td>已从 tilelink 获取的缓存行的物理地址。</td>
      </tr>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>标识由 MSHR 处理的缺失（miss）请求完成后，返回的数据块应该写入到哪个路（way）中。</td>
      </tr>
      <tr>
          <td>corrupt</td>
          <td>返回的数据块是否损坏。</td>
      </tr>
  </tbody>
</table>
<h4 id="waylookupwrite-向-waylookup-写数据">wayLookupWrite： 向 waylookup 写数据</h4>
<p>在 s1 流水级，向 waylookup 写数据。
包含 entry（WayLookupEntry）和 gpf（WayLookupGPFEntry）两个子结构。</p>
<p>entry 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>来自 MSHR 的 waymask。</td>
      </tr>
      <tr>
          <td>ptag</td>
          <td>物理地址标签。</td>
      </tr>
      <tr>
          <td>itlb_exception</td>
          <td>指示 itlb 是否产生了异常 pf/gpf/af</td>
      </tr>
      <tr>
          <td>itlb_pbmt</td>
          <td>指示 itlb 是否产生 pbmt。</td>
      </tr>
      <tr>
          <td>meta_codes</td>
          <td>meta 的 ecc 校验码。</td>
      </tr>
  </tbody>
</table>
<p>gpf 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>gpaddr</td>
          <td>客户页地址。</td>
      </tr>
      <tr>
          <td>isForVSnonLeafPTE</td>
          <td>指示是否为非叶 PTE。</td>
      </tr>
  </tbody>
</table>
<h3 id="mainpipe-模块接口">MainPipe 模块接口</h3>
<h4 id="不需要关注的接口">不需要关注的接口</h4>
<p><code>hartId</code>硬件线程 ID，difftest 使用，不需要关注。</p>
<p><code>perfInfo</code>性能信息，不需要关注。</p>
<h4 id="dataarray和-dataarray-交互的读请求和读响应">dataArray：和 DataArray 交互的读请求和读响应</h4>
<p>在 s0 流水级读请求。</p>
<p>dataArray 包含 toData 和 fromData 两个子结构，即读请求和读响应。</p>
<p>toData 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>标识由 MSHR 处理的缺失（miss）请求完成后，返回的数据块应该写入到哪个路（way）中。通过 MissUnit 写给 prefetch，prefetch 写入 waylookup，mainpipe 从 waylookup 中读出。</td>
      </tr>
      <tr>
          <td>blkOffset</td>
          <td>指令在块中的偏移。</td>
      </tr>
      <tr>
          <td>isDoubleLine</td>
          <td>预测块是否跨缓存行。</td>
      </tr>
  </tbody>
</table>
<p>fromData 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>datas</td>
          <td>DataArray 本身的数据。</td>
      </tr>
      <tr>
          <td>codes</td>
          <td>data 的 ecc 校验码。</td>
      </tr>
  </tbody>
</table>
<h4 id="metaarrayflush-刷新-metaarray">metaArrayFlush： 刷新 metaArray</h4>
<p>在 s2 流水级，向 metaArray 发送刷新请求, 为重新取指做准备。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>virIdx</td>
          <td>需要刷新的虚拟地址索引。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>需要刷新的路。</td>
      </tr>
  </tbody>
</table>
<h4 id="touch-更新-replacer">touch: 更新 replacer</h4>
<p>在 s1 流水级，更新 replacer，向 replacer 发送 touch 请求。
把一次访问告诉 replacer，让它更新 plru 状态。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>vSetIdx</td>
          <td>被访问的缓存行的虚拟组索引。</td>
      </tr>
      <tr>
          <td>way</td>
          <td>被访问的缓存行在集合中的路。</td>
      </tr>
  </tbody>
</table>
<h4 id="waylookupread-读取预取流水写入-waylookup-的信息">wayLookupRead： 读取预取流水写入 waylookup 的信息</h4>
<p>在 s0 流水级，从 waylookup 获取元信息。
包含 entry（WayLookupEntry）和 gpf（WayLookupGPFEntry）两个子结构。</p>
<p>entry 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>waymask</td>
          <td>来自 MSHR 的 waymask。</td>
      </tr>
      <tr>
          <td>ptag</td>
          <td>物理地址标签。</td>
      </tr>
      <tr>
          <td>itlb_exception</td>
          <td>指示 itlb 是否产生了异常 pf/gpf/af</td>
      </tr>
      <tr>
          <td>itlb_pbmt</td>
          <td>指示 itlb 是否产生 pbmt。</td>
      </tr>
      <tr>
          <td>meta_codes</td>
          <td>meta 的 ecc 校验码。</td>
      </tr>
  </tbody>
</table>
<p>gpf 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>gpaddr</td>
          <td>客户页地址。</td>
      </tr>
      <tr>
          <td>isForVSnonLeafPTE</td>
          <td>指示是否为非叶 PTE。</td>
      </tr>
  </tbody>
</table>
<h4 id="mshr-对-missunit-中的-mshr-的请求和响应">mshr: 对 MissUnit 中的 mshr 的请求和响应</h4>
<p>在 s1 流水级，监听 MSHR 的响应。
在 s2 流水级，缺失时将请求发送至 MissUnit，同时对 MSHR 的响应进行监听，命中时寄存 MSHR 响应的数据。</p>
<p>包含 req 和 resp 两个子结构。</p>
<p>req 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>blkPaddr</td>
          <td>要从 tilelink 获取的缓存行的物理地址。</td>
      </tr>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引。</td>
      </tr>
  </tbody>
</table>
<p>resp 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>blkPaddr</td>
          <td>已从 tilelink 获取的缓存行的物理地址。</td>
      </tr>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>标识由 MSHR 处理的缺失（miss）请求完成后，返回的数据块应该写入到哪个路（way）中。</td>
      </tr>
      <tr>
          <td>data</td>
          <td>返回的数据块。</td>
      </tr>
      <tr>
          <td>corrupt</td>
          <td>返回的数据块是否损坏。</td>
      </tr>
  </tbody>
</table>
<h4 id="fetch-与-ftq-交互和-ifu-交互接口">fetch: 与 FTQ 交互和 IFU 交互接口</h4>
<p>包含 req 和 resp 两个子结构。</p>
<h5 id="req-ftq-取指请求">req： FTQ 取指请求</h5>
<p>在 s0 流水级，接收 FTQ 的取指请求。
包含 pcMemRead,readValid 和 backendException 三个子结构。</p>
<p>其中 pcMemRead 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>startAddr</td>
          <td>预测块起始地址。</td>
      </tr>
      <tr>
          <td>nextlineStart</td>
          <td>预测块下一个缓存行的起始地址。</td>
      </tr>
  </tbody>
</table>
<p>readValid:读取请求的有效性。</p>
<p>backendException：是否有来自后端的 Exception。</p>
<h5 id="resp-ifu-取指响应">resp: IFU 取指响应</h5>
<p>在 s2 流水级，向 IFU 发送取指响应。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>doubleLine</td>
          <td>指示预测块是否跨缓存行。</td>
      </tr>
      <tr>
          <td>vaddr</td>
          <td>指令块起始虚拟地址、下一个缓存行的虚拟地址。</td>
      </tr>
      <tr>
          <td>data</td>
          <td>要传送的缓存行。</td>
      </tr>
      <tr>
          <td>paddr</td>
          <td>指令块的起始物理地址</td>
      </tr>
      <tr>
          <td>exception</td>
          <td>向 IFU 报告每个缓存行上的异常情况，方便 ICache 生成每个指令的异常向量。</td>
      </tr>
      <tr>
          <td>pmp_mmio</td>
          <td>指示当前指令块是否在 MMIO 空间。</td>
      </tr>
      <tr>
          <td>itlb_pbmt</td>
          <td>ITLB 基于客户页的内存类型，对 MMIO 状态有用。</td>
      </tr>
      <tr>
          <td>backendException</td>
          <td>后端是否存在异常。</td>
      </tr>
      <tr>
          <td>gpaddr</td>
          <td>客户页地址。</td>
      </tr>
      <tr>
          <td>isForVSnonLeafPTE</td>
          <td>是否为非叶的 PTE，来自 itlb。</td>
      </tr>
  </tbody>
</table>
<h4 id="flush全局刷新信号">flush：全局刷新信号</h4>
<p>来自 FTQ。</p>
<h4 id="pmp-物理内存保护相关的信息-1">pmp: 物理内存保护相关的信息</h4>
<p>在 s1 流水级做 pmp 检查。
pmp 包含 req 和 resp 两个子结构。</p>
<p>req 的结构如下（编译后）：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>addr</td>
          <td>需要检查的地址</td>
      </tr>
  </tbody>
</table>
<p>resp 的结构如下（编译后）：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>instr</td>
          <td>指示物理地址是否有权限访问，没有则会引起 pmp 的 af 异常。</td>
      </tr>
      <tr>
          <td>mmio</td>
          <td>地址在 mmio 空间。</td>
      </tr>
  </tbody>
</table>
<h4 id="respstall">respStall</h4>
<p>IFU 的 f3_ready 为低时会被置位,表示 IFU 没有准备好接收数据，此时需要 stall。</p>
<h4 id="errors-向-beu-报告指令缓存中检测到的错误">errors: 向 BEU 报告指令缓存中检测到的错误</h4>
<p>在 s2 流水级，综合 data 的 ECC 校验加上从 s1 传来的 meta 的 ECC 校验结果，决定是否向 BEU 报告错误。</p>
<p>编译后：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>valid</td>
          <td>指示 errors 是否有效。</td>
      </tr>
      <tr>
          <td>bits</td>
          <td>有两个量。paddr 表示错误的物理地址，report_to_beu 表示是否向 beu 报告错误</td>
      </tr>
  </tbody>
</table>
<h4 id="perfinfo-性能相关信息不关注">perfInfo： 性能相关信息，不关注</h4>
<h3 id="waylookup-模块接口">WayLookup 模块接口</h3>
<h4 id="flush全局刷新信号-1">flush：全局刷新信号</h4>
<p>来自 FTQ。</p>
<h4 id="readmainpipe-的读接口">read：Mainpipe 的读接口</h4>
<p>包含 entry（WayLookupEntry）和 gpf（WayLookupGPFEntry）两个子结构。</p>
<p>entry 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>waymask</td>
          <td>来自 MSHR 的 waymask。</td>
      </tr>
      <tr>
          <td>ptag</td>
          <td>物理地址标签。</td>
      </tr>
      <tr>
          <td>itlb_exception</td>
          <td>指示 itlb 是否产生了异常 pf/gpf/af</td>
      </tr>
      <tr>
          <td>itlb_pbmt</td>
          <td>指示 itlb 是否产生 pbmt。</td>
      </tr>
      <tr>
          <td>meta_codes</td>
          <td>meta 的 ecc 校验码。</td>
      </tr>
  </tbody>
</table>
<p>gpf 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>gpaddr</td>
          <td>客户页地址。</td>
      </tr>
      <tr>
          <td>isForVSnonLeafPTE</td>
          <td>指示是否为非叶 PTE。</td>
      </tr>
  </tbody>
</table>
<h4 id="writeiprefetchpipe-的写接口">write：IprefetchPipe 的写接口</h4>
<p>包含 entry（WayLookupEntry）和 gpf（WayLookupGPFEntry）两个子结构。</p>
<p>entry 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>来自 MSHR 的 waymask。</td>
      </tr>
      <tr>
          <td>ptag</td>
          <td>物理地址标签。</td>
      </tr>
      <tr>
          <td>itlb_exception</td>
          <td>指示 itlb 是否产生了异常 pf/gpf/af</td>
      </tr>
      <tr>
          <td>itlb_pbmt</td>
          <td>指示 itlb 是否产生 pbmt。</td>
      </tr>
      <tr>
          <td>meta_codes</td>
          <td>meta 的 ecc 校验码。</td>
      </tr>
  </tbody>
</table>
<p>gpf 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>gpaddr</td>
          <td>客户页地址。</td>
      </tr>
      <tr>
          <td>isForVSnonLeafPTE</td>
          <td>指示是否为非叶 PTE。</td>
      </tr>
  </tbody>
</table>
<h4 id="updatemissunit-的更新接口">update：MissUnit 的更新接口</h4>
<p>在 IPrefetchPipe 中等待入队 WayLookup 阶段和在 WayLookup 中等待出队阶段，可能会发生 MSHR 对 Meta/DataArray 的更新。也就是命中状态可能在出入队 WayLookup 时不同。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>blkPaddr</td>
          <td>已从 tilelink 获取的缓存行的物理地址。</td>
      </tr>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>标识由 MSHR 处理的缺失（miss）请求完成后，返回的数据块应该写入到哪个路（way）中。</td>
      </tr>
      <tr>
          <td>corrupt</td>
          <td>返回的数据块是否损坏。</td>
      </tr>
  </tbody>
</table>
<h3 id="missunit-模块接口">MissUnit 模块接口</h3>
<h4 id="fencei-软件刷新信号">fencei： 软件刷新信号</h4>
<h4 id="flush全局刷新信号-2">flush：全局刷新信号</h4>
<p>来自 FTQ。</p>
<h4 id="fetch_reqmainpipe-的取指请求缺失时的请求">fetch_req：MainPipe 的取指请求缺失时的请求</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>blkPaddr</td>
          <td>要从 tilelink 获取的缓存行的物理地址。</td>
      </tr>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引。</td>
      </tr>
  </tbody>
</table>
<h4 id="fetch_respf-mainpipe-的取指响应缺失时的响应">fetch_respf: MainPipe 的取指响应缺失时的响应</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>blkPaddr</td>
          <td>已从 tilelink 获取的缓存行的物理地址。</td>
      </tr>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>标识由 MSHR 处理的缺失（miss）请求完成后，返回的数据块应该写入到哪个路（way）中。</td>
      </tr>
      <tr>
          <td>data</td>
          <td>返回的数据块。</td>
      </tr>
      <tr>
          <td>corrupt</td>
          <td>返回的数据块是否损坏。</td>
      </tr>
  </tbody>
</table>
<h4 id="prefetch_req-iprefetchpipe-的预取请求缺失时的请求">prefetch_req: IPrefetchPipe 的预取请求缺失时的请求</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>blkPaddr</td>
          <td>要从 tilelink 获取的缓存行的物理地址。</td>
      </tr>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引。</td>
      </tr>
  </tbody>
</table>
<h4 id="meta_write-metaarray-的写请求接口">meta_write: MetaArray 的写请求接口</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>virIdx</td>
          <td>需要写入的虚拟地址索引。</td>
      </tr>
      <tr>
          <td>phyTag</td>
          <td>需要写入的物理地址标签。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>指示写入哪一路。</td>
      </tr>
      <tr>
          <td>bankIdx</td>
          <td>指示写入哪一个存储体索引。</td>
      </tr>
  </tbody>
</table>
<h4 id="data_write-dataarray-的写请求接口">data_write: DataArray 的写请求接口</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>virIdx</td>
          <td>需要写入的虚拟地址索引。</td>
      </tr>
      <tr>
          <td>data</td>
          <td>需要写入的数据块。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>需要写入的路。</td>
      </tr>
  </tbody>
</table>
<h4 id="victim与缓存的替换器replacer交互获取需要被替换的缓存路way的信息">victim：与缓存的替换器（replacer）交互，获取需要被替换的缓存路（way）的信息</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引。</td>
      </tr>
      <tr>
          <td>way</td>
          <td>被替换的路。</td>
      </tr>
  </tbody>
</table>
<h4 id="mem_acquiretilelink-a-通道发送请求">mem_acquire：Tilelink a 通道发送请求</h4>
<p>L2 的总线空闲时，发送请求。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>source</td>
          <td>标识发起此请求的源。</td>
      </tr>
      <tr>
          <td>address</td>
          <td>要访问的内存的起始物理地址。</td>
      </tr>
  </tbody>
</table>
<h4 id="mem_granttilelink-d-通道返回数据">mem_grant：Tilelink d 通道返回数据</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>opcode</td>
          <td>标识响应消息类型的关键字段，它指示了响应的性质和意图。针对 acquire 请求的响应是 GrantData (5,授予)</td>
      </tr>
      <tr>
          <td>source</td>
          <td>请求的源标识。</td>
      </tr>
      <tr>
          <td>data</td>
          <td>返回的数据块。</td>
      </tr>
      <tr>
          <td>corrupt</td>
          <td>返回的数据块是否损坏。</td>
      </tr>
  </tbody>
</table>
<h3 id="fifo-模块接口">FIFO 模块接口</h3>
<h4 id="enq-入队信号">enq: 入队信号</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>valid</td>
          <td>指示 enq 是否有效。</td>
      </tr>
      <tr>
          <td>bits</td>
          <td>要入队的数据。</td>
      </tr>
  </tbody>
</table>
<h4 id="deq-出队信号">deq: 出队信号</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ready</td>
          <td>指示 deq 是否就绪。</td>
      </tr>
      <tr>
          <td>bits</td>
          <td>要出队的数据。</td>
      </tr>
  </tbody>
</table>
<h3 id="replacer-模块接口">Replacer 模块接口</h3>
<h4 id="touch-更新-replacer-1">touch： 更新 replacer</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>vSetIdx</td>
          <td>被访问的缓存行的虚拟组索引。</td>
      </tr>
      <tr>
          <td>way</td>
          <td>被访问的缓存行在集合中的路。</td>
      </tr>
  </tbody>
</table>
<h4 id="victim-与缓存的替换器replacer交互获取需要被替换的缓存路way的信息">victim： 与缓存的替换器（replacer）交互，获取需要被替换的缓存路（way）的信息</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引。</td>
      </tr>
      <tr>
          <td>way</td>
          <td>被替换的路。</td>
      </tr>
  </tbody>
</table>
<h3 id="metaarray-模块接口">MetaArray 模块接口</h3>
<h4 id="write-metaarray-的写请求接口">write: MetaArray 的写请求接口</h4>
<p>写请求来自 MissUnit 或者 CtrlUnit。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>virIdx</td>
          <td>需要写入的虚拟地址索引。</td>
      </tr>
      <tr>
          <td>phyTag</td>
          <td>需要写入的物理地址标签。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>指示写入哪一路。</td>
      </tr>
      <tr>
          <td>bankIdx</td>
          <td>指示写入哪一个存储体索引。</td>
      </tr>
      <tr>
          <td>poison</td>
          <td>指示是否为毒化位。</td>
      </tr>
  </tbody>
</table>
<h4 id="read-metaarray-的读请求接口">read: MetaArray 的读请求接口</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引（Virtual Set Index）。</td>
      </tr>
      <tr>
          <td>isDoubleLine</td>
          <td>预测块是否跨缓存行。</td>
      </tr>
  </tbody>
</table>
<h4 id="readresp-metaarray-的读响应接口">readResp： MetaArray 的读响应接口</h4>
<p>fromIMeta 的结构如下（编译后）：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>metas</td>
          <td>MetaArray 的本身，包含 tag 量。tag，即 cache 的标签。</td>
      </tr>
      <tr>
          <td>codes</td>
          <td>ptag 的 ecc 校验码。</td>
      </tr>
      <tr>
          <td>entryValid</td>
          <td>指示 meta 是否有效。</td>
      </tr>
  </tbody>
</table>
<h4 id="flush双端刷新信号">flush：双端刷新信号</h4>
<p>来自 MainPipe 的刷新信号。可以只刷新指定的某一个端口，也可以都刷新。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>virIdx</td>
          <td>需要刷新的虚拟地址索引。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>需要刷新的路。</td>
      </tr>
  </tbody>
</table>
<h4 id="flushall刷新所有-metaarray">flushAll：刷新所有 MetaArray</h4>
<p>来自软件刷新信号 fencei。</p>
<h3 id="dataarray-模块接口">DataArray 模块接口</h3>
<h4 id="writedataarray-的写请求接口">write：DataArray 的写请求接口</h4>
<p>来自 MissUnit 或者 CtrlUnit 的写请求。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>virIdx</td>
          <td>需要写入的虚拟地址索引。</td>
      </tr>
      <tr>
          <td>data</td>
          <td>需要写入的数据块。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>需要写入的路。</td>
      </tr>
      <tr>
          <td>poison</td>
          <td>指示是否为毒化位。</td>
      </tr>
  </tbody>
</table>
<h4 id="readdataarray-的读请求接口">read：DataArray 的读请求接口</h4>
<p>来自 MainPipe 的读请求。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>vSetIdx</td>
          <td>虚拟地址的缓存组索引。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>标识由 MSHR 处理的缺失（miss）请求完成后，返回的数据块应该写入到哪个路（way）中。通过 MissUnit 写给 prefetch，prefetch 写入 waylookup，mainpipe 从 waylookup 中读出。</td>
      </tr>
      <tr>
          <td>blkOffset</td>
          <td>指令在块中的偏移。</td>
      </tr>
  </tbody>
</table>
<h4 id="readrespdataarray-的读响应接口">readResp：DataArray 的读响应接口</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>datas</td>
          <td>DataArray 本身的数据。</td>
      </tr>
      <tr>
          <td>codes</td>
          <td>data 的 ecc 校验码。</td>
      </tr>
  </tbody>
</table>
<h3 id="ctrlunit-模块接口">CtrlUnit 模块接口</h3>
<h4 id="auto_in-tilelink-相关接口">auto_in: Tilelink 相关接口</h4>
<p>CtrlUnit 和 Tilelink 交互，分为 a 通道和 d 通道。</p>
<p>a 通道：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>opcode</td>
          <td>标识携带消息类型。</td>
      </tr>
      <tr>
          <td>size</td>
          <td>传输的数据大小对数，表示操作的字节数为$2^n$。</td>
      </tr>
      <tr>
          <td>source</td>
          <td>标识发起此请求的源，主设备源标识符。</td>
      </tr>
      <tr>
          <td>address</td>
          <td>传输的目标字节地址。</td>
      </tr>
      <tr>
          <td>mask</td>
          <td>要读的字节通道。</td>
      </tr>
      <tr>
          <td>data</td>
          <td>忽略。</td>
      </tr>
  </tbody>
</table>
<p>d 通道：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>opcode</td>
          <td>标识携带消息类型。</td>
      </tr>
      <tr>
          <td>size</td>
          <td>传输的数据大小对数，表示操作的字节数为$2^n$。</td>
      </tr>
      <tr>
          <td>source</td>
          <td>标识发起此请求的源，主设备源标识符。</td>
      </tr>
      <tr>
          <td>data</td>
          <td>数据载荷。</td>
      </tr>
  </tbody>
</table>
<h4 id="ecc_enable-ecc-控制信号">ecc_enable： ecc 控制信号</h4>
<p>指示 ecc 是否开启。</p>
<h4 id="injecting-ecc-注入信号">injecting： ecc 注入信号</h4>
<p>指示 eccctrl 的 istatus 域是否处于 working 状态，即收到注入请求，注入中</p>
<h4 id="metaread-对-metaarray-的读请求">metaRead： 对 MetaArray 的读请求</h4>
<p>在对应读状态机 is_readMetaReq 中，对 MetaArray 发起读请求。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>vSetIdx</td>
          <td>要读取的拟地址的缓存组索引。</td>
      </tr>
  </tbody>
</table>
<h4 id="metareadresp-对-metaarray-的读响应">metaReadResp： 对 MetaArray 的读响应</h4>
<p>在状态机 is_readMetaResp 中，接收 MetaArray 的读响应。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>metas</td>
          <td>MetaArray 的本身，包含 tag 量。tag，即 cache 的标签。</td>
      </tr>
      <tr>
          <td>entryValid</td>
          <td>指示 meta 是否有效。</td>
      </tr>
  </tbody>
</table>
<h4 id="metawrite-对-metaarray-的写">metaWrite： 对 MetaArray 的写</h4>
<p>在状态机 is_writeMeta 中，对 MetaArray 发起写。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>virIdx</td>
          <td>需要写入的虚拟地址索引。</td>
      </tr>
      <tr>
          <td>phyTag</td>
          <td>需要写入的物理地址标签。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>指示写入哪一路。</td>
      </tr>
      <tr>
          <td>bankIdx</td>
          <td>指示写入哪一个存储体索引。</td>
      </tr>
  </tbody>
</table>
<h4 id="datawrite-对-dataarray-的写请求">dataWrite： 对 DataArray 的写请求</h4>
<p>在状态机 is_writeData 中，对 DataArray 发起写请求。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>virIdx</td>
          <td>需要写入的虚拟地址索引。</td>
      </tr>
      <tr>
          <td>waymask</td>
          <td>需要写入的路。</td>
      </tr>
  </tbody>
</table>
<h3 id="icache-顶层模块接口">ICache 顶层模块接口</h3>
<p>在 scala 代码中，顶层模块除了包含对外的接口，实际上还包括了 MetaArray、DataArray 和 Replacer。在编译成 verilog 后，这三个模块会被编译成三个独立的模块，然后再通过顶层模块的接口连接起来。</p>
<h4 id="不需要关注的接口-1">不需要关注的接口</h4>
<p><code>hartId</code>硬件线程 ID，difftest 使用，不需要关注。
<code>perfInfo</code>性能信息，不需要关注。</p>
<h4 id="auto_ctrlunitopt_inctrlunit-和-tilelink-交互的接口">auto_ctrlUnitOpt_in：CtrlUnit 和 Tilelink 交互的接口</h4>
<p>CtrlUnit 和 Tilelink 交互，分为 a 通道和 d 通道。</p>
<p>a 通道：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>opcode</td>
          <td>标识携带消息类型。</td>
      </tr>
      <tr>
          <td>size</td>
          <td>传输的数据大小对数，表示操作的字节数为$2^n$。</td>
      </tr>
      <tr>
          <td>source</td>
          <td>标识发起此请求的源，主设备源标识符。</td>
      </tr>
      <tr>
          <td>address</td>
          <td>传输的目标字节地址。</td>
      </tr>
      <tr>
          <td>mask</td>
          <td>要读的字节通道。</td>
      </tr>
      <tr>
          <td>data</td>
          <td>忽略。</td>
      </tr>
  </tbody>
</table>
<p>d 通道：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>opcode</td>
          <td>标识携带消息类型。</td>
      </tr>
      <tr>
          <td>size</td>
          <td>传输的数据大小对数，表示操作的字节数为$2^n$。</td>
      </tr>
      <tr>
          <td>source</td>
          <td>标识发起此请求的源，主设备源标识符。</td>
      </tr>
      <tr>
          <td>data</td>
          <td>数据载荷。</td>
      </tr>
  </tbody>
</table>
<h4 id="auto_client_out-missunit-和-tilelink-交互的接口">auto_client_out： MissUnit 和 Tilelink 交互的接口</h4>
<p>MissUnit 和 Tilelink 交互，分为 a 通道和 d 通道。
a 通道：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>source</td>
          <td>标识发起此请求的源。</td>
      </tr>
      <tr>
          <td>address</td>
          <td>要访问的内存的起始物理地址。</td>
      </tr>
  </tbody>
</table>
<p>d 通道：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>opcode</td>
          <td>标识响应消息类型的关键字段，它指示了响应的性质和意图。针对 acquire 请求的响应是 GrantData (5,授予)</td>
      </tr>
      <tr>
          <td>source</td>
          <td>请求的源标识。</td>
      </tr>
      <tr>
          <td>data</td>
          <td>返回的数据块。</td>
      </tr>
      <tr>
          <td>corrupt</td>
          <td>返回的数据块是否损坏。</td>
      </tr>
  </tbody>
</table>
<h4 id="fetch-与-ftq-交互和-ifu-交互接口-1">fetch: 与 FTQ 交互和 IFU 交互接口</h4>
<p>包含 req 和 resp 两个子结构。</p>
<h5 id="req-ftq-取指请求-1">req： FTQ 取指请求</h5>
<p>在 s0 流水级，接收 FTQ 的取指请求。
包含 pcMemRead,readValid 和 backendException 三个子结构。</p>
<p>其中 pcMemRead 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>startAddr</td>
          <td>预测块起始地址。</td>
      </tr>
      <tr>
          <td>nextlineStart</td>
          <td>预测块下一个缓存行的起始地址。</td>
      </tr>
  </tbody>
</table>
<p>readValid:读取请求的有效性。</p>
<p>backendException：是否有来自后端的 Exception。</p>
<h5 id="resp-ifu-取指响应-1">resp: IFU 取指响应</h5>
<p>在 s2 流水级，向 IFU 发送取指响应。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>doubleLine</td>
          <td>指示预测块是否跨缓存行。</td>
      </tr>
      <tr>
          <td>vaddr</td>
          <td>指令块起始虚拟地址、下一个缓存行的虚拟地址。</td>
      </tr>
      <tr>
          <td>data</td>
          <td>要传送的缓存行。</td>
      </tr>
      <tr>
          <td>paddr</td>
          <td>指令块的起始物理地址</td>
      </tr>
      <tr>
          <td>exception</td>
          <td>向 IFU 报告每个缓存行上的异常情况，方便 ICache 生成每个指令的异常向量。</td>
      </tr>
      <tr>
          <td>pmp_mmio</td>
          <td>指示当前指令块是否在 MMIO 空间。</td>
      </tr>
      <tr>
          <td>itlb_pbmt</td>
          <td>ITLB 基于客户页的内存类型，对 MMIO 状态有用。</td>
      </tr>
      <tr>
          <td>backendException</td>
          <td>后端是否存在异常。</td>
      </tr>
      <tr>
          <td>gpaddr</td>
          <td>客户页地址。</td>
      </tr>
      <tr>
          <td>isForVSnonLeafPTE</td>
          <td>是否为非叶的 PTE，来自 itlb。</td>
      </tr>
  </tbody>
</table>
<h4 id="ftqprefetchftq-预取相关信息">ftqPrefetch:FTQ 预取相关信息</h4>
<p>包含三个子结构：
req： 来自 FTQ 的预取请求
flushFromBpu:来自 BPU 的刷新信息
bakckendException:来自后端的异常信息</p>
<h5 id="req-来自-ftq-的预取请求">req： 来自 FTQ 的预取请求</h5>
<p>由于 BPU 基本无阻塞，它经常能走到 IFU 的前面，于是 BPU 提供的这些还没发到 IFU 的取指请求就可以用作指令预取，FTQ 中实现了这部分逻辑，直接给 ICache 发送预取请求。
预取请求来自 FTQ，在 MainPipe 的 S0 流水级传入。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ready</td>
          <td></td>
      </tr>
      <tr>
          <td>valid</td>
          <td>指示软件预取或者硬件预取是否有效。</td>
      </tr>
      <tr>
          <td>startAddr</td>
          <td>预测块起始地址。</td>
      </tr>
      <tr>
          <td>nextlineStart</td>
          <td>预测块下一个缓存行的起始地址。</td>
      </tr>
      <tr>
          <td>ftqIdx</td>
          <td>指示当前预测块在 FTQ 中的位置，包含 flag 和 value 两个量。</td>
      </tr>
  </tbody>
</table>
<h5 id="flushfrombpu来自-bpu-的刷新信息-1">flushFromBpu:来自 BPU 的刷新信息</h5>
<p>由 FTQ 传递而来的 BPU 刷新信息，在 MainPipe 的 S0 流水级传入。
这是预测错误引起的，包括 s2 和 s3 两个同构成员，指示是否在 BPU 的 s2 和 s3 流水级发现了问题。
s2 的详细结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>valid</td>
          <td>指示 s2 是否有效。</td>
      </tr>
      <tr>
          <td>ftqIdx</td>
          <td>指示 s2 流水级请求冲刷的预测块在 FTQ 中的位置，包含 flag 和 value 两个量。</td>
      </tr>
  </tbody>
</table>
<h5 id="backendexception-后端异常信息">backendException： 后端异常信息</h5>
<p>ICache 向 IFU 报告后端存在的异常类型</p>
<h4 id="softprefetch-来自-memblock-的软件预取信息">softPrefetch： 来自 Memblock 的软件预取信息</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>vaddr</td>
          <td>软件预取的虚拟地址。</td>
      </tr>
  </tbody>
</table>
<h4 id="stop-ifu-发送到-icache-的停止信号">stop： IFU 发送到 ICache 的停止信号</h4>
<p>IFU 在 F3 流水级之前出现了问题，通知 ICache 停下。</p>
<h4 id="toifu-发送给-i-fu-的就绪信号">ToIFU： 发送给 I FU 的就绪信号</h4>
<p>由 MainPipe 的 s0 流水级 s0_can_go 生成。该信号用于提醒 IFU，Icache 的流水可用，可以发送换存行了。</p>
<h4 id="pmp-mainpipe-和-prefetchpipe-的-pmp-信息">pmp： MainPipe 和 PrefetchPipe 的 pmp 信息</h4>
<p>0,1 通道为 MainPipe 的 pmp 信息，2,3 通道为 PrefetchPipe 的 pmp 信息。
pmp 包含 req 和 resp 两个子结构。</p>
<p>req 的结构如下（编译后）：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>addr</td>
          <td>需要检查的地址</td>
      </tr>
  </tbody>
</table>
<p>resp 的结构如下（编译后）：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>instr</td>
          <td>指示物理地址是否有权限访问，没有则会引起 pmp 的 af 异常。</td>
      </tr>
      <tr>
          <td>mmio</td>
          <td>地址在 mmio 空间。</td>
      </tr>
  </tbody>
</table>
<h4 id="itlbprefetchpipe-的-itlb-信息">itlb：PrefetchPipe 的 itlb 信息</h4>
<p>在 PrefetchPipe 的 s0 流水级，发送 itlb_req；在 PrefetchPipe 的 s1 流水级，如果 itlb 命中则直接接收 itlb_resp，否则重发 itlb_req。</p>
<p>itlb 包含 req 和 resp 两个子结构。</p>
<p>req 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>valid</td>
          <td>指示 req 请求是否有效。</td>
      </tr>
      <tr>
          <td>Tlbreq</td>
          <td>有多个子结构，这里我们只用上了 vaddr,即 req 请求的虚拟地址</td>
      </tr>
  </tbody>
</table>
<p>resp 的结构如下：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>paddr</td>
          <td>指令物理地址。</td>
      </tr>
      <tr>
          <td>gpaddr</td>
          <td>客户页地址。</td>
      </tr>
      <tr>
          <td>pbmt</td>
          <td>基于页面的内存类型。</td>
      </tr>
      <tr>
          <td>miss</td>
          <td>指示 itlb 是否未命中。</td>
      </tr>
      <tr>
          <td>isForVSnonLeafPTE</td>
          <td>指示是否为非叶 PTE。</td>
      </tr>
      <tr>
          <td>excp</td>
          <td>ITLB 可能产生的异常，包括：访问异常指令 af_instr、客户页错误指令 gpf_instr、页错误指令 pf_instr。见<a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#%e5%bc%82%e5%b8%b8%e4%bc%a0%e9%80%92%e7%89%b9%e6%ae%8a%e6%83%85%e5%86%b5%e5%a4%84%e7%90%86">异常传递/特殊情况处理</a></td>
      </tr>
  </tbody>
</table>
<h4 id="itlbflushpipe-itlb-刷新信号">itlbFlushPipe： itlb 刷新信号</h4>
<p>在 itlb 中，如果出现 gpf 的取指请求处于推测路径上，且发现出现错误的推测，则会通过 flushPipe 信号进行刷新（包括后端 redirect、或前端多级分支预测器出现后级预测器的预测结果更新前级预测器的预测结果等）。
当 iprefetchpipe 的 s1 被刷新时，itlb 也应该被刷新，该信号会在 iprefetchpipe 的 s1 流水被置位。</p>
<h4 id="error向-beu-报告指令缓存中检测到的错误">error：向 BEU 报告指令缓存中检测到的错误</h4>
<p>将 MainPipe 中收集到的 errors 多个错误信息，使用优先级选择器选择索引最小且有效的错误信息，然后通过 error 信号发送给 BEU。接口结构和 MainPipe 中相同，区别在于 MainPipe 中有两个端口，所以有两个 errors,而这里要发送的只有一个。</p>
<p>编译后：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>valid</td>
          <td>指示 errors 是否有效。</td>
      </tr>
      <tr>
          <td>bits</td>
          <td>有两个量。paddr 表示错误的物理地址，report_to_beu 表示是否向 beu 报告错误</td>
      </tr>
  </tbody>
</table>
<h4 id="csr_pf_enable">csr_pf_enable</h4>
<p>控制 s1_real_fire，软件控制预取开关</p>
<h4 id="fencei-软件刷新信号-1">fencei： 软件刷新信号</h4>
<h4 id="flush-全局刷新信号">flush： 全局刷新信号</h4>
<p>在 FTQ 中，有后端重新定向或者 IFU 重定向时，会将其 icacheFlush 信号拉高，触发 icache 的刷新。</p>
<h2><strong><a id="icache_functions">测试点汇总 </a></strong></h2>
<p>再次声明，本测试点仅供参考，如果有其他测试点需要补充可以告知我们。</p>
<p>建议覆盖点采用<code>功能名称</code>_<code>测试点名称</code>命名。</p>
<mrs-testpoints>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#11-%e7%a1%ac%e4%bb%b6%e9%a2%84%e5%8f%96%e8%af%b7%e6%b1%82">ICACHE_PREFETCH_HARDPREFETCH</a></td>
          <td>RECEIVE</td>
          <td>当预取请求有效且 IPrefetchPipe 处于空闲状态时，预取请求应该被接收。<br> s0_fire 信号在没有 s0 的刷新信号（ s0_flush 为低）时，应该被置为高。</td>
      </tr>
      <tr>
          <td>1.1.2</td>
          <td>ICACHE_PREFETCH_HARDPREFETCH</td>
          <td>INVALID_PREFETCH</td>
          <td>当预取请求无效时，预取请求应该被拒绝。<br> s0_fire 信号应该被置为低。</td>
      </tr>
      <tr>
          <td>1.1.3</td>
          <td>ICACHE_PREFETCH_HARDPREFETCH</td>
          <td>PREFETCHPIPE_BUSY</td>
          <td>当 IPrefetchPipe 非空闲时，预取请求应该被拒绝。<br> s0_fire 信号应该被置为低。</td>
      </tr>
      <tr>
          <td>1.1.4</td>
          <td>ICACHE_PREFETCH_HARDPREFETCH</td>
          <td>INVALID_PREFETCH_AND_PREFETCHPIPE_BUSY</td>
          <td>当预取请求无效且 IPrefetchPipe 非空闲时，预取请求应该被拒绝。<br>s0_fire 信号应该被置为低。</td>
      </tr>
      <tr>
          <td>1.1.5</td>
          <td>ICACHE_PREFETCH_HARDPREFETCH</td>
          <td>SINGLE_CACHELINE</td>
          <td>当预取请求有效且为单 cacheline 时，预取请求应该被接收。<br>s0_fire 为高，s0_doubleline 应该被置低（false）。</td>
      </tr>
      <tr>
          <td>1.1.6</td>
          <td>ICACHE_PREFETCH_HARDPREFETCH</td>
          <td>DOUBLE_CACHELINE</td>
          <td>当预取请求有效且为双 cacheline 时，预取请求应该被接收。<br> s0_fire 为高，s0_doubleline 应该被置高（true）。</td>
      </tr>
      <tr>
          <td>1.2.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#12-%e8%bd%af%e4%bb%b6%e9%a2%84%e5%8f%96%e8%af%b7%e6%b1%82">ICACHE_PREFETCH_SOFTPREFETCH</a></td>
          <td>RECEIVE</td>
          <td>当预取请求有效且 IPrefetchPipe 处于空闲状态时，软件预取请求应该被接收。<br>当预取请求有效且 IPrefetchPipe 处于空闲状态时，软件预取请求应该被接收。</td>
      </tr>
      <tr>
          <td>1.2.2</td>
          <td>ICACHE_PREFETCH_SOFTPREFETCH</td>
          <td>INVALID_PREFETCH</td>
          <td>当预取请求无效时，软件预取请求应该被拒绝。<br>s0_fire 信号应该被置为低。</td>
      </tr>
      <tr>
          <td>1.2.3</td>
          <td>ICACHE_PREFETCH_SOFTPREFETCH</td>
          <td>PREFETCHPIPE_BUSY</td>
          <td>当 IPrefetchPipe 非空闲时，软件预取请求应该被拒绝。<br>s0_fire 信号应该被置为低。</td>
      </tr>
      <tr>
          <td>1.2.4</td>
          <td>ICACHE_PREFETCH_SOFTPREFETCH</td>
          <td>INVALID_PREFETCH_AND_PREFETCHPIPE_BUSY</td>
          <td>当预取请求无效且 IPrefetchPipe 非空闲时，软件预取请求应该被拒绝。<br> s0_fire 信号应该被置为低。</td>
      </tr>
      <tr>
          <td>1.2.5</td>
          <td>ICACHE_PREFETCH_SOFTPREFETCH</td>
          <td>SINGLE_CACHELINE</td>
          <td>当软件预取请求有效且为单 cacheline 时，软件预取请求应该被接收。<br>s0_fire 为高，s0_doubleline 应该被置低（false）。</td>
      </tr>
      <tr>
          <td>1.2.6</td>
          <td>ICACHE_PREFETCH_SOFTPREFETCH</td>
          <td>DOUBLE_CACHELINE</td>
          <td>当软件预取请求有效且为双 cacheline 时，软件预取请求应该被接收。<br> s0_fire 为高，s0_doubleline 应该被置高（true）。</td>
      </tr>
      <tr>
          <td>2.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#21-%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2%e5%ae%8c%e6%88%90">ICACHE_PREFETCH_ITLB_ADDR</a></td>
          <td>RETURN_PADDR</td>
          <td>ITLB 在一个周期内成功返回物理地址 paddr，s1_valid 为高。<br> 确认 s1 阶段正确接收到 paddr。</td>
      </tr>
      <tr>
          <td>2.1.2</td>
          <td>ICACHE_PREFETCH_ITLB_ADDR</td>
          <td>TLB_MISS</td>
          <td>fromITLB(PortNumber).bits.miss 为高，表示对应通道的 ITLB 发生了 TLB 缺失，需要重发。<br> 重发完成后，后续步骤继续进行，fromITLB(PortNumber).bits.miss 为低。</td>
      </tr>
      <tr>
          <td>2.2.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#22-%e5%a4%84%e7%90%86-itlb-%e5%bc%82%e5%b8%b8">ICACHE_PREFETCH_ITLB_EXCEPTION</a></td>
          <td>PF</td>
          <td>s1_itlb_exception 返回的页错误。<br> iTLB 返回的物理地址有效（fromITLB(PortNumber).bits.miss 为低），s1_itlb_exception 指示页错误 pf。</td>
      </tr>
      <tr>
          <td>2.2.2</td>
          <td>ICACHE_PREFETCH_ITLB_EXCEPTION</td>
          <td>PGF</td>
          <td>s1_itlb_exception 返回的虚拟机页错误。<br> iTLB 返回的物理地址有效（fromITLB(PortNumber).bits.miss 为低），s1_itlb_exception 指示虚拟机页错误 pgf。</td>
      </tr>
      <tr>
          <td>2.2.3</td>
          <td>ICACHE_PREFETCH_ITLB_EXCEPTION</td>
          <td>AF</td>
          <td>s1_itlb_exception 返回的访问错误。<br> iTLB 返回的物理地址有效（fromITLB(PortNumber).bits.miss 为低），s1_itlb_exception 指示访问错误 af。</td>
      </tr>
      <tr>
          <td>2.3.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#23-%e5%a4%84%e7%90%86%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80%e7%94%a8%e4%ba%8e%e8%99%9a%e6%8b%9f%e5%8c%96">ICACHE_PREFETCH_ITLB_GPADDR</a></td>
          <td>PGF</td>
          <td>发生 pgf 后，需要返回对应的 gpaddr。<br> 只有一个通道发生 pgf 时，返回对应通道的 gpaddr 即可；多个通道发生 pgf 时，返回第一个通道的 gpaddr。</td>
      </tr>
      <tr>
          <td>2.3.2</td>
          <td>ICACHE_PREFETCH_ITLB_GPADDR</td>
          <td>VS_NONLEAF_PTE</td>
          <td>发生 gpf 后，如果是访问二级虚拟机的非叶子页表项时，需要返回对应的 gpaddr。<br> 只有一个通道发生 pgf 时，返回对应通道的 gpaddr 即可；多个通道发生 pgf 时，返回第一个通道的 gpaddr。</td>
      </tr>
      <tr>
          <td>2.4</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#24-%e8%bf%94%e5%9b%9e%e5%9f%ba%e4%ba%8e%e9%a1%b5%e9%9d%a2%e7%9a%84%e5%86%85%e5%ad%98%e7%b1%bb%e5%9e%8b-pbmt-%e4%bf%a1%e6%81%af">ICACHE_PREFETCH_ITLB_PBMT</a></td>
          <td>PBMT</td>
          <td>TLB 有效时，返回 pbmt 信息。</td>
      </tr>
      <tr>
          <td>3.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#3-%e6%8e%a5%e6%94%b6%e6%9d%a5%e8%87%aa-imeta%e7%bc%93%e5%ad%98%e5%85%83%e6%95%b0%e6%8d%ae%e7%9a%84%e5%93%8d%e5%ba%94%e5%b9%b6%e6%a3%80%e6%9f%a5%e7%bc%93%e5%ad%98%e5%91%bd%e4%b8%ad">ICACHE_PREFETCH_IMETA</a></td>
          <td>PTAG_AND_VALID</td>
          <td>从物理地址中提取物理标签（ptag），将其与缓存元数据中的标签进行比较，检查所有缓存路（Way）。检查有效位，确保只考虑有效的缓存行。</td>
      </tr>
      <tr>
          <td>3.1</td>
          <td>ICACHE_PREFETCH_IMETA</td>
          <td>MISS</td>
          <td>当标签不匹配或者标签匹配，但是有效位为假时，表示缓存未命中。 <br>s1_meta_ptags(PortNumber)(nWays) 不等于 ptags(PortNumber) 或者它们相等，但是对应的 s1_meta_valids 为低时，总之返回的 waymasks 为全 0。</td>
      </tr>
      <tr>
          <td>3.2</td>
          <td>ICACHE_PREFETCH_IMETA</td>
          <td>SINGLE_HIT</td>
          <td>当标签匹配，且有效位为真时，表示缓存命中。 <br>waymasks 对应的位为 1。</td>
      </tr>
      <tr>
          <td>4.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#4-pmp%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e4%bf%9d%e6%8a%a4%e6%9d%83%e9%99%90%e6%a3%80%e6%9f%a5">ICACHE_PREFETCH_PMP</a></td>
          <td>NONE_EXCEPTION</td>
          <td>itlb 返回的物理地址在 PMP 允许的范围内。 <br>s1_pmp_exception(i) 为 none。</td>
      </tr>
      <tr>
          <td>4.2</td>
          <td>ICACHE_PREFETCH_PMP</td>
          <td>AF_EXCEPTION</td>
          <td>s1_req_paddr(i) 对应的地址在 PMP 禁止的范围内。 <br>s1_pmp_exception(i) 为 af。</td>
      </tr>
      <tr>
          <td>4.3</td>
          <td>ICACHE_PREFETCH_PMP</td>
          <td>MMIO</td>
          <td>itlb 返回的物理地址在 MMIO 区域。 <br>s1_pmp_mmio 为高。</td>
      </tr>
      <tr>
          <td>5.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#5-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e5%92%8c%e5%90%88%e5%b9%b6">ICACHE_PREFETCH_EXCEPTION_MERGE</a></td>
          <td>ONLY_ITLB_EXCEPTION</td>
          <td>s1_itlb_exception(i) 为非零，s1_pmp_exception(i) 为零。 <br>s1_exception_out(i) 正确包含 ITLB 异常。</td>
      </tr>
      <tr>
          <td>5.2</td>
          <td>ICACHE_PREFETCH_EXCEPTION_MERGE</td>
          <td>ONLY_PMP_EXCEPTION</td>
          <td>s1_itlb_exception(i) 为零，s1_pmp_exception(i) 为非零。 <br>s1_exception_out(i) 正确包含 PMP 异常。</td>
      </tr>
      <tr>
          <td>5.3</td>
          <td>ICACHE_PREFETCH_EXCEPTION_MERGE</td>
          <td>ONLY_BACKEND_EXCEPTION</td>
          <td>s1_itlb_exception(i) 为零，s1_pmp_exception(i) 为零。 <br>s1_exception_out(i) 正确包含 后端 异常。</td>
      </tr>
      <tr>
          <td>5.4</td>
          <td>ICACHE_PREFETCH_EXCEPTION_MERGE</td>
          <td>ITLB_AND_PMP_EXCEPTION</td>
          <td>s1_itlb_exception(i) 和 s1_pmp_exception(i) 都为非零。 <br>s1_exception_out(i) 包含 ITLB 异常（优先级更高）。</td>
      </tr>
      <tr>
          <td>5.5</td>
          <td>ICACHE_PREFETCH_EXCEPTION_MERGE</td>
          <td>ITLB_AND_BACKEND_EXCEPTION</td>
          <td>s1_itlb_exception(i) 和 s1_backendException(i) 都为非零。 <br>s1_exception_out(i) 包含 后端 异常（优先级更高）。</td>
      </tr>
      <tr>
          <td>5.6</td>
          <td>ICACHE_PREFETCH_EXCEPTION_MERGE</td>
          <td>PMP_AND_BACKEND_EXCEPTION</td>
          <td>s1_pmp_exception(i) 和 s1_backendException(i) 都为非零。 <br>s1_exception_out(i) 包含 后端 异常（优先级更高）。</td>
      </tr>
      <tr>
          <td>5.7</td>
          <td>ICACHE_PREFETCH_EXCEPTION_MERGE</td>
          <td>ALL_EXCEPTION</td>
          <td>s1_itlb_exception(i)、s1_pmp_exception(i) 和 s1_backendException(i) 都为非零。 <br>s1_exception_out(i) 包含 后端 异常（优先级更高）。</td>
      </tr>
      <tr>
          <td>5.8</td>
          <td>ICACHE_PREFETCH_EXCEPTION_MERGE</td>
          <td>NONE_EXCEPTION</td>
          <td>s1_itlb_exception(i)、s1_pmp_exception(i)、s1_backendException(i) 都为零。 <br>s1_exception_out(i) 指示无异常。</td>
      </tr>
      <tr>
          <td>6.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#6-%e5%8f%91%e9%80%81%e8%af%b7%e6%b1%82%e5%88%b0-waylookup-%e6%a8%a1%e5%9d%97">ICACHE_PREFETCH_WAYLOOKUP</a></td>
          <td>NORMAL</td>
          <td>toWayLookup.valid 为高，toWayLookup.ready 为高，s1_isSoftPrefetch 为假。 <br>请求成功发送，包含正确的地址、标签、waymask 和异常信息。</td>
      </tr>
      <tr>
          <td>6.2</td>
          <td>ICACHE_PREFETCH_WAYLOOKUP</td>
          <td>WAYLOOKUP_REJECT</td>
          <td>toWayLookup.valid 为高，toWayLookup.ready 为假。 <br>状态机等待 WayLookup 准备好，不会错误地推进。</td>
      </tr>
      <tr>
          <td>6.3</td>
          <td>ICACHE_PREFETCH_WAYLOOKUP</td>
          <td>SOFTPREFETCH_NOT_GO_WAYLOOKUP</td>
          <td>s1_isSoftPrefetch 为真。 <br>toWayLookup.valid 为假，不会发送预取请求到 WayLookup。</td>
      </tr>
      <tr>
          <td>7.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#71-%e5%88%9d%e5%a7%8b%e4%b8%ba-m_idle-%e7%8a%b6%e6%80%81">ICACHE_PREFETCH_FSM_IDLE</a></td>
          <td>NORMAL_IMPEL_KEEP_IDLE</td>
          <td>s1_valid 为高，itlb_finish 为真，toWayLookup.fire 为真，s2_ready 为真。 <br>状态机保持在 m_idle 状态，s1 阶段顺利推进。</td>
      </tr>
      <tr>
          <td>7.1.2</td>
          <td>ICACHE_PREFETCH_FSM_IDLE</td>
          <td>ITLB_UNFINISH_RESEND</td>
          <td>s1_valid 为高，itlb_finish 为假。 <br>状态机进入 m_itlbResend 状态，等待 ITLB 完成。</td>
      </tr>
      <tr>
          <td>7.1.3</td>
          <td>ICACHE_PREFETCH_FSM_IDLE</td>
          <td>ITLB_FINISH_WAYLOOKUP_MISS</td>
          <td>s1_valid 为高，itlb_finish 为真，toWayLookup.fire 为假。 <br>状态机进入 m_enqWay 状态，等待 WayLookup 入队。</td>
      </tr>
      <tr>
          <td>7.2.1</td>
          <td>ICACHE_PREFETCH_FSM_ITLBRESEND</td>
          <td>WAIT_WAYLOOKUP_ENQ</td>
          <td>itlb_finish 为假，toMeta.ready 为真。 <br>状态机进入 m_enqWay 状态，等待 WayLookup 入队。</td>
      </tr>
      <tr>
          <td>7.2.2</td>
          <td>ICACHE_PREFETCH_FSM_ITLBRESEND</td>
          <td>WAIT_META_READ_REQ</td>
          <td>itlb_finish 为假，toMeta.ready 为假。 <br>状态机进入 m_metaResend 状态，MetaArray 读请求</td>
      </tr>
      <tr>
          <td>7.3</td>
          <td>ICACHE_PREFETCH_FSM_METARESEND</td>
          <td>WAIT_WAYLOOKUP_ENQ</td>
          <td>toMeta.ready 为真。 <br>状态机进入 m_enqWay 状态，等待 WayLookup 入队。</td>
      </tr>
      <tr>
          <td>7.4.1</td>
          <td>ICACHE_PREFETCH_FSM_ENQWAY</td>
          <td>ENTER_IDLE</td>
          <td>toWayLookup.fire 或 s1_isSoftPrefetch 为真，s2_ready 为假。 <br>状态机进入空闲状态 m_idle。</td>
      </tr>
      <tr>
          <td>7.4.2</td>
          <td>ICACHE_PREFETCH_FSM_ENQWAY</td>
          <td>WAIT_ENTERS2</td>
          <td>toWayLookup.fire 或 s1_isSoftPrefetch 为真，s2_ready 为真。 <br>状态机进入 m_enterS2 状态，等待 s2 阶段准备好。</td>
      </tr>
      <tr>
          <td>7.5</td>
          <td>ICACHE_PREFETCH_FSM_ENTERS2</td>
          <td>ENTER_IDLE</td>
          <td>s2_ready 为真。 <br>状态机进入空闲状态 m_idle。</td>
      </tr>
      <tr>
          <td>8.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#8-%e7%9b%91%e6%8e%a7-missunit-%e7%9a%84%e8%af%b7%e6%b1%82">ICACHE_PREFETCH_MISSUNIT_MONITER</a></td>
          <td>MATCH_AND_VALID</td>
          <td>s2_req_vSetIdx 和 s2_req_ptags 与 fromMSHR 中的数据匹配，且 fromMSHR.valid 为高，fromMSHR.bits.corrupt 为假。 <br>s2_MSHR_match(PortNumber) 为真, s2_MSHR_hits(PortNumber) 应保持为真</td>
      </tr>
      <tr>
          <td>8.2</td>
          <td>ICACHE_PREFETCH_MISSUNIT_MONITER</td>
          <td>SRAM_HIT</td>
          <td>s2_waymasks(PortNumber) 中有一位为高，表示在缓存中命中。 <br>s2_SRAM_hits(PortNumber) 为真,s2_hits(PortNumber) 应为真。</td>
      </tr>
      <tr>
          <td>8.3</td>
          <td>ICACHE_PREFETCH_MISSUNIT_MONITER</td>
          <td>MISS</td>
          <td>请求未匹配 MSHR，且 s2_waymasks(PortNumber) 为空。 <br>s2_MSHR_hits(PortNumber)、s2_SRAM_hits(PortNumber) 均为假, s2_hits(PortNumber) 为假。</td>
      </tr>
      <tr>
          <td>9.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#91-%e7%a1%ae%e5%ae%9a%e9%9c%80%e8%a6%81%e5%8f%91%e9%80%81%e7%bb%99-missunit-%e7%9a%84%e8%af%b7%e6%b1%82">ICACHE_PREFETCH_MISSUNIT_REQ</a></td>
          <td>SEND_TO_MISSUNIT</td>
          <td>s2_hits(PortNumber) 为假(未命中缓存)，s2_exception 无异常，s2_mmio 为假(不是 MMIO 或不可缓存的内存)。 <br>s2_miss(PortNumber) 为真，表示需要发送请求到 missUnit。</td>
      </tr>
      <tr>
          <td>9.1.2</td>
          <td>ICACHE_PREFETCH_MISSUNIT_REQ</td>
          <td>NO_SEND_TO_MISSUNIT</td>
          <td>s2_hits(i) 为真（已命中）或者 s2_exception 有异常 或者 s2_mmio 为真（MMIO 访问）。 <br>s2_miss(i) 为假，不会发送请求到 missUnit。</td>
      </tr>
      <tr>
          <td>9.1.3</td>
          <td>ICACHE_PREFETCH_MISSUNIT_REQ</td>
          <td>DOUBLE_PREFETCH</td>
          <td>s2_doubleline 为真，处理第二个请求。 <br>如果第一个请求有异常或 MMIO，s2_miss(1) 应为假，后续请求被取消或处理。</td>
      </tr>
      <tr>
          <td>9.2.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#92-%e9%81%bf%e5%85%8d%e5%8f%91%e9%80%81%e9%87%8d%e5%a4%8d%e8%af%b7%e6%b1%82%e5%8f%91%e9%80%81%e8%af%b7%e6%b1%82%e5%88%b0-missunit">ICACHE_PREFETCH_MISSUNIT_UNIQUE</a></td>
          <td>RESET_HAS_SEND</td>
          <td>s1_real_fire 为高。 <br>has_send(PortNumber) 应被复位为假，表示新的请求周期开始。</td>
      </tr>
      <tr>
          <td>9.2.2</td>
          <td>ICACHE_PREFETCH_MISSUNIT_UNIQUE</td>
          <td>UPDATE_HAS_SEND</td>
          <td>toMSHRArbiter.io.in(PortNumber).fire 为高（请求已发送）。 <br>has_send(PortNumber) 被设置为真，表示该端口已发送请求。</td>
      </tr>
      <tr>
          <td>9.2.3</td>
          <td>ICACHE_PREFETCH_MISSUNIT_UNIQUE</td>
          <td>UNIQUE_REQ</td>
          <td>同一请求周期内，has_send(PortNumber) 为真，s2_miss(PortNumber) 为真。 <br>toMSHRArbiter.io.in(PortNumber).valid 为假，不会再次发送请求。</td>
      </tr>
      <tr>
          <td>9.2.4</td>
          <td>ICACHE_PREFETCH_MISSUNIT_UNIQUE</td>
          <td>RIGHTLY_SEND</td>
          <td>s2_valid 为高，s2_miss(i) 为真，has_send(i) 为假。 <br>toMSHRArbiter.io.in(i).valid 为高，请求被成功发送。</td>
      </tr>
      <tr>
          <td>9.2.5</td>
          <td>ICACHE_PREFETCH_MISSUNIT_UNIQUE</td>
          <td>ARBITRATE_REQ</td>
          <td>多个端口同时需要发送请求。 <br>仲裁器按照优先级或设计要求选择请求发送到 missUnit,未被选中的请求在下个周期继续尝试发送。</td>
      </tr>
      <tr>
          <td>10.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#10-%e5%88%b7%e6%96%b0%e6%9c%ba%e5%88%b6">ICACHE_PREFETCH_FLUSH</a></td>
          <td>GLOBAL_FLUSH</td>
          <td>io.flush 为高。 <br>s0_flush、s1_flush、s2_flush 分别为高，所有阶段的请求被正确清除。</td>
      </tr>
      <tr>
          <td>10.2</td>
          <td>ICACHE_PREFETCH_FLUSH</td>
          <td>FLUSH_FROM_BPU</td>
          <td>io.flushFromBpu.shouldFlushByStageX 为真（X 为 2 或 3），且请求不是软件预取。 <br>对应阶段的 from_bpu_sX_flush 为高，sX_flush 为高，阶段请求被刷新。</td>
      </tr>
      <tr>
          <td>10.3</td>
          <td>ICACHE_PREFETCH_FLUSH</td>
          <td>RESET_FSM</td>
          <td>s1_flush 为高。 <br>状态机 state 被重置为 m_idle 状态。</td>
      </tr>
      <tr>
          <td>10.4</td>
          <td>ICACHE_PREFETCH_FLUSH</td>
          <td>ITLB_FLUSH_PIPE</td>
          <td>s1_flush 为高。 <br>io.itlbFlushPipe 为高，ITLB 被同步刷新。</td>
      </tr>
      <tr>
          <td>11.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#11-%e8%ae%bf%e9%97%ae-dataarray-%e7%9a%84%e5%8d%95%e8%b7%af">ICACHE_MAINPIPE_DATA_ARRAY</a></td>
          <td>WAY_HIT_AND_ITLB_SUCCESS</td>
          <td>当 WayLookup 中的信息表明路命中时，ITLB 查询成功，并且 DataArray 当前没有写时，MainPipe 会向 DataArray 发送读取请求，以获取数据。 <br>s0_hits 为高（一路命中），s0_itlb_exception 信号为零（ITLB 查询成功），toData.last.ready 为高（DataArray 没有正在进行的写操作）。 <br>toData.valid 信号为高，表示 MainPipe 向 DataArray 发出了读取请求。</td>
      </tr>
      <tr>
          <td>11.2</td>
          <td>ICACHE_MAINPIPE_DATA_ARRAY</td>
          <td>WAY_MISS</td>
          <td>当 WayLookup 中的信息表明路未命中时，MainPipe 不会向 DataArray 发送读取请求。 <br>s0_hits 为低表示缓存未命中 <br>toData.valid 信号为低，表示 MainPipe 未向 DataArray 发出读取请求。</td>
      </tr>
      <tr>
          <td>11.3</td>
          <td>ICACHE_MAINPIPE_DATA_ARRAY</td>
          <td>ITLB_FAIL</td>
          <td>当 ITLB 查询失败时，MainPipe 不会向 DataArray 发送读取请求。 <br>s0_itlb_exception 信号不为零（ITLB 查询失败）。 <br>toData.valid 信号为低，表示 MainPipe 未向 DataArray 发出读取请求。</td>
      </tr>
      <tr>
          <td>11.4</td>
          <td>ICACHE_MAINPIPE_DATA_ARRAY</td>
          <td>DATA_ARRAY_WRITING</td>
          <td>当 DataArray 正在进行写操作时，MainPipe 不会向 DataArray 发送读取请求。 <br>toData.last.ready 信号为低，表示 DataArray 正在进行写操作。 <br>toData.valid 信号为低，表示 MainPipe 未向 DataArray 发出读取请求。</td>
      </tr>
      <tr>
          <td>12.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#12-meta-ecc-%e6%a0%a1%e9%aa%8c">ICACHE_MAINPIPE_META_ECC</a></td>
          <td>NO_ECC_ERROR</td>
          <td>当 waymask 全为 0（没有命中），则 hit_num 为 0 或 waymask 有一位为 1（一路命中），hit_num 为 1 且 ECC 对比通过（encodeMetaECC(meta) == code） <br>s1_meta_corrupt 为假。</td>
      </tr>
      <tr>
          <td>12.2</td>
          <td>ICACHE_MAINPIPE_META_ECC</td>
          <td>SINGLE_ECC_ERROR</td>
          <td>当 waymask 有一位为 1（一路命中），ECC 对比失败（encodeMetaECC(meta) != code） <br>s1_data_corrupt(i)， io.errors(i).valid， io.errors(i).bits.report_to_beu， io.errors(i).bits.source.data 为 true。</td>
      </tr>
      <tr>
          <td>12.3</td>
          <td>ICACHE_MAINPIPE_META_ECC</td>
          <td>MULTI_WAY_HIT</td>
          <td>&gt; hit multi-way, must be an ECC failure <br>当 waymask 有两位及以上为 1（多路命中），视为 ECC 错误。 <br>s1_data_corrupt(i)， io.errors(i).valid， io.errors(i).bits.report_to_beu， io.errors(i).bits.source.data 为 true。</td>
      </tr>
      <tr>
          <td>12.4</td>
          <td>ICACHE_MAINPIPE_META_ECC</td>
          <td>ECC_CLOSE</td>
          <td>当奇偶校验关闭时（ecc_enable 为低），强制清除 s1_meta_corrupt 信号置位。 <br>不管是否发生 ECC 错误，s1_meta_corrupt 都为假。</td>
      </tr>
      <tr>
          <td>13.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#13-pmp-%e6%a3%80%e6%9f%a5">ICACHE_MAINPIPE_PMP</a></td>
          <td>NONE_EXCEPTION</td>
          <td>s1_pmp_exception 为全零，表示没有 PMP 异常。</td>
      </tr>
      <tr>
          <td>13.2</td>
          <td>ICACHE_MAINPIPE_PMP</td>
          <td>CHANNEL_0_EXCEPTION</td>
          <td>s1_pmp_exception(0) 为真，表示通道 0 有 PMP 异常。</td>
      </tr>
      <tr>
          <td>13.3</td>
          <td>ICACHE_MAINPIPE_PMP</td>
          <td>CHANNEL_1_EXCEPTION</td>
          <td>s1_pmp_exception(1) 为真，表示通道 1 有 PMP 异常。</td>
      </tr>
      <tr>
          <td>13.4</td>
          <td>ICACHE_MAINPIPE_PMP</td>
          <td>CHANNEL_0_AND_1_EXCEPTION</td>
          <td>s1_pmp_exception(0) 和 s1_pmp_exception(1) 都为真，表示通道 0 和通道 1 都有 PMP 异常。</td>
      </tr>
      <tr>
          <td>13.5</td>
          <td>ICACHE_MAINPIPE_PMP</td>
          <td>NONE_MMIO</td>
          <td>s1_pmp_mmio（0） 和 s1_pmp_mergemmio（1） 都为假，表示没有映射到 MMIO 区域。</td>
      </tr>
      <tr>
          <td>13.6</td>
          <td>ICACHE_MAINPIPE_PMP</td>
          <td>CHANNEL_0_MMIO</td>
          <td>s1_pmp_mmio（0） 为真，表示映射到了 MMIO 区域。</td>
      </tr>
      <tr>
          <td>13.7</td>
          <td>ICACHE_MAINPIPE_PMP</td>
          <td>CHANNEL_1_MMIO</td>
          <td>s1_pmp_mmio（1） 为真，表示映射到了 MMIO 区域。</td>
      </tr>
      <tr>
          <td>13.8</td>
          <td>ICACHE_MAINPIPE_PMP</td>
          <td>CHANNEL_0_AND_1_MMIO</td>
          <td>s1_pmp_mmio（0） 和 s1_pmp_mmio（1） 都为真，表示通道 0 和通道 1 都映射到了 MMIO 区域。</td>
      </tr>
      <tr>
          <td>14.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#14-%e5%bc%82%e5%b8%b8%e5%90%88%e5%b9%b6">ICACHE_MAINPIPE_EXCEPTION_MERGE</a></td>
          <td>NONE_EXCEPTION</td>
          <td>s1_exception_out 为全零，表示没有异常。</td>
      </tr>
      <tr>
          <td>14.2</td>
          <td>ICACHE_MAINPIPE_EXCEPTION_MERGE</td>
          <td>ITLB_EXCEPTION</td>
          <td>s1_exception_out 和 s1_itlb_exception 一致</td>
      </tr>
      <tr>
          <td>14.3</td>
          <td>ICACHE_MAINPIPE_EXCEPTION_MERGE</td>
          <td>PMP_EXCEPTION</td>
          <td>s1_exception_out 和 s1_pmp_exception 一致</td>
      </tr>
      <tr>
          <td>14.4</td>
          <td>ICACHE_MAINPIPE_EXCEPTION_MERGE</td>
          <td>ITLB_AND_PMP_EXCEPTION</td>
          <td>&gt; itlb has the highest priority, pmp next <br>s1_exception_out 和 s1_itlb_exception 一致</td>
      </tr>
      <tr>
          <td>15.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#15-mshr-%e5%8c%b9%e9%85%8d%e5%92%8c%e6%95%b0%e6%8d%ae%e9%80%89%e6%8b%a9">ICACHE_MAINPIPE_MSHR_MATCH</a></td>
          <td>MSHR_HIT</td>
          <td>MSHR 中已有正确数据时，S1 阶段能直接拿到 <br>s1_MSHR_hits(i) 为 true 时，s1_datas(i) 为 s1_bankMSHRHit(i)，s1_data_is_from_MSHR(i) 为 true</td>
      </tr>
      <tr>
          <td>15.2</td>
          <td>ICACHE_MAINPIPE_MSHR_MATCH</td>
          <td>MSHR_MISS</td>
          <td>MSHR 中存放的地址与当前请求不同，那么应该读取 SRAM 的数据 <br>s1_MSHR_hits(i) 为 true 时，s1_datas(i) 为 fromData.datas(i)，s1_data_is_from_MSHR(i) 为 false</td>
      </tr>
      <tr>
          <td>15.3</td>
          <td>ICACHE_MAINPIPE_MSHR_MATCH</td>
          <td>MSHR_DATA_CORRUPT</td>
          <td>fromMSHR.bits.corrupt = true，那么 MSHR 将不匹配，应该读取 SRAM 的数据 <br>s1_datas(i) 为 fromData.datas(i)，s1_data_is_from_MSHR(i) 为 false</td>
      </tr>
      <tr>
          <td>16.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#16-data-ecc-%e6%a0%a1%e9%aa%8c">ICACHE_MAINPIPE_DATA_ECC</a></td>
          <td>NO_ECC_ERROR</td>
          <td>s2_bank 全部没有损坏，bank 也选对了对应的端口和 bank，数据不来自 MSHR <br>s2_data_corrupt(i) 为 false，没有 ECC 错误。</td>
      </tr>
      <tr>
          <td>16.2</td>
          <td>ICACHE_MAINPIPE_DATA_ECC</td>
          <td>SINGLE_Bank_ECC_ERROR</td>
          <td>s2_bank_corrupt(bank) 有一个为 true ,即对应的 bank 有损坏；同时 bank 也选对了对应的端口和 bank，数据不来自 MSHR <br>s2_data_corrupt(i)， io.errors(i).valid， io.errors(i).bits.report_to_beu， io.errors(i).bits.source.data 为 true。</td>
      </tr>
      <tr>
          <td>16.3</td>
          <td>ICACHE_MAINPIPE_DATA_ECC</td>
          <td>MULTIPLE_Bank_ECC_ERROR</td>
          <td>s2_bank_corrupt(bank) 有两个或以上为 true,即对应的 bank 有损坏；同时 bank 也选对了对应的端口和 bank，数据不来自 MSHR <br>s2_data_corrupt(i)， io.errors(i).valid， io.errors(i).bits.report_to_beu， io.errors(i).bits.source.data 为 true。</td>
      </tr>
      <tr>
          <td>16.4</td>
          <td>ICACHE_MAINPIPE_DATA_ECC</td>
          <td>ECC_CLOSE</td>
          <td>当奇偶校验关闭时（ecc_enable 为低），强制清除 s2_data_corrupt 信号置位。 <br>不管是否发生 ECC 错误，s2_data_corrupt 都为假。</td>
      </tr>
      <tr>
          <td>17.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#17-%e5%86%b2%e5%88%b7-metaarray">ICACHE_MAINPIPE_META_FLUSH</a></td>
          <td>FLUSH_META_ARRAY</td>
          <td>&gt; if is meta corrupt, clear all way (since waymask may be unreliable) <br>当 s1_meta_corrupt 为真时，MetaArray 的所有路都会被冲刷。 <br>toMetaFlush(i).valid 为真，toMetaFlush(i).bits.waymask 对应端口的所有路置位。</td>
      </tr>
      <tr>
          <td>17.2</td>
          <td>ICACHE_MAINPIPE_META_FLUSH</td>
          <td>FLUSH_DATA_ARRAY</td>
          <td>&gt; if is data corrupt, only clear the way that has error <br>当 s2_data_corrupt 为真时，只有对应路会被冲刷。 <br>toMetaFlush(i).valid 为真，toMetaFlush(i).bits.waymask 对应端口的对应路置位。</td>
      </tr>
      <tr>
          <td>17.3</td>
          <td>ICACHE_MAINPIPE_META_FLUSH</td>
          <td>FLUSH_META_ARRAY_AND_DATA_ARRAY</td>
          <td>处理 Meta ECC 的优先级更高， 将 MetaArray 的所有路冲刷。 <br>toMetaFlush(i).valid 为真，toMetaFlush(i).bits.waymask 对应端口的所有路置位。</td>
      </tr>
      <tr>
          <td>18.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#18-%e7%9b%91%e6%8e%a7-mshr-%e5%8c%b9%e9%85%8d%e4%b8%8e%e6%95%b0%e6%8d%ae%e6%9b%b4%e6%96%b0">ICACHE_MAINPIPE_MSHR_MONITER</a></td>
          <td>MSHR_HIT</td>
          <td>MSHR 的 vSetIdx / blkPaddr 与 S2 请求一致， fromMSHR.valid 有效，s2_valid 也有效 <br>s2_MSHR_match，s2_MSHR_hits 为高，s2_bankMSHRHit 对应 bank 为高 <br>s1_fire 无效时，s2_datas 更新为 MSHR 的数据，将 s2_data_is_from_MSHR 对应位置位，s2_hits 置位，清除 s2_data_corrupt，l2 的 corrupt 更新为 fromMSHR.bits.corrupt <br>s1_fire 有效时，s2_datas 为 s1_datas 的数据，将 s2_data_is_from_MSHR 对应位置为 s1 的 s1_data_is_from_MSHR，s2_hits 置为 s1_hits，清除 s2_data_corrupt，l2 的 corrupt 为 false</td>
      </tr>
      <tr>
          <td>18.2</td>
          <td>ICACHE_MAINPIPE_MSHR_MONITER</td>
          <td>MSHR_MISS</td>
          <td>MSHR 的 vSetIdx / blkPaddr 与 S2 请求一致， fromMSHR.valid 有效，s2_valid 也有效，至少有一个未达成 <br>s2_MSHR_hits(i) = false，S2 不会更新 s2_datas，继续保持原先 SRAM 数据或进入 Miss 流程。</td>
      </tr>
      <tr>
          <td>19.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#19-miss-%e8%af%b7%e6%b1%82%e5%8f%91%e9%80%81%e9%80%bb%e8%be%91%e5%92%8c%e5%90%88%e5%b9%b6%e5%bc%82%e5%b8%b8">ICACHE_MAINPIPE_MISS_REQ</a></td>
          <td>NONE_MISS</td>
          <td>当 s2_hits(i) 为高（s2 已经命中），s2 的 meta 和 data 都没有错误，s2 异常，处于 mmio 区域 <br>以上条件至少满足一个时，s2_should_fetch(i) 为低，表示不发送 Miss 请求。</td>
      </tr>
      <tr>
          <td>19.2</td>
          <td>ICACHE_MAINPIPE_MISS_REQ</td>
          <td>SINGLE_MISS</td>
          <td>当出现未命中 (!s2_hits(i)) 或 ECC 错误(s2_meta_corrupt(i)</td>
      </tr>
      <tr>
          <td>19.3</td>
          <td>ICACHE_MAINPIPE_MISS_REQ</td>
          <td>DOUBLE_MISS</td>
          <td>同上，但是两个端口都满足 s2_should_fetch 为高的条件。 <br>toMSHRArbiter.io.in(0).valid、toMSHRArbiter.io.in(1).valid 均为 true，Arbiter 根据仲裁顺序依次发出请求。</td>
      </tr>
      <tr>
          <td>19.4</td>
          <td>ICACHE_MAINPIPE_MISS_REQ</td>
          <td>BLOCK_REPETITION</td>
          <td>当 s1_fire 为高，表示可以进入 s2 阶段,那么 s2 还没有发送 s2_has_send(i) := false.B <br>如果已经有请求发送了，那么对应的 toMSHRArbiter.io.in(i).fire 为高，表示对应的请求可以发送，s2_has_send(i) := true。 <br>此时再次发送，toMSHRArbiter.io.in(i).valid 为低，表示发送失败。</td>
      </tr>
      <tr>
          <td>19.5</td>
          <td>ICACHE_MAINPIPE_MISS_REQ</td>
          <td>ONLY_ITLB_OR_PMP_EXCEPTION</td>
          <td>S1 阶段已记录了 ITLB 或 PMP 异常，L2 corrupt = false。 <br>2_exception_out 仅保留 ITLB/PMP 异常标记，无新增 AF 异常。</td>
      </tr>
      <tr>
          <td>19.6</td>
          <td>ICACHE_MAINPIPE_MISS_REQ</td>
          <td>ONLY_L2_EXCEPTION</td>
          <td>S2 阶段 s2_l2_corrupt(i) = true，且无 ITLB/PMP 异常。 <br>s2_exception_out(i) 表示 L2 访问错误(AF)。</td>
      </tr>
      <tr>
          <td>19.7</td>
          <td>ICACHE_MAINPIPE_MISS_REQ</td>
          <td>ITLB_AND_L2_EXCEPTION</td>
          <td>同时触发 ITLB 异常和 L2 corrupt。 <br>s2_exception_out 优先保留 ITLB 异常类型，不被 L2 覆盖。</td>
      </tr>
      <tr>
          <td>19.8</td>
          <td>ICACHE_MAINPIPE_MISS_REQ</td>
          <td>S2_FETCH_FINISH</td>
          <td>s2_should_fetch 的所有端口都为低，表示需要取指，那么取指完成 <br>s2_fetch_finish 为高</td>
      </tr>
      <tr>
          <td>20.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#20-%e5%93%8d%e5%ba%94-ifu">ICACHE_MAINPIPE_IFU</a></td>
          <td>HIT_AND_RETURN</td>
          <td>不存在任何异常或 Miss，s2 命中，s2 阶段取指完成，外部的 respStall 停止信号也为低 。 <br>toIFU.valid = true，toIFU.bits.data 为正确的 Cacheline 数据，toIFU.bits.exception、pmp_mmio、itlb_pbmt = none。</td>
      </tr>
      <tr>
          <td>20.2</td>
          <td>ICACHE_MAINPIPE_IFU</td>
          <td>ABNORMAL_RETURN</td>
          <td>设置 ITLB、PMP、或 L2 corrupt 异常。 <br>toIFU.bits.exception(i) = 对应异常类型，pmp_mmio、itlb_pbmt 根据是否有对应的异常设置为 true。</td>
      </tr>
      <tr>
          <td>20.3</td>
          <td>ICACHE_MAINPIPE_IFU</td>
          <td>CROSSLINE_FETCH</td>
          <td>s2_doubleline = true，同时检查第一路、第二路返回情况。 <br>toIFU.bits.doubleline = true。 <br>若第二路正常，toIFU.bits.exception(1) = none；若第二路异常，则 exception(1) 标记相应类型。 <br>pmp_mmio、itlb_pbmt 类似。</td>
      </tr>
      <tr>
          <td>20.4</td>
          <td>ICACHE_MAINPIPE_IFU</td>
          <td>RESPSTALL</td>
          <td>外部 io.respStall = true，导致 S2 阶段无法发射到 IFU。 <br>s2_fire = false，toIFU.valid 也不拉高，S2 保持原状态等待下一拍（或直到 respStall 解除）。</td>
      </tr>
      <tr>
          <td>21.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#21-l2-corrupt-%e6%8a%a5%e5%91%8a">ICACHE_MAINPIPE_L2_CORRUPT</a></td>
          <td>SINGLE_L2_CORRUPT</td>
          <td>s2 阶段准备完成可以发射（s2_fire 为高），s2_MSHR_hits(0)和 fromMSHR.bits.corrupt 为高 <br>s2_l2_corrupt(0) = true，io.errors(0).valid = true，io.errors(0).bits.source.l2 = true。</td>
      </tr>
      <tr>
          <td>21.2</td>
          <td>ICACHE_MAINPIPE_L2_CORRUPT</td>
          <td>DOUBLE_L2_CORRUPT</td>
          <td>端口 0 和端口 1 都从 L2 corrupt 数据中获取。 <br>s2_l2_corrupt 均为 true，发射后分别报告到 io.errors(0) 和 io.errors(1)。</td>
      </tr>
      <tr>
          <td>22.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#22-%e5%88%b7%e6%96%b0%e6%9c%ba%e5%88%b6">ICACHE_MAINPIPE_FLUSH</a></td>
          <td>GLOBAL_FLUSH</td>
          <td>io.flush 被激活时，流水线的各个阶段（S0, S1 和 S2）都能正确响应并执行刷新操作。 <br>io.flush = true。 <br>s0_flush, s1_flush, s2_flush = true。</td>
      </tr>
      <tr>
          <td>22.2</td>
          <td>ICACHE_MAINPIPE_FLUSH</td>
          <td>S0_FLUSH</td>
          <td>s0_flush = true。 <br>s0_fire = false。</td>
      </tr>
      <tr>
          <td>22.3</td>
          <td>ICACHE_MAINPIPE_FLUSH</td>
          <td>S1_FLUSH</td>
          <td>s1_flush = true。 <br>s1_valid， s1_fire = false。</td>
      </tr>
      <tr>
          <td>22.4</td>
          <td>ICACHE_MAINPIPE_FLUSH</td>
          <td>S2_FLUSH</td>
          <td>s2_flush = true。 <br>s2_valid， toMSHRArbiter.io.in(i).valid ， s2_fire = false</td>
      </tr>
      <tr>
          <td>23.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#22-%e5%88%b7%e6%96%b0%e6%9c%ba%e5%88%b6">ICACHE_WAYLOOKUP_FLUSH</a></td>
          <td>READ_POINTER</td>
          <td>io.flush 为高时，重置读指针。 <br>readPtr.value 为 0， readPtr.flag 为 false。</td>
      </tr>
      <tr>
          <td>23.2</td>
          <td>ICACHE_WAYLOOKUP_FLUSH</td>
          <td>WRITE_POINTER</td>
          <td>io.flush 为高时，重置写指针。 <br>writePtr.value 为 0， writePtr.flag 为 false。</td>
      </tr>
      <tr>
          <td>23.3</td>
          <td>ICACHE_WAYLOOKUP_FLUSH</td>
          <td>GPF</td>
          <td>io.flush 为高时，重置 GPF 信息。 <br>gpf_entry.valid 为 0， gpf_entry.bits 为 0。</td>
      </tr>
      <tr>
          <td>24.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#24-%e8%af%bb%e5%86%99%e6%8c%87%e9%92%88%e6%9b%b4%e6%96%b0">ICACHE_WAYLOOKUP_UPDATE_POINTER</a></td>
          <td>READ_POINTER</td>
          <td>当 io.read.fire 为高时，读指针加一。 <br>readPtr.value 加一。 <br>如果 readPtr.value 超过环形队列的大小，readPtr.flag 会翻转。</td>
      </tr>
      <tr>
          <td>24.2</td>
          <td>ICACHE_WAYLOOKUP_UPDATE_POINTER</td>
          <td>WRITE_POINTER</td>
          <td>当 io.write.fire 为高时，写指针加一。 <br>writePtr.value 加一。 <br>如果 writePtr.value 超过环形队列的大小，writePtr.flag 会翻转。</td>
      </tr>
      <tr>
          <td>25.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#25-%e6%9b%b4%e6%96%b0%e6%93%8d%e4%bd%9c">ICACHE_WAYLOOKUP_UPDATE</a></td>
          <td>HIT</td>
          <td>MissUnit 返回的更新信息和 WayLookup 的信息相同时，更新 waymask 和 meta_codes。 <br>vset_same 和 ptag_same 为真。 <br>waymask 和 meta_codes 更新。 <br>hits 对应位为高。</td>
      </tr>
      <tr>
          <td>25.2</td>
          <td>ICACHE_WAYLOOKUP_UPDATE</td>
          <td>MISS</td>
          <td>vset_same 和 way_same 为真。 <br>waymask 清零。 <br>hit 对应位为高。</td>
      </tr>
      <tr>
          <td>25.3</td>
          <td>ICACHE_WAYLOOKUP_UPDATE</td>
          <td>NONE_UPDATE</td>
          <td>其他情况下不更新。 <br>vset_same 为假或者 ptag_same 和 way_same 都为假。 <br>hits 对应位为低。</td>
      </tr>
      <tr>
          <td>26.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#26-%e8%af%bb%e6%93%8d%e4%bd%9c">ICACHE_WAYLOOKUP_READ</a></td>
          <td>BYPASS_READ</td>
          <td>队列为空，并且 io.write.valid 写有效时，可以直接读取，而不经过队列。 <br>empty 和 io.write.valid 都为真。 <br>io.read.bits = io.write.bits</td>
      </tr>
      <tr>
          <td>26.2</td>
          <td>ICACHE_WAYLOOKUP_READ</td>
          <td>READ_INVALID</td>
          <td>队列为空（readPtr === writePtr）且写信号 io.write.valid 为低。 <br>io.read.valid 为低，读信号无效。</td>
      </tr>
      <tr>
          <td>26.3</td>
          <td>ICACHE_WAYLOOKUP_READ</td>
          <td>NORMAL_READ</td>
          <td>未达成绕过条件（empty 和 io.write.valid 至少有一个为假）且 io.read.valid 为高。 <br>从环形队列中读取信息。 <br>io.read.bits.entry = entries(readPtr.value)</td>
      </tr>
      <tr>
          <td>26.4</td>
          <td>ICACHE_WAYLOOKUP_READ</td>
          <td>GPF_HIT</td>
          <td>io.read.valid 为高，可以读。 <br>当 gpf_hits 为高时，从 GPF 队列中读取信息。 <br>io.read.bits.gpf = gpf_entry.bits</td>
      </tr>
      <tr>
          <td>26.5</td>
          <td>ICACHE_WAYLOOKUP_READ</td>
          <td>GPF_HIT_AND_READ</td>
          <td>io.read.valid 为高，可以读。 <br>&gt; also clear gpf_entry.valid when it&rsquo;s read <br>当 gpf 命中且被读取其时（io.read.fire 为高），gpf_entry.valid 会被置为 0。</td>
      </tr>
      <tr>
          <td>26.6</td>
          <td>ICACHE_WAYLOOKUP_READ</td>
          <td>GPF_MISS</td>
          <td>io.read.valid 为高，可以读。 <br>io.read.bits.gpf 清零。</td>
      </tr>
      <tr>
          <td>27.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#27-%e5%86%99%e6%93%8d%e4%bd%9c">ICACHE_WAYLOOKUP_WRITE</a></td>
          <td>GPF_STOP</td>
          <td>&gt; if there is a valid gpf to be read, we should stall write <br>gpf 队列数据有效，并且没有被读取或者没有命中，就会产生 gpf 停止，此时写操作会被停止。 <br>gpf_entry.valid &amp;&amp; !(io.read.fire &amp;&amp; gpf_hit) 为高时，写操作会被停止（io.write.ready 为低）。</td>
      </tr>
      <tr>
          <td>27.2</td>
          <td>ICACHE_WAYLOOKUP_WRITE</td>
          <td>WRITE_READY_INVALID</td>
          <td>当队列为满（(readPtr.value === writePtr.value) &amp;&amp; (readPtr.flag ^ writePtr.flag)）或者 gpf 停止时，写操作会被停止。 <br>（io.write.ready 为低）</td>
      </tr>
      <tr>
          <td>27.3</td>
          <td>ICACHE_WAYLOOKUP_WRITE</td>
          <td>NORMAL_WRITE</td>
          <td>当 io.write.valid 为高时（没满且没有 gpf 停止），写操作会被执行。 <br>正常握手完毕 io.write.fire 为高。 <br>写信息会被写入环形队列。 <br>entries(writePtr.value) = io.write.bits.entry。</td>
      </tr>
      <tr>
          <td>27.4.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#274-%e6%9c%89-itlb-%e5%bc%82%e5%b8%b8%e7%9a%84%e5%86%99">ICACHE_WAYLOOKUP_WRITE_WITH_ITLB_EXCEPTION</a></td>
          <td>BYPASS</td>
          <td>can_bypass 和 io.read.fire 都为高。 <br>gpf_entry.valid 为 false。 <br>gpf_entry.bits = io.write.bits.gpf <br>gpfPtr = writePtr <br></td>
      </tr>
      <tr>
          <td>27.4.2</td>
          <td>ICACHE_WAYLOOKUP_WRITE_WITH_ITLB_EXCEPTION</td>
          <td>NO_BYPASS</td>
          <td>can_bypass 为低。 <br>gpf_entry.valid 为 true。 <br>gpf_entry.bits = io.write.bits.gpf <br>gpfPtr = writePtr</td>
      </tr>
      <tr>
          <td>28.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#28-%e5%85%a5%e9%98%9f%e6%93%8d%e4%bd%9c">ICACHE_WAYLOOKUP_ENQ</a></td>
          <td>NORMAL_ENQ</td>
          <td>当队列未满，且空位不小于一时，可以正常入队，如果从零号位开始入队到最大容量，入队指针的 flag 不会翻转。 <br>io.enq.fire 为高有效，regFiles(enq_ptr.value) = io.enq.bits，enq_ptr.value+1 入队指针移动，入队指针标记位不翻转。 <br>重复以上操作至队满。</td>
      </tr>
      <tr>
          <td>28.2</td>
          <td>ICACHE_WAYLOOKUP_ENQ</td>
          <td>REVERSE_FLAG</td>
          <td>当队未满，但是空位却是靠近队尾时，入队一位后就到达了队头，入队指针的 flag 会翻转。 <br>队列的容量为 10，入队指针指向 9，队未满。此时如果 io.enq.fire 为高，则 regFiles(9) = io.enq.bits，enq_ptr.value+1（循环队列，加完后 enq_ptr.value=0）入队指针移动，入队指针标记位翻转。</td>
      </tr>
      <tr>
          <td>28.3</td>
          <td>ICACHE_WAYLOOKUP_ENQ</td>
          <td>FULL</td>
          <td>当队满时，(enq_ptr.value === deq_ptr.value) &amp;&amp; (enq_ptr.flag ^ deq_ptr.flag) 为高，io.enq.ready 为低，io.enq.fire 为低无效。 <br>此时入队，入队指针的 value 和 flag 不变。</td>
      </tr>
      <tr>
          <td>29.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#29-%e5%87%ba%e9%98%9f%e6%93%8d%e4%bd%9c">ICACHE_WAYLOOKUP_DEQ</a></td>
          <td>NORMAL_DEQ</td>
          <td>当队列非空时，可以正常出队，如果出队指针不经过最大容量位置，出队指针的 flag 不会翻转。 <br>io.deq.fire 为高有效，io.deq.bits = regFiles(deq_ptr.value)，deq_ptr.value+1 出队指针移动，出队指针标记位不翻转。</td>
      </tr>
      <tr>
          <td>29.2</td>
          <td>ICACHE_WAYLOOKUP_DEQ</td>
          <td>REVERSE_FLAG</td>
          <td>当队非空，但是出队指针是靠近队尾时，出队一位后就到达了队头，出队指针的 flag 会翻转。 <br>队列的容量为 10，出队指针指向 9，队非空。此时如果 io.deq.fire 为高，则 io.deq.bits = regFiles(9)，deq_ptr.value+1（循环队列，加完后 deq_ptr.value=0）出队指针移动，出队指针标记位翻转。</td>
      </tr>
      <tr>
          <td>29.3</td>
          <td>ICACHE_WAYLOOKUP_DEQ</td>
          <td>EMPTY</td>
          <td>当队空时，enq_ptr === deq_ptr 为高，io.deq.valid 为低，io.deq.fire 为低无效。 <br>此时出队，出队指针的 value 和 flag 不变。</td>
      </tr>
      <tr>
          <td>30.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#30-%e5%88%b7%e6%96%b0%e6%b8%85%e7%a9%ba%e6%93%8d%e4%bd%9c">ICACHE_WAYLOOKUP_FLUSH</a></td>
          <td>FLUSH</td>
          <td>当刷新信号有效时，重置出队和入队的指针和标记位，清空队列。 <br>当 flush 为高时，deq_ptr.value=0，enq_ptr.value=0，deq_ptr.flag=false，enq_ptr.flag=false，empty=true,full=false。</td>
      </tr>
      <tr>
          <td>31.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#31-%e5%a4%84%e7%90%86%e5%8f%96%e6%8c%87%e7%bc%ba%e5%a4%b1%e8%af%b7%e6%b1%82">ICACHE_MISSUNIT_HANDLE_FETCH</a></td>
          <td>RECEIVE_NEW_REQ</td>
          <td>当新的 fetch miss 与 MSHR 中的已有请求不重复时（通过 io.fetch_req.bits.blkPaddr / vSetIdx 给出具体地址），MissUnit 会将请求分配到一个空闲的 Fetch MSHR 中。 <br>当有新的取指缺失请求到达时（io.fetch_req.valid 为高），且没有命中已有的 MSHR（fetchHit 为低），io.fetch_req.ready 应为高，表示可以接受请求。 <br>io.fetch_req.fire 成功握手后，该 MSHR 处于 valid = true 状态，并记录地址。</td>
      </tr>
      <tr>
          <td>31.2</td>
          <td>ICACHE_MISSUNIT_HANDLE_FETCH</td>
          <td>ALREADY_REQ</td>
          <td>当已有取指缺失请求到达时（io.fetch_req.valid 为高），且命中已有的 MSHR（fetchHit 为高），io.fetch_req.ready 应为高，虽然不接受请求，但是表现出来为已经接收请求。 <br>fetchDemux.io.in.valid 应为低，fetchDemux.io.in.fire 为低，表示没有新的请求被分发到 MSHR。</td>
      </tr>
      <tr>
          <td>31.3</td>
          <td>ICACHE_MISSUNIT_HANDLE_FETCH</td>
          <td>MSHR_PRIORITY</td>
          <td>Fetch 的请求会通过 fetchDemux 分配到多个 Fetch MSHR，fetchDemux 的实现中，低索引的 MSHR 会优先被分配请求。 <br>当取指请求有多个 io.out(i).read 时，选择其中的第一个，也就是低索引的写入 MSHR，io.chose 为对应的索引。</td>
      </tr>
      <tr>
          <td>32.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#32-%e5%a4%84%e7%90%86%e9%a2%84%e5%8f%96%e7%bc%ba%e5%a4%b1%e8%af%b7%e6%b1%82">ICACHE_MISSUNIT_HANDLE_PREFETCH</a></td>
          <td>RECEIVE_NEW_REQ</td>
          <td>当新的 prefetch miss 与 MSHR 中的已有请求不重复时（通过 io.prefetch_req.bits.blkPaddr / vSetIdx 给出具体地址），MissUnit 会将请求分配到一个空闲的 Prefetch MSHR 中。 <br>当有新的预取缺失请求到达时（io.prefetch_req.valid 为高），且没有命中已有的 MSHR（prefetchHit 为低），io.prefetch_req.ready 应为高，表示可以接受请求。 <br>io.prefetch_req.fire 成功握手后，该 MSHR 处于 valid = true 状态，并记录地址。</td>
      </tr>
      <tr>
          <td>32.2</td>
          <td>ICACHE_MISSUNIT_HANDLE_PREFETCH</td>
          <td>ALREADY_REQ</td>
          <td>当已有预取缺失请求到达时（io.prefetch_req.valid 为高），且命中已有的 MSHR（prefetchHit 为高），io.prefetch_req.ready 应为高，虽然不接受请求，但是表现出来为已经接收请求。 <br>prefetchDemux.io.in.valid 应为低，prefetchDemux.io.in.fire 为低，表示请求被接受但未分发到新的 MSHR。</td>
      </tr>
      <tr>
          <td>32.3</td>
          <td>ICACHE_MISSUNIT_HANDLE_PREFETCH</td>
          <td>MSHR_PRIORITY</td>
          <td>Prefetch 的请求会通过 prefetchDemux 分配到多个 Prefetch MSHR，prefetchDemux 的实现中，低索引的 MSHR 会优先被分配请求。 <br>当取指请求有多个 io.out(i).read 时，选择其中的第一个，也就是低索引的写入 MSHR，io.chose 为对应的索引。</td>
      </tr>
      <tr>
          <td>32.4</td>
          <td>ICACHE_MISSUNIT_HANDLE_PREFETCH</td>
          <td>FIFO_PRIORITY</td>
          <td>从 prefetchDemux 离开后，请求的编号会进入 priorityFIFO，priorityFIFO 会根据进入队列的顺序排序，先进入队列的请求会先进入 prefetchArb。 <br>prefetchDemux.io.in.fire 为高，并且 prefetchDemux.io.chosen 有数据时，将其编号写入 priorityFIFO。 <br>在 priorityFIFO 中有多个编号时，出队的顺序和入队顺序一致。 <br>检查 priorityFIFO.io.deq.bit 中的数据即可。</td>
      </tr>
      <tr>
          <td>33.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#33-mshr-%e7%ae%a1%e7%90%86%e4%b8%8e%e6%9f%a5%e6%89%be">ICACHE_MISSUNIT_MSHR</a></td>
          <td>HIT</td>
          <td>当新的请求到来时，能够正确查找所有 MSHR，判断请求是否命中已有 MSHR。 <br>当新的请求（取指或预取）到来时，系统遍历所有 MSHR，根据所有 MSHR 的查找信号 allMSHRs(i).io.lookUps(j).hit，检查请求是否已经存在于某个 MSHR 中。 <br>如果命中，则对应的 fetchHit 或 prefetchHit 为高。 <br>对于 prefetchHit 为高，还有一种情况：预取的物理块地址和组索引与取指的相等（(io.prefetch_req.bits.blkPaddr === io.fetch_req.bits.blkPaddr) &amp;&amp; (io.prefetch_req.bits.vSetIdx === io.fetch_req.bits.vSetIdx)）并且有取指请求 io.fetch_req.valid 有效时，也算命中</td>
      </tr>
      <tr>
          <td>33.2</td>
          <td>ICACHE_MISSUNIT_MSHR</td>
          <td>UPDATE_AND RELEASE</td>
          <td>当请求完成后，也就是来自内存总线的响应完成（D 通道接收完所有节拍），MSHR 能够正确地释放（清除其有效位），以便接收新的请求。 <br>TileLink D 通道返回的 source ID ，即 io.mem_grant.bits.source。 <br>无效化信号 allMSHRs(i).io.invalid 为高，对应的 MSHR 的有效位 allMSHRs(i).valid 变为低</td>
      </tr>
      <tr>
          <td>34.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#34-acquirearb-%e4%bb%b2%e8%a3%81">ICACHE_MISSUNIT_ACQUIREARB</a></td>
          <td>ARBITRATE</td>
          <td>acquireArb 会选择一个 acquire 发送给 mem_acquire。 <br>当有多个 MSHR 同时发出请求时，acquireArb 会根据优先级进行仲裁，选择优先级最高的 MSHR 发送请求。 <br>取指请求总是在 0-3 号，预取请求直接在最后一号，所以取指请求优先级高于预取请求。 <br>当取指 acquire 和预取 acquire 同时发出时，fetchMSHRs(i).io.acquire 和 prefetchMSHRs(i).io.acquire 都有效，仲裁结果 acquireArb.io.out 应该和 fetchMSHRs(i).io.acquire 一致。</td>
      </tr>
      <tr>
          <td>35.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#35-grant-%e6%95%b0%e6%8d%ae%e6%8e%a5%e6%94%b6%e4%b8%8e-refill">ICACHE_MISSUNIT_GRANT</a></td>
          <td>READBEATCNT_EQUAL_0</td>
          <td>readBeatCnt 初始为 0，refillCycles - 1 也为 0。 <br>io.mem_grant.valid 为高（因为 io.mem_grant.ready 默认为高，所以 io.mem_grant.fire 为高只需要 io.mem_grant.valid 为高）且 io.mem_grant.bits.opcpde(0)为高。 <br>此时 respDataReg(0)= io.mem_grant.bits.data <br>readBeatCnt 加一为 1。</td>
      </tr>
      <tr>
          <td>35.2</td>
          <td>ICACHE_MISSUNIT_GRANT</td>
          <td>READBEATCNT_EQUAL_1</td>
          <td>io.mem_grant.valid 为高且 io.mem_grant.bits.opcpde(0)为高。 <br>此时 respDataReg(1)= io.mem_grant.bits.data <br>readBeatCnt 重置回 0。 <br>last_fire 为高。 <br>下一拍 last_fire_r 为高，id_r=io.mem_grant.bits.source。</td>
      </tr>
      <tr>
          <td>35.3</td>
          <td>ICACHE_MISSUNIT_GRANT</td>
          <td>LAST_FIRE_R_EQUAL_HIGH</td>
          <td>last_fire_r 为高，并且 id_r 为 0-13 中的一个。 <br>对应的 fetchMSHRs 或者 prefetchMSHRs 会被无效，也就是 fetchMSHRs_i 或 prefetchMSHRs_i-4 的 io_invalid 会被置高。</td>
      </tr>
      <tr>
          <td>35.4</td>
          <td>ICACHE_MISSUNIT_GRANT</td>
          <td>GRANT_WITH_CORRUPT</td>
          <td>io.mem_grant.valid 为高且 io.mem_grant.bits.opcpde(0)为高，io.mem_grant.bits.corrupt 为高，则 corrupt_r 应为高。 <br>如果 io.mem_grant.valid 为高且 io.mem_grant.bits.opcpde(0)为高，io.mem_grant.bits.corrupt 为高中有一个不满足，且此时 last_fire_r 为高，则 corrupt_r 重置为低。</td>
      </tr>
      <tr>
          <td>36.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#36-%e6%9b%bf%e6%8d%a2%e7%ad%96%e7%95%a5%e6%9b%b4%e6%96%b0-replacer">ICACHE_MISSUNIT_REPLACER</a></td>
          <td>UPDATE</td>
          <td>当 io.mem.acquire.ready &amp; acquireArb.io.out.valid 同时为高，也就是 acquireArb.io.out.fir 为高时，io.victim.vSetIdx.valid 也为高。 <br>io.victim.vSetIdx.bits = 当前 MSHR 请求的 acquireArb.io.out.bits.vSetIdx。</td>
      </tr>
      <tr>
          <td>36.2</td>
          <td>ICACHE_MISSUNIT_REPLACER</td>
          <td>GENERATE_WAYMASK</td>
          <td>根据从 L2 返回的 mshr_resp 中 mshr_resp.bits.way 生成 waymask 信息。 <br>返回的 mshr_resp.bits.way 有 16 位，通过独热码生成一位掩码信息，waymask 表示其中哪一路被替换。 <br>生成的 waymask 应该和 mshr_resp.bits.way 一致。</td>
      </tr>
      <tr>
          <td>37.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#37-%e5%86%99%e5%9b%9e-sram-meta--data">ICACHE_MISSUNIT_WRITE_SRAM</a></td>
          <td>GENERATE_META_AND_DATA_WRITE_VALID</td>
          <td>当 grant 传输完成后，经过一拍后，即 last_fire_r 为高，且从 TileLink 返回的 mshr_resp 中的 mshr_resp.valid 为高。 <br>并且此时没有硬件刷新信号和软件刷新信号，也就是 io.flush 和 io.fencei 为低。 在等待 l2 响应的过程中，没有刷新信号 <br>也没有数据 corrupt，即 corrupt_r 为低。 <br>那么 io.meta_write.valid 和 io.data_write.valid 均为高。</td>
      </tr>
      <tr>
          <td>37.2</td>
          <td>ICACHE_MISSUNIT_WRITE_SRAM</td>
          <td>WRITE_SRAM</td>
          <td>io.meta_write.bits 的 virIdx、phyTag、waymask、bankIdx、poison 应该正常更新 <br>io.data_write.bits 的 virIdx、data、waymask、bankIdx、poison 应该正常更新</td>
      </tr>
      <tr>
          <td>38.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#38-%e5%90%91-mainpipeprefetchpipe-%e5%8f%91%e5%87%ba-miss-%e5%ae%8c%e6%88%90%e5%93%8d%e5%ba%94fetch_resp">ICACHE_MISSUNIT_FINISH</a></td>
          <td>MISS_REQ_FINISH</td>
          <td>当 grant 传输完成后，经过一拍后，即 last_fire_r 为高，且从 TileLink 返回的 mshr_resp 中的 mshr_resp.valid 为高。 <br>无论此时是否有硬件刷新信号和软件刷新信号， io.fetch_resp.valid 都为高，说明可向取指端发送响应。 <br>io.fetch_resp.bits 中的数据更新： <br>io.fetch_resp.bits.blkPaddr = mshr_resp.bits.blkPaddr <br>io.fetch_resp.bits.vSetIdx = mshr_resp.bits.vSetIdx <br>io.fetch_resp.bits.waymask = waymask <br>io.fetch_resp.bits.data = respDataReg.asUInt <br>io.fetch_resp.bits.corrupt = corrupt_r</td>
      </tr>
      <tr>
          <td>39.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#39-%e5%a4%84%e7%90%86-flush--fencei">ICACHE_MISSUNIT_FLUSH_OR_FENCEI</a></td>
          <td>FENCEI_BEFORE_MSHR_ISSUE</td>
          <td>如果 MSHR 还没有通过 io.acquire.fire 发出请求，就应立即取消该 MSHR（mshr_resp.valid= false），既不发出请求，也不要写 SRAM。 <br>当 io.fencei 为高时，fetchMSHRs 和 prefetchMSHRs 的 io.req.ready 和 io.acquire.valid 均为低，表示请求不发射。</td>
      </tr>
      <tr>
          <td>39.2</td>
          <td>ICACHE_MISSUNIT_FLUSH_OR_FENCEI</td>
          <td>FLUSH_BEFORE_MSHR_ISSUE</td>
          <td>由于 fetchMSHRs 的 io.flush 被直接设置为 false，所以 io.flush 对 fetchMSHRs 无效，但是对 prefetchMSHRs 有效。 <br>当 io.flush 为高时，只能发射 fetchMSHRs 的请求。</td>
      </tr>
      <tr>
          <td>39.3</td>
          <td>ICACHE_MISSUNIT_FLUSH_OR_FENCEI</td>
          <td>FLUSH_OR_FENCEI_AFTER_MSHR_ISSUE</td>
          <td>已经发射了请求，之后再有刷新信号，那么等数据回来了但不写 SRAM。 <br>在发射后，io.flush/io.fencei 为高时，等待数据回来，但是写 SRAM 的信号，write_sram_valid、io.meta_write.valid 和 io.data_write.valid 均为低，表示不写 SRAM。 <br>对于 response fetch 无影响。</td>
      </tr>
      <tr>
          <td>40.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#40-ecc-%e5%90%af%e7%94%a8%e7%a6%81%e7%94%a8">ICACHE_CTRLUNIT_ECCCTRL</a></td>
          <td>ENABLE_ECC</td>
          <td>向 eccctrl.enable 寄存器写入 true，验证模块内部 eccctrl.enable 设置为 true，并确保后续的错误注入操作能够成功进行。此测试确保 eccctrl.enable 写操作被执行。 <br>确保 eccctrl.enable 被正确设置为 true，并触发 eccctrlRegWriteFn 中的写操作逻辑。</td>
      </tr>
      <tr>
          <td>40.2</td>
          <td>ICACHE_CTRLUNIT_ECCCTRL</td>
          <td>DISANLE_ECC</td>
          <td>向 eccctrl.enable 寄存器写入 false，验证模块内部 eccctrl.enable 设置为 false，并确保在后续的错误注入过程中，ECC 功能被禁用，不允许进行错误注入。此测试确保 eccctrl.enable 写操作被正确设置为 false。 <br>验证禁用 ECC 时 eccctrl.enable 为 false，并触发 eccctrlRegWriteFn 中的错误处理分支。x.istatus = eccctrlInjStatus.error 和 x.ierror = eccctrlInjError.notEnabled</td>
      </tr>
      <tr>
          <td>41.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#41-%e7%8a%b6%e6%80%81%e6%9c%ba%e8%bd%ac%e6%8d%a2">ICACHE_CTRLUNIT_FSM</a></td>
          <td>IDLE</td>
          <td>初始为 is_idle 状态。 <br>当 eccctrl.istatus 为 working 时，验证此时的状态为 is_readMetaReq。</td>
      </tr>
      <tr>
          <td>41.2</td>
          <td>ICACHE_CTRLUNIT_FSM</td>
          <td>READMETAREQ</td>
          <td>当握手成功后（io.metaRead.ready 和 io.metaRead.valid 都为高），验证此时的状态为 is_readMetaResp。</td>
      </tr>
      <tr>
          <td>41.3.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#413-is_readmetaresp-%e7%8a%b6%e6%80%81">ICACHE_CTRLUNIT_FSM_READMETARESP</a></td>
          <td>MISS</td>
          <td>当 waymask 全零的时候，表示没有命中，会进入 is_idle 状态，并且设置错误错误注入状态和错误原因。 <br>验证此时的状态为 is_idle， eccctrl.istatus = error 和 eccctrl.ierror = notFound。</td>
      </tr>
      <tr>
          <td>41.3.2</td>
          <td>ICACHE_CTRLUNIT_FSM_READMETARESP</td>
          <td>HIT</td>
          <td>当 waymask 不全零的时候，表示命中，会根据错误注入目标来判断是向元数据还是数据阵列写入错误。 <br>当 eccctrl.itarget=metaArray 时，验证此时的状态为 is_writeMeta ；当 eccctrl.itarget！=metaArray 时，验证此时的状态为 is_writeData。</td>
      </tr>
      <tr>
          <td>41.4.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#414-is_writemeta-%e7%8a%b6%e6%80%81">ICACHE_CTRLUNIT_FSM_WRITEMETA</a></td>
          <td>REGWRITEFN</td>
          <td>此状态进入后，io.dataWrite.valid 会为高 <br>x.itarget = req.itarget <br>当 req.inject 为高并且 x.istatus = idle 时： <br>1. 如果 ecc 的 req.enable = false，则验证 x.istatus = error 且 x.ierror = notEnabled <br>2. 否则，如果 req.itarget ！= metaArray 和 dataArray，则验证 x.istatus = error 且 x.ierror = targetInvalid <br>3. 如果都不满足，则验证 x.istatus = working</td>
      </tr>
      <tr>
          <td>41.4.2</td>
          <td>ICACHE_CTRLUNIT_FSM_WRITEMETA</td>
          <td>STATE_TRANSFER</td>
          <td>当 io.metaWrite.fire 为高， 验证下一个状态为 is_idle，并且 eccctrl.istatus = injected。</td>
      </tr>
      <tr>
          <td>41.5.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#415-is_writedata-%e7%8a%b6%e6%80%81">ICACHE_CTRLUNIT_FSM_WRITEDATA</a></td>
          <td>REGWRITEFN</td>
          <td>此状态进入后，io.dataWrite.valid 会为高 <br>res.inject = false <br>当 ready 为高，且 x.istatus = injected 或 x.istatus = error 时，验证 x.istatus = idle 和 x.ierror = notEnabled</td>
      </tr>
      <tr>
          <td>41.5.2</td>
          <td>ICACHE_CTRLUNIT_FSM_WRITEDATA</td>
          <td>STATE_TRANSFER</td>
          <td>当 io.dataWrite.fire 为高， 验证下一个状态为 is_idle，并且 eccctrl.istatus = injected。</td>
      </tr>
      <tr>
          <td>42.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#42-%e5%af%84%e5%ad%98%e5%99%a8%e6%98%a0%e5%b0%84%e5%92%8c%e5%a4%96%e9%83%a8%e8%ae%bf%e9%97%ae">ICACHE_CTRLUNIT_EXTERNAL</a></td>
          <td>READ_OR_WRITE_ECC_REGISTER</td>
          <td>验证外部模块可以通过 TileLink 协议正确读取和写入 eccctrl 和 ecciaddr 寄存器，并对模块内部的状态产生影响，确保读写操作完全覆盖。</td>
      </tr>
      <tr>
          <td>42.2</td>
          <td>ICACHE_CTRLUNIT_EXTERNAL</td>
          <td>EXTERNAL_MODULE_TRIGGER_ERROR_INJECT</td>
          <td>通过外部模块经 TileLink 总线向 eccctrl.inject 寄存器写入 true，触发错误注入，验证内部状态是否按 RegWriteFn 内部过程执行。</td>
      </tr>
      <tr>
          <td>43.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#43-ftq-%e9%a2%84%e5%8f%96%e8%af%b7%e6%b1%82%e5%a4%84%e7%90%86">ICACHE_ICACHE_PREFETCH</a></td>
          <td>PREFETCH_HIT_WITHOUT_EXCEPTION</td>
          <td>io.ftqPrefetch.req.bits 的 startAddr 和 nextlineStart 在正常地址范围内，itlb 命中无异常，itlb 查询到的地址与 MetaArry 的 ptag 匹配，pmp 检查通过。 <br>如果没有监听到 MSHR 同样的位置发生了其它 cacheline 的写入，那么验证 wayLookup.io.write 的内容应该命中的取指数据。 <br>如果监听到 MSHR 同样的位置发生了其它 cacheline 的写入，那么验证 wayLookup.io.write 的内容应该是未命中的取指数据。</td>
      </tr>
      <tr>
          <td>43.2</td>
          <td>ICACHE_ICACHE_PREFETCH</td>
          <td>PREFETCH_MISS_WITHOUT_EXCEPTION</td>
          <td>io.ftqPrefetch.req.bits 的 startAddr 和 nextlineStart 在正常地址范围内，itlb 命中无异常，itlb 查询到的地址与 MetaArry 的 ptag 不匹配，pmp 检查通过。 <br>如果监听到 MSHR 将该请求对应的 cacheline 写入了 SRAM，那么验证 wayLookup.io.write 的内容应该命中的取指数据。 <br>如果监听到 MSHR 没有将该请求对应的 cacheline 写入了 SRAM，那么验证 wayLookup.io.write 的内容应该未命中的取指数据。</td>
      </tr>
      <tr>
          <td>43.3</td>
          <td>ICACHE_ICACHE_PREFETCH</td>
          <td>ONLY_TLB_EXCEPTION</td>
          <td>io.ftqPrefetch.req.bits 的 startAddr 和 nextlineStart 在正常地址范围内，itlb 异常。 <br>验证 wayLookup.io.write 的 itlb_exception 内容中，其有对应的异常类型编号（pf:01;gpf:10;af:11）。</td>
      </tr>
      <tr>
          <td>43.4</td>
          <td>ICACHE_ICACHE_PREFETCH</td>
          <td>ONLY_TPMP_EXCEPTION</td>
          <td>io.ftqPrefetch.req.bits 的 startAddr 和 nextlineStart 在正常地址范围内，itlb 命中无异常，itlb 查询到的地址与 MetaArry 的 ptag 匹配，pmp 检查未通过。 <br>验证 wayLookup.io.write 的 tlb_pbmt 内容中，其有对应的异常类型编号（nc:01;io:10）。</td>
      </tr>
      <tr>
          <td>44.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#44-ftq-%e5%8f%96%e6%8c%87%e8%af%b7%e6%b1%82%e5%a4%84%e7%90%86">ICACHE_ICACHE_FETCH</a></td>
          <td>FETCH_HIT_WITHOUT_EXCEPTION</td>
          <td>io.fetch.req.bits.pcMemRead 的 0-4 的 startAddr 和 nextlineStart 在正常地址范围内，从 WayLookup 获取信息，命中，pmp 检查正常，DataArray 和 MetaArray 的 ECC 校验正常。 <br>验证 replacer.io.touch 的 vSetIdx 和 way 和 ftq 的 fetch 一致，missUnit.io.victim 的 vSetIdx 和 way 是按照制定的算法生成的。 <br>验证 io.fetch.resp 的数据应该是取指的数据。</td>
      </tr>
      <tr>
          <td>44.2</td>
          <td>ICACHE_ICACHE_FETCH</td>
          <td>FETCH_MISS_MSHR_HIT_WITHOUT_EXCEPTION</td>
          <td>io.fetch.req.bits.pcMemRead 的 0-4 的 startAddr 和 nextlineStart 在正常地址范围内，从 WayLookup 获取信息，未命中，pmp 检查正常，DataArray 和 MetaArray 的 ECC 校验正常。 <br>请求在 MSHR 返回的响应命中。 <br>验证 missUnit.io.victim 的 vSetIdx 和 way 是按照制定的算法生成的。 <br>验证 io.fetch.resp 的数据应该是取指的数据。</td>
      </tr>
      <tr>
          <td>44.3</td>
          <td>ICACHE_ICACHE_FETCH</td>
          <td>FETCH_MISS_AND_ECC_ERROR_WITHOUT_ELSE_EXCEPTION</td>
          <td>io.fetch.req.bits.pcMemRead 的 0-4 的 startAddr 和 nextlineStart 在正常地址范围内，从 WayLookup 获取信息，命中，pmp 检查正常，DataArray 或 MetaArray 的 ECC 校验错误。 <br>验证 io.error.valid 为高，且 io.error.bits 内容为对应的错误源和错误类型。 <br>先刷 MetaArray 的 ValidArray,给 MissUnit 发请求，由其在 L2 重填，阻塞至数据返回。 <br>验证 replacer.io.touch 的 vSetIdx 和 way 和 ftq 的 fetch 一致，missUnit.io.victim 的 vSetIdx 和 way 是按照制定的算法生成的。 <br>验证 io.fetch.resp 的数据应该是取指的数据。</td>
      </tr>
      <tr>
          <td>44.4</td>
          <td>ICACHE_ICACHE_FETCH</td>
          <td>FETCH_MISS_AND_SOME_EXCEPTION_WITHOUT_ELSE_EXCEPTION</td>
          <td>io.fetch.req.bits.pcMemRead 的 0-4 的 startAddr 和 nextlineStart 在正常地址范围内，从 WayLookup 获取信息，命中，pmp 检查未通过，DataArray 和 MetaArray 的 ECC 校验正常。 <br>验证 io.fetch.resp 为对应的错误源和错误类型。 <br>验证 io.fetch.resp 的数据无效，里面有异常类型。</td>
      </tr>
      <tr>
          <td>44.5</td>
          <td>ICACHE_ICACHE_FETCH</td>
          <td>FETCH_MISS_AND_ITLB_PBMT</td>
          <td>有 itlb_pbmt 和 pmp_mmio 时，他们合成 s1_mmio，传递到 s2_mmio,生成 s2_miss,有特殊情况就不会取指。 <br>io.fetch.req.bits.pcMemRead 的 0-4 的 startAddr 和 nextlineStart 在正常地址范围内，从 WayLookup 获取信息，命中，pmp 检查通过，DataArray 和 MetaArray 的 ECC 校验正常。 <br>验证 io.fetch.resp 为对应的错误源和错误类型。 <br>验证 io.fetch.resp 的数据无效，里面有特殊情况类型类型。</td>
      </tr>
      <tr>
          <td>44.6</td>
          <td>ICACHE_ICACHE_FETCH</td>
          <td>FETCH_MISS_AND_PMP_MMIO</td>
          <td>处理同 5。</td>
      </tr>
      <tr>
          <td>45.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#45-metaarray-%e5%8a%9f%e8%83%bd">ICACHE_ICACHE_METAARRAY</a></td>
          <td>WRITE_META</td>
          <td>从 MissUnit 返回的请求都是未命中的请求（已命中不会向 MissUnit 请求，那么 MissUnit 自然也不会向 MetaArray 写入）。 <br>发送一个写请求 write 到 ICacheMetaArray，ICacheReplacer 根据 PLRU 替换策略指定 way，替换路被写入 waymask，最后指定 virIdx、phyTag、waymask、bankIdx、poison。 <br>写入操作后，发起一个对相同虚拟索引的读请求。验证 readResp 的 metas 和 codes 分别包含写入的 ptag 和 ecc code，并且对于写入的路，readResp.entryValid 信号被置为有效。</td>
      </tr>
      <tr>
          <td>45.2</td>
          <td>ICACHE_ICACHE_METAARRAY</td>
          <td>READ_META_HIT</td>
          <td>首先，向特定的虚拟索引（组和路）写入元数据（参照上面的写入操作）。然后，向相同的虚拟索引发送一个读请求。 <br>验证 readResp.metas 包含之前写入的物理标签，并且对于相应的路，readResp.entryValid 信号被置为有效。</td>
      </tr>
      <tr>
          <td>45.3</td>
          <td>ICACHE_ICACHE_METAARRAY</td>
          <td>READ_META_MISS</td>
          <td>向 ICacheMetaArray 发送一个读请求，请求的虚拟索引在复位后从未被写入过。 <br>验证对于任何路，readResp.entryValid 信号都没有被置为有效。 对应的 readResp.metas 和 codes 的内容是 DontCare 也就是 0。</td>
      </tr>
      <tr>
          <td>45.4</td>
          <td>ICACHE_ICACHE_METAARRAY</td>
          <td>SINGLE_CACHELINE_FLUSH</td>
          <td>先向 ICacheMetaArray 写入指定一个或多个端口的元数据，然后再给对应的端口的路发送刷新请求 io.flush，其包含虚拟索引 virIdx 和路掩码 waymask。 <br>验证 valid_array 对应的路中的 virIdx 被置为无效，io.readResp.entryValid 对应路的对应端口为无效。</td>
      </tr>
      <tr>
          <td>45.5</td>
          <td>ICACHE_ICACHE_METAARRAY</td>
          <td>FLUSH_ALL</td>
          <td>先向多个不同的虚拟索引写入元数据。然后置位 io.flushAll 信号。 <br>验证步骤: 在 io.flushAll 信号置位后，发起对所有之前写入过的虚拟索引的读请求。验证在所有的读取响应中，对于任何路，readResp.entryValid 信号都没有被置为有效。</td>
      </tr>
      <tr>
          <td>46.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#46-dataarray-%e5%8a%9f%e8%83%bd">ICACHE_ICACHE_DATAARRAY</a></td>
          <td>WRITE_DATA</td>
          <td>发送一个写请求 write 到 ICacheDataArray，ICacheReplacer 根据 PLRU 替换策略指定 way，替换路被写入 waymask，最终指定虚拟索引、数据、路掩码、存储体索引 bankIdx 和毒化位。写入的数据模式应跨越多个数据存储体。 <br>写入操作后，发起一个对相同虚拟索引和块偏移量的读请求。验证 readResp.datas 与写入的数据相匹配。</td>
      </tr>
      <tr>
          <td>46.2</td>
          <td>ICACHE_ICACHE_DATAARRAY</td>
          <td>READ_DATA_HIT</td>
          <td>首先，向特定的虚拟索引和块偏移量写入数据。然后，向相同的虚拟索引和块偏移量发送一个读请求。使用不同的块偏移量进行测试，以覆盖存储体的选择逻辑。 <br>验证 readResp.datas 包含之前写入的数据。</td>
      </tr>
      <tr>
          <td>46.3</td>
          <td>ICACHE_ICACHE_DATAARRAY</td>
          <td>READ_DATA_MISS</td>
          <td>向 ICacheDataArray 发送一个读请求，请求的虚拟索引在复位后从未被写入过。 <br>验证 readResp.datas 为 0。</td>
      </tr>
  </tbody>
</table>
</mrs-testpoints>
</div>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>本文档也将错误检查 &amp; 错误恢复 &amp; 错误注入相关功能称为 ECC，见 <a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/#ecc">ECC</a> 一节开始的说明。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>BPU 精确预测器（BPU s2/s3 给出结果）可能覆盖简单预测器（BPU s0 给出结果）的预测，显然其重定向请求最晚在预取请求的 1- 2 拍之后就到达 ICache，因此仅需要：</p>
<p>BPU s2 redirect：冲刷 IPrefetchPipe s0</p>
<p>BPU s3 redirect：冲刷 IPrefetchPipe s0/1</p>
<p>当 IPrefetchPipe 的对应流水级中的请求来自于软件预取时 <code>isSoftPrefetch === true.B</code>，不需要进行冲刷</p>
<p>当 IprefetchPipe 的对应流水级中的请求来自于硬件预取，但 <code>ftqIdx</code> 与冲刷请求不匹配时，不需要进行冲刷&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p><code>fence.i</code> 在逻辑上需要冲刷 MainPipe 和 IPrefetchPipe（因为此时流水级中的数据可能无效），但实际上<code>io.fencei</code>拉高必然伴随一个后端重定向，因此目前的实现中没有冲刷 MainPipe 和 IPrefetchPipe 的必要。&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref1:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>此 RAS（Reliability, Availability, and Serviceability）非彼 RAS（Return Address Stack）。&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p>RERI（RAS Error-record Register Interface），参考 <a href="https://github.com/riscv-non-isa/riscv-ras-eri">RISC-V RERI 手册</a>。&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref1:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9dd28b73c093d88ee2b921332ab31c44">12.2.2.1 - CtrlUnit</h1>
    
	<div class="icache-ctx">
</div>
<h2 id="ctrlunit">CtrlUnit</h2>
<p>目前 CtrlUnit 主要负责 ECC 校验使能/错误注入等功能。
RegField 案例类和伴生对象的作用，RegReadFn 和 RegWriteFn 案例类和伴生对象的作用。</p>
<p>通过两个控制寄存器 CSR：eccctrl 和 ecciaddr，来实现错误注入。
在 eccctrlBundle 中，定义 eccctrl 的 ierror、istatus、itarget、inject、enable 域的初始值。
在 ecciaddrBundle 中，定义 ecciaddr 的 paddr 域的初始值。</p>
<h3 id="mmio-mapped-csr">mmio-mapped CSR</h3>
<p>CtrlUnit 内实现了一组 mmio-mapped CSR，连接在 tilelink 总线上，地址可由参数 <code>cacheCtrlAddressOpt</code> 配置，默认地址为<code>0x38022080</code>。总大小为 128B。</p>
<p>当参数 <code>cacheCtrlAddressOpt</code> 为 <code>None</code> 时，CtrlUnit <strong>不会实例化</strong>。此时 ECC 校验使能<strong>默认开启</strong>，软件不可控制关闭；软件不可控制错误注入。</p>
<p>目前实现的 CSR 如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>              64     10        7         4         2        1        0
</span></span><span style="display:flex;"><span>0x00 eccctrl   | WARL | ierror | istatus | itarget | inject | enable |
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>              64 PAddrBits-1               0
</span></span><span style="display:flex;"><span>0x08 ecciaddr  | WARL |       paddr        |
</span></span></code></pre></div><table>
  <thead>
      <tr>
          <th>CSR</th>
          <th>field</th>
          <th>desp</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>eccctrl</td>
          <td>enable</td>
          <td>ECC 错误校验使能，原 sfetchctl(0) 。 <br>注：即使不使能，在 icache 重填时仍会计算 parity，可能会有额外功耗；但如果不计算，则在未使能转换成使能时需要冲刷 icache（否则读出的 parity 有 50%概率是错的）。</td>
      </tr>
      <tr>
          <td>eccctrl</td>
          <td>inject</td>
          <td>ECC 错误注入使能，写 1 即使能，读恒 0</td>
      </tr>
      <tr>
          <td>eccctrl</td>
          <td>itarget</td>
          <td>ECC 错误注入目标 <br>0: metaArray<br>1: rsvd<br>2: dataArray<br>3: rsvd</td>
      </tr>
      <tr>
          <td>eccctrl</td>
          <td>istatus</td>
          <td>ECC 错误注入状态（read-only）<br>0: idle：注入控制器闲置<br>1: working：收到注入请求，注入中<br>2: injected：注入完成，等待触发<br>3: rsvd<br>4: rsvd<br>5: rsvd<br>6: rsvd<br>7: error：注入出错</td>
      </tr>
      <tr>
          <td>eccctrl</td>
          <td>ierror</td>
          <td>ECC 错误原因（read-only）<br>0: ECC 未使能 (i.e. !eccctrl.enable) <br>1: inject 目标 SRAM 无效 (i.e. eccctrl.itarget==rsvd) <br>2: inject 目标地址 (i.e. ecciaddr.paddr) 不在 ICache 中<br>3: rsvd <br>4: rsvd <br>5: rsvd <br>6: rsvd <br>7: rsvd</td>
      </tr>
      <tr>
          <td>ecciaddr</td>
          <td>paddr</td>
          <td>ECC 错误注入物理地址</td>
      </tr>
      <tr>
          <td>RERI standard</td>
          <td></td>
          <td>RERI 手册还要求了错误计数等寄存器，用于软件获取 RAS controller 状态，参考手册，可能需要与 dcache、L2cache 统一在后端实现，icache 像现在给 BEU 送 error 一样送给后端。<br>即：暂时不需要在 icache 实现，但要把错误计数等机制所需的接口准备出来</td>
      </tr>
  </tbody>
</table>
<h3 id="错误校验使能">错误校验使能</h3>
<p>CtrlUnit 的 <code>eccctrl.enable</code> 位直接连接到 MainPipe，控制 ECC 校验使能。当该位为 0 时，ICache 不会进行 ECC 校验。但仍会在重填时计算校验码并存储，这可能会有少量的额外功耗；如果不计算，则在未使能转换成使能时需要冲刷 ICache（否则读出的 parity code 可能是错的）。</p>
<h3 id="错误注入使能">错误注入使能</h3>
<p>CtrlUnit 内部使用一个状态机控制错误注入过程，其 status （注意：与 <code>eccctrl.istatus</code> 不同）有：</p>
<ul>
<li>idle：注入控制器闲置</li>
<li>readMetaReq：发送读取 metaArray 请求</li>
<li>readMetaResp：接收读取 metaArray 响应</li>
<li>writeMeta：写入 metaArray</li>
<li>writeData：写入 dataArray</li>
</ul>
<p>当软件向 <code>eccctrl.inject</code> 写入 1 时，进行以下简单检查，检查通过时状态机进入 <code>readMetaReq</code> 状态：</p>
<ul>
<li>若 <code>eccctrl.enable</code> 为 0，报错 <code>eccctrl.ierror=0</code></li>
<li>若 <code>eccctrl.itarget</code> 为 rsvd(1/3)，报错 <code>eccctrl.ierror=1</code></li>
</ul>
<p>在 <code>readMetaReq</code> 状态下，CtrlUnit 向 MetaArray 发送 <code>ecciaddr.paddr</code> 地址对应的 set 读取的请求，等待握手。握手后转移到 <code>readMetaResp</code> 状态。</p>
<p>在 <code>readMetaResp</code> 状态下，CtrlUnit 接收到 MetaArray 的响应，检查 <code>ecciaddr.paddr</code> 地址对应的 ptag 是否命中，若未命中则报错 <code>eccctrl.ierror=2</code>。否则，根据 <code>eccctrl.itarget</code> 进入 <code>writeMeta</code> 或 <code>writeData</code> 状态。</p>
<p>在 <code>writeMeta</code> 或 <code>writeData</code> 状态下，CtrlUnit 向 MetaArray/DataArray 写入任意数据，同时拉高 <code>poison</code> 位，写入完成后状态机进入 <code>idle</code> 状态。</p>
<p>ICache 顶层中实现了一个 Mux，当 CtrlUnit 的状态机不为 <code>idle</code> 时，将 MetaArray/DataArray 的读写口连接到 CtrlUnit，而非 MainPipe/IPrefetchPipe/MissUnit。当状态机 <code>idle</code> 时反之。</p>
<p>状态机和错误注入流程</p>
<ul>
<li><code>is_idle</code>：模块处于空闲状态，等待错误注入的触发。只有当 <code>eccctrl.istatus</code> 为 <code>working</code> 时，状态机才会转移到 <code>is_readMetaReq</code> 状态，准备读取元数据。</li>
<li><code>is_readMetaReq</code>：发送读取元数据请求。通过接口 <code>metaRead</code> 向缓存发送读取请求。当握手成功后状态会转移到 <code>is_readMetaResp</code>。</li>
<li><code>is_readMetaResp</code>：接收元数据响应并验证。如果未命中，则会设置错误状态。没命中会转移状态到<code>is_idle</code>,并设置错误错误注入状态和错误原因；如果找到有效的缓存行并且标签匹配，根据错误注入目标来判断是向元数据还是数据阵列写入错误。</li>
<li><code>is_writeMeta</code>：写入带 poison 标记的数据完成注入。当握手成功后，错误注入状态设置为 injected（注入完成，等待触发）,状态转移到<code>is_idle</code>。</li>
<li><code>is_writeData</code>：写入带 poison 标记的数据完成注入。当握手成功后，向数据阵列写入错误数据，错误注入状态设置为 injected（注入完成，等待触发）,状态转移到<code>is_idle</code>。</li>
</ul>
<p>寄存器和接口映射</p>
<ul>
<li>eccctrl：控制 ECC 启用、错误注入状态等。寄存器通过 eccctrlRegField 进行映射。</li>
<li>ecciaddr：指定错误注入的物理地址。通过 ecciaddrRegField 映射。</li>
<li>通过寄存器描述符（RegFieldDesc）和寄存器字段（RegField），定义了寄存器的这些是寄存器的描述信息和读写逻辑。</li>
<li>通过 node.regmap，这两个寄存器被映射到指定的地址偏移。eccctrl 寄存器被映射到 params.eccctrlOffset 地址，ecciaddr 寄存器被映射到 params.ecciaddrOffset 地址。</li>
<li><code>node.regmap</code> 使得这两个寄存器可以通过外部的 TileLink 接口进行访问，外部模块可以读写这些寄存器以控制 ECC 和错误注入功能。</li>
</ul>
<h2 id="ctrlunit-的功能点和测试点">CtrlUnit 的功能点和测试点</h2>
<h3 id="ecc-启用禁用">ECC 启用/禁用</h3>
<p>控制 eccctrl.enable 字段来启用或禁用 ECC 功能。外部系统可以通过写寄存器 eccctrl 来控制 ECC 是否启用。</p>
<ul>
<li>通过寄存器写入控制信号 enable，当 enable 为 true 时，ECC 功能启用；为 false 时，ECC 功能禁用。</li>
</ul>
<ol>
<li>启用 ECC</li>
</ol>
<ul>
<li>向 eccctrl.enable 寄存器写入 true，验证模块内部 eccctrl.enable 设置为 true，并确保后续的错误注入操作能够成功进行。此测试确保 eccctrl.enable 写操作被执行。</li>
<li>确保 eccctrl.enable 被正确设置为 true，并触发 eccctrlRegWriteFn 中的写操作逻辑。</li>
</ul>
<ol start="2">
<li>禁用 ECC</li>
</ol>
<ul>
<li>向 eccctrl.enable 寄存器写入 false，验证模块内部 eccctrl.enable 设置为 false，并确保在后续的错误注入过程中，ECC 功能被禁用，不允许进行错误注入。此测试确保 eccctrl.enable 写操作被正确设置为 false。</li>
<li>验证禁用 ECC 时 eccctrl.enable 为 false，并触发 eccctrlRegWriteFn 中的错误处理分支。x.istatus = eccctrlInjStatus.error 和 x.ierror = eccctrlInjError.notEnabled</li>
</ul>
<h3 id="状态机转换">状态机转换</h3>
<p>根据状态机的状态，验证错误注入的流程是否正确。</p>
<ol>
<li>is_idle 状态</li>
</ol>
<ul>
<li>初始为 is_idle 状态。</li>
<li>当 eccctrl.istatus 为 working 时，验证此时的状态为 is_readMetaReq。</li>
</ul>
<ol start="2">
<li>is_readMetaReq 状态</li>
</ol>
<ul>
<li>当握手成功后（io.metaRead.ready 和 io.metaRead.valid 都为高），验证此时的状态为 is_readMetaResp。</li>
</ul>
<ol start="3">
<li>is_readMetaResp 状态</li>
</ol>
<ul>
<li>未命中
<ul>
<li>当 waymask 全零的时候，表示没有命中，会进入 is_idle 状态，并且设置错误错误注入状态和错误原因。</li>
<li>验证此时的状态为 is_idle， eccctrl.istatus = error 和 eccctrl.ierror = notFound。</li>
</ul>
</li>
<li>命中
<ul>
<li>当 waymask 不全零的时候，表示命中，会根据错误注入目标来判断是向元数据还是数据阵列写入错误。</li>
<li>当 eccctrl.itarget=metaArray 时，验证此时的状态为 is_writeMeta ；当 eccctrl.itarget！=metaArray 时，验证此时的状态为 is_writeData。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>is_writeMeta 状态</li>
</ol>
<ul>
<li>RegWriteFn
<ul>
<li>此状态进入后，io.dataWrite.valid 会为高</li>
<li>x.itarget = req.itarget</li>
<li>当 req.inject 为高并且 x.istatus = idle 时：
<ul>
<li>如果 ecc 的 req.enable = false，则验证 x.istatus = error 且 x.ierror = notEnabled</li>
<li>否则，如果 req.itarget ！= metaArray 和 dataArray，则验证 x.istatus = error 且 x.ierror = targetInvalid</li>
<li>如果都不满足，则验证 x.istatus = working</li>
</ul>
</li>
</ul>
</li>
<li>状态转换
<ul>
<li>当 io.metaWrite.fire 为高， 验证下一个状态为 is_idle，并且 eccctrl.istatus = injected。</li>
</ul>
</li>
</ul>
<ol start="5">
<li>is_writeData 状态</li>
</ol>
<ul>
<li>RegWriteFn
<ul>
<li>此状态进入后，io.dataWrite.valid 会为高</li>
<li>res.inject = false</li>
<li>当 ready 为高，且 x.istatus = injected 或 x.istatus = error 时，验证 x.istatus = idle 和 x.ierror = notEnabled</li>
</ul>
</li>
<li>状态转换
<ul>
<li>当 io.dataWrite.fire 为高， 验证下一个状态为 is_idle，并且 eccctrl.istatus = injected。</li>
</ul>
</li>
</ul>
<h3 id="寄存器映射和外部访问">寄存器映射和外部访问</h3>
<p>通过 TileLink 总线将寄存器映射到特定地址，使外部模块可以读写 ECC 控制寄存器和注入地址寄存器。</p>
<ul>
<li>使用 TLRegisterNode 实现寄存器的映射，使得外部系统可以通过地址访问寄存器。寄存器的读写操作通过 TileLink 协议进行。</li>
</ul>
<ol>
<li>外部读取和写入 ECC 控制寄存器</li>
</ol>
<ul>
<li>验证外部模块可以通过 TileLink 协议正确读取和写入 eccctrl 和 ecciaddr 寄存器，并对模块内部的状态产生影响，确保读写操作完全覆盖。</li>
</ul>
<ol start="2">
<li>外部模块触发错误注入</li>
</ol>
<ul>
<li>通过外部模块经 TileLink 总线向 eccctrl.inject 寄存器写入 true，触发错误注入，验证内部状态是否按 RegWriteFn 内部过程执行。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-cc1ecb7ceb308765a81e31303c5aea88">12.2.2.2 - ICache</h1>
    
	<div class="icache-ctx">
</div>
<h2 id="icache">ICache</h2>
<p>各种组合数据的宽度以 system verilog/verilog 中的为准。</p>
<ul>
<li>IPrefetchPipe 接收来自 FTQ 的预取请求，然后向 MetaArray 和 ITLB 发送请求，再从 ITLB 的响应得到 paddr，之后与 MetaArray 返回的 tag 进行比较得到命中信息，把命中信息、MetaArray ECC 校验信息和 ITLB 信息一并写入 WayLookup，同时进行 PMP 检查。未命中就将信息发送给 MissUnit 处理，MissUnit 通过 TileLink 总线向 L2Cache 发起请求，获取数据后返回给 MetaArray 和 IPrefetchPipe。之后会判断是否 Miss，如果 Miss 则把预取请求发送到 MissUnit，它会通过 TileLink 向 L2 做预取指。</li>
<li>MainPipe 接收来自 FTQ 的取指请求，然后从 WayLookup 获取路命中信息和 ITLB 查询结果，再访问 DataArray。命中后向 replacer 发送 touch 请求，replacer 采用 PLRU 替换策略,接收到 MainPipe 的命中更新，向 MissUnit 提供写入的 waymask。同时进行 PMP 检查，接收 DataArry 返回的数据。对 DataArray 做 ECC 校验，根据 DataArry 和 MetaArry 的校验结果（MetaArray 的校验结果来自 Waylookup）判断是否将错误报告给总线（beu）。之后，如果 DataArry 没有命中，将信息发往 MissUnit 处理。MissUnit 通过 TileLink 总线向 L2Cache 发起请求，获取数据后返回给 DataArray 和 MainPipe。之后就可以将数据返回给 IFU。</li>
<li>MetaArray 存储缓存行的标签（Tag）和 ECC 校验码
<ul>
<li>使用双 Bank SRAM 结构，支持双线访问（Double-Line），每个 Bank 存储部分元数据。</li>
<li>标签包含物理地址的高位，用于地址匹配。</li>
<li>支持标签 ECC 校验，检测和纠正存储错误。</li>
<li>valid_array 记录每个 Way 的有效状态，Flush 操作会清零</li>
</ul>
</li>
<li>DataArray 存储实际的指令数据块。
<ul>
<li>数据按 Bank 划分为八个，每个 Bank 宽度为 64 位，支持多 Bank 并行访问。</li>
<li>数据 ECC 校验，分段生成校验码，增强错误检测能力。</li>
<li>支持双线访问，根据地址偏移选择 Bank，单周期可读取 32 字节数据。</li>
</ul>
</li>
<li>冲刷信号有三种：ftqPrefetch.flushFromBpu，itlbFlushPipe，模块外部的 fencei 和 flush 信号。
<ul>
<li>ftqPrefetch.flushFromBpu：通过 FTQ 来自的 BPU 刷新信号，用于控制预取请求的冲刷。</li>
<li>itlbFlushPipe：ITLB 的冲刷信号，itlb 在收到该信号时会冲刷 gpf 缓存。</li>
<li>fencei:刷新 MetaArray，清除所有路的 valid_array 清零；missUnit 中所有 MSHR 置无效。</li>
<li>flush:mainPipe 和 prefetchPipe 所有流水级直接置无效，wayLookup 读写指针复位，gpf_entry 直接置无效,missUnit 中所有 MSHR 置无效。</li>
</ul>
</li>
</ul>
<h3 id="replacer">Replacer</h3>
<p>采用 PLRU 更新算法，考虑到每次取指可能访问连续的 doubleline，对于奇地址和偶地址设置两个 replacer，在进行 touch 和 victim 时根据地址的奇偶分别更新 replacer。</p>
<div>			
    <center>	
    <img src="../plru.png"
         alt="PLRU 算法示意"
         style="zoom:100%"/>
    <br>		
    PLRU 算法示意	
    </center>
</div>
<br>
<h4 id="touch">touch</h4>
<p>Replacer 具有两个 touch 端口，用以支持双行，根据 touch 的地址奇偶分配到对应的 replacer 进行更新。</p>
<h4 id="victim">victim</h4>
<p>Replacer 只有一个 victim 端口，因为同时只有一个 MSHR 会写入 SRAM，同样根据地址的奇偶从对应的 replacer 获取 waymask。并且在下一拍再进行 touch 操作更新 replacer。</p>
<h2 id="icache-的功能点和测试点">ICache 的功能点和测试点</h2>
<h3 id="ftq-预取请求处理">FTQ 预取请求处理</h3>
<p>接收来自 FTQ 的预取请求，经 IPrefetchPipe 请求过滤（查询 ITLB 地址，是否命中 MetaArry，PMP 检查），（有异常则由 MissUnit 处理）后进入 WayLookup。</p>
<ol>
<li>预取地址命中，无异常</li>
</ol>
<ul>
<li>io.ftqPrefetch.req.bits 的 startAddr 和 nextlineStart 在正常地址范围内，itlb 命中无异常，itlb 查询到的地址与 MetaArry 的 ptag 匹配，pmp 检查通过。</li>
<li>如果没有监听到 MSHR 同样的位置发生了其它 cacheline 的写入，那么验证 wayLookup.io.write 的内容应该命中的取指数据。</li>
<li>如果监听到 MSHR 同样的位置发生了其它 cacheline 的写入，那么验证 wayLookup.io.write 的内容应该是未命中的取指数据。</li>
</ul>
<ol start="2">
<li>预取地址未命中，无异常</li>
</ol>
<ul>
<li>io.ftqPrefetch.req.bits 的 startAddr 和 nextlineStart 在正常地址范围内，itlb 命中无异常，itlb 查询到的地址与 MetaArry 的 ptag 不匹配，pmp 检查通过。</li>
<li>如果监听到 MSHR 将该请求对应的 cacheline 写入了 SRAM，那么验证 wayLookup.io.write 的内容应该命中的取指数据。</li>
<li>如果监听到 MSHR 没有将该请求对应的 cacheline 写入了 SRAM，那么验证 wayLookup.io.write 的内容应该未命中的取指数据。</li>
</ul>
<ol start="3">
<li>预取地址 TLB 异常，无其他异常</li>
</ol>
<ul>
<li>io.ftqPrefetch.req.bits 的 startAddr 和 nextlineStart 在正常地址范围内，itlb 异常。</li>
<li>验证 wayLookup.io.write 的 itlb_exception 内容中，其有对应的异常类型编号（pf:01;gpf:10;af:11）。</li>
</ul>
<ol start="4">
<li>预取地址 PMP 异常，无其他异常</li>
</ol>
<ul>
<li>io.ftqPrefetch.req.bits 的 startAddr 和 nextlineStart 在正常地址范围内，itlb 命中无异常，itlb 查询到的地址与 MetaArry 的 ptag 匹配，pmp 检查未通过。</li>
<li>验证 wayLookup.io.write 的 tlb_pbmt 内容中，其有对应的异常类型编号（nc:01;io:10）。</li>
</ul>
<h3 id="ftq-取指请求处理">FTQ 取指请求处理</h3>
<p>io.fetch.resp &lt;&gt; mainPipe.io.fetch.resp 发送回 IFU 的数据是在 io.fetch.resp。</p>
<p>接收来自 FTQ 的取指请求，从 WayLookup 获取路命中信息和 ITLB 查询结果，再访问 DataArray，监控 MSHR 的响应。更新 replacer，做 pmp 检查。后做 DataArray 和 MetaArray 的 ECC 校验。最后将数据发送给 IFU。</p>
<ol>
<li>取指请求命中，无异常</li>
</ol>
<ul>
<li>io.fetch.req.bits.pcMemRead 的 0-4 的 startAddr 和 nextlineStart 在正常地址范围内，从 WayLookup 获取信息，命中，pmp 检查正常，DataArray 和 MetaArray 的 ECC 校验正常。</li>
<li>验证 replacer.io.touch 的 vSetIdx 和 way 和 ftq 的 fetch 一致，missUnit.io.victim 的 vSetIdx 和 way 是按照制定的算法生成的。</li>
<li>验证 io.fetch.resp 的数据应该是取指的数据。</li>
</ul>
<ol start="2">
<li>取指请求未命中，MSHR 返回的响应命中，无异常</li>
</ol>
<ul>
<li>io.fetch.req.bits.pcMemRead 的 0-4 的 startAddr 和 nextlineStart 在正常地址范围内，从 WayLookup 获取信息，未命中，pmp 检查正常，DataArray 和 MetaArray 的 ECC 校验正常。</li>
<li>请求在 MSHR 返回的响应命中。</li>
<li>验证 missUnit.io.victim 的 vSetIdx 和 way 是按照制定的算法生成的。</li>
<li>验证 io.fetch.resp 的数据应该是取指的数据。</li>
</ul>
<ol start="3">
<li>取指请求命中,ECC 校验错误，无其他异常</li>
</ol>
<ul>
<li>io.fetch.req.bits.pcMemRead 的 0-4 的 startAddr 和 nextlineStart 在正常地址范围内，从 WayLookup 获取信息，命中，pmp 检查正常，DataArray 或 MetaArray 的 ECC 校验错误。</li>
<li>验证 io.error.valid 为高，且 io.error.bits 内容为对应的错误源和错误类型。</li>
<li>先刷 MetaArray 的 ValidArray,给 MissUnit 发请求，由其在 L2 重填，阻塞至数据返回。</li>
<li>验证 replacer.io.touch 的 vSetIdx 和 way 和 ftq 的 fetch 一致，missUnit.io.victim 的 vSetIdx 和 way 是按照制定的算法生成的。</li>
<li>验证 io.fetch.resp 的数据应该是取指的数据。</li>
</ul>
<ol start="4">
<li>取指请求未命中，但是 exception 非 0（af、gpf、pf），无其他异常</li>
</ol>
<ul>
<li>io.fetch.req.bits.pcMemRead 的 0-4 的 startAddr 和 nextlineStart 在正常地址范围内，从 WayLookup 获取信息，命中，pmp 检查未通过，DataArray 和 MetaArray 的 ECC 校验正常。</li>
<li>验证 io.fetch.resp 为对应的错误源和错误类型。</li>
<li>验证 io.fetch.resp 的数据无效，里面有异常类型。</li>
</ul>
<ol start="5">
<li>取指请求未命中，通过 WayLookup 中读取到的预取过来的 itlb 中返回 pbmt。</li>
</ol>
<ul>
<li>有 itlb_pbmt 和 pmp_mmio 时，他们合成 s1_mmio，传递到 s2_mmio,生成 s2_miss,有特殊情况就不会取指。</li>
<li>io.fetch.req.bits.pcMemRead 的 0-4 的 startAddr 和 nextlineStart 在正常地址范围内，从 WayLookup 获取信息，命中，pmp 检查通过，DataArray 和 MetaArray 的 ECC 校验正常。</li>
<li>验证 io.fetch.resp 为对应的错误源和错误类型。</li>
<li>验证 io.fetch.resp 的数据无效，里面有特殊情况类型类型。</li>
</ul>
<ol start="6">
<li>取指请求未命中，pmp 返回 mmio ，处理同 5。</li>
</ol>
<h3 id="metaarray-功能">MetaArray 功能</h3>
<p>在 IPrefetchPipe 的 S0，接收来自 IPrefetchPipe 的读请求 read，返回对应路和组的响应 readResp。
在 miss 的时候，MissUnit 会将会应的数据写入 write 到 MetaArray。
MetaArray 主要存储了每个 Cache 行的标签和 ECC 校验码。</p>
<ol>
<li>元数据写入操作（对应的 Set 已满）: ICacheMetaArray 应当能够正确地将元数据（标签和有效位）写入到指定的 Set 和 Way 。</li>
</ol>
<ul>
<li>从 MissUnit 返回的请求都是未命中的请求（已命中不会向 MissUnit 请求，那么 MissUnit 自然也不会向 MetaArray 写入）。</li>
<li>发送一个写请求 write 到 ICacheMetaArray，ICacheReplacer 根据 PLRU 替换策略指定 way，替换路被写入 waymask，最后指定 virIdx、phyTag、waymask、bankIdx、poison。</li>
<li>写入操作后，发起一个对相同虚拟索引的读请求。验证 readResp 的 metas 和 codes 分别包含写入的 ptag 和 ecc code，并且对于写入的路，readResp.entryValid 信号被置为有效。</li>
</ul>
<ol start="2">
<li>元数据读取操作 (命中): 当一个读请求在 ICacheMetaArray 中命中时（存在有效的条目），它应该返回正确的元数据（标签和有效位）。</li>
</ol>
<ul>
<li>首先，向特定的虚拟索引（组和路）写入元数据（参照上面的写入操作）。然后，向相同的虚拟索引发送一个读请求。</li>
<li>验证 readResp.metas 包含之前写入的物理标签，并且对于相应的路，readResp.entryValid 信号被置为有效。</li>
</ul>
<ol start="3">
<li>元数据读取操作 (未命中): 当读取一个尚未被写入的地址时，ICacheMetaArray 应当指示未命中（条目无效）。</li>
</ol>
<ul>
<li>向 ICacheMetaArray 发送一个读请求，请求的虚拟索引在复位后从未被写入过。</li>
<li>验证对于任何路，readResp.entryValid 信号都没有被置为有效。 对应的 readResp.metas 和 codes 的内容是 DontCare 也就是 0。</li>
</ul>
<ol start="4">
<li>独立的缓存组刷新：在第 i 个端口是有效的刷新请求，并且该请求的 waymask 指定了当前正在处理的第 w 路时，应该使第 i 个端口的条目无效。</li>
</ol>
<ul>
<li>先向 ICacheMetaArray 写入指定一个或多个端口的元数据，然后再给对应的端口的路发送刷新请求 io.flush，其包含虚拟索引 virIdx 和路掩码 waymask。</li>
<li>验证 valid_array 对应的路中的 virIdx 被置为无效，io.readResp.entryValid 对应路的对应端口为无效。</li>
</ul>
<ol start="5">
<li>全部刷新操作: ICacheMetaArray 应当能够在接收到全部刷新请求时，使所有条目无效。</li>
</ol>
<ul>
<li>先向多个不同的虚拟索引写入元数据。然后置位 io.flushAll 信号。</li>
<li>验证步骤: 在 io.flushAll 信号置位后，发起对所有之前写入过的虚拟索引的读请求。验证在所有的读取响应中，对于任何路，readResp.entryValid 信号都没有被置为有效。</li>
</ul>
<h3 id="dataarray-功能">DataArray 功能</h3>
<p>与 MetaArray 类似，在 MainPipe 的 S0，接收来自 MainPipe 的读请求 read，返回对应路和组的响应 readResp。
在 miss 的时候，MissUnit 会将会应的数据写入 write 到 DataArray。
DataArray 主要存储了每个 Cache 行的标签和 ECC 校验码。</p>
<ol>
<li>数据写入操作（对应的 Set 已满）: ICacheDataArray 应当能够正确地将数据写入到指定的 Set (组)、Way (路) 和数据 Bank (存储体)。</li>
</ol>
<ul>
<li>发送一个写请求 write 到 ICacheDataArray，ICacheReplacer 根据 PLRU 替换策略指定 way，替换路被写入 waymask，最终指定虚拟索引、数据、路掩码、存储体索引 bankIdx 和毒化位。写入的数据模式应跨越多个数据存储体。</li>
<li>写入操作后，发起一个对相同虚拟索引和块偏移量的读请求。验证 readResp.datas 与写入的数据相匹配。</li>
</ul>
<ol start="2">
<li>数据读取操作 (命中): 当一个读请求命中时（相应的元数据有效），它应该从相应的组、路和数据存储体返回正确的数据。</li>
</ol>
<ul>
<li>首先，向特定的虚拟索引和块偏移量写入数据。然后，向相同的虚拟索引和块偏移量发送一个读请求。使用不同的块偏移量进行测试，以覆盖存储体的选择逻辑。</li>
<li>验证 readResp.datas 包含之前写入的数据。</li>
</ul>
<ol start="3">
<li>数据读取操作 (未命中): 当读取一个尚未被写入的地址时，ICacheDataArray 的输出应该是默认值或无关值。</li>
</ol>
<ul>
<li>向 ICacheDataArray 发送一个读请求，请求的虚拟索引在复位后从未被写入过。</li>
<li>验证 readResp.datas 为 0。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-50120bb49e006cebe08f3f3d10a23195">12.2.2.3 - IPrefetchPipe</h1>
    
	<div class="icache-ctx">
</div>
<h2 id="iprefetchpipe">IPrefetchPipe</h2>
<p>IPrefetchPipe 为预取的流水线，三级流水设计，负责预取请求的过滤。</p>
<div>			
    <center>	
    <img src="../iprefetchpipe_structure.png"
         alt="IPrefetchPipe模块结构示意图"
         style="zoom:40%"/>
    <br>		
    IPrefetchPipe结构示意图	
    </center>
</div>
<br>
<ol>
<li>接收预取请求（s0 阶段）：</li>
</ol>
<ul>
<li>从 FTQ 或后端接收预取请求。</li>
<li>发送读请求到 ITLB 和 MetaArray 缓存元数据模块。</li>
</ul>
<ol start="2">
<li>地址转换和缓存检查（s1 阶段）：</li>
</ol>
<ul>
<li>接收 ITLB 的地址转换结果，处理可能的缺失和重发。</li>
<li>从缓存元数据中读取标签和有效位，检查是否命中。</li>
<li>进行 PMP 权限检查，合并异常信息。</li>
<li>根据情况决定是否发送请求到 WayLookup 模块。</li>
</ul>
<ol start="3">
<li>未命中请求处理（s2 阶段）：</li>
</ol>
<ul>
<li>检查与 missUnit 的交互，更新命中状态。</li>
<li>对于无异常的未命中请求，向 missUnit 发送请求以获取数据。</li>
<li>控制流水线的推进和刷新，处理可能的阻塞和异常。</li>
</ul>
<h3 id="s0-流水级">S0 流水级</h3>
<p>在 S0 流水级，接收来自 FTQ 的预取请求，向 MetaArray 和 ITLB 发送请求。</p>
<ul>
<li>接收预取请求：从 FTQ 或后端接收预取请求，提取预取请求的虚拟地址、FTQ 索引、是否为软件预取、是否跨缓存行信、虚拟组索引（s0_req_vSetIdx）和后端的异常信息。</li>
<li>发送请求到 ITLB：将虚拟地址发送到 ITLB 进行地址转换。</li>
<li>发送请求到缓存元数据（Meta SRAM）：将请求发送到缓存的元数据存储器，以便在后续阶段读取缓存标签和有效位。</li>
</ul>
<h3 id="s1-流水级">S1 流水级</h3>
<p>软件预取 enqway 持续一拍&hellip;</p>
<ul>
<li>接收 ITLB 的响应：从 ITLB 接收地址转换的结果，包括物理地址 paddr、异常类型(<code>af</code>/<code>pf</code>)和特殊情况(<code>pbmt.nc</code>/<code>pbmt.io</code>)。</li>
<li>接收缓存元数据的响应并检查缓存命中：从缓存元数据存储器 MetaArray 读取缓存标签 <code>tag</code> 和有效位，检查预取地址是否在缓存中已存在，命中结果存入 <code>waymask</code> 中。</li>
<li>权限检查：使用 PMP 对物理地址进行权限检查，确保预取操作的合法性。</li>
<li>异常处理和合并：合并来自后端、ITLB、PMP 的异常信息，准备在后续阶段处理。</li>
<li>发送请求到 WayLookup 模块：当条件满足时，将元数据（命中信息 <code>waymask</code>、ITLB 信息 <code>paddr</code>/<code>af</code>/<code>pf</code>）发送到 WayLookup 模块，以便进行后续的缓存访问。</li>
<li>状态机转换：根据当前状态和条件，更新下一个状态。
<ul>
<li>状态机初始状态为 <code>idle</code>，当 S1 流水级进入新的请求时，首先判断 ITLB 是否缺失，如果缺失，就进入 <code>itlbResend</code>；如果 ITLB 命中但命中信息未入队 WayLookup，就进入 <code>enqWay</code>；如果 ITLB 命中且 WayLookup 入队但 S2 请求未处理完，就进入 <code>enterS2</code>。</li>
<li>在 <code>itlbResend</code> 状态，重发 ITLB 请求，此时占用 ITLB 端口，直至请求回填完成，在回填完成的当拍向 MetaArray 再次发送读请求，回填期间可能发生新的写入，如果 MetaArray 繁忙（正在被写入），就进入<code>metaResend</code>，否则进入 <code>enqWay</code>。</li>
<li>在 <code>metaResend</code> 状态，重发 MetaArray 读请求，发送成功后进入 <code>enqWay</code>。</li>
<li>在 <code>enqWay</code> 状态，尝试将元数据入队 WayLookup，如果 WayLookup 队列已满，就阻塞至 WayLookup 入队成功，另外在 MSHR 发生新的写入时禁止入队，主要是为了防止写入的信息与命中信息所冲突，需要对命中信息进行更新。当成功入队 WayLookup 或者是软件预取时，如果 S2 空闲，就直接进入 <code>idle</code>，否则进入 <code>enterS2</code>。</li>
<li>在 <code>enterS2</code> 状态，尝试将请求流入下一流水级，流入后进入 <code>idle</code>。</li>
</ul>
</li>
</ul>
<div>			<!--块级封装-->
    <center>	<!--将图片和文字居中-->
    <img src="../iprefetchpipe_fsm.png"
         alt="IPrefetchPipe状态机"
         style="zoom:100%"/>
    <br>		<!--换行-->
    IPrefetchPipe S1状态机	<!--标题-->
    </center>
</div>
<br>
<h3 id="s2-流水级">S2 流水级</h3>
<ul>
<li>监控 missUnit 的请求：更新 MSHR 的匹配状态。综合该请求的命中结果、ITLB 异常、PMP 异常、meta 损坏，判断是否需要预取，只有不存在异常时才进行预取。</li>
<li>发送请求到 missUnit：因为同一个预测块可能对应两个 cacheline，所以通过 Arbiter 依次将请求发送至 MissUnit。</li>
</ul>
<h3 id="命中信息的更新">命中信息的更新</h3>
<p>在 S1 流水级中得到命中信息后，距离命中信息真正在 MainPipe 中被使用要经过两个阶段，分别是在 IPrefetchPipe 中等待入队 WayLookup 阶段和在 WayLookup 中等待出队阶段，在等待期间可能会发生 MSHR 对 Meta/DataArray 的更新，因此需要对 MSHR 的响应进行监听，分为两种情况：</p>
<ol>
<li>请求在 MetaArray 中未命中，监听到 MSHR 将该请求对应的 cacheline 写入了 SRAM，需要将命中信息更新为命中状态。</li>
<li>请求在 MetaArray 中已经命中，监听到同样的位置发生了其它 cacheline 的写入，原有数据被覆盖，需要将命中信息更新为缺失状态。</li>
</ol>
<p>为了防止更新逻辑的延迟引入到 DataArray 的访问路径上，在 MSHR 发生新的写入时禁止入队 WayLookup，在下一拍入队。</p>
<h3 id="刷新机制">刷新机制</h3>
<p>在 IPrefetch 中如果收到后端重定向、IFU 预译码、fencei 带来的刷新，就冲刷整个流水线</p>
<p>IPrefetchPipe 模块中的刷新信号主要来自以下两个方面：</p>
<ol>
<li>全局刷新信号：由系统的其他模块发出的全局刷新信号，如怀疑流水线中存在错误数据或需要清除流水线时触发。</li>
</ol>
<ul>
<li>io.flush：模块输入的全局刷新信号。当系统需要清除所有流水线阶段的数据时，该信号被置为高。</li>
</ul>
<ol start="2">
<li>来自分支预测单元（BPU）的刷新信号：当分支预测错误或需要更新预测信息时，BPU 会发出刷新信号。</li>
</ol>
<ul>
<li>io.flushFromBpu：包含来自 BPU 的刷新信息，指示哪些指令需要被刷新。</li>
</ul>
<h2 id="iprefetchpipe-的功能点和测试点">IPrefetchPipe 的功能点和测试点</h2>
<h3 id="接收预取请求">接收预取请求</h3>
<p>从 FTQ 接收预取请求，请求可能有效（ io.req.valid 为高），可能无效； IPrefetchPipe 可能处于空闲（ io.req.ready 为高），可能处于非空闲状态。
只有在请求有效且 IPrefetchPipe 处于空闲状态时，预取请求才会被接收（这里暂不考虑 s0 的刷新信号 s0_flush ，默认其为低）。
预取请求分为不同类型，包括硬件预取请求 (isSoftPrefetch = false)和软件预取请求 (isSoftPrefetch = true)。
cacheline 也分为单 cacheline 和双 cacheline。</p>
<ol>
<li>
<p>硬件预取请求：
预取请求为硬件 (isSoftPrefetch = false)</p>
<ol>
<li>预取请求可以继续：
<ul>
<li>当预取请求有效且 IPrefetchPipe 处于空闲状态时，预取请求应该被接收。</li>
<li>s0_fire 信号在没有 s0 的刷新信号（ s0_flush 为低）时，应该被置为高。</li>
</ul>
</li>
<li>预取请求被拒绝&ndash;预取请求无效时：
<ul>
<li>当预取请求无效时，预取请求应该被拒绝。</li>
<li>s0_fire 信号应该被置为低。</li>
</ul>
</li>
<li>预取请求被拒绝&ndash;IPrefetchPipe 非空闲时：
<ul>
<li>当 IPrefetchPipe 非空闲时，预取请求应该被拒绝。</li>
<li>s0_fire 信号应该被置为低。</li>
</ul>
</li>
<li>预取请求被拒绝&ndash;预取请求无效且 IPrefetchPipe 非空闲时：
<ul>
<li>当预取请求无效且 IPrefetchPipe 非空闲时，预取请求应该被拒绝。</li>
<li>s0_fire 信号应该被置为低。</li>
</ul>
</li>
<li>预取请求有效且为单 cacheline 时：
<ul>
<li>当预取请求有效且为单 cacheline 时，预取请求应该被接收。</li>
<li>s0_fire 为高，s0_doubleline 应该被置低（false）。</li>
</ul>
</li>
<li>预取请求有效且为双 cacheline 时：
<ul>
<li>当预取请求有效且为双 cacheline 时，预取请求应该被接收。</li>
<li>s0_fire 为高，s0_doubleline 应该被置高（true）。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>软件预取请求：
预取请求为软件 (isSoftPrefetch = true)</p>
<ol>
<li>软件预取请求可以继续：
<ul>
<li>当预取请求有效且 IPrefetchPipe 处于空闲状态时，软件预取请求应该被接收。</li>
<li>s0_fire 信号在没有 s0 的刷新信号（ s0_flush 为低）时，应该被置为高。</li>
</ul>
</li>
<li>软件预取请求被拒绝&ndash;预取请求无效时：
<ul>
<li>当预取请求无效时，软件预取请求应该被拒绝。</li>
<li>s0_fire 信号应该被置为低。</li>
</ul>
</li>
<li>软件预取请求被拒绝&ndash;IPrefetchPipe 非空闲时：
<ul>
<li>当 IPrefetchPipe 非空闲时，软件预取请求应该被拒绝。</li>
<li>s0_fire 信号应该被置为低。</li>
</ul>
</li>
<li>软件预取请求被拒绝&ndash;预取请求无效且 IPrefetchPipe 非空闲时：
<ul>
<li>当预取请求无效且 IPrefetchPipe 非空闲时，软件预取请求应该被拒绝。</li>
<li>s0_fire 信号应该被置为低。</li>
</ul>
</li>
<li>软件预取请求有效且为单 cacheline 时：
<ul>
<li>当软件预取请求有效且为单 cacheline 时，软件预取请求应该被接收。</li>
<li>s0_fire 为高，s0_doubleline 应该被置低（false）。</li>
</ul>
</li>
<li>软件预取请求有效且为双 cacheline 时：
<ul>
<li>当软件预取请求有效且为双 cacheline 时，软件预取请求应该被接收。</li>
<li>s0_fire 为高，s0_doubleline 应该被置高（true）。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="接收来自-itlb-的响应并处理结果">接收来自 ITLB 的响应并处理结果</h3>
<p>接收 ITLB 的响应，完成虚拟地址到物理地址的转换。
当 ITLB 发生缺失（miss）时，保存请求信息，等待 ITLB 完成后再继续处理。</p>
<ol>
<li>
<p>地址转换完成：</p>
<ul>
<li>根据 ITLB 的响应，接收物理地址（paddr），并完成地址转换。</li>
<li>处理 ITLB 响应可能在不同周期到达的情况，管理有效信号和数据保持机制，确保正确使用物理地址。</li>
</ul>
<ol>
<li>
<p>当 ITLB 正常返回物理地址时：</p>
<ul>
<li>ITLB 在一个周期内成功返回物理地址 paddr，s1_valid 为高。</li>
<li>确认 s1 阶段正确接收到 paddr。</li>
</ul>
</li>
<li>
<p>当 ITLB 发生 TLB 缺失，需要重试时：</p>
<ul>
<li>fromITLB(PortNumber).bits.miss 为高，表示对应通道的 ITLB 发生了 TLB 缺失，需要重发。</li>
<li>重发完成后，后续步骤继续进行，fromITLB(PortNumber).bits.miss 为低。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>处理 ITLB 异常：</p>
<ul>
<li>根据 ITLB 的异常信息，处理可能的异常。pf 缺页、pgf 虚拟机缺页、af 访问错误。</li>
</ul>
<ol>
<li>当 ITLB 发生页错误异常时：
<ul>
<li>s1_itlb_exception 返回的页错误。</li>
<li>iTLB 返回的物理地址有效（fromITLB(PortNumber).bits.miss 为低），s1_itlb_exception 指示页错误 pf。</li>
</ul>
</li>
<li>当 ITLB 发生虚拟机页错误异常时：
<ul>
<li>s1_itlb_exception 返回的虚拟机页错误。</li>
<li>iTLB 返回的物理地址有效（fromITLB(PortNumber).bits.miss 为低），s1_itlb_exception 指示虚拟机页错误 pgf。</li>
</ul>
</li>
<li>当 ITLB 发生访问错误异常时：
<ul>
<li>s1_itlb_exception 返回的访问错误。</li>
<li>iTLB 返回的物理地址有效（fromITLB(PortNumber).bits.miss 为低），s1_itlb_exception 指示访问错误 af。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>处理虚拟机物理地址（用于虚拟化）：</p>
<ul>
<li>在虚拟化环境下，处理虚拟机物理地址（gpaddr），确定访问是否针对二级虚拟机的非叶子页表项（isForVSnonLeafPTE）。</li>
</ul>
<ol>
<li>发生虚拟机页错误异常返回虚拟机物理地址（gpaddr）：
<ul>
<li>发生 pgf 后，需要返回对应的 gpaddr。</li>
<li>只有一个通道发生 pgf 时，返回对应通道的 gpaddr 即可；多个通道发生 pgf 时，返回第一个通道的 gpaddr。</li>
</ul>
</li>
<li>当访问二级虚拟机的非叶子页表项时：
<ul>
<li>发生 gpf 后，如果是访问二级虚拟机的非叶子页表项时，需要返回对应的 gpaddr。</li>
<li>只有一个通道发生 pgf 时，返回对应通道的 gpaddr 即可；多个通道发生 pgf 时，返回第一个通道的 gpaddr。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>返回基于页面的内存类型 pbmt 信息：</p>
<ul>
<li>TLB 有效时，返回 pbmt 信息。</li>
</ul>
</li>
</ol>
<h3 id="接收来自-imeta缓存元数据的响应并检查缓存命中">接收来自 IMeta（缓存元数据）的响应并检查缓存命中</h3>
<p>从 Meta SRAM 中读取缓存标签和有效位。
将物理地址的标签部分与缓存元数据中的标签比较，确定是否命中。</p>
<ol>
<li>
<p>缓存标签比较和有效位检查：</p>
<ul>
<li>从物理地址中提取物理标签（ptag），将其与缓存元数据中的标签进行比较，检查所有缓存路（Way）。检查有效位，确保只考虑有效的缓存行。</li>
</ul>
<ol>
<li>缓存未命中（标签不匹配或有效位为假）：
<ul>
<li>当标签不匹配或者标签匹配，但是有效位为假时，表示缓存未命中。</li>
<li>s1_meta_ptags(PortNumber)(nWays) 不等于 ptags(PortNumber) 或者它们相等，但是对应的 s1_meta_valids 为低时，总之返回的 waymasks 为全 0。</li>
</ul>
</li>
<li>单路缓存命中（标签匹配且有效位为真）：
<ul>
<li>当标签匹配，且有效位为真时，表示缓存命中。</li>
<li>waymasks 对应的位为 1。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="pmp物理内存保护权限检查">PMP（物理内存保护）权限检查</h3>
<p>对物理地址进行 PMP 权限检查，确保预取操作的合法性。
处理 PMP 返回的异常和 MMIO 信息</p>
<ol>
<li>访问被允许的内存区域
<ul>
<li>itlb 返回的物理地址在 PMP 允许的范围内。</li>
<li>s1_pmp_exception(i) 为 none。</li>
</ul>
</li>
<li>访问被禁止的内存区域
<ul>
<li>s1_req_paddr(i) 对应的地址在 PMP 禁止的范围内。</li>
<li>s1_pmp_exception(i) 为 af。</li>
</ul>
</li>
<li>访问 MMIO 区域
<ul>
<li>itlb 返回的物理地址在 MMIO 区域。</li>
<li>s1_pmp_mmio 为高。</li>
</ul>
</li>
</ol>
<h3 id="异常处理和合并">异常处理和合并</h3>
<p>backend 优先级最高，merge 方法里的异常越靠前优先级越高</p>
<p>合并来自后端、ITLB、PMP 的异常信息，按照优先级确定最终的异常类型。</p>
<ol>
<li>仅 ITLB 产生异常
<ul>
<li>s1_itlb_exception(i) 为非零，s1_pmp_exception(i) 为零。</li>
<li>s1_exception_out(i) 正确包含 ITLB 异常。</li>
</ul>
</li>
<li>仅 PMP 产生异常
<ul>
<li>s1_itlb_exception(i) 为零，s1_pmp_exception(i) 为非零。</li>
<li>s1_exception_out(i) 正确包含 PMP 异常。</li>
</ul>
</li>
<li>仅 后端 产生异常
<ul>
<li>s1_itlb_exception(i) 为零，s1_pmp_exception(i) 为零。</li>
<li>s1_exception_out(i) 正确包含 后端 异常。</li>
</ul>
</li>
<li>ITLB 和 PMP 都产生异常
<ul>
<li>s1_itlb_exception(i) 和 s1_pmp_exception(i) 都为非零。</li>
<li>s1_exception_out(i) 包含 ITLB 异常（优先级更高）。</li>
</ul>
</li>
<li>ITLB 和 后端 都产生异常
<ul>
<li>s1_itlb_exception(i) 和 s1_backendException(i) 都为非零。</li>
<li>s1_exception_out(i) 包含 后端 异常（优先级更高）。</li>
</ul>
</li>
<li>PMP 和 后端 都产生异常
<ul>
<li>s1_pmp_exception(i) 和 s1_backendException(i) 都为非零。</li>
<li>s1_exception_out(i) 包含 后端 异常（优先级更高）。</li>
</ul>
</li>
<li>ITLB、PMP 和 后端 都产生异常
<ul>
<li>s1_itlb_exception(i)、s1_pmp_exception(i) 和 s1_backendException(i) 都为非零。</li>
<li>s1_exception_out(i) 包含 后端 异常（优先级更高）。</li>
</ul>
</li>
<li>无任何异常
<ul>
<li>s1_itlb_exception(i)、s1_pmp_exception(i)、s1_backendException(i) 都为零。</li>
<li>s1_exception_out(i) 指示无异常。</li>
</ul>
</li>
</ol>
<h3 id="发送请求到-waylookup-模块">发送请求到 WayLookup 模块</h3>
<p>当条件满足时，将请求发送到 WayLookup 模块，以进行后续的缓存访问。</p>
<ol>
<li>正常发送请求到 WayLookup
<ul>
<li>toWayLookup.valid 为高，toWayLookup.ready 为高，s1_isSoftPrefetch 为假。</li>
<li>请求成功发送，包含正确的地址、标签、waymask 和异常信息。</li>
</ul>
</li>
<li>WayLookup 无法接收请求
<ul>
<li>toWayLookup.valid 为高，toWayLookup.ready 为假。</li>
<li>状态机等待 WayLookup 准备好，不会错误地推进。</li>
</ul>
</li>
<li>软件预取请求不发送到 WayLookup
<ul>
<li>s1_isSoftPrefetch 为真。</li>
<li>toWayLookup.valid 为假，不会发送预取请求到 WayLookup。</li>
</ul>
</li>
</ol>
<h3 id="状态机控制和请求处理流程">状态机控制和请求处理流程</h3>
<p>使用状态机管理 s1 阶段的请求处理流程。
包括处理 ITLB 重发、Meta 重发、进入 WayLookup、等待 s2 准备等状态</p>
<ol>
<li>
<p>初始为 m_idle 状态：</p>
<ol>
<li>正常流程推进，保持 m_idle 状态</li>
</ol>
<ul>
<li>s1_valid 为高，itlb_finish 为真，toWayLookup.fire 为真，s2_ready 为真。</li>
<li>状态机保持在 m_idle 状态，s1 阶段顺利推进。</li>
</ul>
<ol start="2">
<li>ITLB 未完成，需要重发</li>
</ol>
<ul>
<li>s1_valid 为高，itlb_finish 为假。</li>
<li>状态机进入 m_itlbResend 状态，等待 ITLB 完成。</li>
</ul>
<ol start="3">
<li>ITLB 完成，WayLookup 未命中</li>
</ol>
<ul>
<li>s1_valid 为高，itlb_finish 为真，toWayLookup.fire 为假。</li>
<li>状态机进入 m_enqWay 状态，等待 WayLookup 入队。</li>
</ul>
</li>
<li>
<p>初始为 m_itlbResend 状态：</p>
<ol>
<li>ITLB 命中, MetaArray 空闲，需要 WayLookup 入队
<ul>
<li>itlb_finish 为假，toMeta.ready 为真。</li>
<li>状态机进入 m_enqWay 状态，等待 WayLookup 入队。</li>
</ul>
</li>
<li>ITLB 命中, MetaArray 繁忙，等待 MetaArray 读请求
<ul>
<li>itlb_finish 为假，toMeta.ready 为假。</li>
<li>状态机进入 m_metaResend 状态，MetaArray 读请求</li>
</ul>
</li>
</ol>
</li>
<li>
<p>初始为 m_metaResend 状态：</p>
<ol>
<li>MetaArray 空闲 ，需要 WayLookup 入队
<ul>
<li>toMeta.ready 为真。</li>
<li>状态机进入 m_enqWay 状态，等待 WayLookup 入队。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>初始为 m_enqWay 状态：</p>
<ol>
<li>WayLookup 入队完成或者为软件预取, S2 空闲, 重新进入空闲状态
<ul>
<li>toWayLookup.fire 或 s1_isSoftPrefetch 为真，s2_ready 为假。</li>
<li>状态机进入空闲状态 m_idle。</li>
</ul>
</li>
<li>WayLookup 入队完成或者为软件预取, S2 繁忙，需要 enterS2 状态
<ul>
<li>toWayLookup.fire 或 s1_isSoftPrefetch 为真，s2_ready 为真。</li>
<li>状态机进入 m_enterS2 状态，等待 s2 阶段准备好。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>初始为 m_enterS2 状态：</p>
<ol>
<li>s2 阶段准备好，请求进入下流水级，流入后进入 m_idle 状态</li>
</ol>
<ul>
<li>s2_ready 为真。</li>
<li>状态机进入空闲状态 m_idle。</li>
</ul>
</li>
</ol>
<h3 id="监控-missunit-的请求">监控 missUnit 的请求</h3>
<p>检查 missUnit 的响应，更新缓存的命中状态和 MSHR 的匹配状态。</p>
<ol>
<li>
<p>请求与 MSHR 匹配且有效：</p>
<ul>
<li>s2_req_vSetIdx 和 s2_req_ptags 与 fromMSHR 中的数据匹配，且 fromMSHR.valid 为高，fromMSHR.bits.corrupt 为假。</li>
<li>s2_MSHR_match(PortNumber) 为真, s2_MSHR_hits(PortNumber) 应保持为真</li>
</ul>
</li>
<li>
<p>请求在 SRAM 中命中：</p>
<ul>
<li>s2_waymasks(PortNumber) 中有一位为高，表示在缓存中命中。</li>
<li>s2_SRAM_hits(PortNumber) 为真,s2_hits(PortNumber) 应为真。</li>
</ul>
</li>
<li>
<p>请求未命中 MSHR 和 SRAM：</p>
<ul>
<li>请求未匹配 MSHR，且 s2_waymasks(PortNumber) 为空。</li>
<li>s2_MSHR_hits(PortNumber)、s2_SRAM_hits(PortNumber) 均为假, s2_hits(PortNumber) 为假。</li>
</ul>
</li>
</ol>
<h3 id="发送请求到-missunit">发送请求到 missUnit</h3>
<p>对于未命中的预取请求，向 missUnit 发送请求，以获取缺失的数据。</p>
<ol>
<li>确定需要发送给 missUnit 的请求</li>
</ol>
<ul>
<li>
<p>根据命中状态、异常信息、MMIO 信息等，确定哪些请求需要发送到 missUnit（即 s2_miss）。</p>
<ol>
<li>
<p>请求未命中且无异常，需要发送到 missUnit：</p>
<ul>
<li>s2_hits(PortNumber) 为假(未命中缓存)，s2_exception 无异常，s2_mmio 为假(不是 MMIO 或不可缓存的内存)。</li>
<li>s2_miss(PortNumber) 为真，表示需要发送请求到 missUnit。</li>
</ul>
</li>
<li>
<p>请求命中或有异常，不需要发送到 missUnit：</p>
<ul>
<li>s2_hits(i) 为真（已命中）或者 s2_exception 有异常 或者 s2_mmio 为真（MMIO 访问）。</li>
<li>s2_miss(i) 为假，不会发送请求到 missUnit。</li>
</ul>
</li>
<li>
<p>双行预取时，处理第二个请求的条件：</p>
<ul>
<li>s2_doubleline 为真，处理第二个请求。</li>
<li>如果第一个请求有异常或 MMIO，s2_miss(1) 应为假，后续请求被取消或处理。</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="2">
<li>避免发送重复请求，发送请求到 missUnit</li>
</ol>
<ul>
<li>
<p>使用寄存器 has_send 记录每个端口是否已发送请求，避免重复发送。</p>
</li>
<li>
<p>将需要发送的请求通过仲裁器 toMSHRArbiter 发送到 missUnit。</p>
<ol>
<li>
<p>在 s1_real_fire 时，复位 has_send：</p>
<ul>
<li>s1_real_fire 为高。</li>
<li>has_send(PortNumber) 应被复位为假，表示新的请求周期开始。</li>
</ul>
</li>
<li>
<p>当请求成功发送时，更新 has_send：</p>
<ul>
<li>toMSHRArbiter.io.in(PortNumber).fire 为高（请求已发送）。</li>
<li>has_send(PortNumber) 被设置为真，表示该端口已发送请求。</li>
</ul>
</li>
<li>
<p>避免重复发送请求：</p>
<ul>
<li>同一请求周期内，has_send(PortNumber) 为真，s2_miss(PortNumber) 为真。</li>
<li>toMSHRArbiter.io.in(PortNumber).valid 为假，不会再次发送请求。</li>
</ul>
</li>
<li>
<p>正确发送需要的请求到 missUnit：</p>
<ul>
<li>s2_valid 为高，s2_miss(i) 为真，has_send(i) 为假。</li>
<li>toMSHRArbiter.io.in(i).valid 为高，请求被成功发送。</li>
</ul>
</li>
<li>
<p>仲裁器正确仲裁多个请求：</p>
<ul>
<li>多个端口同时需要发送请求。</li>
<li>仲裁器按照优先级或设计要求选择请求发送到 missUnit,未被选中的请求在下个周期继续尝试发送。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="刷新机制-1">刷新机制</h3>
<ul>
<li>io.flush: 全局刷新信号，当该信号为高时，所有请求都需要刷新。</li>
<li>from_bpu_s0_flush：当请求不是软件预取（!s0_isSoftPrefetch, 软件预取请求是由特定的指令触发的，与指令流中的分支预测无关。因此，在处理刷新信号时，对于软件预取请求，通常不受来自 BPU 的刷新信号影响。），且 BPU 指示需要在 Stage 2 或 Stage 3 刷新的请求，由于该请求尚未进入 s1 阶段，因此在 s0 阶段也需要刷新。</li>
<li>s0_flush：综合考虑全局刷新信号、来自 BPU 的刷新信号，以及 s1 阶段的刷新信号</li>
<li>from_bpu_s1_flush：当 s1 阶段的请求有效且不是软件预取，且 BPU 指示在 Stage 3 需要刷新，则在 s1 阶段需要刷新。</li>
<li>io.itlbFlushPipe：当 s1 阶段需要刷新时，该信号用于通知 ITLB 刷新其流水线，以保持一致性。</li>
<li>s1_flush：综合考虑全局刷新信号和来自 BPU 的刷新信号。</li>
<li>s2_flush：用于控制 s2 阶段是否需要刷新。</li>
</ul>
<ol>
<li>发生全局刷新
<ul>
<li>io.flush 为高。</li>
<li>s0_flush、s1_flush、s2_flush 分别为高，所有阶段的请求被正确清除。</li>
</ul>
</li>
<li>来自 BPU 的刷新
<ul>
<li>io.flushFromBpu.shouldFlushByStageX 为真（X 为 2 或 3），且请求不是软件预取。</li>
<li>对应阶段的 from_bpu_sX_flush 为高，sX_flush 为高，阶段请求被刷新。</li>
</ul>
</li>
<li>刷新时状态机复位
<ul>
<li>s1_flush 为高。</li>
<li>状态机 state 被重置为 m_idle 状态。</li>
</ul>
</li>
<li>ITLB 管道同步刷新
<ul>
<li>s1_flush 为高。</li>
<li>io.itlbFlushPipe 为高，ITLB 被同步刷新。</li>
</ul>
</li>
</ol>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-777e92538bab7ee062508e3c71e1460d">12.2.2.4 - MainPipe</h1>
    
	<div class="icache-ctx">
</div>
<h2 id="mainpipe">MainPipe</h2>
<p>MainPipe 为 ICache 的主流水，为三级流水设计，负责从 DataArray 中读取数据，pmp 检查，缺失处理，并且将结果返回给 IFU。</p>
<div>			
    <center>	
    <img src="../mainpipe_structure.png"
         alt="MainPipe结构示意图"
         style="zoom:100%"/>
    <br>		
    MainPipe结构示意图	
    </center>
</div>
<br>
<ol>
<li>从 WayLookup 获取信息，访问 DataArray 单路（S0 阶段）
在 S0 流水级，从 WayLookup 获取元数据，包括路命中信息和 ITLB 查询结果，访问 DataArray 的单路，如果 DataArray 正在被写或 WayLookup 中没有有效表项，流水线就会阻塞。每次重定向后，FTQ 中同一个请求被同时发送到 MainPipe 和 IPrefetchPipe 中，MainPipe 始终需要等待 IPrefetchPipe 将请求的查询信息写入 WayLookup 后才能向下走，导致了 1 拍重定向延迟，当预取超过取指时，该延迟就会被覆盖。</li>
</ol>
<ul>
<li>接收并解析来自 FTQ 的取指请求，提取必要的请求信息，如虚拟地址、缓存组索引、块内偏移、是否为双行读、后端的异常信息。</li>
<li>从 WayLookup 模块获取缓存命中信息和 TLB 信息，包括 waymask、物理标签、虚拟机物理地址、是否为叶节点、 ITLB 异常、ITLB 的 PBMT 信息、缓存元数据的校验码。</li>
<li>访问 DataArray 的单路，如果 DataArray 正在被写或 WayLookup 中没有有效表项，流水线就会阻塞。</li>
<li>每次重定向后，FTQ 中同一个请求被同时发送到 MainPipe 和 IPrefetchPipe 中，MainPipe 始终需要等待 IPrefetchPipe 将请求的查询信息写入 WayLookup 后才能向下走，导致了 1 拍重定向延迟，当预取超过取指时，该延迟就会被覆盖。</li>
</ul>
<ol start="2">
<li>接收上一个阶段的信息并进行数据暂存、PMP 检查、从 DataArray 获取读响应异常合并、替换策略更新以及监控 MissUnit（S1 阶段）</li>
</ol>
<ul>
<li>寄存并延迟 S0 阶段信息
<ul>
<li>从 S0 获取的地址、tag、命中方式（waymask）、TLB 异常标志、下一拍要用的数据等，都会在 S1 寄存一拍，保证在流水线停顿时也能维持正确值。</li>
</ul>
</li>
<li>Meta ECC 检查
<ul>
<li>对 S0 读出的 meta 和其校验码（ECC/Parity）进行比对，判断是否发生错误。如果关闭 parity 功能，则跳过该检查。</li>
</ul>
</li>
<li>更新 replacer
<ul>
<li>对确定命中的访问请求，进行“touch”更新，标记最近使用过的 way，以便后续替换算法正确运行。</li>
</ul>
</li>
<li>PMP 检查
<ul>
<li>根据 S0 得到的物理地址（paddr），在 S1 对其进行 PMP 检查，判断是否拥有执行权限、是否为 MMIO 等。在当拍收到响应，将结果寄存到下一流水级进行处理。</li>
<li>需要指出，IPrefetchPipe s1 流水级也会进行 PMP 检查，和此处的检查实际上是完全一样的，分别检查只是为了优化时序（避免 <code>ITLB(reg) -&gt; ITLB.resp -&gt; PMP.req -&gt; PMP.resp -&gt; WayLookup.write -&gt; bypass -&gt; WayLookup.read -&gt; MainPipe s1(reg)</code> 的超长组合逻辑路径）。</li>
</ul>
</li>
<li>异常合并
<ul>
<li>将 ITLB 与 PMP 异常进行优先级合并，产生最终的异常标记。</li>
</ul>
</li>
<li>选择数据来源：MSHR 或 SRAM
<ul>
<li>接收 DataArray 返回的 data 和 code 并寄存，同时监听 MSHR 的响应，当 DataArray 和 MSHR 的响应同时有效时，后者的优先级更高。当 MSHR 已在填充一些数据，如果当前请求与 MSHR 命中，可以在 S1 阶段直接选用 MSHR 的数据，而不必依赖 SRAM 读出的结果。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>监控 MissUnit，在 ECC 校验、异常处理和缺失处理之后，将最终的数据、异常信息传递给 IFU，完成取指流程（S2 阶段）</li>
</ol>
<ul>
<li>ECC 校验
<ul>
<li>DataArray ECC 校验，对 S1 流水级寄存的 code 进行校验，生成 data 是否损坏信号 s2_data_corrupt。如果校验出错，就将错误报告给 BEU。</li>
<li>MetaArray ECC 校验，IPrefetchPipe 读出 MetaArray 的数据后会直接进行校验，并将校验结果随命中信息一起入队 WayLookup 并随 MainPipe 流水到达 S2 级（meta_corrupt 信号），在此处随 DataArray 的 ECC 校验结果一起报告给 BEU。</li>
</ul>
</li>
<li>监控 MissUnit 响应端口
<ul>
<li>检查当前 S2 阶段的请求是否与 MSHR 中的条目匹配，命中时寄存 MSHR 响应的数据，为了时序在下一拍才将数据发送到 IFU。</li>
<li>更新 Data 和其是否来自 MSHR 的信息。</li>
<li>更新 s2_hits 和处理异常。</li>
<li>处理 L2 Cache 的 Corrupt 标志。</li>
</ul>
</li>
<li>缺失处理，发送 Miss 请求到 MSHR
<ul>
<li>计算是否需要重新获取（Refetch）。</li>
<li>通过是否命中、ECC 错误、正确跨行、是否异常和是否属于 MMIO 区域来发送 Miss 请求。</li>
<li>设置 Arbiter 合并多个端口的 Miss 请求，确保一次只处理一个请求，同时有避免重复请求的设置。</li>
<li>判断 Fetch 是否完成。</li>
<li>生成 L2 Cache 的异常标记，再将当前 S2 阶段的异常（包括 ITLB、PMP）与 L2 Cache 的异常进行合并。</li>
</ul>
</li>
<li>响应 IFU
<ul>
<li>将最终的数据、异常信息传递给 IFU，完成取指流程。</li>
<li>根据请求是否为跨行，决定如何处理双行数据。</li>
</ul>
</li>
<li>报告 TileLink 的 Corrupt 错误
<ul>
<li>对于每个端口，如果在当前周期 s2_fire 时检测到来自 L2 Cache 的数据 corrupt 错误，就将错误报告给 BEU。</li>
</ul>
</li>
</ul>
<h2 id="mainpipe-的功能点和测试点">MainPipe 的功能点和测试点</h2>
<h3 id="访问-dataarray-的单路">访问 DataArray 的单路</h3>
<p>根据从 WayLookup 获取信息，包括路命中信息和 ITLB 查询结果还有 DataArray 当前的情况，决定是否需要从 DataArray 中读取数据。</p>
<ol>
<li>访问 DataArray 的单路
<ul>
<li>当 WayLookup 中的信息表明路命中时，ITLB 查询成功，并且 DataArray 当前没有写时，MainPipe 会向 DataArray 发送读取请求，以获取数据。</li>
<li>s0_hits 为高（一路命中），s0_itlb_exception 信号为零（ITLB 查询成功），toData.last.ready 为高（DataArray 没有正在进行的写操作）。</li>
<li>toData.valid 信号为高，表示 MainPipe 向 DataArray 发出了读取请求。</li>
</ul>
</li>
<li>不访问 DataArray（Way 未命中） ==会访问，但是返回数据无效==
<ul>
<li>当 WayLookup 中的信息表明路未命中时，MainPipe 不会向 DataArray 发送读取请求。</li>
<li>s0_hits 为低表示缓存未命中</li>
<li>toData.valid 信号为低，表示 MainPipe 未向 DataArray 发出读取请求。</li>
</ul>
</li>
<li>不访问 DataArray（ITLB 查询失败）==会访问，但是返回数据无效==
<ul>
<li>当 ITLB 查询失败时，MainPipe 不会向 DataArray 发送读取请求。</li>
<li>s0_itlb_exception 信号不为零（ITLB 查询失败）。</li>
<li>toData.valid 信号为低，表示 MainPipe 未向 DataArray 发出读取请求。</li>
</ul>
</li>
<li>不访问 DataArray（DataArray 正在进行写操作）
<ul>
<li>当 DataArray 正在进行写操作时，MainPipe 不会向 DataArray 发送读取请求。</li>
<li>toData.last.ready 信号为低，表示 DataArray 正在进行写操作。</li>
<li>toData.valid 信号为低，表示 MainPipe 未向 DataArray 发出读取请求。</li>
</ul>
</li>
</ol>
<h3 id="meta-ecc-校验">Meta ECC 校验</h3>
<p>将物理地址的标签部分与对应的 Meta 进行 ECC 校验，以确保 Meta 的完整性。</p>
<ol>
<li>无 ECC 错误</li>
</ol>
<ul>
<li>当 waymask 全为 0（没有命中），则 hit_num 为 0 或 waymask 有一位为 1（一路命中），hit_num 为 1 且 ECC 对比通过（encodeMetaECC(meta) == code）</li>
<li>s1_meta_corrupt 为假。</li>
</ul>
<ol start="2">
<li>单路命中的 ECC 错误</li>
</ol>
<ul>
<li>当 waymask 有一位为 1（一路命中），ECC 对比失败（encodeMetaECC(meta) != code）</li>
<li>s1_data_corrupt(i)， io.errors(i).valid， io.errors(i).bits.report_to_beu， io.errors(i).bits.source.data 为 true。</li>
</ul>
<ol start="3">
<li>多路命中
<blockquote>
<p>hit multi-way, must be an ECC failure</p></blockquote>
</li>
</ol>
<ul>
<li>当 waymask 有两位及以上为 1（多路命中），视为 ECC 错误。</li>
<li>s1_data_corrupt(i)， io.errors(i).valid， io.errors(i).bits.report_to_beu， io.errors(i).bits.source.data 为 true。</li>
</ul>
<ol start="4">
<li>ECC 功能关闭</li>
</ol>
<ul>
<li>当奇偶校验关闭时（ecc_enable 为低），强制清除 s1_meta_corrupt 信号置位。</li>
<li>不管是否发生 ECC 错误，s1_meta_corrupt 都为假。</li>
</ul>
<h3 id="pmp-检查">PMP 检查</h3>
<ul>
<li>将 S1 的物理地址 s1_req_paddr(i) 和指令 TlbCmd.exec 发往 PMP，判断取指是否合法。</li>
<li>防止非法地址，区分普通内存和 MMIO 内存。</li>
</ul>
<ol>
<li>没有异常
<ul>
<li>s1_pmp_exception 为全零，表示没有 PMP 异常。</li>
</ul>
</li>
<li>通道 0 有 PMP 异常
<ul>
<li>s1_pmp_exception(0) 为真，表示通道 0 有 PMP 异常。</li>
</ul>
</li>
<li>通道 1 有 PMP 异常
<ul>
<li>s1_pmp_exception(1) 为真，表示通道 1 有 PMP 异常。</li>
</ul>
</li>
<li>通道 0 和通道 1 都有 PMP 异常
<ul>
<li>s1_pmp_exception(0) 和 s1_pmp_exception(1) 都为真，表示通道 0 和通道 1 都有 PMP 异常。</li>
</ul>
</li>
<li>没有映射到 MMIO 区域
<ul>
<li>s1_pmp_mmio（0） 和 s1_pmp_mmio（1） 都为假，表示没有映射到 MMIO 区域。</li>
</ul>
</li>
<li>通道 0 映射到了 MMIO 区域
<ul>
<li>s1_pmp_mmio（0） 为真，表示映射到了 MMIO 区域。</li>
</ul>
</li>
<li>通道 1 映射到了 MMIO 区域
<ul>
<li>s1_pmp_mmio（1） 为真，表示映射到了 MMIO 区域。</li>
</ul>
</li>
<li>通道 0 和通道 1 都映射到了 MMIO 区域
<ul>
<li>s1_pmp_mmio（0） 和 s1_pmp_mmio（1） 都为真，表示通道 0 和通道 1 都映射到了 MMIO 区域。</li>
</ul>
</li>
</ol>
<h3 id="异常合并">异常合并</h3>
<ul>
<li>将 s1_itlb_exception 与 s1_pmp_exception 合并生成 s1_exception_out。</li>
<li>ITLB 异常通常优先于 PMP 异常。merge</li>
</ul>
<ol>
<li>没有异常
<ul>
<li>s1_exception_out 为全零，表示没有异常。</li>
</ul>
</li>
<li>只有 ITLB 异常
<ul>
<li>s1_exception_out 和 s1_itlb_exception 一致</li>
</ul>
</li>
<li>只有 PMP 异常
<ul>
<li>s1_exception_out 和 s1_pmp_exception 一致</li>
</ul>
</li>
<li>ITLB 与 PMP 异常同时出现
<blockquote>
<p>itlb has the highest priority, pmp next</p></blockquote>
<ul>
<li>s1_exception_out 和 s1_itlb_exception 一致</li>
</ul>
</li>
</ol>
<h3 id="mshr-匹配和数据选择">MSHR 匹配和数据选择</h3>
<ul>
<li>检查当前的请求是否与 MSHR 中正在处理的缺失请求匹配。</li>
<li>判断 缓存组索引相同(s1_req_vSetIdx(i) == fromMSHR.bits.vSetIdx) ，物理标签相同 (s1_req_ptags(i) == fromMSHR.bits.blkPaddr)；若匹配 MSHR 有效且没有错误（fromMSHR.valid &amp;&amp; !fromMSHR.bits.corrupt），则优先使用 MSHR 中的数据</li>
<li>避免重复访问 Data SRAM，提升性能；当 MSHR 中已有重填结果时，可立即命中。</li>
</ul>
<ol>
<li>命中 MSHR</li>
</ol>
<ul>
<li>MSHR 中已有正确数据时，S1 阶段能直接拿到</li>
<li>s1_MSHR_hits(i) 为 true 时，s1_datas(i) 为 s1_bankMSHRHit(i)，s1_data_is_from_MSHR(i) 为 true</li>
</ul>
<ol start="2">
<li>未命中 MSHR</li>
</ol>
<ul>
<li>MSHR 中存放的地址与当前请求不同，那么应该读取 SRAM 的数据</li>
<li>s1_MSHR_hits(i) 为 true 时，s1_datas(i) 为 fromData.datas(i)，s1_data_is_from_MSHR(i) 为 false</li>
</ul>
<ol start="3">
<li>MSHR 数据 corrupt</li>
</ol>
<ul>
<li>fromMSHR.bits.corrupt = true，那么 MSHR 将不匹配，应该读取 SRAM 的数据</li>
<li>s1_datas(i) 为 fromData.datas(i)，s1_data_is_from_MSHR(i) 为 false</li>
</ul>
<h3 id="data-ecc-校验">Data ECC 校验</h3>
<p>在 S2 阶段，对从 S1 或 MSHR 获得的数据（如 s2_datas）进行 ECC 校验：</p>
<ul>
<li>若 ECC 校验失败，则标记 s2_data_corrupt(i) = true。</li>
<li>若数据来自 MSHR，则不重复进行 ECC 校验（或忽略 corrupt）</li>
</ul>
<ol>
<li>无 ECC 错误</li>
</ol>
<ul>
<li>s2_bank 全部没有损坏，bank 也选对了对应的端口和 bank，数据不来自 MSHR</li>
<li>s2_data_corrupt(i) 为 false，没有 ECC 错误。</li>
</ul>
<ol start="2">
<li>单 Bank ECC 错误</li>
</ol>
<ul>
<li>s2_bank_corrupt(bank) 有一个为 true ,即对应的 bank 有损坏；同时 bank 也选对了对应的端口和 bank，数据不来自 MSHR</li>
<li>s2_data_corrupt(i)， io.errors(i).valid， io.errors(i).bits.report_to_beu， io.errors(i).bits.source.data 为 true。</li>
</ul>
<ol start="3">
<li>多 Bank ECC 错误</li>
</ol>
<ul>
<li>s2_bank_corrupt(bank) 有两个或以上为 true,即对应的 bank 有损坏；同时 bank 也选对了对应的端口和 bank，数据不来自 MSHR</li>
<li>s2_data_corrupt(i)， io.errors(i).valid， io.errors(i).bits.report_to_beu， io.errors(i).bits.source.data 为 true。</li>
</ul>
<ol start="4">
<li>ECC 功能关闭</li>
</ol>
<ul>
<li>当奇偶校验关闭时（ecc_enable 为低），强制清除 s2_data_corrupt 信号置位。</li>
<li>不管是否发生 ECC 错误，s2_data_corrupt 都为假。</li>
</ul>
<h3 id="冲刷-metaarray">冲刷 MetaArray</h3>
<p>Meta 或者 Data ECC 校验错误时，会冲刷 MetaArray，为重取做准备。</p>
<ol>
<li>只有 Meta ECC 校验错误
<blockquote>
<p>if is meta corrupt, clear all way (since waymask may be unreliable)</p></blockquote>
</li>
</ol>
<ul>
<li>当 s1_meta_corrupt 为真时，MetaArray 的所有路都会被冲刷。</li>
<li>toMetaFlush(i).valid 为真，toMetaFlush(i).bits.waymask 对应端口的所有路置位。</li>
</ul>
<ol start="2">
<li>只有 Data ECC 校验错误
<blockquote>
<p>if is data corrupt, only clear the way that has error</p></blockquote>
</li>
</ol>
<ul>
<li>当 s2_data_corrupt 为真时，只有对应路会被冲刷。</li>
<li>toMetaFlush(i).valid 为真，toMetaFlush(i).bits.waymask 对应端口的对应路置位。</li>
</ul>
<ol start="3">
<li>同时有 Meta ECC 校验错误和 Data ECC 校验错误</li>
</ol>
<ul>
<li>处理 Meta ECC 的优先级更高， 将 MetaArray 的所有路冲刷。</li>
<li>toMetaFlush(i).valid 为真，toMetaFlush(i).bits.waymask 对应端口的所有路置位。</li>
</ul>
<h3 id="监控-mshr-匹配与数据更新">监控 MSHR 匹配与数据更新</h3>
<ul>
<li>判断是否命中 MSHR</li>
<li>根据 MSHR 是否命中和 s1 阶段是否发射来更新 s2 的数据，s2 的命中状态和 l2 是否损坏</li>
</ul>
<ol>
<li>MSHR 命中（匹配且本阶段有效）</li>
</ol>
<ul>
<li>MSHR 的 vSetIdx / blkPaddr 与 S2 请求一致， fromMSHR.valid 有效，s2_valid 也有效</li>
<li>s2_MSHR_match，s2_MSHR_hits 为高，s2_bankMSHRHit 对应 bank 为高</li>
<li>s1_fire 无效时，s2_datas 更新为 MSHR 的数据，将 s2_data_is_from_MSHR 对应位置位，s2_hits 置位，清除 s2_data_corrupt，l2 的 corrupt 更新为 fromMSHR.bits.corrupt</li>
<li>s1_fire 有效时，s2_datas 为 s1_datas 的数据，将 s2_data_is_from_MSHR 对应位置为 s1 的 s1_data_is_from_MSHR，s2_hits 置为 s1_hits，清除 s2_data_corrupt，l2 的 corrupt 为 false</li>
</ul>
<ol start="2">
<li>MSHR 未命中</li>
</ol>
<ul>
<li>MSHR 的 vSetIdx / blkPaddr 与 S2 请求一致， fromMSHR.valid 有效，s2_valid 也有效，至少有一个未达成</li>
<li>s2_MSHR_hits(i) = false，S2 不会更新 s2_datas，继续保持原先 SRAM 数据或进入 Miss 流程。</li>
</ul>
<h3 id="miss-请求发送逻辑和合并异常">Miss 请求发送逻辑和合并异常</h3>
<ul>
<li>通过计算 s2_should_fetch(i) 判断是否需要向 MSHR 发送 Miss 请求：
<ul>
<li>当出现未命中 (!s2_hits(i)) 或 ECC 错误(s2_meta_corrupt(i) || s2_data_corrupt(i)) 时，需要请求重新获取。</li>
<li>若端口存在异常或处于 MMIO 区域，则不发送 Miss 请求。</li>
</ul>
</li>
<li>使用 Arbiter 将多个端口的请求合并后发送至 MSHR。</li>
<li>通过 s2_has_send(i) 避免重复请求。</li>
<li>将 S2 阶段已有的 ITLB/PMP 异常（s2_exception）与 L2 Cache 报告的 s2_l2_corrupt(i)（封装后为 s2_l2_exception(i)）进行合并。</li>
</ul>
<ol>
<li>未发生 Miss</li>
</ol>
<ul>
<li>当 s2_hits(i) 为高（s2 已经命中），s2 的 meta 和 data 都没有错误，s2 异常，处于 mmio 区域</li>
<li>以上条件至少满足一个时，s2_should_fetch(i) 为低，表示不发送 Miss 请求。</li>
</ul>
<ol start="2">
<li>单口 Miss</li>
</ol>
<ul>
<li>当出现未命中 (!s2_hits(i)) 或 ECC 错误(s2_meta_corrupt(i) || s2_data_corrupt(i))，端口不存在异常且未处于 MMIO 区域时，会向 MSHR 发送 Miss 请求。</li>
<li>toMSHRArbiter.io.in(i).valid = true ，Arbiter 只发送一条 Miss 请求。</li>
</ul>
<ol start="3">
<li>双口都需要 Miss</li>
</ol>
<ul>
<li>同上，但是两个端口都满足 s2_should_fetch 为高的条件。</li>
<li>toMSHRArbiter.io.in(0).valid、toMSHRArbiter.io.in(1).valid 均为 true，Arbiter 根据仲裁顺序依次发出请求。</li>
</ul>
<ol start="4">
<li>重复请求屏蔽</li>
</ol>
<ul>
<li>当 s1_fire 为高，表示可以进入 s2 阶段,那么 s2 还没有发送 s2_has_send(i) := false.B</li>
<li>如果已经有请求发送了，那么对应的 toMSHRArbiter.io.in(i).fire 为高，表示对应的请求可以发送，s2_has_send(i) := true。</li>
<li>此时再次发送，toMSHRArbiter.io.in(i).valid 为低，表示发送失败。</li>
</ul>
<ol start="5">
<li>仅 ITLB/PMP 异常</li>
</ol>
<ul>
<li>S1 阶段已记录了 ITLB 或 PMP 异常，L2 corrupt = false。</li>
<li>2_exception_out 仅保留 ITLB/PMP 异常标记，无新增 AF 异常。</li>
</ul>
<ol start="6">
<li>仅 L2 异常</li>
</ol>
<ul>
<li>S2 阶段 s2_l2_corrupt(i) = true，且无 ITLB/PMP 异常。</li>
<li>s2_exception_out(i) 表示 L2 访问错误(AF)。</li>
</ul>
<ol start="7">
<li>ITLB + L2 同时出现</li>
</ol>
<ul>
<li>同时触发 ITLB 异常和 L2 corrupt。</li>
<li>s2_exception_out 优先保留 ITLB 异常类型，不被 L2 覆盖。</li>
</ul>
<ol start="8">
<li>s2 阶段取指完成</li>
</ol>
<ul>
<li>s2_should_fetch 的所有端口都为低，表示需要取指，那么取指完成</li>
<li>s2_fetch_finish 为高</li>
</ul>
<h3 id="响应-ifu">响应 IFU</h3>
<ul>
<li>若当前周期 S2 成功发射（s2_fire = true）且数据获取完毕（s2_fetch_finish），则把数据、异常信息、物理地址等打包到 toIFU.bits 输出。</li>
<li>若为双行请求（s2_doubleline = true），也会向 IFU 发送第二路的信息（地址、异常）。</li>
</ul>
<ol>
<li>正常命中并返回</li>
</ol>
<ul>
<li>不存在任何异常或 Miss，s2 命中，s2 阶段取指完成，外部的 respStall 停止信号也为低 。</li>
<li>toIFU.valid = true，toIFU.bits.data 为正确的 Cacheline 数据，toIFU.bits.exception、pmp_mmio、itlb_pbmt = none。</li>
</ul>
<ol start="2">
<li>异常返回</li>
</ol>
<ul>
<li>设置 ITLB、PMP、或 L2 corrupt 异常。</li>
<li>toIFU.bits.exception(i) = 对应异常类型，pmp_mmio、itlb_pbmt 根据是否有对应的异常设置为 true。</li>
</ul>
<ol start="3">
<li>跨行取指</li>
</ol>
<ul>
<li>s2_doubleline = true，同时检查第一路、第二路返回情况。</li>
<li>toIFU.bits.doubleline = true。</li>
<li>若第二路正常，toIFU.bits.exception(1) = none；若第二路异常，则 exception(1) 标记相应类型。</li>
<li>pmp_mmio、itlb_pbmt 类似。</li>
</ul>
<ol start="4">
<li>RespStall</li>
</ol>
<ul>
<li>外部 io.respStall = true，导致 S2 阶段无法发射到 IFU。</li>
<li>s2_fire = false，toIFU.valid 也不拉高，S2 保持原状态等待下一拍（或直到 respStall 解除）。</li>
</ul>
<h3 id="l2-corrupt-报告">L2 Corrupt 报告</h3>
<ul>
<li>当检测到 L2 Cache 返回的 corrupt 标记时（s2_l2_corrupt(i) = true），在 S2 完成发射后额外向外部错误接口 io.errors(i) 报告。</li>
<li>与 Data ECC 或 Meta ECC 不同，L2 corrupt 由 L2 自己报告给 BEU，这里不需要再次报告给 beu。</li>
</ul>
<ol>
<li>L2 Corrupt 单路</li>
</ol>
<ul>
<li>s2 阶段准备完成可以发射（s2_fire 为高），s2_MSHR_hits(0)和 fromMSHR.bits.corrupt 为高</li>
<li>s2_l2_corrupt(0) = true，io.errors(0).valid = true，io.errors(0).bits.source.l2 = true。</li>
</ul>
<ol start="2">
<li>双路同时 corrupt</li>
</ol>
<ul>
<li>端口 0 和端口 1 都从 L2 corrupt 数据中获取。</li>
<li>s2_l2_corrupt 均为 true，发射后分别报告到 io.errors(0) 和 io.errors(1)。</li>
</ul>
<h3 id="刷新机制">刷新机制</h3>
<ul>
<li>io.flush：外部的全局刷新信号，它用于指示整个流水线需要被冲刷（清空）。</li>
<li>s0_flush： S0 阶段内部的刷新信号，它由 io.flush 传递而来，用于控制 S0 阶段的刷新操作。</li>
<li>s1_flush： S1 阶段内部的刷新信号，它由 io.flush 传递而来，用于控制 S1 阶段的刷新操作。</li>
<li>s2_flush： S2 阶段内部的刷新信号，它由 io.flush 传递而来，用于控制 S2 阶段的刷新操作。</li>
</ul>
<ol>
<li>全局刷新</li>
</ol>
<ul>
<li>io.flush 被激活时，流水线的各个阶段（S0, S1 和 S2）都能正确响应并执行刷新操作。</li>
<li>io.flush = true。</li>
<li>s0_flush, s1_flush, s2_flush = true。</li>
</ul>
<ol start="2">
<li>S0 阶段刷新</li>
</ol>
<ul>
<li>s0_flush = true。</li>
<li>s0_fire = false。</li>
</ul>
<ol start="3">
<li>S1 阶段刷新</li>
</ol>
<ul>
<li>s1_flush = true。</li>
<li>s1_valid， s1_fire = false。</li>
</ul>
<ol start="4">
<li>S2 阶段刷新</li>
</ol>
<ul>
<li>s2_flush = true。</li>
<li>s2_valid， toMSHRArbiter.io.in(i).valid ， s2_fire = false</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-10e6e7e44838197595b01ddda75ad636">12.2.2.5 - MissUnit</h1>
    
	<div class="icache-ctx">
</div>
<h2 id="子模块fifo">子模块：FIFO</h2>
<ul>
<li>一个先入先出的循环队列，目前仅在 MissUnit 中有使用，作为优先队列 priorityFIFO。</li>
<li>按照在 MissUnit 中的实例化，pipe 是默认值 false，hasflush 是 true。</li>
<li>队列的指针都是环形的，分为入队指针（写指针，ent_ptr）和出队指针（读指针，deq_ptr），记录读和写的位置。</li>
<li>两个指针都有对应的 flag 位，当指针超过队列大小时，flag 位会翻转，用以判断是否已经循环。</li>
<li>在入队、出队对应的 fire（valid &amp;&amp; ready） 信号有效时，移动对应的指针。</li>
</ul>
<h2 id="fifo-的功能点和测试点">FIFO 的功能点和测试点</h2>
<h3 id="入队操作">入队操作</h3>
<ol>
<li>队未满，正常入队</li>
</ol>
<ul>
<li>当队列未满，且空位不小于一时，可以正常入队，如果从零号位开始入队到最大容量，入队指针的 flag 不会翻转。</li>
<li>io.enq.fire 为高有效，regFiles(enq_ptr.value) = io.enq.bits，enq_ptr.value+1 入队指针移动，入队指针标记位不翻转。</li>
<li>重复以上操作至队满。</li>
</ul>
<ol start="2">
<li>队未满，入队后标记位翻转</li>
</ol>
<ul>
<li>当队未满，但是空位却是靠近队尾时，入队一位后就到达了队头，入队指针的 flag 会翻转。</li>
<li>队列的容量为 10，入队指针指向 9，队未满。此时如果 io.enq.fire 为高，则 regFiles(9) = io.enq.bits，enq_ptr.value+1（循环队列，加完后 enq_ptr.value=0）入队指针移动，入队指针标记位翻转。</li>
</ul>
<ol start="3">
<li>队满，入队就绪信号为低，无法入队</li>
</ol>
<ul>
<li>当队满时，(enq_ptr.value === deq_ptr.value) &amp;&amp; (enq_ptr.flag ^ deq_ptr.flag) 为高，io.enq.ready 为低，io.enq.fire 为低无效。</li>
<li>此时入队，入队指针的 value 和 flag 不变。</li>
</ul>
<h3 id="出队操作">出队操作</h3>
<ol>
<li>队非空，正常出队</li>
</ol>
<ul>
<li>当队列非空时，可以正常出队，如果出队指针不经过最大容量位置，出队指针的 flag 不会翻转。</li>
<li>io.deq.fire 为高有效，io.deq.bits = regFiles(deq_ptr.value)，deq_ptr.value+1 出队指针移动，出队指针标记位不翻转。</li>
</ul>
<ol start="2">
<li>队非空，出队后标记位翻转</li>
</ol>
<ul>
<li>当队非空，但是出队指针是靠近队尾时，出队一位后就到达了队头，出队指针的 flag 会翻转。</li>
<li>队列的容量为 10，出队指针指向 9，队非空。此时如果 io.deq.fire 为高，则 io.deq.bits = regFiles(9)，deq_ptr.value+1（循环队列，加完后 deq_ptr.value=0）出队指针移动，出队指针标记位翻转。</li>
</ul>
<ol start="3">
<li>队空，出队有效信号为低，无法出队</li>
</ol>
<ul>
<li>当队空时，enq_ptr === deq_ptr 为高，io.deq.valid 为低，io.deq.fire 为低无效。</li>
<li>此时出队，出队指针的 value 和 flag 不变。</li>
</ul>
<h3 id="刷新清空操作">刷新清空操作</h3>
<ol>
<li>flush 清空</li>
</ol>
<ul>
<li>当刷新信号有效时，重置出队和入队的指针和标记位，清空队列。</li>
<li>当 flush 为高时，deq_ptr.value=0，enq_ptr.value=0，deq_ptr.flag=false，enq_ptr.flag=false，empty=true,full=false。</li>
</ul>
<h2 id="missunit">MissUnit</h2>
<div>			
    <center>	
    <img src="../missunit_structure.png"
         alt="MissUnit 结构"
         style="zoom:100%"/>
    <br>		
    MissUnit 结构	
    </center>
</div>
<br>
<ul>
<li>接收并管理多个 Miss 请求
<ul>
<li>处理来自 Fetch 和 Prefetch 的 Miss 请求。</li>
<li>将这些请求分派给适当数量的 MSHR 进行排队和状态管理。</li>
</ul>
</li>
<li>管理 MSHR
<ul>
<li>ICacheMissUnit 使用多个 MSHR 来跟踪和管理未完成的缓存未命中请求。为了防止 flush 时取指 MSHR 不能完全释放，设置取指 MSHR 的数量为 4，预取 MSHR 的数量为 10。采用数据和地址分离的设计方法，所有的 MSHR 共用一组数据寄存器，在 MSHR 只存储请求的地址信息、状态等信息。</li>
<li>接收来自 MainPipe 的取指请求和来自 IPrfetchPipe 的预取请求，取指请求只能被分配到 fetchMSHR，预取请求只能分配到 prefetchMSHR，入队时采用低 index 优先的分配方式。</li>
<li>在入队的同时对 MSHR 进行查询，如果请求已经在 MSHR 中存在，就丢弃该请求，对外接口仍表现 fire，只是不入队到 MSHR 中。==在入队时向 Replacer 请求写入 waymask==。当请求完成后，MSHR 会被释放，以便处理新的请求。</li>
</ul>
</li>
<li>通过 TileLink 协议与 L2 缓存进行通信，发送获取缓存块的请求（mem_acquire），并接收 L2 缓存的响应（mem_grant）。
<ul>
<li>当到 L2 的总线空闲时，选择 MSHR 表现进行处理，整体 fetchMSHR 的优先级高于 prefetchMSHR，只有没有需要处理的 fetchMSHR，才会处理 prefetchMSHR。</li>
<li>对于 fetchMSHR，采用低 index 优先的优先级策略，因为同时最多只有两个请求需要处理，并且只有当两个请求都处理完成时才能向下走，所有 fetchMSHR 之间的优先级并不重要。</li>
<li>对于 prefetchMSHR，考虑到预取请求之间具有时间顺序，采用先到先得的优先级策略，在入队时通过一个 FIFO 记录入队顺序，处理时按照入队顺序进行处理。</li>
<li>通过状态机与 Tilelink 的 D 通道进行交互，到 L2 的带宽为 32byte，需要分 2 次传输，并且不同的请求不会发生交织，所以只需要一组寄存器来存储数据。</li>
<li>当一次传输完成时，根据传输的 id 选出对应的 MSHR，从 MSHR 中读取地址、掩码等信息，将相关信息写入 SRAM，同时将 MSHR 释放。</li>
</ul>
</li>
<li>向 MetaArray 和 DataArray 发送写请求，向 MainPipe 发送响应
<ul>
<li>当数据传回后，MissUnit 根据相应的替换策略信息（victim way），将新数据写回 ICache 的 SRAM(Meta/Data) 。</li>
<li>同时向取指端（或预取端）返回“Miss 已完成”的响应，包括：写入了哪一路（way）、实际数据以及可能的校验信息（如 corrupt 标记等）。</li>
</ul>
</li>
<li>处理特殊情况（如 flush、fencei、数据损坏等）
<ul>
<li>遇到 Flush 或 fence.i 等指令时，MissUnit 可以终止或跳过某些 Miss 请求的写回，从而保证不在无效或过期的情况下写入缓存。</li>
<li>数据若出现 corrupt（部分拍损坏），也会在写回或发给前端时进行特殊处理或标记。</li>
</ul>
</li>
</ul>
<p>过程：</p>
<ol>
<li>fetch_req 和 prefetch_req 分别先经过 DeMultiplexer (Demux)，把请求分发给对应数量的 MSHR。fetch 的 MSHR 和 prefetch 的 MSHR 分成两组，分别处理取指和预取请求。</li>
<li>每个 MSHR 内部会记录当前 Miss 请求的地址、索引、是否已经发出 acquire 等状态。当有其它相同的 miss 请求进来时，可以直接 “ hit MSHR ” 而不用重复创建新的请求。</li>
<li>对于 fetchMSHR，采用低 index 优先的优先级策略；对于 prefetchMSHR，采用先到先得的优先级策略，在入队 prefetchMSHR 前通过一个 priorityFIFO.记录入队顺序，处理时按照入队顺序进行处理。</li>
<li>fetchMSHR 发出的请求与 prefetchArb 选出的 prefetchMSHR 通过 acquireArb 合并后，通过 mem_acquire 发送给下一级或外部存储。</li>
<li>mem_grant 表示对这一条 Miss 请求的返回数据。需要分多个 beat 收集，直到收满一个 Cacheline。</li>
<li>收集完 Cacheline 数据后，会根据对应 MSHR 的信息向 metaArray 和 dataArray 发起写操作 (meta_write, data_write)，同时向取指端 (fetch_resp) 发送补全后的数据和标记 (waymask 等)。</li>
<li>如果发生 flush 或 fencei，在未发出请求前，请求会被无效化；请求被发出后，会持续阻止新请求进入，已经发出的访问最终会将返回过程走完，但收到的响应并不会回复给 MainPipe 和 IPrefetchPipe，也不会写给 MetaArray 和 DataArray。</li>
</ol>
<p>Demultiplexer 类
grant:选择第一个 ready（能写）的 mshr，写进去（第 0 到 n 个端口，前面有 ready 的。比如 grant=seq(false,true),grant(1)为 true，表示 1 端口前面有一个 ready 的端口（0 端口））
io.out(i).valid:前 i-1 个 mshr 没有 ready 的,输入的写有效。
io.in.ready := grant.last || io.out.last.ready，给 MissUnit 的 ready 信号有一个有效，那么 MissUnit 给 MSHR 的 ready 信号就有效。</p>
<h2 id="missunit-的功能点和测试点">MissUnit 的功能点和测试点</h2>
<h3 id="处理取指缺失请求">处理取指缺失请求</h3>
<p>处理来自 MainPipe 的取指单元的缓存缺失请求，将缺失请求分发到多个 Fetch MSHR 中的一个，避免重复请求。
低索引的请求优先处理。</p>
<ol>
<li>
<p>接受新的取指请求</p>
<ul>
<li>当新的 fetch miss 与 MSHR 中的已有请求不重复时（通过 io.fetch_req.bits.blkPaddr / vSetIdx 给出具体地址），MissUnit 会将请求分配到一个空闲的 Fetch MSHR 中。</li>
<li>当有新的取指缺失请求到达时（io.fetch_req.valid 为高），且没有命中已有的 MSHR（fetchHit 为低），io.fetch_req.ready 应为高，表示可以接受请求。</li>
<li>io.fetch_req.fire 成功握手后，该 MSHR 处于 valid = true 状态，并记录地址。</li>
</ul>
</li>
<li>
<p>处理已有的取指请求</p>
<ul>
<li>当已有取指缺失请求到达时（io.fetch_req.valid 为高），且命中已有的 MSHR（fetchHit 为高），io.fetch_req.ready 应为高，虽然不接受请求，但是表现出来为已经接收请求。</li>
<li>fetchDemux.io.in.valid 应为低，fetchDemux.io.in.fire 为低，表示没有新的请求被分发到 MSHR。</li>
</ul>
</li>
<li>
<p>低索引的请求优先进入 MSHR</p>
<ul>
<li>Fetch 的请求会通过 fetchDemux 分配到多个 Fetch MSHR，fetchDemux 的实现中，低索引的 MSHR 会优先被分配请求。</li>
<li>当取指请求有多个 io.out(i).read 时，选择其中的第一个，也就是低索引的写入 MSHR，io.chose 为对应的索引。</li>
</ul>
</li>
</ol>
<h3 id="处理预取缺失请求">处理预取缺失请求</h3>
<p>与 Fetch Miss 类似，但走另一些 MSHR（Prefetch MSHR）。</p>
<ol>
<li>
<p>接受新的预取请求</p>
<ul>
<li>当新的 prefetch miss 与 MSHR 中的已有请求不重复时（通过 io.prefetch_req.bits.blkPaddr / vSetIdx 给出具体地址），MissUnit 会将请求分配到一个空闲的 Prefetch MSHR 中。</li>
<li>当有新的预取缺失请求到达时（io.prefetch_req.valid 为高），且没有命中已有的 MSHR（prefetchHit 为低），io.prefetch_req.ready 应为高，表示可以接受请求。</li>
<li>io.prefetch_req.fire 成功握手后，该 MSHR 处于 valid = true 状态，并记录地址。</li>
</ul>
</li>
<li>
<p>处理已有的预取请求</p>
<ul>
<li>当已有预取缺失请求到达时（io.prefetch_req.valid 为高），且命中已有的 MSHR（prefetchHit 为高），io.prefetch_req.ready 应为高，虽然不接受请求，但是表现出来为已经接收请求。</li>
<li>prefetchDemux.io.in.valid 应为低，prefetchDemux.io.in.fire 为低，表示请求被接受但未分发到新的 MSHR。</li>
</ul>
</li>
<li>
<p>低索引的请求优先进入 MSHR</p>
<ul>
<li>Prefetch 的请求会通过 prefetchDemux 分配到多个 Prefetch MSHR，prefetchDemux 的实现中，低索引的 MSHR 会优先被分配请求。</li>
<li>当取指请求有多个 io.out(i).read 时，选择其中的第一个，也就是低索引的写入 MSHR，io.chose 为对应的索引。</li>
</ul>
</li>
<li>
<p>先进入 MSHR 的优先进入 prefetchArb</p>
<ul>
<li>从 prefetchDemux 离开后，请求的编号会进入 priorityFIFO，priorityFIFO 会根据进入队列的顺序排序，先进入队列的请求会先进入 prefetchArb。</li>
<li>prefetchDemux.io.in.fire 为高，并且 prefetchDemux.io.chosen 有数据时，将其编号写入 priorityFIFO。</li>
<li>在 priorityFIFO 中有多个编号时，出队的顺序和入队顺序一致。</li>
<li>检查 priorityFIFO.io.deq.bit 中的数据即可。</li>
</ul>
</li>
</ol>
<h3 id="mshr-管理与查找">MSHR 管理与查找</h3>
<ol>
<li>
<p>MSHR 查找命中逻辑</p>
<ul>
<li>当新的请求到来时，能够正确查找所有 MSHR，判断请求是否命中已有 MSHR。</li>
<li>当新的请求（取指或预取）到来时，系统遍历所有 MSHR，根据所有 MSHR 的查找信号 allMSHRs(i).io.lookUps(j).hit，检查请求是否已经存在于某个 MSHR 中。</li>
<li>如果命中，则对应的 fetchHit 或 prefetchHit 为高。</li>
<li>对于 prefetchHit 为高，还有一种情况：预取的物理块地址和组索引与取指的相等（(io.prefetch_req.bits.blkPaddr === io.fetch_req.bits.blkPaddr) &amp;&amp; (io.prefetch_req.bits.vSetIdx === io.fetch_req.bits.vSetIdx)）并且有取指请求 io.fetch_req.valid 有效时，也算命中</li>
</ul>
</li>
<li>
<p>MSHR 状态的更新与释放</p>
<ul>
<li>当请求完成后，也就是来自内存总线的响应完成（D 通道接收完所有节拍），MSHR 能够正确地释放（清除其有效位），以便接收新的请求。</li>
<li>TileLink D 通道返回的 source ID ，即 io.mem_grant.bits.source。</li>
<li>无效化信号 allMSHRs(i).io.invalid 为高，对应的 MSHR 的有效位 allMSHRs(i).valid 变为低</li>
</ul>
</li>
</ol>
<h3 id="acquirearb-仲裁">acquireArb 仲裁</h3>
<p>预取和取指的 acquire 都会发送给 acquireArb，acquireArb 会选择一个 acquire 发送给 mem_acquire。
acquireArb 使用 chisel 自带的 Arbiter 实现,Arbiter 使用固定优先级仲裁，优先级从编号 0 开始，编号越小优先级越高。</p>
<ol>
<li>acquireArb 仲裁
<ul>
<li>acquireArb 会选择一个 acquire 发送给 mem_acquire。</li>
<li>当有多个 MSHR 同时发出请求时，acquireArb 会根据优先级进行仲裁，选择优先级最高的 MSHR 发送请求。</li>
<li>取指请求总是在 0-3 号，预取请求直接在最后一号，所以取指请求优先级高于预取请求。</li>
<li>当取指 acquire 和预取 acquire 同时发出时，fetchMSHRs(i).io.acquire 和 prefetchMSHRs(i).io.acquire 都有效，仲裁结果 acquireArb.io.out 应该和 fetchMSHRs(i).io.acquire 一致。</li>
</ul>
</li>
</ol>
<h3 id="grant-数据接收与-refill">Grant 数据接收与 Refill</h3>
<p>在收到 TileLink D 通道数据时收集整行</p>
<ul>
<li>累计 beat 数（readBeatCnt），直到完成一整行 (last_fire)</li>
<li>记录 corrupt 标志</li>
<li>将完成的请求映射回对应的 MSHR (id_r = mem_grant.bits.source)</li>
</ul>
<ol>
<li>正常完整 Grant 流程，readBeatCnt 为 0 时
<ul>
<li>readBeatCnt 初始为 0，refillCycles - 1 也为 0。</li>
<li>io.mem_grant.valid 为高（因为 io.mem_grant.ready 默认为高，所以 io.mem_grant.fire 为高只需要 io.mem_grant.valid 为高）且 io.mem_grant.bits.opcpde(0)为高。</li>
<li>此时 respDataReg(0)= io.mem_grant.bits.data</li>
<li>readBeatCnt 加一为 1。</li>
</ul>
</li>
<li>正常完整 Grant 流程，readBeatCnt 为 1 时
<ul>
<li>io.mem_grant.valid 为高且 io.mem_grant.bits.opcpde(0)为高。</li>
<li>此时 respDataReg(1)= io.mem_grant.bits.data</li>
<li>readBeatCnt 重置回 0。</li>
<li>last_fire 为高。</li>
<li>下一拍 last_fire_r 为高，id_r=io.mem_grant.bits.source。</li>
</ul>
</li>
<li>正常完整 Grant 流程，last_fire_r 为高
<ul>
<li>last_fire_r 为高，并且 id_r 为 0-13 中的一个。</li>
<li>对应的 fetchMSHRs 或者 prefetchMSHRs 会被无效，也就是 fetchMSHRs_i 或 prefetchMSHRs_i-4 的 io_invalid 会被置高。</li>
</ul>
</li>
<li>Grant 带有 corrupt 标志
<ul>
<li>io.mem_grant.valid 为高且 io.mem_grant.bits.opcpde(0)为高，io.mem_grant.bits.corrupt 为高，则 corrupt_r 应为高。</li>
<li>如果 io.mem_grant.valid 为高且 io.mem_grant.bits.opcpde(0)为高，io.mem_grant.bits.corrupt 为高中有一个不满足，且此时 last_fire_r 为高，则 corrupt_r 重置为低。</li>
</ul>
</li>
</ol>
<h3 id="替换策略更新-replacer">替换策略更新 (Replacer)</h3>
<p>MissUnit 在发出 Acquire 请求时，还会将本次选中的 victim way 对应的索引告诉 io.victim，让替换策略更新其记录（替换策略采用 PLRU）
只有当 Acquire 真正“fire”时，才说明成功替换，replacer 需要更新状态</p>
<ol>
<li>正常替换更新
<ul>
<li>当 io.mem.acquire.ready &amp; acquireArb.io.out.valid 同时为高，也就是 acquireArb.io.out.fir 为高时，io.victim.vSetIdx.valid 也为高。</li>
<li>io.victim.vSetIdx.bits = 当前 MSHR 请求的 acquireArb.io.out.bits.vSetIdx。</li>
</ul>
</li>
<li>生成 waymask
<ul>
<li>根据从 L2 返回的 mshr_resp 中 mshr_resp.bits.way 生成 waymask 信息。</li>
<li>返回的 mshr_resp.bits.way 有 16 位，通过独热码生成一位掩码信息，waymask 表示其中哪一路被替换。</li>
<li>生成的 waymask 应该和 mshr_resp.bits.way 一致。</li>
</ul>
</li>
</ol>
<h3 id="写回-sram-meta--data">写回 SRAM (Meta / Data)</h3>
<p>在一条 Miss Request refill 完成时，将新得到的 Cache line 写到 ICache。
生成 io.meta_write 和 io.data_write 的请求，带上 waymask, tag, idx, data 。
生成 io.meta_write.valid 和 io.data_write.valid 信号。</p>
<ol>
<li>生成 io.meta_write.valid 和 io.data_write.valid 信号
<ul>
<li>当 grant 传输完成后，经过一拍后，即 last_fire_r 为高，且从 TileLink 返回的 mshr_resp 中的 mshr_resp.valid 为高。</li>
<li>并且此时没有硬件刷新信号和软件刷新信号，也就是 io.flush 和 io.fencei 为低。 在等待 l2 响应的过程中，没有刷新信号</li>
<li>也没有数据 corrupt，即 corrupt_r 为低。</li>
<li>那么 io.meta_write.valid 和 io.data_write.valid 均为高。</li>
</ul>
</li>
<li>正常写 SRAM
<ul>
<li>io.meta_write.bits 的 virIdx、phyTag、waymask、bankIdx、poison 应该正常更新</li>
<li>io.data_write.bits 的 virIdx、data、waymask、bankIdx、poison 应该正常更新</li>
</ul>
</li>
</ol>
<h3 id="向-mainpipeprefetchpipe-发出-miss-完成响应fetch_resp">向 mainPipe/prefetchPipe 发出 Miss 完成响应（fetch_resp）</h3>
<p>在完成 refill 后，无论是否要真正写阵列，都会向取指端发送“Miss 请求完成”
更新 io.fetch_resp.valid 和 fetch_resp.bits。</p>
<ol>
<li>正常 Miss 完成响应
<ul>
<li>当 grant 传输完成后，经过一拍后，即 last_fire_r 为高，且从 TileLink 返回的 mshr_resp 中的 mshr_resp.valid 为高。</li>
<li>无论此时是否有硬件刷新信号和软件刷新信号， io.fetch_resp.valid 都为高，说明可向取指端发送响应。</li>
<li>io.fetch_resp.bits 中的数据更新：
<ul>
<li>io.fetch_resp.bits.blkPaddr = mshr_resp.bits.blkPaddr</li>
<li>io.fetch_resp.bits.vSetIdx = mshr_resp.bits.vSetIdx</li>
<li>io.fetch_resp.bits.waymask = waymask</li>
<li>io.fetch_resp.bits.data = respDataReg.asUInt</li>
<li>io.fetch_resp.bits.corrupt = corrupt_r</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="处理-flush--fencei">处理 flush / fencei</h3>
<p>一旦收到 io.flush 或 io.fencei 时，对未发射的请求可立即取消，对已经发射的请求在拿到数据后也不写 SRAM。</p>
<ol>
<li>MSHR 未发射前 fencei
<ul>
<li>如果 MSHR 还没有通过 io.acquire.fire 发出请求，就应立即取消该 MSHR（mshr_resp.valid= false），既不发出请求，也不要写 SRAM。</li>
<li>当 io.fencei 为高时，fetchMSHRs 和 prefetchMSHRs 的 io.req.ready 和 io.acquire.valid 均为低，表示请求不发射。</li>
</ul>
</li>
<li>MSHR 未发射前 flush
<ul>
<li>由于 fetchMSHRs 的 io.flush 被直接设置为 false，所以 io.flush 对 fetchMSHRs 无效，但是对 prefetchMSHRs 有效。</li>
<li>当 io.flush 为高时，只能发射 fetchMSHRs 的请求。</li>
</ul>
</li>
<li>MSHR 已发射后 flush/fencei
<ul>
<li>已经发射了请求，之后再有刷新信号，那么等数据回来了但不写 SRAM。</li>
<li>在发射后，io.flush/io.fencei 为高时，等待数据回来，但是写 SRAM 的信号，write_sram_valid、io.meta_write.valid 和 io.data_write.valid 均为低，表示不写 SRAM。</li>
<li>对于 response fetch 无影响。</li>
</ul>
</li>
</ol>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8feff2ec4ca745f27b9938a74f513167">12.2.2.6 - WayLookup</h1>
    
	<div class="icache-ctx">
</div>
<h2 id="waylookup">WayLookup</h2>
<div>			
    <center>	
    <img src="../waylookup_structure_rw.png"
         alt="WayLookup 读写结构"
         style="zoom:40%"/>
    <br>		
    WayLookup 读写结构	
    </center>
</div>
<br>
<div>			
    <center>	
    <img src="../waylookup_structure_update.png"
         alt="WayLookup 更新结构"
         style="zoom:40%"/>
    <br>		
    WayLookup 更新结构	
    </center>
</div>
<br>
<ul>
<li>内部是 FIFO 环形队列结构。暂存 IPrefetchPipe 查询 MetaArray 和 ITLB 得到的元数据，以备 MainPipe 使用。同时监听 MSHR 写入 SRAM 的 cacheline，对命中信息进行更新。</li>
<li>通过 readPtr 和 writePtr 来管理读写位置。当有 flush 信号时，读写指针都会被重置。当写入数据时，写指针递增；读取时，读指针递增。需要处理队列的空和满的情况，empty 是读指针等于写指针，而 full 则是两者的值相同且标志位不同。</li>
<li>处理 GPF 的部分，有一个 gpf_entry 寄存器，存储 GPF 的相关信息。当写入的数据包含 GPF 异常时，需要将信息存入 gpf_entry，并记录当前的写指针位置到 gpfPtr。当读取的时候，如果当前读指针的位置与 gpfPtr 匹配，并且 gpf_entry 有效，那么就将 GPF 信息一并输出。</li>
<li>IPrefetchPipe 向其写入 WayLookupInfo 信息（包括 vSetIdx，waymask，ptag，itlb_exception，itlb_pbmt，meta_codes，gpaddr，isForVSnonLeafPTE）。
<ul>
<li>写入前，需要考虑队列是否已满，以及是否有 GPF 阻塞。如果有 GPF 信息待读取且未被处理，则写入需要等待，防止覆盖 GPF 信息。写入时，如果数据中包含 GPF 异常，就将信息存入 gpf_entry，并更新 gpfPtr。</li>
</ul>
</li>
<li>MainPipe 从其读出 WayLookupInfo 信息。
<ul>
<li>在读取上，有两种情况：当队列为空但有写请求时，可以直接将写的数据旁路（bypass）给读端口；否则就从 entries 数组中读取对应读指针的数据。同时，如果当前读的位置存在 GPF 信息，就将 GPF 信息一起输出，并在读取后清除有效位。</li>
</ul>
</li>
<li>允许 bypass（当队列为空但有写请求时，可以直接将写的数据旁路给读端口），为了不将更新逻辑的延迟引入到 DataArray 的访问路径上，在 MSHR 有新的写入时禁止出队，MainPipe 的 S0 流水级也需要访问 DataArray，当 MSHR 有新的写入时无法向下走，所以该措施并不会带来额外影响。</li>
<li>MissUnit 向其写入命中信息。
<ul>
<li>若是命中则将 waymask 更新 ICacheMissResp 信息（包括 blkPaddr，vSetIdx，waymask，data，corrupt）且 meta_codes 也更新，否则 waymask 清零。更新逻辑与 IPrefetchPipe 中相同，见 <a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/01_iprefetchpipe/#%e5%91%bd%e4%b8%ad%e4%bf%a1%e6%81%af%e7%9a%84%e6%9b%b4%e6%96%b0">IPrefetchPipe 子模块文档中的“命中信息的更新”</a>一节。</li>
</ul>
</li>
</ul>
<h3 id="gpaddr-省面积机制">GPaddr 省面积机制</h3>
<p>由于 <code>gpaddr</code> 仅在 guest page fault 发生时有用，并且每次发生 gpf 后前端实际上工作在错误路径上，后端保证会送一个 redirect（WayLookup flush）到前端（无论是发生 gpf 前就已经预测错误/发生异常中断导致的；还是 gpf 本身导致的），因此在 WayLookup 中只需存储 reset/flush 后第一个 gpf 有效时的 gpaddr。对双行请求，只需存储第一个有 gpf 的行的 <code>gpaddr。</code></p>
<p>在实现上，把 gpf 相关信号（目前只有 <code>gpaddr</code>）与其它信号（<code>paddr</code>，etc.）拆成两个 bundle，其它信号实例化 nWayLookupSize 个，gpf 相关只实例化一个寄存器。同时另用一个 <code>gpfPtr</code> 指针。总计可以节省$(\text{nWayLookupSize}\times2-1)\times \text{GPAddrBits} - \log_2{(\text{nWayLookupSize})} - 1$bit 的寄存器。
当 prefetch 向 WayLookup 写入时，若有 gpf 发生，且 WayLookup 中没有已经存在的 gpf，则将 gpf/gpaddr 写入 <code>gpf_entry</code> 寄存器，同时将 <code>gpfPtr</code> 设置为此时的 <code>writePtr。</code>
当 MainPipe 从 WayLookup 读取时，若 bypass，则仍然直接将 prefetch 入队的数据出队；否则，若 <code>readPtr === gpfPtr</code>，则读出 gpf_entry；否则读出全 0。
需要指出：</p>
<ol>
<li>考虑双行请求，<code>gpaddr</code> 只需要存一份（若第一行发生 gpf，则第二行肯定也在错误路径上，不必存储），但 gpf 信号本身仍然需要存两份，因为 ifu 需要判断是否是跨行异常。</li>
<li><code>readPtr===gpfPtr</code> 这一条件可能导致 flush 来的比较慢时 <code>readPtr</code> 转了一圈再次与 <code>gpfPtr</code> 相等，从而错误地再次读出 gpf，但如前所述，此时工作在错误路径上，因此即使再次读出 gpf 也无所谓。</li>
<li>需要注意一个特殊情况：一个跨页的取指块，其 32B 在前一页且无异常，后 2B 在后一页且发生 gpf，若前 32B 正好是 16 条 RVC 压缩指令，则 IFU 会将后 2B 及对应的异常信息丢弃，此时可能导致下一个取指块的 <code>gpaddr</code> 丢失。需要在 WayLookup 中已有一个未被 MainPipe 取走的 gpf 及相关信息时阻塞 WayLookup 的入队（即 IPrefetchPipe s1 流水级），见 PR#3719。</li>
</ol>
<h2 id="waylookup-的功能点和测试点">WayLookup 的功能点和测试点</h2>
<h3 id="刷新操作">刷新操作</h3>
<ul>
<li>接收到全局刷新刷新信号 io.flush 后，读、写指针和 GPF 信息都被重置。</li>
</ul>
<ol>
<li>刷新读指针</li>
</ol>
<ul>
<li>io.flush 为高时，重置读指针。</li>
<li>readPtr.value 为 0， readPtr.flag 为 false。</li>
</ul>
<ol start="2">
<li>刷新写指针</li>
</ol>
<ul>
<li>io.flush 为高时，重置写指针。</li>
<li>writePtr.value 为 0， writePtr.flag 为 false。</li>
</ul>
<ol start="3">
<li>刷新 GPF 信息</li>
</ol>
<ul>
<li>io.flush 为高时，重置 GPF 信息。</li>
<li>gpf_entry.valid 为 0， gpf_entry.bits 为 0。</li>
</ul>
<h3 id="读写指针更新">读写指针更新</h3>
<ul>
<li>读写信号握手完毕之后（io.read.fire/io.write.fire 为高），对应指针加一。</li>
<li>因为是在环形队列上，所以超过队列大小后，指针会回到队列头部。</li>
</ul>
<ol>
<li>读指针更新</li>
</ol>
<ul>
<li>当 io.read.fire 为高时，读指针加一。</li>
<li>readPtr.value 加一。</li>
<li>如果 readPtr.value 超过环形队列的大小，readPtr.flag 会翻转。</li>
</ul>
<ol start="2">
<li>写指针更新</li>
</ol>
<ul>
<li>当 io.write.fire 为高时，写指针加一。</li>
<li>writePtr.value 加一。</li>
<li>如果 writePtr.value 超过环形队列的大小，writePtr.flag 会翻转。</li>
</ul>
<h3 id="更新操作">更新操作</h3>
<ul>
<li>MissUnit 处理完 Cache miss 后，向 WayLookup 写入命中信息，也就是 update 操作。</li>
<li>情况分为两种：
<ul>
<li>命中：更新 waymask 和 meta_codes。</li>
<li>未命中：重置 waymask。</li>
</ul>
</li>
</ul>
<ol>
<li>命中更新</li>
</ol>
<ul>
<li>MissUnit 返回的更新信息和 WayLookup 的信息相同时，更新 waymask 和 meta_codes。</li>
<li>vset_same 和 ptag_same 为真。</li>
<li>waymask 和 meta_codes 更新。</li>
<li>hits 对应位为高。</li>
</ul>
<ol start="2">
<li>未命中更新</li>
</ol>
<ul>
<li>vset_same 和 way_same 为真。</li>
<li>waymask 清零。</li>
<li>hit 对应位为高。</li>
</ul>
<ol start="3">
<li>不更新</li>
</ol>
<ul>
<li>其他情况下不更新。</li>
<li>vset_same 为假或者 ptag_same 和 way_same 都为假。</li>
<li>hits 对应位为低。</li>
</ul>
<h3 id="读操作">读操作</h3>
<ul>
<li>读操作会根据读指针从环形队列中读取信息。</li>
<li>如果达成了绕过条件，优先绕过。</li>
</ul>
<ol>
<li>Bypass 读</li>
</ol>
<ul>
<li>队列为空，并且 io.write.valid 写有效时，可以直接读取，而不经过队列。</li>
<li>empty 和 io.write.valid 都为真。</li>
<li>io.read.bits = io.write.bits</li>
</ul>
<ol start="2">
<li>读信号无效</li>
</ol>
<ul>
<li>队列为空（readPtr === writePtr）且写信号 io.write.valid 为低。</li>
<li>io.read.valid 为低，读信号无效。</li>
</ul>
<ol start="3">
<li>正常读</li>
</ol>
<ul>
<li>未达成绕过条件（empty 和 io.write.valid 至少有一个为假）且 io.read.valid 为高。</li>
<li>从环形队列中读取信息。</li>
<li>io.read.bits.entry = entries(readPtr.value)</li>
</ul>
<ol start="4">
<li>gpf 命中</li>
</ol>
<ul>
<li>io.read.valid 为高，可以读。</li>
<li>当 gpf_hits 为高时，从 GPF 队列中读取信息。</li>
<li>io.read.bits.gpf = gpf_entry.bits</li>
</ul>
<ol start="5">
<li>gpf 命中且被读取</li>
</ol>
<ul>
<li>
<p>io.read.valid 为高，可以读。</p>
<blockquote>
<p>also clear gpf_entry.valid when it&rsquo;s read</p></blockquote>
</li>
<li>
<p>当 gpf 命中且被读取其时（io.read.fire 为高），gpf_entry.valid 会被置为 0。</p>
</li>
</ul>
<ol start="6">
<li>gpf 未命中</li>
</ol>
<ul>
<li>io.read.valid 为高，可以读。</li>
<li>io.read.bits.gpf 清零。</li>
</ul>
<h3 id="写操作">写操作</h3>
<ul>
<li>写操作会根据写指针从环形队列中读取信息。</li>
<li>如果有 gpf 停止，就会停止写。</li>
</ul>
<ol>
<li>gpf 停止
<blockquote>
<p>if there is a valid gpf to be read, we should stall write</p></blockquote>
</li>
</ol>
<ul>
<li>gpf 队列数据有效，并且没有被读取或者没有命中，就会产生 gpf 停止，此时写操作会被停止。</li>
<li>gpf_entry.valid &amp;&amp; !(io.read.fire &amp;&amp; gpf_hit) 为高时，写操作会被停止（io.write.ready 为低）。</li>
</ul>
<ol start="2">
<li>写就绪无效</li>
</ol>
<ul>
<li>当队列为满（(readPtr.value === writePtr.value) &amp;&amp; (readPtr.flag ^ writePtr.flag)）或者 gpf 停止时，写操作会被停止。</li>
<li>（io.write.ready 为低）</li>
</ul>
<ol start="3">
<li>正常写</li>
</ol>
<ul>
<li>当 io.write.valid 为高时（没满且没有 gpf 停止），写操作会被执行。</li>
<li>正常握手完毕 io.write.fire 为高。</li>
<li>写信息会被写入环形队列。</li>
<li>entries(writePtr.value) = io.write.bits.entry。</li>
</ul>
<p>有 ITLB 异常的写</p>
<ul>
<li>前面与正常写相同，只不过当写信息中存在 ITLB 异常时，会更新 gpf 队列和 gpf 指针。</li>
<li>此时如果已经被绕过直接读取了，那么就不需要存储它了。
<ul>
<li>
<ol start="4">
<li>被绕过直接读取了</li>
</ol>
<ul>
<li>can_bypass 和 io.read.fire 都为高。</li>
<li>gpf_entry.valid 为 false。</li>
<li>gpf_entry.bits = io.write.bits.gpf</li>
<li>gpfPtr = writePtr</li>
</ul>
</li>
<li>
<ol start="5">
<li>没有被绕过直接读取</li>
</ol>
<ul>
<li>can_bypass 为低。</li>
<li>gpf_entry.valid 为 true。</li>
<li>gpf_entry.bits = io.write.bits.gpf</li>
<li>gpfPtr = writePtr</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-025e98ca37bba9c567819bf7fb3e31b4">12.2.3 - IFU</h1>
    
	<p><strong>本文档参考<a href="https://github.com/OpenXiangShan/XiangShan-Design-Doc/blob/master/docs/frontend/IFU/index.md">香山IFU设计文档</a>写成</strong></p>
<p>本文档撰写的内容截至[c670557]</p>
<p>请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！</p>
<h1 id="ifu说明文档"><strong>IFU说明文档</strong></h1>
<div class="ifu-ctx">
<h2 id="文档概述">文档概述</h2>
<p>本文档描述IFU的功能，并根据功能给出测试点参考，方便测试的参与者理解测试需求，编写相关测试用例。</p>
<p>为方便验证参与者，本文档中还额外给出了整体框图和流水级的示意图，以及各个rtl接口的详细说明。此外，本文档还给出了两个时序示例。</p>
<h2 id="术语说明">术语说明</h2>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>RVC（RISC-V Compressed Instructions）</td>
          <td>RISC-V 手册&quot;C&quot;扩展规定的 16 位长度压缩指令</td>
      </tr>
      <tr>
          <td>RVI（RISC-V Integer Instructions）</td>
          <td>RISC-V 手册规定的 32 位基本整型指令</td>
      </tr>
      <tr>
          <td>IFU（Instruction Fetch Unit）</td>
          <td>取指令单元</td>
      </tr>
      <tr>
          <td>FTQ（Fetch Target Queue）</td>
          <td>取指目标队列</td>
      </tr>
      <tr>
          <td>ICache（L1 Instruction Cache）</td>
          <td>一级指令缓存</td>
      </tr>
      <tr>
          <td>IBuffer（Instruction Buffer）</td>
          <td>指令缓冲</td>
      </tr>
      <tr>
          <td>CFI（Control Flow Instruction）</td>
          <td>控制流指令</td>
      </tr>
      <tr>
          <td>ITLB（Instruction Translation Lookaside Buffer）</td>
          <td>指令地址转译后备缓冲器</td>
      </tr>
      <tr>
          <td>InstrUncache（Instruction Ucache Module）</td>
          <td>指令 MMIO 取指处理单元</td>
      </tr>
  </tbody>
</table>
<h2 id="整体框图">整体框图</h2>
<p>以下是IFU的架构简图：</p>
<p><img src="framework.jpg" alt="framework"></p>
<h2 id="流水级示意图">流水级示意图</h2>
<p>香山的IFU一共分为5个stage。</p>
<p>F0 stage：接收FTQ请求，同时告诉FTQ自己已经ready了，同时，FTQ也会通知ICache准备数据。此外，这一阶段还会接受重定向信息。</p>
<p>F1 stage：从FTQ请求中先计算出每个指令的pc，half_pc，并计算cut_ptr（这是后续将icache返回的指令码进行切分的依据）</p>
<p>F2 stage：从icache获取响应数据（缓存行）并校验，提取出异常信息（包括页错误、访问错误、mmio信息）；生成预测到的指令范围（但这并不是一个数字，而是一个用多位表示的bool数组，该位为1表示这一指令在预测块范围内）；从缓存行中，利用上一阶段求出的cut_ptr切分出17×2的初步指令码，最后进行预译码和指令扩展。</p>
<p>F3 stage：这一阶段主要是对译码阶段的结果进行预检查，对RVC指令进行扩展，以及MMIO状态下的处理逻辑，并向IBuffer写指令码和前端信息</p>
<p>WB（写回）stage：将预检查的结果写回FTQ。根据预检查结果判断是否进行内部冲刷。</p>
<p>以下是一张示意图：</p>
<p><img src="stages.svg" alt="stages"></p>
<h2 id="子模块列表">子模块列表</h2>
<table>
  <thead>
      <tr>
          <th>子模块</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/01_predecode/">PreDecoder</a></td>
          <td>预译码模块</td>
      </tr>
      <tr>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/02_f3predecoder/">F3Predecoder</a></td>
          <td>F3阶段预译码模块</td>
      </tr>
      <tr>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/03_ifu_rvc_exp/">RVCExpander</a></td>
          <td>RVC指令扩展模块</td>
      </tr>
      <tr>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/04_pred_checker/">PredChecker</a></td>
          <td>预检查模块</td>
      </tr>
      <tr>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/05_frontend_trigger/">FrontendTrigger</a></td>
          <td>前端断点模块</td>
      </tr>
  </tbody>
</table>
<mrs-functions>
<h2 id="ifu模块功能说明">IFU模块功能说明</h2>
<p>FTQ 将预测块请求分别发送到 ICache 和 IFU 模块，IFU 等到来自 ICache 返回至多两个缓存行的指令码后，进行切分产生取指令请求范围限定的初始指令码，并送到预译码器进行预译码下一拍根据预译码信息修正有效指令范围，同时进行指令码扩展并将指令码及其他信息发送给 IBuffer 模块。当 ICache 查询地址属性发现是 MMIO 地址空间时，IFU 需要将地址发送给 MMIO 处理单元取指令，这个时候处理器进入多周期顺序执行模式，IFU 阻塞流水线直到收到来自 ROB 的提交信号时，IFU 才允许下一个取指令请求的进行，同时 IFU 需要对跨页的 MMIO 地址空间 32 位指令做特殊处理（重发机制）。</p>
<h3 id="1-接收ftq取指令请求f0流水级">1. 接收FTQ取指令请求（F0流水级）</h3>
<p>​	在F0流水级，IFU接收来自FTQ以预测块为单位的取指令请求。请求内容包括预测块起始地址、起始地址所在cache line的下一个cache line开始地址、下一个预测块的起始地址、该预测块在FTQ里的队列指针、该预测块有无taken的CFI指令（控制流指令）和该taken的CFI指令在预测块里的位置以及请求控制信号（请求是否有效和IFU是否ready）。每个预测块最多包含32字节指令码，最多为16条指令。IFU需要置位ready驱动FTQ向ICache发送请求。</p>
<h4 id="11-f0流水级接收请求">1.1. F0流水级接收请求</h4>
<p>IFU应当能向FTQ报告自己已ready。</p>
<p>所以，对于这一测试点我们只需要在发送请求后检查和ftq相关的的ready情况即可。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>IFU_RCV_REQ</td>
          <td>READY</td>
          <td>IFU接收FTQ请求后，设置ready</td>
      </tr>
  </tbody>
</table>
<h3 id="2-指令切分产生初始指令码f1f2流水级">2. 指令切分产生初始指令码（F1、F2流水级）</h3>
<p>F0流水级时，FTQ同时会向ICache发送取缓存行的指令。这是ICache在其S2流水级需要返回的，所以IFU在F2流水级才会得到ICache返回的缓存行。在此之前，IFU会在F1流水线先进行PC的计算，以及计算切分缓存行的指针。</p>
<p>进入F2流水级，IFU将会针对每个指令，取出对应的异常信息、物理地址、客户物理地址等。同时，根据FTQ的taken信息，IFU将会计算该预测块在无跳转和跳转发生情况下的有效指令范围。无跳转情况下的指令有效范围ftr_range即当前预测块从起始地址到下一个预测块的起始地址的差值。有跳转情况下的指令有效范围jump_range即当前预测块的起始地址到预测块中第一个跳转指令地址的差值。</p>
<p>最后，IFU需要从缓存行和上一流水级计算的指针，完成对17x2字节初始指令码的拼接。这里的拼接代码可能存在一些迷惑性</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">f2_cache_response_data</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">fromICache</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">map</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">_</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">bits</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">data</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">f2_data_2_cacheline</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Cat</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">f2_cache_response_data</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#ce5c00;font-weight:bold">),</span> <span style="color:#000">f2_cache_response_data</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#0000cf;font-weight:bold">0</span><span style="color:#ce5c00;font-weight:bold">))</span>
</span></span></code></pre></div><p>在调用cut之前，我们先是从ICache获取了缓存行（ICache返回的缓存行种类已经在ICache中进行了分类讨论，IFU中直接使用即可），然后将第0个缓存数据进行了拼接，
这一操作的原因来自于ICache中对数据的细粒度拆分：</p>
<p>fetch block可能跨缓存行，但是由于fetch block最大只有34B，如果将两个缓存行（2x64B）都传送给IFU则显得浪费，因此，fetch block的选择由ICache完成。</p>
<p>ICache返回给IFU的并不是直接的预测块，而是带有跨缓存行信息的64字节。</p>
<p>我们将每个缓存行分为8份，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>cacheline 0: |0-7|0-6|0-5|0-4|0-3|0-2|0-1|0-0|
</span></span><span style="display:flex;"><span>cacheline 1: |1-7|1-6|1-5|1-4|1-3|1-2|1-1|1-0|
</span></span></code></pre></div><p>如果fetch block的起始位置为0-1，则必定不跨缓存行。</p>
<p>如果fetch block的起始位置为0-6，那么fetch block的位置为0-6~1-2，此时传送的缓存行结构如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>cacheline 0: |0-7|0-6|xx|xx|xx|1-2|1-1|1-0|
</span></span></code></pre></div><p>由此，只要将该缓存行复制一遍，即可获得拼接后的fetch block。</p>
<p>综上所述，对这两种情况，我们都只需要把返回的cacheline复制一份拼接在一起，从中间截取就可以拿到数据。</p>
<p>详细的信息可以参考<a href="https://github.com/OpenXiangShan/XiangShan-Design-Doc/blob/master/docs/frontend/ICache/ICache.md#dataarray-%E5%88%86-bank-%E7%9A%84%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%BE%E8%AE%A1">ICache文档</a></p>
<h4 id="21-f1流水级计算信息和切分指针">2.1. F1流水级计算信息和切分指针</h4>
<p>F1流水级也会计算PC。</p>
<p>同时还需要生成17位的切分指针（也就是从拼接后的缓存行切出初始指令码的idx数组，在昆明湖架构中，计算方式为拼接00和startAddr[5:1]，
然后分别与0～16相加） 用于后续从缓存行提取初始指令码。</p>
<p>所以，首先我们需要检查F1流水级生成的PC的正确与否。如果可能，也需要检查一下切分指针的生成。</p>
<p>可以总结出以下的细分测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.1.1</td>
          <td>IFU_F1_INFOS</td>
          <td>PC</td>
          <td>IFU接收FTQ请求后，在F1流水级生成PC</td>
      </tr>
      <tr>
          <td>2.1.2</td>
          <td>IFU_F1_INFOS</td>
          <td>CUT_PTR</td>
          <td>IFU接收FTQ请求后，在F1流水级生成后续切取缓存行的指针</td>
      </tr>
  </tbody>
</table>
<h4 id="22-f2流水级获取指令信息">2.2. F2流水级获取指令信息</h4>
<p>包括获取异常信息、物理地址、客户物理地址、是否在MMIO空间等。</p>
<p>获取异常信息之后，还需要计算异常向量。ICache会为每个缓存行返回一个异常类型，只需要计算每个指令pc属于哪个缓存行，
然后将对应缓存行的异常类型赋给该位置即可。</p>
<p>所以，只需要分别检查几种指令信息即可。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.2.1</td>
          <td>IFU_F2_INFOS</td>
          <td>EXCP_VEC</td>
          <td>IFU接收ICache内容后，会根据ICache的结果生成属于每个指令的异常向量</td>
      </tr>
      <tr>
          <td>2.2.2</td>
          <td>IFU_F2_INFOS</td>
          <td>PADDR</td>
          <td>IFU接收ICache内容后，会根据ICache的结果生成属于每个端口的物理地址。</td>
      </tr>
      <tr>
          <td>2.2.3</td>
          <td>IFU_F2_INFOS</td>
          <td>GPADDR</td>
          <td>IFU接收ICache内容后，会根据ICache的结果生成0号端口的客户物理地址。</td>
      </tr>
      <tr>
          <td>2.2.4</td>
          <td>IFU_F2_INFOS</td>
          <td>MMIO</td>
          <td>IFU接收ICache内容后，会根据ICache的结果判断当前取指请求是否属于MMIO空间。</td>
      </tr>
  </tbody>
</table>
<h4 id="23-f2流水级计算预测块有效指令范围">2.3. F2流水级计算预测块有效指令范围</h4>
<p>指令有效范围包括两种，无跳转和有跳转的</p>
<p>无跳转的指令有效范围为当前预测块从起始地址到下一个预测块的起始地址的所有指令。</p>
<p>有跳转的指令有效范围jump_range为当前预测块的起始地址到预测块中第一个跳转指令地址（包含第一个跳转指令地址）之间的所有指令。</p>
<p>最终的指令有效范围是两者相与的结果。</p>
<p>我们需要分别对两种有效范围进行检查，再检查最终结果。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.3.1</td>
          <td>IFU_INSTR_VALID_RANGE</td>
          <td>NORMAL</td>
          <td>IFU根据FTQ请求，计算无跳转指令有效范围</td>
      </tr>
      <tr>
          <td>2.3.2</td>
          <td>IFU_INSTR_VALID_RANGE</td>
          <td>JUMP</td>
          <td>IFU根据FTQ请求，计算跳转指令有效范围</td>
      </tr>
      <tr>
          <td>2.3.3</td>
          <td>IFU_INSTR_VALID_RANGE</td>
          <td>FINAL</td>
          <td>IFU综合两类指令有效范围，生成最终指令有效范围</td>
      </tr>
  </tbody>
</table>
<h4 id="24-提取初始指令码">2.4. 提取初始指令码</h4>
<p>IFU需要将ICache返回的缓存行复制一份并拼接。然后利用上一流水级计算的idx数组，从缓存行提取17x2字节的初始指令码。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.4</td>
          <td>IFU_INSTR_CUT</td>
          <td>CUT</td>
          <td>IFU根据上一流水级的切取指针，从缓存行提取初始指令码。</td>
      </tr>
  </tbody>
</table>
<h3 id="3-预译码f2流水级主要由predecode模块完成">3. 预译码（F2流水级，主要由PreDecode模块完成）</h3>
<p>在F2流水级，我们需要将上一步完成切分的指令码交给PreDecode子模块,他的作用主要有二：</p>
<p>其一是生成预译码信息，包括该指令是否是有效指令的开始、是否是RVC指令、是否是CFI指令、CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移等。输出的预译码信息中brType域的编码如下:</p>
<table>
  <thead>
      <tr>
          <th>CFI指令类型</th>
          <th>brType类型编码</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>非CFI</td>
          <td>00</td>
      </tr>
      <tr>
          <td>branch指令</td>
          <td>01</td>
      </tr>
      <tr>
          <td>jal指令</td>
          <td>10</td>
      </tr>
      <tr>
          <td>jalr指令</td>
          <td>11</td>
      </tr>
  </tbody>
</table>
<p>（<strong><a id="brtype">brType类型一览</a></strong>）</p>
<p>其二是将初始指令码两两组合之后，得到16x4字节的指令码（从起始地址开始，2字节做地址递增，地址开始的4字节作为一条32位初始指令码）。</p>
<p>此外，预译码阶段还需要分类讨论，得出两种指令有效向量（起始指令是不是RVI指令的后半部分），并交给IFU进行判断选择，可以参阅后面的<a href="#kyck_32">跨预测块32位指令</a>处理部分</p>
<p>其他功能和详细内容（比如怎么判断RET和CALL指令等）参见<a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/01_predecode/">PreDecode</a>和<a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/02_f3predecoder/">F3Predecoder</a>子模块的描述。</p>
<h4 id="31-指令码拼接">3.1. 指令码拼接</h4>
<p>对于上一功能中生成的指令序列，应当拼接成为16x4的指令码序列。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>3.1.1</td>
          <td>IFU_PREDECODE</td>
          <td>CONCAT</td>
          <td>将生成的指令序列拼接成为16x4的指令码序列</td>
      </tr>
  </tbody>
</table>
<h4 id="32-判定rvc指令">3.2. 判定RVC指令</h4>
<p>PreDecode功能需要判断一条指令是否为RVC指令</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>3.2.1</td>
          <td>IFU_PREDECODE_RVC</td>
          <td>RVC</td>
          <td>传入RVC指令，应该判断为RVC</td>
      </tr>
      <tr>
          <td>3.2.2</td>
          <td>IFU_PREDECODE_RVC</td>
          <td>RVI</td>
          <td>传入RVI指令，不应判断为RVC</td>
      </tr>
  </tbody>
</table>
<h4 id="33-计算跳转偏移">3.3. 计算跳转偏移</h4>
<p>预译码阶段需要对BR和J类型的跳转指令偏移进行计算。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>3.3.1</td>
          <td>IFU_PREDECODE_JMP_TGT</td>
          <td>RVC_J</td>
          <td>对传入RVC扩展的J指令，检查计算的偏移</td>
      </tr>
      <tr>
          <td>3.3.2</td>
          <td>IFU_PREDECODE_JMP_TGT</td>
          <td>RVI_J</td>
          <td>对传入RVI扩展的J指令，检查计算的偏移</td>
      </tr>
      <tr>
          <td>3.3.3</td>
          <td>IFU_PREDECODE_JMP_TGT</td>
          <td>RVC_BR</td>
          <td>对传入RVC扩展的BR指令，检查计算的偏移</td>
      </tr>
      <tr>
          <td>3.3.4</td>
          <td>IFU_PREDECODE_JMP_TGT</td>
          <td>RVI_BR</td>
          <td>对传入RVI扩展的BR指令，检查计算的偏移</td>
      </tr>
  </tbody>
</table>
<h4 id="34-判定cfi指令类型">3.4. 判定CFI指令类型</h4>
<p>预译码阶段需要对CFI指令的类型进行判断，一共有四种判断结果：非CFI指令、BR指令、JAL指令、JALR指令</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>3.4.1</td>
          <td>IFU_PREDECODE_CFI_TYPE</td>
          <td>NON_CFI</td>
          <td>对传入的非CFI指令（包括RVC.EBREAK），应该判定为类型0</td>
      </tr>
      <tr>
          <td>3.4.2</td>
          <td>IFU_PREDECODE_CFI_TYPE</td>
          <td>BR</td>
          <td>对传入的BR指令，应该判定为类型1</td>
      </tr>
      <tr>
          <td>3.4.3</td>
          <td>IFU_PREDECODE_CFI_TYPE</td>
          <td>JAL</td>
          <td>对传入的JAL指令，应该判定为类型2</td>
      </tr>
      <tr>
          <td>3.4.4</td>
          <td>IFU_PREDECODE_CFI_TYPE</td>
          <td>JALR</td>
          <td>对传入的JALR指令，应该判定为类型3</td>
      </tr>
  </tbody>
</table>
<h4 id="35-判定ret和call">3.5. 判定RET和CALL</h4>
<p>预译码阶段需要判断一条指令是否为ret或者call指令，具体请参阅<a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/02_f3predecoder/#retcall%e5%88%a4%e5%ae%9a">F3Predecoder文档</a></p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>3.5.1</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>NON_CFI_BR</td>
          <td>对传入的非CFI和BR指令，都不应判定为call或者ret</td>
      </tr>
      <tr>
          <td>3.5.2.1.1</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVI_JAL_CALL</td>
          <td>对传入的RVI.JAL指令，当rd设置为1或5，应当判定该指令为call</td>
      </tr>
      <tr>
          <td>3.5.2.1.2</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVI_JAL_NOP</td>
          <td>对传入的RVI.JAL指令，当rd设置为1和5之外的值，不应当判定该指令为call或ret</td>
      </tr>
      <tr>
          <td>3.5.2.2</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVC_JAL_NOP</td>
          <td>对传入的RVC.JAL指令，无论什么情况都不能判定为call或ret</td>
      </tr>
      <tr>
          <td>3.5.3.1.1</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVI_JALR_CALL</td>
          <td>传入RVI.JALR指令，并且rd为1或5，无论其他取值，都应判定为call</td>
      </tr>
      <tr>
          <td>3.5.3.1.2</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVI_JALR_RET</td>
          <td>传入RVI.JALR指令，rd不为1和5，rs为1或5，应判定为ret</td>
      </tr>
      <tr>
          <td>3.5.3.1.3</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVI_JALR_NOP</td>
          <td>对传入的JALR指令，若rd和rs均不为link，则不应判定为ret和call</td>
      </tr>
      <tr>
          <td>3.5.3.2.1</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVC_JALR_CALL</td>
          <td>传入RVC.JALR指令，必定为call</td>
      </tr>
      <tr>
          <td>3.5.3.2.2.1</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVC_JR_RET</td>
          <td>传入RVC.JR指令，rs为1或5，应判定为ret</td>
      </tr>
      <tr>
          <td>3.5.3.2.2.2</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVC_JR_NOP</td>
          <td>传入RVC.JR指令，rs不为1或5，不应判定为ret</td>
      </tr>
  </tbody>
</table>
<h4 id="36-计算指令有效开始向量">3.6. 计算指令有效开始向量</h4>
<p>预译码阶段需要根据两种情况计算有效指令开始向量，IFU top需要对有效指令开始向量进行选择。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>3.6.1</td>
          <td>IFU_PREDECODE_VALID_STARTS</td>
          <td>LAST_IS_END</td>
          <td>上一预测块的最后2字节恰为RVC指令或RVI指令的后半部分，按第一位为True推导有效开始向量</td>
      </tr>
      <tr>
          <td>3.6.2</td>
          <td>IFU_PREDECODE_VALID_STARTS</td>
          <td>LAST_NOT_END</td>
          <td>上一预测块的最后2字节上一预测块的最后2字节为RVI指令的前半部分，按第一位为False推导有效开始向量</td>
      </tr>
  </tbody>
</table>
<h3 id="4-指令扩展f3流水级">4. 指令扩展（F3流水级）</h3>
<p>这一部分将从PreDecode返回的16条指令码分别送交指令扩展器（RVCExpander）进行32位指令扩展（RVI保持不变， RVC指令根据手册的规定进行扩充）。</p>
<p>但是，如果RVC指令非法，需要向IBuffer写入原始指令码。</p>
<h4 id="41-指令扩展和检错">4.1. 指令扩展和检错</h4>
<p>指令扩展阶段需要分RVC和RVI指令进行考虑，其中RVC指令需要判断合法与否。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>4.1.1</td>
          <td>IFU_RVC_EXPAND</td>
          <td>VALID_RVC</td>
          <td>对合法RVC指令，写扩展后的指令码，判断结果为合法指令</td>
      </tr>
      <tr>
          <td>4.1.2</td>
          <td>IFU_RVC_EXPAND</td>
          <td>INVALID_RVC</td>
          <td>对非法RVC指令，写原始指令码，判断结果为非法指令</td>
      </tr>
      <tr>
          <td>4.1.3</td>
          <td>IFU_RVC_EXPAND</td>
          <td>RVI</td>
          <td>RVI指令直接写入原始指令即可，判断结果为合法指令</td>
      </tr>
  </tbody>
</table>
<h3 id="5-预测错误预检查f3流水级主要由prechecker子模块完成">5. 预测错误预检查（F3流水级，主要由PreChecker子模块完成）</h3>
<p>这一功能是为了将一些不依赖于执行结果的预测错误在早期就发现出来。这一阶段检查五类错误：</p>
<p><strong>jal类型错误</strong>：预测块的范围内有jal指令，但是预测器没有对这条指令预测跳转；</p>
<p><strong>ret类型错误</strong>：预测块的范围内有ret指令，但是预测器没有对这条指令预测跳转；</p>
<p><strong>jalr类型错误</strong>：预测块的范围内有jalr指令，但是预测器没有对这条指令预测跳转；</p>
<p><strong>无效指令预测错误</strong>：预测器对一条无效的指令（不在预测块范围/是一条32位指令中间）进行了预测；</p>
<p><strong>非CFI指令预测错误</strong>：预测器对一条有效但是不是CFI的指令进行了预测；</p>
<p><strong>转移目标地址错误</strong>：预测器给出的转移目标地址不正确。</p>
<p>在预检查的最后将会修正之前预测的各个指令的跳转情况。同时，如果存在jal或者ret类型预测错误，还将修正fixedRange——这是指令有效范围向量，可以看作一个bool数组，其中某一位为1也就是对应的指令在这一范围内。</p>
<p>这一部分的功能点和<a href="./04_predchecker.md">PredChecker</a>子模块的功能点相同。</p>
<h3 id="51-bpu预测信息的jal预测错误检查">5.1. BPU预测信息的JAL预测错误检查</h3>
<p>PredChecker会对传入的预测块进行JAL预测错误预检查并修正指令有效范围向量和预测的跳转指令。</p>
<p>对这一模块的测试，我们分为两部分：正确的输入是否会误检和确有JAL检测错误的预测块输入能否检出。</p>
<p>对此，我们设计如下的测试点:</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>5.1.1.1</td>
          <td>IFU_PRECHECK_JAL_MISS</td>
          <td>NOP</td>
          <td>预测块中没有JAL指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JAL预测错误。</td>
      </tr>
      <tr>
          <td>5.1.2.1</td>
          <td>IFU_PRECHECK_JAL_MISS</td>
          <td>CORRECT</td>
          <td>预测块中有JAL指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JAL预测错误。</td>
      </tr>
      <tr>
          <td>5.1.2.1</td>
          <td>IFU_PRECHECK_JAL_CHECK</td>
          <td>NO_SEL</td>
          <td>预测块中存在JAL指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出JAL预测错误。</td>
      </tr>
      <tr>
          <td>5.1.2.2</td>
          <td>IFU_PRECHECK_JAL_CHECK</td>
          <td>SEL_LATE</td>
          <td>预测块中存在JAL指令，但是BPU预测信息取的跳转指令在第一条JAL指令之后，检查PredChecker是否能检测出JAL预测错误。</td>
      </tr>
  </tbody>
</table>
<h3 id="52-bpu预测信息的ret预测错误检查">5.2. BPU预测信息的RET预测错误检查</h3>
<p>PredChecker会对传入的预测块进行RET预测错误预检查并修正指令有效范围向量和新的预测结果。</p>
<p>和JAL预测错误类似，我们也按照误检和正检来构造。</p>
<p>为此，我们设计如下的测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>5.2.1.1</td>
          <td>IFU_PRECHECK_RET_MISS</td>
          <td>NOP</td>
          <td>预测块中没有RET指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报RET预测错误。</td>
      </tr>
      <tr>
          <td>5.2.2.1</td>
          <td>IFU_PRECHECK_RET_MISS</td>
          <td>CORRECT</td>
          <td>预测块中有RET指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报RET预测错误。</td>
      </tr>
      <tr>
          <td>5.2.2.1</td>
          <td>IFU_PRECHECK_RET_CHECK</td>
          <td>NO_SEL</td>
          <td>预测块中存在RET指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出RET预测错误。</td>
      </tr>
      <tr>
          <td>5.2.2.2</td>
          <td>IFU_PRECHECK_RET_CHECK</td>
          <td>SEL_LATE</td>
          <td>预测块中存在RET指令，但是BPU预测信息取的跳转指令在第一条RET指令之后，检查PredChecker是否能检测出RET预测错误。</td>
      </tr>
  </tbody>
</table>
<h3 id="53-bpu预测信息的jalr预测错误检查">5.3. BPU预测信息的JALR预测错误检查</h3>
<p>PredChecker会对传入的预测块进行JALR预测错误预检查并修正指令有效范围向量和新的预测结果。</p>
<p>和JAL/RET预测错误类似，我们也按照误检和正检来构造。</p>
<p>为此，我们设计如下的测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>5.3.2.2</td>
          <td>IFU_PRECHECK_JALR_MISS</td>
          <td>NOP</td>
          <td>预测块中没有JALR指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JALR预测错误。</td>
      </tr>
      <tr>
          <td>5.3.2.2</td>
          <td>IFU_PRECHECK_JALR_MISS</td>
          <td>CORRECT</td>
          <td>预测块中有JALR指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JALR预测错误。</td>
      </tr>
      <tr>
          <td>5.3.2.2</td>
          <td>IFU_PRECHECK_JALR_CHECK</td>
          <td>NO_SEL</td>
          <td>预测块中存在JALR指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出RET预测错误。</td>
      </tr>
      <tr>
          <td>5.3.2.2</td>
          <td>IFU_PRECHECK_JALR_CHECK</td>
          <td>SEL_LATE</td>
          <td>预测块中存在JALR指令，但是BPU预测信息取的跳转指令在第一条JALR指令之后，检查PredChecker是否能检测出JALR预测错误。</td>
      </tr>
  </tbody>
</table>
<h3 id="54-更新指令有效范围向量和预测跳转的指令">5.4. 更新指令有效范围向量和预测跳转的指令</h3>
<p>PredChecker在检查出Jal/Ret/Jalr指令预测错误时，需要重新生成指令有效范围向量，
有效范围截取到Jal/Ret/Jalr指令的位置，之后的bit全部置为0。
同时，还需要根据每条指令的预译码信息和BPU的预测信息修复预测跳转的结果。</p>
<p>所以，根据功能要求，我们可以划分出三类情况，分别是预测的有效范围和取用的跳转指令正确的情况，
由于RET和JAL预测错误引起的有效范围偏大和错判非跳转指令和无效指令引起的有效范围偏小。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>5.4.1</td>
          <td>IFU_PREDCHECK_FIX</td>
          <td>NOP</td>
          <td>不存在任何错误的情况下，PredChecker应当保留之前的预测结果。</td>
      </tr>
      <tr>
          <td>5.4.2</td>
          <td>IFU_PREDCHECK_FIX</td>
          <td>BIGGER_FIX</td>
          <td>如果检测到了JAL、RET、JALR类的预测错误，PredChecker应该将有效指令的范围修正为预测块开始至第一条跳转指令。同时，应该将预测跳转的指令位置修正为预测块中的第一条跳转指令。</td>
      </tr>
      <tr>
          <td>5.4.3</td>
          <td>IFU_PREDCHECK_FIX</td>
          <td>SMALLER_NOP</td>
          <td>如果出现了非控制流指令和无效指令的误预测，不应该将预测跳转的指令重新修正到预测块中第一条跳转指令（也即不能扩大范围），因为后续会直接冲刷并重新从重定向的位置取指令，如果这里修正的话，会导致下一预测块传入重复的指令</td>
      </tr>
  </tbody>
</table>
<h3 id="55-非cfi预测错误检查">5.5. 非CFI预测错误检查</h3>
<p>非CFI预测错误的条件是被预测跳转的指令根据预译码信息显示不是一条CFI指令。</p>
<p>要检验这一功能，我们仍然按误检和正确检验来设计测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>5.5.1.1</td>
          <td>IFU_PREDCHECK_NON_CFI_MISS</td>
          <td>NOP</td>
          <td>构造不存在CFI指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检非CFI预测错误</td>
      </tr>
      <tr>
          <td>5.5.1.2</td>
          <td>IFU_PREDCHECK_NON_CFI_MISS</td>
          <td>CORRECT</td>
          <td>构造存在CFI指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检非CFI预测错误</td>
      </tr>
      <tr>
          <td>5.5.2</td>
          <td>IFU_PREDCHECK_NON_CFI_CHECK</td>
          <td>ERROR</td>
          <td>构造不存在CFI指令但是预测了跳转的预测信息作为输入，测试PredChecker是否能检查出非CFI预测错误</td>
      </tr>
  </tbody>
</table>
<h3 id="56-无效指令预测错误检查">5.6. 无效指令预测错误检查</h3>
<p>目标地址预测错误的条件是，被预测的是一条有效的jal或者branch指令，
同时预测的跳转目标地址和由指令码计算得到的跳转目标不一致。</p>
<p>和先前的思路一样，我们仍然按误检和检出两类组织测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>5.6.1.1</td>
          <td>IFU_PREDCHECK_INVALID_MISS</td>
          <td>NOP</td>
          <td>构造不存在跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误</td>
      </tr>
      <tr>
          <td>5.6.1.2</td>
          <td>IFU_PREDCHECK_INVALID_MISS</td>
          <td>INVALID_JMP</td>
          <td>构造存在无效跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误</td>
      </tr>
      <tr>
          <td>5.6.1.3</td>
          <td>IFU_PREDCHECK_INVALID_MISS</td>
          <td>CORRECT</td>
          <td>构造存在有效跳转指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误</td>
      </tr>
      <tr>
          <td>5.6.2</td>
          <td>IFU_PREDCHECK_INVALID_MISS</td>
          <td>ERROR</td>
          <td>构造无效指令但是预测了跳转的预测信息作为输入，测试PredChecker是否能检查出无效指令预测错误</td>
      </tr>
  </tbody>
</table>
<h3 id="57-目标地址预测错误检查">5.7. 目标地址预测错误检查</h3>
<p>无效指令预测错误的条件是被预测的指令的位置根据预译码信息中的指令有效向量显示不是一条有效指令的开始。</p>
<p>要检验这一功能，我们按照误检和正确检测来设计测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>5.7.1.1</td>
          <td>IFU_PREDCHECK_TARGET_MISS</td>
          <td>NOP</td>
          <td>构造不存在跳转指令并且未预测跳转的预测信息作输入，测试PredChecker是否会错检目标地址预测错误</td>
      </tr>
      <tr>
          <td>5.7.1.2</td>
          <td>IFU_PREDCHECK_TARGET_MISS</td>
          <td>CORRECT</td>
          <td>构造存在有效跳转指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检目标地址预测错误</td>
      </tr>
      <tr>
          <td>5.7.2</td>
          <td>IFU_PREDCHECK_TARGET_CHECK</td>
          <td>ERROR</td>
          <td>构造存在有效跳转指令的预测块和预测跳转但跳转目标计算错误的预测信息作为输入，测试PredChecker能否检出目标地址预测错误</td>
      </tr>
  </tbody>
</table>
<h3 id="58-生成跳转和顺序目标">5.8. 生成跳转和顺序目标</h3>
<p>PredChecker还需要负责生成跳转和顺序目标。</p>
<p>我们通过随机生成译码信息进行测试</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>5.8</td>
          <td>IFU_PREDCHECK_TARGETS</td>
          <td>TARGETS</td>
          <td>随机提供译码信息，检测生成的跳转目标和顺序目标。</td>
      </tr>
  </tbody>
</table>
<h3 id="6-前端重定向wb阶段">6. 前端重定向（WB阶段）</h3>
<p>如果在预测错误预检查的部分发现了上述的6类错误，那么需要在写回阶段产生一个前端重定向将F3以外的流水级进行冲刷，
从而让BPU能够从正确路径重新开始预测。</p>
<p>还有一种情况下需要冲刷流水线。在下一节中，如果误判了当前预测块的最后2B为RVI指令的上半部分，则也需要冲刷当前预测块F3之前的流水级。</p>
<h4 id="61-预测错误重定向">6.1. 预测错误重定向</h4>
<p>如果发现了预检阶段检出的错误，则需要产生前端重定向，将F3以外的流水级冲刷</p>
<p>只需要构造有预测错误的预测请求，检查冲刷情况即可。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>6.1.1</td>
          <td>IFU_REDIRECT</td>
          <td>JAL</td>
          <td>预测请求中存在JAL预测错误，需要冲刷流水线</td>
      </tr>
      <tr>
          <td>6.1.2</td>
          <td>IFU_REDIRECT</td>
          <td>RET</td>
          <td>预测请求中存在RET预测错误，需要冲刷流水线</td>
      </tr>
      <tr>
          <td>6.1.3</td>
          <td>IFU_REDIRECT</td>
          <td>JALR</td>
          <td>预测请求中存在JALR预测错误，需要冲刷流水线</td>
      </tr>
      <tr>
          <td>6.1.4</td>
          <td>IFU_REDIRECT</td>
          <td>NON_CFI</td>
          <td>预测请求中存在非CFI预测错误，需要冲刷流水线</td>
      </tr>
      <tr>
          <td>6.1.5</td>
          <td>IFU_REDIRECT</td>
          <td>INVALID</td>
          <td>预测请求中存在无效指令预测错误，需要冲刷流水线</td>
      </tr>
      <tr>
          <td>6.1.6</td>
          <td>IFU_REDIRECT</td>
          <td>TARGET_FAULT</td>
          <td>预测请求中存在跳转目标错误，需要冲刷流水线</td>
      </tr>
  </tbody>
</table>
<h3 id="7-跨预测块32位指令处理">7. 跨预测块32位指令处理<a id="kyck_32"></a></h3>
<p>因为预测块的长度有限制，因此存在一条RVI指令前后两字节分别在两个预测块的情况。IFU首先在第一个预测块里检查最后2字节是不是一条RVI指令的开始，如果是并且该预测块没有跳转，那么就设置一个标识寄存器f3_lastHalf_valid，告诉接下来的预测块含有后半条指令。在F2预译码时，会产生两种不同的指令有效向量：</p>
<ul>
<li>
<p>预测块起始地址开始即为一条指令的开始，以这种方式根据后续指令是RVC还是RVI产生指令有效向量</p>
</li>
<li>
<p>预测块起始地址是一条RVI指令的中间，以起始地址 + 2位一条指令的开始产生有效向量</p>
</li>
</ul>
<p>在F3，根据是否有跨预测块RVI标识来决定选用哪种作为最终的指令有效向量，如果f3_lastHalf_valid为高则选择后一种（即这个预测块第一个2字节不是指令的开始）。IFU所做的处理只是把这条指令算在第一个预测块里，而把第二个预测块的起始地址位置的2字节通过改变指令有效向量来无效掉。</p>
<h4 id="71-跨预测块32位指令处理">7.1. 跨预测块32位指令处理</h4>
<p>如果发现当前预测块的最后两个字节是一条RVI指令的开始，则设置一个标识f3_lastHalf_valid，告诉接下来的预测块含有后半条指令。</p>
<p>我们没有办法直接观察到这个标识，但是可以通过下一预测块的开始向量的首位来判断。</p>
<h4 id="72-跨预测块指令误判">7.2. 跨预测块指令误判</h4>
<p>但是，如果这一判断出现问题（比如当前预测块存在跳转），则需要进行流水线冲刷。</p>
<p>这一功能需要PredChecker子模块“配合”（仅仅通过外部IO的修改很难触发这个防御机制），实现起来比较麻烦，但是还是列举一个测试点（见后文总表）</p>
<h3 id="8-将指令码和前端信息送入ibufferf3流水级">8. 将指令码和前端信息送入IBuffer（F3流水级）</h3>
<p>F3流水级最终得到经过扩展的32位指令码（或者对于非法指令直接传递原始指令码），以及16条指令中每条指令的例外信息、
预译码信息、FTQ队列中的指针位置、其他后端需要的信息（比如经过折叠的PC）等。IFU除了常规的valid-ready控制信号外，
还会给IBuffer两个特殊的信号：一个是16位的io_toIbuffer_bits_valid（因为我们最后组合出来的指令也是16条，
所以这里每一位刚好也对应一个指令的状态，为1说明是一条指令的开始，为0则是说明是一条指令的中间），标识预测块里有效的指令。
另一个是16位的io_toIbuffer_bits_enqEnable，这个在io_toIbuffer_bits_valid的基础上与上了被修正过的预测块的指令范围fixedRange。
enqEnable为1表示这个2字节指令码是一条指令的开始且在预测块表示的指令范围内。</p>
<p>除此之外，异常信息也需要写给IBuffer。</p>
<p>注意一个特例：当且仅当发生guest page fault时，后端需要gpaddr信息，为了节省面积，gpaddr不走正常通路进入ibuffer，
而是随ftqPtr被发送到gpaMem，后端需要时从gpaMem读出。IFU需要保证gpf发生时通向gpaMem的valid拉高、gpaddr正确。</p>
<h4 id="81-传送指令码和前端信息">8.1. 传送指令码和前端信息</h4>
<p>传送给IBuffer的信息包括：经过扩展的32位指令码、16条指令中每条指令的例外信息、预译码信息、FTQ队列中的指针位置、其他后端需要的信息（经过折叠的PC）、
io_toIbuffer_bits_valid（表示指令是否是一条指令的开始）、io_toIbuffer_bits_enqEnable（前者与上被修正过的预测块指令范围，
从而还能表示指令是否在预测块表示的指令范围内）。</p>
<p>这里要做的只是确认这些信息是否正确传递</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>8.1.1</td>
          <td>IFU_TO_IBUFFER</td>
          <td>INSTRS</td>
          <td>IFU向IBuffer传送扩展后的指令码</td>
      </tr>
      <tr>
          <td>8.1.2</td>
          <td>IFU_TO_IBUFFER</td>
          <td>EXCP</td>
          <td>IFU向IBuffer传送每个指令的异常信息</td>
      </tr>
      <tr>
          <td>8.1.3</td>
          <td>IFU_TO_IBUFFER</td>
          <td>PD_INFO</td>
          <td>IFU向IBuffer传递每个指令的预译码信息</td>
      </tr>
      <tr>
          <td>8.1.4</td>
          <td>IFU_TO_IBUFFER</td>
          <td>FTQ_PTR</td>
          <td>IFU向IBuffer传送FTQ预测块的指针</td>
      </tr>
      <tr>
          <td>8.1.5</td>
          <td>IFU_TO_IBUFFER</td>
          <td>FOLD_PC</td>
          <td>IFU向IBuffer传送折叠的PC</td>
      </tr>
      <tr>
          <td>8.1.6</td>
          <td>IFU_TO_IBUFFER</td>
          <td>VALID_STARTS</td>
          <td>IFU向IBuffer传送表示指令有效和指令是否为指令开始的向量</td>
      </tr>
  </tbody>
</table>
<h4 id="功能点82-客户页错误传送gpaddr信息">功能点8.2. 客户页错误传送gpaddr信息</h4>
<p>当且仅当发生guest page fault时，后端需要gpaddr信息，为了节省面积，gpaddr不走正常通路进入ibuffer，
而是随ftqPtr被发送到gpaMem，后端需要时从gpaMem读出。IFU需要保证gpf发生时通向gpaMem的valid拉高、gpaddr正确，同时还要传递预测块的ftqIdx（通过waddr传入）。</p>
<p>这里我们只需要确保在客户页错误发生时通向gpaMem的valid为高，且gpaddr正确填入。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>8.2.1</td>
          <td>IFU_TO_GPAMEM</td>
          <td>GPADDR</td>
          <td>客户页错误发生时，IFU应将gpaMem的valid拉高且填入gpaddr</td>
      </tr>
  </tbody>
</table>
<h3 id="9-分支预测overriding冲刷流水线">9. 分支预测overriding冲刷流水线</h3>
<p>当FTQ内未缓存足够预测块时，IFU可能直接使用简单分支预测器提供的预测地址进行取指，这种情况下，当精确预测器发现简单预测器错误时，需要通知IFU取消正在进行的取指请求。具体而言，当BPU的S2流水级和S3流水级发现错误时，需要冲刷且仅冲刷IFU的F0流水级（参见香山的提交<a href="https://github.com/OpenXiangShan/XiangShan/commit/6f9d483270d76b59c45187bb0889ae8a74ac7dc2">#6f9d483</a>）。</p>
<p>IFU在收到BPU发送的冲刷请求时，会将F0流水级上取指请求的指针与BPU发送的冲刷请求的指针进行比较，若冲刷的指针在取指的指针之前，说明当前取指请求在错误的执行路径上，需要进行流水线冲刷；反之，IFU可以忽略BPU发送的这一冲刷请求。此外，比较的时候还需要注意flag的情况，flag是一个指示队列循环的指针，flag不同即在不同的“圈”上，此时反而是idx的值更小，ftqIdx才会更大。</p>
<h4 id="91-核验指针">9.1 核验指针</h4>
<p>IFU收到BPU冲刷请求后，会将F0/F1流水级上取指令请求的指针比较，冲刷的指针在取指之前，即当前取指令请求在错误的执行路径上，才需要
冲刷IFU。</p>
<p>我们仍然需要从两个方向校验这个功能，即当冲刷指针在取指令的指针之前时，IFU能够对流水线进行冲刷。
然而，当冲刷指令在取指令的指针之后时，则不能对流水线进行冲刷。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>9.1.1</td>
          <td>IFU_OVERRIDE_FLUSH_CHECK</td>
          <td>BEFORE</td>
          <td>当冲刷指针在取指令的指针之前时，IFU能够对流水线进行冲刷。</td>
      </tr>
      <tr>
          <td>9.1.2</td>
          <td>IFU_OVERRIDE_FLUSH_CHECK</td>
          <td>NOT_BEFORE</td>
          <td>当冲刷指令在取指令的指针相同或之后时，IFU不能对流水线进行冲刷。</td>
      </tr>
  </tbody>
</table>
<h4 id="92-bpu-s2s3流水级发现错误">9.2 BPU S2/S3流水级发现错误</h4>
<p>BPU的S2和S3流水级发现错误时，需冲刷IFU的F0流水级。故设计下列检查点</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>9.2.1</td>
          <td>IFU_OVERRIDE_FLUSH</td>
          <td>S2</td>
          <td>当BPU的S2流水级出现错误，并且当前取指指针在错误执行路径上时，需要对IFU的F0流水级进行冲刷</td>
      </tr>
      <tr>
          <td>9.2.2</td>
          <td>IFU_OVERRIDE_FLUSH</td>
          <td>S3</td>
          <td>当BPU的S3流水级出现错误，并且当前取指指针在错误执行路径上时，需要对IFU的F0流水级进行冲刷</td>
      </tr>
  </tbody>
</table>
<h3 id="10-指令信息和误预测信息写回ftqwb阶段">10. 指令信息和误预测信息写回FTQ（WB阶段）</h3>
<p>在F3的下一级WB级，IFU将指令PC、预译码信息、错误预测指令的位置、正确的跳转地址以及预测块的正确指令范围等信息写回FTQ，同时传递该预测块的FTQ指针用以区分不同请求。</p>
<p>同时，正如前面提到的，IFU检测到预测错误时会进行前端冲刷，同样地，FTQ也需要据此进行冲刷，因此，这也是IFU写回错误信息的意义——可以辅助FTQ判断是否冲刷流水线。</p>
<h4 id="101-写回指令信息和误预测信息">10.1 写回指令信息和误预测信息</h4>
<p>将指令PC、预译码信息、错误预测指令的位置、正确的跳转地址以及预测块的正确指令范围等信息写回FTQ，并传递该预测块的FTQ指针。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>10.1.1</td>
          <td>IFU_WB_FTQ</td>
          <td>PCS</td>
          <td>IFU的WB流水级，需要向FTQ写回指令PC</td>
      </tr>
      <tr>
          <td>10.1.2</td>
          <td>IFU_WB_FTQ</td>
          <td>PD_INFO</td>
          <td>IFU的WB流水级，需要向FTQ写回每个指令的预译码信息</td>
      </tr>
      <tr>
          <td>10.1.3</td>
          <td>IFU_WB_FTQ</td>
          <td>ERR_POS</td>
          <td>IFU的WB流水级，需要向FTQ写回BPU错误预测的指令位置</td>
      </tr>
      <tr>
          <td>10.1.4</td>
          <td>IFU_WB_FTQ</td>
          <td>TARGET</td>
          <td>IFU的WB流水级，需要向FTQ写回该预测块的正确跳转地址</td>
      </tr>
      <tr>
          <td>10.1.5</td>
          <td>IFU_WB_FTQ</td>
          <td>RANGE</td>
          <td>IFU的WB流水级，需要向FTQ写回预测块的正确指令范围</td>
      </tr>
      <tr>
          <td>10.1.6</td>
          <td>IFU_WB_FTQ</td>
          <td>FTQ_PTR</td>
          <td>IFU的WB流水级，需要向FTQ传递预测块的FTQ指针</td>
      </tr>
  </tbody>
</table>
<h3 id="11-mmio处理逻辑">11. MMIO处理逻辑</h3>
<p>在处理器上电复位时，内存还没有准备好，此时需要从Flash中取指令执行。
这种情况下需要IFU向MMIO总线发送宽度为64位的请求从flash地址空间取指令执行。同时IFU禁止对MMIO总线的推测执行，即IFU需要等到每一条指令执行完成得到准确的下一条指令地址之后才继续向总线发送请求。</p>
<p>这之后，根据FTQ中的指令地址，决定是否MMIO取指令。</p>
<p><img src="f3_mmio_fsm.svg" alt="mmio_states"></p>
<ol>
<li>状态机默认在 <code>m_idle</code> 状态，若 F3 流水级是 MMIO 取指令请求，且此前没有发生异常，状态机进入 <code>m_waitLastCmt</code> 状态。</li>
<li>（<code>m_waitLastCmt</code>）IFU 通过 mmioCommitRead 端口到 FTQ 查询，IF3 预测块之前的指令是否都已提交，如果没有提交则阻塞等待前面的指令都提交完<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</li>
<li>（<code>m_sendReq</code>）将请求发送到 InstrUncache 模块，向 MMIO 总线发送请求。</li>
<li>（<code>m_waitResp</code>）InstrUncache 模块返回后根据 pc 从 64 位数据中截取指令码。</li>
<li>若 pc 低位为<code>3'b110</code>，由于 MMIO 总线的带宽限制为 8B 且只能访问对齐的区域，本次请求的高 2B 将不是有效的数据。若返回的指令数据表明指令不是 RVC 指令，则这种情况需要对 pc+2 的位置（即对齐到下一个 8B 的位置）进行重发才能取回完整的 4B 指令码。
<ol>
<li>重发前，需要重新对 pc+2 进行 ITLB 地址翻译和 PMP 检查（因为可能跨页）（<code>m_sendTLB</code>、<code>m_TLBResp</code>、<code>m_sendPMP</code>），若 ITLB 或 PMP 出现异常（access fault、page fault、guest page fault）、或检查发现 pc+2 的位置不在 MMIO 地址空间，则直接将异常信息发送到后端，不进行取指。</li>
<li>若无异常，（<code>m_resendReq</code>、<code>m_waitResendResp</code>）类似 2/3 两步向 InstrUncache 发出请求并收到指令码。</li>
</ol>
</li>
<li>当 IFU 寄存了完整的指令码，或出错（重发时的ITLB/PMP出错，<del>或 Uncache 模块 tilelink 总线返回 corrupt</del><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>）时，（<code>m_waitCommit</code>）即可将指令数据和异常信息发送到 IBuffer。需要注意，MMIO 取指令每次只能非推测性地向总线发起一条指令的取指请求，因此也只能向 IBuffer 发送一条指令数据。并等待指令提交。
<ol>
<li>若这条指令是 CFI 指令，由后端发送向 FTQ 发起冲刷。</li>
<li>若是顺序指令，则由 IFU 复用前端重定向通路刷新流水线，同时复用 FTQ 写回机制，把它当作一条错误预测的指令进行冲刷，重定向到该指令地址 +2 或者 +4（根据这条指令是 RVI 还是 RVC 选择）。这一机制保证了 MMIO 每次只取入一条指令。</li>
</ol>
</li>
<li>提交后，（<code>m_commited</code>）状态机复位到 <code>m_idle</code> 并清空各类寄存器。</li>
</ol>
<p>除了上电时，debug 扩展、Svpbmt 扩展可能也会使处理器在运行的任意时刻跳到一块 MMIO 地址空间取指令，请参考 RISC-V 手册。对这些情况中 MMIO 取指的处理是相同的。</p>
<h4 id="111-上电复位处理">11.1. 上电复位处理</h4>
<p>处理器上电复位时，IFU需向MMIO总线发送宽度为64位的请求从flash地址空间取指令，并禁止对MMIO总线的推测执行。</p>
<p>上电的情况和正常情况其实没有任何区别，但是，上电时的MMIO请求没有任何差别，只是，第一条请求一定是MMIO，并且不需要等待。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>11.1.1</td>
          <td>IFU_MMIO_RESET</td>
          <td>FIRST_MMIO</td>
          <td>IFU收到的第一条MMIO请求可以直接查询Instr Uncache</td>
      </tr>
  </tbody>
</table>
<h4 id="112-向instruncache发送请求">11.2. 向InstrUncache发送请求</h4>
<p>在正常的处理逻辑下，如果请求地址处于MMIO地址空间，则IFU会向FTQ查询指令提交状态，IFU需要等待当前请求之前的所有请求（包括MMIO和非MMIO）提交完成，
才能向InstrUncache模块发送请求。</p>
<p>这里需要和FTQ交互，可以让FTQ模拟请求提交情况，从而测试等待情况。
如果MMIO请求之前的请求都已经提交，则也不需要等待。反之，则需要一直等待直到查询结果表明前面的指令均已提交。</p>
<p>此外，对于属性为<code>NC</code>的内存区域，可以进行推测执行，无需等待前面的指令提交。</p>
<p>故设计测试点如下：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>11.2.1</td>
          <td>IFU_MMIO_SEND_UNCACHE</td>
          <td>BLOCK</td>
          <td>IFU收到MMIO请求后，查询FTQ，如果前面还有尚未提交的指令，持续等待</td>
      </tr>
      <tr>
          <td>11.2.2</td>
          <td>IFU_MMIO_SEND_UNCACHE</td>
          <td>FREE</td>
          <td>如果查到FTQ不再有未提交的指令，则IFU将指令发送给Instr Uncache</td>
      </tr>
      <tr>
          <td>11.2.3</td>
          <td>IFU_MMIO_SEND_UNCACHE</td>
          <td>NC</td>
          <td>对于属性为NC的内存区域，无需等待前一条指令完成提交</td>
      </tr>
  </tbody>
</table>
<h4 id="113-跨总线请求处理">11.3. 跨总线请求处理</h4>
<p>由于MMIO不支持非对齐访问，因此当检测到的RVI指令地址[2,1]两位为b11时，64位总线无法一次传递所有指令，所以需要增加地址进行重发，再次查询ITLB。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>11.3.1</td>
          <td>IFU_MMIO_RESEND_ITLB</td>
          <td>RESEND</td>
          <td>遇到一次无法查询完毕的RVI指令时，需要向ITLB查询获得新增指令的物理地址</td>
      </tr>
  </tbody>
</table>
<p>如果存在异常，则直接将指令和异常信息发送到IBuffer并等待，否则向PMP发送请求。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>11.3.2.1</td>
          <td>IFU_MMIO_RESEND_ITLB</td>
          <td>EXCP</td>
          <td>IFU查询ITLB出现异常时，应当将异常信息发送到IBuffer，然后等待ROB提交完成</td>
      </tr>
      <tr>
          <td>11.3.2.2</td>
          <td>IFU_MMIO_RESEND_ITLB</td>
          <td>PADDR</td>
          <td>IFU查询ITLB正常返回物理地址时，IFU继续向PMP请求检查</td>
      </tr>
  </tbody>
</table>
<p>根据pmp_recheck的结果，如果和上一次请求状态不一致，则说明存在访问错误，
为访问异常，不然则根据PMP的回复结果决定是否存在异常。如存在异常（访问异常和其他异常），则将报错信息发送给IBuffer并等待。如无异常，重新向InstrUncache模块
发送请求。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>11.3.3.1</td>
          <td>IFU_MMIO_PMP_RECHECK</td>
          <td>STATUS_DIFF</td>
          <td>IFU检查PMP之后如果发现重发请求状态和上一条请求状态不一致，是访问异常，需要将异常直接发送到IBuffer</td>
      </tr>
      <tr>
          <td>11.3.3.2</td>
          <td>IFU_MMIO_PMP_RECHECK</td>
          <td>EXCP</td>
          <td>PMP检查出现异常的情况下，也需要将异常直接发送到IBuffer并等待ROB提交。</td>
      </tr>
      <tr>
          <td>11.3.3.3</td>
          <td>IFU_MMIO_PMP_RECHECK</td>
          <td>RESEND_UNCACHE</td>
          <td>PMP检查若无异常，则向Instr Uncache发送请求获取指令码的后半部分。</td>
      </tr>
  </tbody>
</table>
<h4 id="114-向ibuffer发送指令">11.4. 向IBuffer发送指令</h4>
<p>IFU获得完整数据之后，根据地址从64位数据中截取指令码，并以每个预测块一条指令的形式发送到Ibuffer。等待ROB返回指令已提交的信号。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>11.4</td>
          <td>IFU_MMIO_TO_IBUFFER</td>
          <td>INSTR</td>
          <td>IFU在获得完整数据后，截取获得指令码，以每个预测块一条指令的形式发送给IBuffer</td>
      </tr>
  </tbody>
</table>
<h4 id="115-指令冲刷">11.5. 指令冲刷</h4>
<p>CFI指令的冲刷由后端发送给FTQ完成。所以只需要指令类型正确传达即可。</p>
<p>顺序指令由IFU复用前端重定向通路刷新流水线，并复用FTQ写回机制，将该指令当作误预测指令冲刷，重定向到+2或+4的位置。</p>
<p>+2和+4是由RVC和RVI指令决定的，所以设置测试点如下：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>11.5.1</td>
          <td>IFU_MMIO_FLUSH_NON_CFI</td>
          <td>RVI</td>
          <td>如果是RVI指令，传递给FTQ的冲刷请求应该重定向到PC+4</td>
      </tr>
      <tr>
          <td>11.5.2</td>
          <td>IFU_MMIO_FLUSH_NON_CFI</td>
          <td>RVC</td>
          <td>如果是RVC指令，传递给FTQ的冲刷请求应该重定向到PC+2</td>
      </tr>
  </tbody>
</table>
<h3 id="12-trigger实现对于pc的硬件断点功能">12. Trigger实现对于PC的硬件断点功能</h3>
<p>该工作主要由FrontEndTrigger子模块完成。本处先进行简单说明。</p>
<p>在 IFU 的 FrontendTrigger 模块里共 4 个 Trigger，编号为 0-3，每个 Trigger 的配置信息（断点类型、匹配地址等）保存在 <code>tdata</code> 寄存器中。</p>
<p>当软件向 CSR 寄存器 <code>tselect</code>、<code>tdata1/2</code> 写入特定的值时，CSR 会向 IFU 发送 tUpdate 请求，更新 FrontendTrigger 内的 <code>tdata</code> 寄存器中的配置信息。目前前端的 Trigger 仅可以配置成 PC 断点（<code>mcontrol.select</code> 寄存器为 0；当 <code>mcontrol.select</code>=1 时，该 Trigger 将永远不会命中，且不会产生异常）。</p>
<p>在取指时，IFU 的 F3 流水级会向 FrontendTrigger 模块发起查询并在同一周期得到结果。后者会对取指块内每一条指令在每一个 Trigger 上做检查，当不处于 debug 模式时，指令的 PC 和 <code>tdata2</code> 寄存器内容的关系满足 <code>mcontrol.match</code> 位所指示的关系（香山支持 <code>mcontrol.match</code> 位为 0、2、3，对应等于、大于、小于）时，该指令会被标记为 Trigger 命中，随着执行在后端产生断点异常，进入 M-Mode 或调试模式。前端的 Trigger 支持 Chain 功能。当它们对应的 <code>mcontrol.chain</code> 位被置时，只有当该 Trigger 和编号在它后面一位的 Trigger 同时命中时，处理器才会产生异常<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>。</p>
<p>FrontendTrigger的测试点可参照<a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/05_frontend_trigger/">子模块文档</a>，这里转录如下：</p>
<h3 id="121-设置断点和断点检查">12.1. 设置断点和断点检查</h3>
<p>FrontEndTrigger目前仅支持设置PC断点，这通过设置断点的tdata1寄存器的select位为0实现。
同时，tdata2寄存器的mcontrol位负责设置指令PC和tdata2寄存器的地址需要满足的关系，
关系满足时，该指令会被标记为trigger命中。</p>
<p>所以，基于以上功能描述，我们需要测试：</p>
<p>select位为1时，断点是否永远不会触发。</p>
<p>select位为0时，当PC和tdata2的数据的关系满足tdata2的match位时，是否会设置断点。</p>
<p>select位为0时，当PC和tdata2的数据的关系不满足tdata2的match位时，断点是否一定不会触发。</p>
<p>综上所述，我们在这一功能点设计的测试点如下：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>12.1.1</td>
          <td>IFU_FRONTEND_TRIGGER</td>
          <td>SELECT1</td>
          <td>给定tdata1的select位为1，随机构造其它输入，检查断点是否没有触发</td>
      </tr>
      <tr>
          <td>12.1.2.1</td>
          <td>IFU_FRONTEND_TRIGGER_SELECT0</td>
          <td>MATCH</td>
          <td>给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位匹配的输入，检查断点是否触发</td>
      </tr>
      <tr>
          <td>12.1.2.2</td>
          <td>IFU_FRONTEND_TRIGGER_SELECT0</td>
          <td>NOT_MATCH</td>
          <td>给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位不匹配的输入，检查断点是否触发</td>
      </tr>
  </tbody>
</table>
<h3 id="122-链式断点">12.2. 链式断点</h3>
<p>当某一个trigger的chain位被置后，当其后的trigger的chain位未设置，且两个trigger均命中时，后一个trigger才会触发。</p>
<p>对0号trigger，不需要考虑链式的情况</p>
<p>由此，我们可以设置几种测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>12.2.1</td>
          <td>IFU_FRONTEND_TRIGGER_CHAIN</td>
          <td>SELF</td>
          <td>对每个trigger，在满足PC断点触发条件的情况下，设置chain位，检查断点是否一定不触发。</td>
      </tr>
      <tr>
          <td>12.2.2.1</td>
          <td>IFU_FRONTEND_TRIGGER_CHAIN</td>
          <td>NOT_HIT</td>
          <td>对两个trigger，仅设置前一个trigger的chain位，设置后一个trigger命中而前一个未命中，检查后一个trigger是否一定不触发。</td>
      </tr>
      <tr>
          <td>12.2.2.2</td>
          <td>IFU_FRONTEND_TRIGGER_CHAIN</td>
          <td>HIT</td>
          <td>对两个trigger，仅设置前一个trigger的chain位且均命中，检查后一个trigger是否触发。</td>
      </tr>
  </tbody>
</table>
</mrs-functions>
<h2 id="ifu接口说明">IFU接口说明</h2>
<p>为方便测试开展，需要对IFU的接口进行进一步的说明，以明确各个接口的含义。</p>
<h3 id="ftq交互接口">FTQ交互接口</h3>
<p>编译后可用的接口包括：</p>
<h4 id="req-ftq取指请求">req FTQ取指请求</h4>
<p>在f0流水级传入</p>
<p>req是FTQ向IFU的取指令请求，编译后包含以下成员：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ftqIdx</td>
          <td>指示当前预测块在FTQ中的位置。</td>
      </tr>
      <tr>
          <td>ftqOffset</td>
          <td>指示预测块的大小</td>
      </tr>
      <tr>
          <td>startAddr</td>
          <td>当前预测块的起始地址。</td>
      </tr>
      <tr>
          <td>nextlineStart</td>
          <td>起始地址所在cacheline的下一个cacheline的开始地址。</td>
      </tr>
      <tr>
          <td>nextStartAddr</td>
          <td>下一个预测块的起始地址</td>
      </tr>
  </tbody>
</table>
<h4 id="redirect-ftq重定向请求">redirect FTQ重定向请求</h4>
<p>在f0流水级传入</p>
<p>FTQ会向IFU发送重定向请求，这通过fromFtq.redirect完成，从而指示IFU应该冲刷的内容。</p>
<p>编译后，redirect包含以下接口成员：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ftqIdx</td>
          <td>需要冲刷的ftq预测块序号，包含flag和value两个量。</td>
      </tr>
      <tr>
          <td>level</td>
          <td>重定向等级</td>
      </tr>
      <tr>
          <td>ftq_offset</td>
          <td>ftq预测块中跳转指令的位置</td>
      </tr>
  </tbody>
</table>
<p>此外，还有valid变量指示是否需要重定向。</p>
<h4 id="frombpuflush">fromBPUFlush</h4>
<p>在f0流水级传入</p>
<p>来自BPU的冲刷请求，这是预测错误引起的，包括s3和s2两个同构成员，指示是否在BPU的s3和s2流水级发现了问题，s3的详细结构如下</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>valid</td>
          <td>是否存在s3流水级冲刷要求</td>
      </tr>
      <tr>
          <td>ftqIdx</td>
          <td>s3流水级请求冲刷的预测块的指针</td>
      </tr>
  </tbody>
</table>
<h4 id="toftq_pdwb-写回">toFtq_pdWb 写回</h4>
<p>在WB阶段传出</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>cfioffset</td>
          <td>经由PredChecker修复的跳转指令的预测位置。但经过编译后，cfioffset的数值已经被优化了，只剩下了cfioffset_valid表示是否存在编译优化。</td>
      </tr>
      <tr>
          <td>ftqIdx</td>
          <td>表明预测块在FTQ中的位置，这条信息主要是对FTQ有用，要和FTQ传入的请求保持一致。</td>
      </tr>
      <tr>
          <td>instrRange</td>
          <td>可以看作是一个bool数组，表示该条指令是不是在这个预测块的有效指令范围内（即第一条有效跳转指令之前的指令）。</td>
      </tr>
      <tr>
          <td>jalTarget</td>
          <td>表明该预测块跳转指令的跳转目标。</td>
      </tr>
      <tr>
          <td>misOffset</td>
          <td>表明错误预测的指令在预测块中的位置。</td>
      </tr>
      <tr>
          <td>pc</td>
          <td>预测块中所有指令的PC指针。</td>
      </tr>
      <tr>
          <td>pd</td>
          <td>每条指令的预测信息，包括CFI指令的类型、isCall、isRet和isRVC。</td>
      </tr>
      <tr>
          <td>target</td>
          <td>该预测块最后一条指令的下一条指令的pc。</td>
      </tr>
  </tbody>
</table>
<h3 id="icache交互接口">ICache交互接口</h3>
<h4 id="控制信号">控制信号</h4>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>icache_ready</td>
          <td>ICache通知IFU自己已经准备好了，可以发送缓存行了。f0流水级就要设置。</td>
      </tr>
      <tr>
          <td>icache_stop</td>
          <td>IFU在F3流水级之前出现了问题，通知ICache停下。</td>
      </tr>
  </tbody>
</table>
<h4 id="icacheinterresp-icache传送给ifu的信息">ICacheInter.resp ICache传送给IFU的信息</h4>
<p>在f2流水级使用</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>data</td>
          <td>ICache传送的缓存行。</td>
      </tr>
      <tr>
          <td>doubleLine</td>
          <td>指示ICache传来的预测块是否跨缓存行。</td>
      </tr>
      <tr>
          <td>exception</td>
          <td>ICache向IFU报告每个缓存行上的异常情况，方便ICache生成每个指令的异常向量。</td>
      </tr>
      <tr>
          <td>backendException</td>
          <td>ICache向IFU报告后端是否存在异常</td>
      </tr>
      <tr>
          <td>gpaddr</td>
          <td>客户页地址</td>
      </tr>
      <tr>
          <td>isForVSnonLeafPTE</td>
          <td>是否为非叶的PTE，这个数据最终会流向写回gpaddrMem的信号</td>
      </tr>
      <tr>
          <td>itlb_pbmt</td>
          <td>ITLB基于客户页的内存类型，对MMIO状态有用</td>
      </tr>
      <tr>
          <td>paddr</td>
          <td>指令块的起始物理地址</td>
      </tr>
      <tr>
          <td>vaddr</td>
          <td>指令块起始虚拟地址、下一个缓存行的虚拟地址</td>
      </tr>
      <tr>
          <td>pmp_mmio</td>
          <td>指示当前指令块是否在MMIO空间</td>
      </tr>
  </tbody>
</table>
<h3 id="性能相关接口">性能相关接口</h3>
<p>ICachePerf和perf，可以先不关注。</p>
<h3 id="itlbinter">ITLBInter</h3>
<p>该接口仅在MMIO状态下，IFU重发请求时活跃（f3流水级用到）。</p>
<h4 id="req-ifu向itlb发送的请求">req IFU向ITLB发送的请求</h4>
<p>这是IFU向ITLB发送的查询请求，只有一个量：bits_vaddr，传递需要让ITLB查询的虚拟地址。</p>
<h4 id="resp-itlb返回给ifu的查询结果">resp ITLB返回给IFU的查询结果</h4>
<p>这是ITLB返回给IFU的查询结果，包含如下接口：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>excp</td>
          <td>指令的异常信息，包含三个量：访问异常指令af_instr、客户页错误指令gpf_instr、页错误指令pf_instr</td>
      </tr>
      <tr>
          <td>gpaddr</td>
          <td>客户页地址</td>
      </tr>
      <tr>
          <td>isForVSnonLeafPTE</td>
          <td>指示传入的是否是非叶PTE</td>
      </tr>
      <tr>
          <td>paddr</td>
          <td>指令物理地址</td>
      </tr>
      <tr>
          <td>pbmt</td>
          <td>指令的基于页的内存类型</td>
      </tr>
  </tbody>
</table>
<h3 id="uncacheinter">UncacheInter</h3>
<p>该接口在MMIO状态下活跃，负责接收IFU并返回指令码。</p>
<h4 id="touncache">toUncache</h4>
<p>这是IFU向Uncache发送的请求，除了ready和valid以外，还传送了一个48位数据，即需要获取的指令的物理地址。</p>
<h4 id="fromuncache">fromUncache</h4>
<p>这是Uncache给IFU的回复，除了valid以外，还传送一个32位数据，即指令码（可为RVC或RVI指令）</p>
<h3 id="toibuffer">toIbuffer</h3>
<p>IFU通过这个接口向Ibuffer写入取指结果。包含以下成员:</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>backendException</td>
          <td>是否存在后端异常</td>
      </tr>
      <tr>
          <td>crossPageIPFFix</td>
          <td>表示跨页异常向量</td>
      </tr>
      <tr>
          <td>valid</td>
          <td>和一般意义上的valid相区别，表示每条指令是否是合法指令的开始（RVI指令的上半条或者RVC指令）</td>
      </tr>
      <tr>
          <td>enqable</td>
          <td>对每条指令，其为valid并且在预测块的范围内</td>
      </tr>
      <tr>
          <td>exceptionType</td>
          <td>每个指令的异常类型</td>
      </tr>
      <tr>
          <td>foldpc</td>
          <td>压缩过后的pc</td>
      </tr>
      <tr>
          <td>ftqOffset</td>
          <td>指令是否在预测块范围中</td>
      </tr>
      <tr>
          <td>ftqPtr</td>
          <td>ftq预测块在FTQ的位置</td>
      </tr>
      <tr>
          <td>illegalInstr</td>
          <td>这条指令是否为非法指令</td>
      </tr>
      <tr>
          <td>instrs</td>
          <td>拼接后的指令码</td>
      </tr>
      <tr>
          <td>isLastInFtqEntry</td>
          <td>判断该指令是否为这个预测块中最后一条有效指令的开始</td>
      </tr>
      <tr>
          <td>pd</td>
          <td>指令控制信息，包括CFI指令的类型和RVC指令的判定</td>
      </tr>
      <tr>
          <td>triggered</td>
          <td>指令是否触发前端的trigger</td>
      </tr>
  </tbody>
</table>
<h3 id="tobackend_gpaddrmem">toBackend_gpaddrMem</h3>
<p>这组接口在gpfault发生时使用，由IFU向gpaddrMem传递预测块指针和页错误地址。</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>waddr</td>
          <td>传递ftq指针</td>
      </tr>
      <tr>
          <td>wdata.gpaddr</td>
          <td>传递出错的客户页地址</td>
      </tr>
      <tr>
          <td>wdata.isForVSnonLeafPTE</td>
          <td>指示是否为非叶PTE</td>
      </tr>
      <tr>
          <td>wen</td>
          <td>类似valid，指示gpaddrMem存在gpfault需要处理</td>
      </tr>
  </tbody>
</table>
<h3 id="io_csr_fsisoff">io_csr_fsIsOff</h3>
<p>指示是否使能了fs.CSR，对非法指令的判断很关键。</p>
<h3 id="rob_commits-来自rob的提交信息">rob_commits 来自ROB的提交信息</h3>
<p>共分为8个相同结构的rob_commit，包含以下成员</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ftqIdx</td>
          <td>预测块指针</td>
      </tr>
      <tr>
          <td>ftqOffset</td>
          <td>预测块的大小</td>
      </tr>
  </tbody>
</table>
<h3 id="pmp">pmp</h3>
<p>和物理内存保护相关，在mmio状态下重发请求时使用。</p>
<h4 id="req">req</h4>
<p>IFU向pmp发起的请求，传递前一步从ITLB查询得到的物理地址。</p>
<h4 id="resp">resp</h4>
<p>PMP给IFU的回复结果，包含以下成员</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>mmio</td>
          <td>在MMIO空间</td>
      </tr>
      <tr>
          <td>instr</td>
          <td>对指令的判断结果，当指令不可执行时，该值为true</td>
      </tr>
  </tbody>
</table>
<h3 id="mmio_commits">mmio_commits</h3>
<h4 id="mmioftqptr">mmioFtqPtr</h4>
<p>IFU传递给FTQ的idx，用于查询上一个预测块的MMIO状态</p>
<h4 id="mmiolastcommit">mmioLastCommit</h4>
<p>上一个请求是MMIO请求</p>
<h3 id="frontendtrigger">frontendTrigger</h3>
<p>用于设置前端断点</p>
<p>包含以下成员：</p>
<h4 id="debugmode">debugMode</h4>
<p>debug的模式</p>
<h4 id="triggercanraisebpexp">triggerCanRaiseBpExp</h4>
<p>trigger是否可以引起断点异常</p>
<h4 id="tenablevec">tEnableVec</h4>
<p>信号数组，表示是否使能对应的trigger</p>
<h4 id="tupdate">tupdate</h4>
<p>表示更新的断点信息，其中包含tdata和addr，addr是请求设置的断点idx。</p>
<p>tdata包括下列成员：</p>
<table>
  <thead>
      <tr>
          <th>接口名</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>matchType</td>
          <td>断点匹配类型，等于、大于、小于</td>
      </tr>
      <tr>
          <td>action</td>
          <td>触发执行的动作</td>
      </tr>
      <tr>
          <td>tdata2</td>
          <td>触发端点的基准数值</td>
      </tr>
      <tr>
          <td>select</td>
          <td>是否选择</td>
      </tr>
      <tr>
          <td>chain</td>
          <td>是否传导</td>
      </tr>
  </tbody>
</table>
<h2 id="接口时序">接口时序</h2>
<h3 id="ftq-请求接口时序示例">FTQ 请求接口时序示例</h3>
<p><img src="port1.png" alt="FTQ请求接口时序示例"></p>
<p>上图示意了三个 FTQ 请求的示例，req1 只请求缓存行 line0，紧接着 req2 请求 line1 和 line2，当到 req3 时，由于指令缓存 SRAM 写优先，此时指令缓存的读请求 ready 被指低，req3 请求的 valid 和地址保持直到请求被接收。</p>
<h3 id="icache-返回接口以及到-ibuffer-和写回-ftq-接口时序示例">ICache 返回接口以及到 Ibuffer 和写回 FTQ 接口时序示例</h3>
<p><img src="port2.png" alt="ICache返回接口以及到Ibuffer和写回FTQ接口时序示例"></p>
<p>上图展示了指令缓存返回数据到 IFU 发现误预测直到 FTQ 发送正确地址的时序，group0 对应的请求在 f2 阶段了两个缓存行 line0 和 line1，下一拍 IFU 做误预测检查并同时把指令给 Ibuffer，但此时后端流水线阻塞导致 Ibuffer 满，Ibuffer 接收端的 ready 置低，goup0 相关信号保持直到请求被 Ibuffer 接收。但是 IFU 到 FTQ 的写回在 tio_toIbuffer_valid 有效的下一拍就拉高，因为此时请求已经无阻塞地进入 wb 阶段，这个阶段锁存的了 PredChecker 的检查结果，报告 group0 第 4（从 0 开始）个 2 字节位置对应的指令发生了错误预测，应该重定向到 vaddrA，之后经过 4 拍（冲刷和重新走预测器流水线），FTQ 重新发送给 IFU 以 vaddrA 为起始地址的预测块。</p>
<h3 id="mmio-请求接口时序示例">MMIO 请求接口时序示例</h3>
<p><img src="port3.png" alt="MMIO请求接口时序示例"></p>
<p>上图展示了一个 MMIO 请求 req1 的取指令时序，首先 ICache 返回的 tlbExcp 信息报告了这是一条 MMIO 空间的指令（其他例外信号必须为低），过两拍 IFU 向 InstrUncache 发送请求，一段时间后收到响应和 32 位指令码，同拍 IFU 将这条指令作为一个预测块发送到 Ibuffer，同时发送对 FTQ 的写回，复用误预测信号端口，重定向地址为紧接着下一条指令的地址。此时 IFU 进入等待指令执行完成。一段时间后 rob_commits 端口报告此条指令执行完成，并且没有后端重定向。则 IFU 重新发起下一条 MMIO 指令的取指令请求。</p>
<h2><strong><a id="ifu_functions">测试点汇总 </a></strong></h2>
<p>再次声明，本测试点仅供参考，如果有其他测试点需要补充可以告知我们。</p>
<p>建议覆盖点采用<code>功能名称</code>_<code>测试点名称</code>命名。</p>
<mrs-testpoints>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#1-%e6%8e%a5%e6%94%b6ftq%e5%8f%96%e6%8c%87%e4%bb%a4%e8%af%b7%e6%b1%82f0%e6%b5%81%e6%b0%b4%e7%ba%a7">IFU_RCV_REQ</a></td>
          <td>READY</td>
          <td>IFU接收FTQ请求后，设置ready</td>
      </tr>
      <tr>
          <td>2.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#21-f1%e6%b5%81%e6%b0%b4%e7%ba%a7%e8%ae%a1%e7%ae%97%e4%bf%a1%e6%81%af%e5%92%8c%e5%88%87%e5%88%86%e6%8c%87%e9%92%88">IFU_F1_INFOS</a></td>
          <td>PC</td>
          <td>IFU接收FTQ请求后，在F1流水级生成PC</td>
      </tr>
      <tr>
          <td>2.1.2</td>
          <td>IFU_F1_INFOS</td>
          <td>CUT_PTR</td>
          <td>IFU接收FTQ请求后，在F1流水级生成后续切取缓存行的指针</td>
      </tr>
      <tr>
          <td>2.2.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#22-f2%e6%b5%81%e6%b0%b4%e7%ba%a7%e8%8e%b7%e5%8f%96%e6%8c%87%e4%bb%a4%e4%bf%a1%e6%81%af">IFU_F2_INFOS</a></td>
          <td>EXCP_VEC</td>
          <td>IFU接收ICache内容后，会根据ICache的结果生成属于每个指令的异常向量</td>
      </tr>
      <tr>
          <td>2.2.2</td>
          <td>IFU_F2_INFOS</td>
          <td>PADDR</td>
          <td>IFU接收ICache内容后，会根据ICache的结果生成属于每个端口的物理地址。</td>
      </tr>
      <tr>
          <td>2.2.3</td>
          <td>IFU_F2_INFOS</td>
          <td>GPADDR</td>
          <td>IFU接收ICache内容后，会根据ICache的结果生成0号端口的客户物理地址。</td>
      </tr>
      <tr>
          <td>2.2.4</td>
          <td>IFU_F2_INFOS</td>
          <td>MMIO</td>
          <td>IFU接收ICache内容后，会根据ICache的结果判断当前取指请求是否属于MMIO空间。</td>
      </tr>
      <tr>
          <td>2.3.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#23-f2%e6%b5%81%e6%b0%b4%e7%ba%a7%e8%ae%a1%e7%ae%97%e9%a2%84%e6%b5%8b%e5%9d%97%e6%9c%89%e6%95%88%e6%8c%87%e4%bb%a4%e8%8c%83%e5%9b%b4">IFU_INSTR_VALID_RANGE</a></td>
          <td>NORMAL</td>
          <td>IFU根据FTQ请求，计算无跳转指令有效范围</td>
      </tr>
      <tr>
          <td>2.3.2</td>
          <td>IFU_INSTR_VALID_RANGE</td>
          <td>JUMP</td>
          <td>IFU根据FTQ请求，计算跳转指令有效范围</td>
      </tr>
      <tr>
          <td>2.3.3</td>
          <td>IFU_INSTR_VALID_RANGE</td>
          <td>FINAL</td>
          <td>IFU综合两类指令有效范围，生成最终指令有效范围</td>
      </tr>
      <tr>
          <td>2.4</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#24-%e6%8f%90%e5%8f%96%e5%88%9d%e5%a7%8b%e6%8c%87%e4%bb%a4%e7%a0%81">IFU_INSTR_CUT</a></td>
          <td>CUT</td>
          <td>IFU根据上一流水级的切取指针，从缓存行提取初始指令码。</td>
      </tr>
      <tr>
          <td>3.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#31-%e6%8c%87%e4%bb%a4%e7%a0%81%e6%8b%bc%e6%8e%a5">IFU_PREDECODE</a></td>
          <td>CONCAT</td>
          <td>将生成的指令序列拼接成为16x4的指令码序列</td>
      </tr>
      <tr>
          <td>3.2.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#32-%e5%88%a4%e5%ae%9arvc%e6%8c%87%e4%bb%a4">IFU_PREDECODE_RVC</a></td>
          <td>RVC</td>
          <td>传入RVC指令，应该判断为RVC</td>
      </tr>
      <tr>
          <td>3.2.2</td>
          <td>IFU_PREDECODE_RVC</td>
          <td>RVI</td>
          <td>传入RVI指令，不应判断为RVC</td>
      </tr>
      <tr>
          <td>3.3.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#33-%e8%ae%a1%e7%ae%97%e8%b7%b3%e8%bd%ac%e5%81%8f%e7%a7%bb">IFU_PREDECODE_JMP_TGT</a></td>
          <td>RVC_J</td>
          <td>对传入RVC扩展的J指令，检查计算的偏移</td>
      </tr>
      <tr>
          <td>3.3.2</td>
          <td>IFU_PREDECODE_JMP_TGT</td>
          <td>RVI_J</td>
          <td>对传入RVI扩展的J指令，检查计算的偏移</td>
      </tr>
      <tr>
          <td>3.3.3</td>
          <td>IFU_PREDECODE_JMP_TGT</td>
          <td>RVC_BR</td>
          <td>对传入RVC扩展的BR指令，检查计算的偏移</td>
      </tr>
      <tr>
          <td>3.3.4</td>
          <td>IFU_PREDECODE_JMP_TGT</td>
          <td>RVI_BR</td>
          <td>对传入RVI扩展的BR指令，检查计算的偏移</td>
      </tr>
      <tr>
          <td>3.4.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#34-%e5%88%a4%e5%ae%9acfi%e6%8c%87%e4%bb%a4%e7%b1%bb%e5%9e%8b">IFU_PREDECODE_CFI_TYPE</a></td>
          <td>NON_CFI</td>
          <td>对传入的非CFI指令（包括RVC.EBREAK），应该判定为类型0</td>
      </tr>
      <tr>
          <td>3.4.2</td>
          <td>IFU_PREDECODE_CFI_TYPE</td>
          <td>BR</td>
          <td>对传入的BR指令，应该判定为类型1</td>
      </tr>
      <tr>
          <td>3.4.3</td>
          <td>IFU_PREDECODE_CFI_TYPE</td>
          <td>JAL</td>
          <td>对传入的JAL指令，应该判定为类型2</td>
      </tr>
      <tr>
          <td>3.4.4</td>
          <td>IFU_PREDECODE_CFI_TYPE</td>
          <td>JALR</td>
          <td>对传入的JALR指令，应该判定为类型3</td>
      </tr>
      <tr>
          <td>3.5.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#35-%e5%88%a4%e5%ae%9aret%e5%92%8ccall">IFU_PREDECODE_RET_CALL</a></td>
          <td>NON_CFI_BR</td>
          <td>对传入的非CFI和BR指令，都不应判定为call或者ret</td>
      </tr>
      <tr>
          <td>3.5.2.1.1</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVI_JAL_CALL</td>
          <td>对传入的RVI.JAL指令，当rd设置为1或5，应当判定该指令为call</td>
      </tr>
      <tr>
          <td>3.5.2.1.2</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVI_JAL_NOP</td>
          <td>对传入的RVI.JAL指令，当rd设置为1和5之外的值，不应当判定该指令为call或ret</td>
      </tr>
      <tr>
          <td>3.5.2.2</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVC_JAL_NOP</td>
          <td>对传入的RVC.JAL指令，无论什么情况都不能判定为call或ret</td>
      </tr>
      <tr>
          <td>3.5.3.1.1</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVI_JALR_CALL</td>
          <td>传入RVI.JALR指令，并且rd为1或5，无论其他取值，都应判定为call</td>
      </tr>
      <tr>
          <td>3.5.3.1.2</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVI_JALR_RET</td>
          <td>传入RVI.JALR指令，rd不为1和5，rs为1或5，应判定为ret</td>
      </tr>
      <tr>
          <td>3.5.3.1.3</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVI_JALR_NOP</td>
          <td>对传入的JALR指令，若rd和rs均不为link，则不应判定为ret和call</td>
      </tr>
      <tr>
          <td>3.5.3.2.1</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVC_JALR_CALL</td>
          <td>传入RVC.JALR指令，必定为call</td>
      </tr>
      <tr>
          <td>3.5.3.2.2.1</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVC_JR_RET</td>
          <td>传入RVC.JR指令，rs为1或5，应判定为ret</td>
      </tr>
      <tr>
          <td>3.5.3.2.2.2</td>
          <td>IFU_PREDECODE_RET_CALL</td>
          <td>RVC_JR_NOP</td>
          <td>传入RVC.JR指令，rs不为1或5，不应判定为ret</td>
      </tr>
      <tr>
          <td>3.6.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#36-%e8%ae%a1%e7%ae%97%e6%8c%87%e4%bb%a4%e6%9c%89%e6%95%88%e5%bc%80%e5%a7%8b%e5%90%91%e9%87%8f">IFU_PREDECODE_VALID_STARTS</a></td>
          <td>LAST_IS_END</td>
          <td>上一预测块的最后2字节恰为RVC指令或RVI指令的后半部分，按第一位为True推导有效开始向量</td>
      </tr>
      <tr>
          <td>3.6.2</td>
          <td>IFU_PREDECODE_VALID_STARTS</td>
          <td>LAST_NOT_END</td>
          <td>上一预测块的最后2字节上一预测块的最后2字节为RVI指令的前半部分，按第一位为False推导有效开始向量</td>
      </tr>
      <tr>
          <td>4.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#41-%e6%8c%87%e4%bb%a4%e6%89%a9%e5%b1%95%e5%92%8c%e6%a3%80%e9%94%99">IFU_RVC_EXPAND</a></td>
          <td>VALID_RVC</td>
          <td>对合法RVC指令，写扩展后的指令码，判断结果为合法指令</td>
      </tr>
      <tr>
          <td>4.1.2</td>
          <td>IFU_RVC_EXPAND</td>
          <td>INVALID_RVC</td>
          <td>对非法RVC指令，写原始指令码，判断结果为非法指令</td>
      </tr>
      <tr>
          <td>4.1.3</td>
          <td>IFU_RVC_EXPAND</td>
          <td>RVI</td>
          <td>RVI指令直接写入原始指令即可，判断结果为合法指令</td>
      </tr>
      <tr>
          <td>5.1.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#51-bpu%e9%a2%84%e6%b5%8b%e4%bf%a1%e6%81%af%e7%9a%84jal%e9%a2%84%e6%b5%8b%e9%94%99%e8%af%af%e6%a3%80%e6%9f%a5">IFU_PRECHECK_JAL_MISS</a></td>
          <td>NOP</td>
          <td>预测块中没有JAL指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JAL预测错误。</td>
      </tr>
      <tr>
          <td>5.1.2.1</td>
          <td>IFU_PRECHECK_JAL_MISS</td>
          <td>CORRECT</td>
          <td>预测块中有JAL指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JAL预测错误。</td>
      </tr>
      <tr>
          <td>5.1.2.1</td>
          <td>IFU_PRECHECK_JAL_CHECK</td>
          <td>NO_SEL</td>
          <td>预测块中存在JAL指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出JAL预测错误。</td>
      </tr>
      <tr>
          <td>5.1.2.2</td>
          <td>IFU_PRECHECK_JAL_CHECK</td>
          <td>SEL_LATE</td>
          <td>预测块中存在JAL指令，但是BPU预测信息取的跳转指令在第一条JAL指令之后，检查PredChecker是否能检测出JAL预测错误。</td>
      </tr>
      <tr>
          <td>5.2.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#52-bpu%e9%a2%84%e6%b5%8b%e4%bf%a1%e6%81%af%e7%9a%84ret%e9%a2%84%e6%b5%8b%e9%94%99%e8%af%af%e6%a3%80%e6%9f%a5">IFU_PRECHECK_RET_MISS</a></td>
          <td>NOP</td>
          <td>预测块中没有RET指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报RET预测错误。</td>
      </tr>
      <tr>
          <td>5.2.2.1</td>
          <td>IFU_PRECHECK_RET_MISS</td>
          <td>CORRECT</td>
          <td>预测块中有RET指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报RET预测错误。</td>
      </tr>
      <tr>
          <td>5.2.2.1</td>
          <td>IFU_PRECHECK_RET_CHECK</td>
          <td>NO_SEL</td>
          <td>预测块中存在RET指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出RET预测错误。</td>
      </tr>
      <tr>
          <td>5.2.2.2</td>
          <td>IFU_PRECHECK_RET_CHECK</td>
          <td>SEL_LATE</td>
          <td>预测块中存在RET指令，但是BPU预测信息取的跳转指令在第一条RET指令之后，检查PredChecker是否能检测出RET预测错误。</td>
      </tr>
      <tr>
          <td>5.3.2.2</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#53-bpu%e9%a2%84%e6%b5%8b%e4%bf%a1%e6%81%af%e7%9a%84jalr%e9%a2%84%e6%b5%8b%e9%94%99%e8%af%af%e6%a3%80%e6%9f%a5">IFU_PRECHECK_JALR_MISS</a></td>
          <td>NOP</td>
          <td>预测块中没有JALR指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JALR预测错误。</td>
      </tr>
      <tr>
          <td>5.3.2.2</td>
          <td>IFU_PRECHECK_JALR_MISS</td>
          <td>CORRECT</td>
          <td>预测块中有JALR指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JALR预测错误。</td>
      </tr>
      <tr>
          <td>5.3.2.2</td>
          <td>IFU_PRECHECK_JALR_CHECK</td>
          <td>NO_SEL</td>
          <td>预测块中存在JALR指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出RET预测错误。</td>
      </tr>
      <tr>
          <td>5.3.2.2</td>
          <td>IFU_PRECHECK_JALR_CHECK</td>
          <td>SEL_LATE</td>
          <td>预测块中存在JALR指令，但是BPU预测信息取的跳转指令在第一条JALR指令之后，检查PredChecker是否能检测出JALR预测错误。</td>
      </tr>
      <tr>
          <td>5.4.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#54-%e6%9b%b4%e6%96%b0%e6%8c%87%e4%bb%a4%e6%9c%89%e6%95%88%e8%8c%83%e5%9b%b4%e5%90%91%e9%87%8f%e5%92%8c%e9%a2%84%e6%b5%8b%e8%b7%b3%e8%bd%ac%e7%9a%84%e6%8c%87%e4%bb%a4">IFU_PREDCHECK_FIX</a></td>
          <td>NOP</td>
          <td>不存在任何错误的情况下，PredChecker应当保留之前的预测结果。</td>
      </tr>
      <tr>
          <td>5.4.2</td>
          <td>IFU_PREDCHECK_FIX</td>
          <td>BIGGER_FIX</td>
          <td>如果检测到了JAL、RET、JALR类的预测错误，PredChecker应该将有效指令的范围修正为预测块开始至第一条跳转指令。同时，应该将预测跳转的指令位置修正为预测块中的第一条跳转指令。</td>
      </tr>
      <tr>
          <td>5.4.3</td>
          <td>IFU_PREDCHECK_FIX</td>
          <td>SMALLER_NOP</td>
          <td>如果出现了非控制流指令和无效指令的误预测，不应该将预测跳转的指令重新修正到预测块中第一条跳转指令（也即不能扩大范围），因为后续会直接冲刷并重新从重定向的位置取指令，如果这里修正的话，会导致下一预测块传入重复的指令</td>
      </tr>
      <tr>
          <td>5.5.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#55-%e9%9d%9ecfi%e9%a2%84%e6%b5%8b%e9%94%99%e8%af%af%e6%a3%80%e6%9f%a5">IFU_PREDCHECK_NON_CFI_MISS</a></td>
          <td>NOP</td>
          <td>构造不存在CFI指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检非CFI预测错误</td>
      </tr>
      <tr>
          <td>5.5.1.2</td>
          <td>IFU_PREDCHECK_NON_CFI_MISS</td>
          <td>CORRECT</td>
          <td>构造存在CFI指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检非CFI预测错误</td>
      </tr>
      <tr>
          <td>5.5.2</td>
          <td>IFU_PREDCHECK_NON_CFI_CHECK</td>
          <td>ERROR</td>
          <td>构造不存在CFI指令但是预测了跳转的预测信息作为输入，测试PredChecker是否能检查出非CFI预测错误</td>
      </tr>
      <tr>
          <td>5.6.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#56-%e6%97%a0%e6%95%88%e6%8c%87%e4%bb%a4%e9%a2%84%e6%b5%8b%e9%94%99%e8%af%af%e6%a3%80%e6%9f%a5">IFU_PREDCHECK_INVALID_MISS</a></td>
          <td>NOP</td>
          <td>构造不存在跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误</td>
      </tr>
      <tr>
          <td>5.6.1.2</td>
          <td>IFU_PREDCHECK_INVALID_MISS</td>
          <td>INVALID_JMP</td>
          <td>构造存在无效跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误</td>
      </tr>
      <tr>
          <td>5.6.1.3</td>
          <td>IFU_PREDCHECK_INVALID_MISS</td>
          <td>CORRECT</td>
          <td>构造存在有效跳转指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误</td>
      </tr>
      <tr>
          <td>5.6.2</td>
          <td>IFU_PREDCHECK_INVALID_MISS</td>
          <td>ERROR</td>
          <td>构造无效指令但是预测了跳转的预测信息作为输入，测试PredChecker是否能检查出无效指令预测错误</td>
      </tr>
      <tr>
          <td>5.7.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#57-%e7%9b%ae%e6%a0%87%e5%9c%b0%e5%9d%80%e9%a2%84%e6%b5%8b%e9%94%99%e8%af%af%e6%a3%80%e6%9f%a5">IFU_PREDCHECK_TARGET_MISS</a></td>
          <td>NOP</td>
          <td>构造不存在跳转指令并且未预测跳转的预测信息作输入，测试PredChecker是否会错检目标地址预测错误</td>
      </tr>
      <tr>
          <td>5.7.1.2</td>
          <td>IFU_PREDCHECK_TARGET_MISS</td>
          <td>CORRECT</td>
          <td>构造存在有效跳转指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检目标地址预测错误</td>
      </tr>
      <tr>
          <td>5.7.2</td>
          <td>IFU_PREDCHECK_TARGET_CHECK</td>
          <td>ERROR</td>
          <td>构造存在有效跳转指令的预测块和预测跳转但跳转目标计算错误的预测信息作为输入，测试PredChecker能否检出目标地址预测错误</td>
      </tr>
      <tr>
          <td>5.8</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#58-%e7%94%9f%e6%88%90%e8%b7%b3%e8%bd%ac%e5%92%8c%e9%a1%ba%e5%ba%8f%e7%9b%ae%e6%a0%87">IFU_PREDCHECK_TARGETS</a></td>
          <td>TARGETS</td>
          <td>随机提供译码信息，检测生成的跳转目标和顺序目标。</td>
      </tr>
      <tr>
          <td>6.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#61-%e9%a2%84%e6%b5%8b%e9%94%99%e8%af%af%e9%87%8d%e5%ae%9a%e5%90%91">IFU_REDIRECT</a></td>
          <td>JAL</td>
          <td>预测请求中存在JAL预测错误，需要冲刷流水线</td>
      </tr>
      <tr>
          <td>6.1.2</td>
          <td>IFU_REDIRECT</td>
          <td>RET</td>
          <td>预测请求中存在RET预测错误，需要冲刷流水线</td>
      </tr>
      <tr>
          <td>6.1.3</td>
          <td>IFU_REDIRECT</td>
          <td>JALR</td>
          <td>预测请求中存在JALR预测错误，需要冲刷流水线</td>
      </tr>
      <tr>
          <td>6.1.4</td>
          <td>IFU_REDIRECT</td>
          <td>NON_CFI</td>
          <td>预测请求中存在非CFI预测错误，需要冲刷流水线</td>
      </tr>
      <tr>
          <td>6.1.5</td>
          <td>IFU_REDIRECT</td>
          <td>INVALID</td>
          <td>预测请求中存在无效指令预测错误，需要冲刷流水线</td>
      </tr>
      <tr>
          <td>6.1.6</td>
          <td>IFU_REDIRECT</td>
          <td>TARGET_FAULT</td>
          <td>预测请求中存在跳转目标错误，需要冲刷流水线</td>
      </tr>
      <tr>
          <td>7.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#71-%e8%b7%a8%e9%a2%84%e6%b5%8b%e5%9d%9732%e4%bd%8d%e6%8c%87%e4%bb%a4%e5%a4%84%e7%90%86">IFU_CROSS_BLOCK</a></td>
          <td>NORMAL</td>
          <td>连续传入两个预测块，其中有一条32位指令跨两个预测块，后一个预测块的指令开始向量的首位应该为False</td>
      </tr>
      <tr>
          <td>7.2</td>
          <td>IFU_CROSS_BLOCK</td>
          <td>ERROR</td>
          <td>当IFU根据PredChecker修复的指令有效范围错判了跨预测块指令时，需要将F3以外的流水级全部冲刷</td>
      </tr>
      <tr>
          <td>8.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#81-%e4%bc%a0%e9%80%81%e6%8c%87%e4%bb%a4%e7%a0%81%e5%92%8c%e5%89%8d%e7%ab%af%e4%bf%a1%e6%81%af">IFU_TO_IBUFFER</a></td>
          <td>INSTRS</td>
          <td>IFU向IBuffer传送扩展后的指令码</td>
      </tr>
      <tr>
          <td>8.1.2</td>
          <td>IFU_TO_IBUFFER</td>
          <td>EXCP</td>
          <td>IFU向IBuffer传送每个指令的异常信息</td>
      </tr>
      <tr>
          <td>8.1.3</td>
          <td>IFU_TO_IBUFFER</td>
          <td>PD_INFO</td>
          <td>IFU向IBuffer传递每个指令的预译码信息</td>
      </tr>
      <tr>
          <td>8.1.4</td>
          <td>IFU_TO_IBUFFER</td>
          <td>FTQ_PTR</td>
          <td>IFU向IBuffer传送FTQ预测块的指针</td>
      </tr>
      <tr>
          <td>8.1.5</td>
          <td>IFU_TO_IBUFFER</td>
          <td>FOLD_PC</td>
          <td>IFU向IBuffer传送折叠的PC</td>
      </tr>
      <tr>
          <td>8.1.6</td>
          <td>IFU_TO_IBUFFER</td>
          <td>VALID_STARTS</td>
          <td>IFU向IBuffer传送表示指令有效和指令是否为指令开始的向量</td>
      </tr>
      <tr>
          <td>8.2.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#%e5%8a%9f%e8%83%bd%e7%82%b982-%e5%ae%a2%e6%88%b7%e9%a1%b5%e9%94%99%e8%af%af%e4%bc%a0%e9%80%81gpaddr%e4%bf%a1%e6%81%af">IFU_TO_GPAMEM</a></td>
          <td>GPADDR</td>
          <td>客户页错误发生时，IFU应将gpaMem的valid拉高且填入gpaddr</td>
      </tr>
      <tr>
          <td>9.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#91-%e6%a0%b8%e9%aa%8c%e6%8c%87%e9%92%88">IFU_OVERRIDE_FLUSH_CHECK</a></td>
          <td>BEFORE</td>
          <td>当冲刷指针在取指令的指针之前时，IFU能够对流水线进行冲刷。</td>
      </tr>
      <tr>
          <td>9.1.2</td>
          <td>IFU_OVERRIDE_FLUSH_CHECK</td>
          <td>NOT_BEFORE</td>
          <td>当冲刷指令在取指令的指针相同或之后时，IFU不能对流水线进行冲刷。</td>
      </tr>
      <tr>
          <td>9.2.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#92-bpu-s2s3%e6%b5%81%e6%b0%b4%e7%ba%a7%e5%8f%91%e7%8e%b0%e9%94%99%e8%af%af">IFU_OVERRIDE_FLUSH</a></td>
          <td>S2</td>
          <td>当BPU的S2流水级出现错误，并且当前取指指针在错误执行路径上时，需要对IFU的F0流水级进行冲刷</td>
      </tr>
      <tr>
          <td>9.2.2</td>
          <td>IFU_OVERRIDE_FLUSH</td>
          <td>S3</td>
          <td>当BPU的S3流水级出现错误，并且当前取指指针在错误执行路径上时，需要对IFU的F0流水级进行冲刷</td>
      </tr>
      <tr>
          <td>10.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#101-%e5%86%99%e5%9b%9e%e6%8c%87%e4%bb%a4%e4%bf%a1%e6%81%af%e5%92%8c%e8%af%af%e9%a2%84%e6%b5%8b%e4%bf%a1%e6%81%af">IFU_WB_FTQ</a></td>
          <td>PCS</td>
          <td>IFU的WB流水级，需要向FTQ写回指令PC</td>
      </tr>
      <tr>
          <td>10.1.2</td>
          <td>IFU_WB_FTQ</td>
          <td>PD_INFO</td>
          <td>IFU的WB流水级，需要向FTQ写回每个指令的预译码信息</td>
      </tr>
      <tr>
          <td>10.1.3</td>
          <td>IFU_WB_FTQ</td>
          <td>ERR_POS</td>
          <td>IFU的WB流水级，需要向FTQ写回BPU错误预测的指令位置</td>
      </tr>
      <tr>
          <td>10.1.4</td>
          <td>IFU_WB_FTQ</td>
          <td>TARGET</td>
          <td>IFU的WB流水级，需要向FTQ写回该预测块的正确跳转地址</td>
      </tr>
      <tr>
          <td>10.1.5</td>
          <td>IFU_WB_FTQ</td>
          <td>RANGE</td>
          <td>IFU的WB流水级，需要向FTQ写回预测块的正确指令范围</td>
      </tr>
      <tr>
          <td>10.1.6</td>
          <td>IFU_WB_FTQ</td>
          <td>FTQ_PTR</td>
          <td>IFU的WB流水级，需要向FTQ传递预测块的FTQ指针</td>
      </tr>
      <tr>
          <td>11.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#%e5%8a%9f%e8%83%bd%e7%82%b9111-%e4%b8%8a%e7%94%b5%e5%a4%8d%e4%bd%8d%e5%a4%84%e7%90%86">IFU_MMIO_RESET</a></td>
          <td>FIRST_MMIO</td>
          <td>IFU收到的第一条MMIO请求可以直接查询Instr Uncache</td>
      </tr>
      <tr>
          <td>11.2.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#112-%e5%90%91instruncache%e5%8f%91%e9%80%81%e8%af%b7%e6%b1%82">IFU_MMIO_SEND_UNCACHE</a></td>
          <td>BLOCK</td>
          <td>IFU收到MMIO请求后，查询FTQ，如果前面还有尚未提交的指令，持续等待</td>
      </tr>
      <tr>
          <td>11.2.2</td>
          <td>IFU_MMIO_SEND_UNCACHE</td>
          <td>FREE</td>
          <td>如果查到FTQ不再有未提交的指令，则IFU将指令发送给Instr Uncache</td>
      </tr>
      <tr>
          <td>11.2.3</td>
          <td>IFU_MMIO_SEND_UNCACHE</td>
          <td>NC</td>
          <td>对于属性为NC的内存区域，无需等待前一条指令完成提交</td>
      </tr>
      <tr>
          <td>11.3.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#113-%e8%b7%a8%e6%80%bb%e7%ba%bf%e8%af%b7%e6%b1%82%e5%a4%84%e7%90%86">IFU_MMIO_RESEND_ITLB</a></td>
          <td>RESEND</td>
          <td>遇到一次无法查询完毕的RVI指令时，需要向ITLB查询获得新增指令的物理地址</td>
      </tr>
      <tr>
          <td>11.3.2.1</td>
          <td>IFU_MMIO_RESEND_ITLB</td>
          <td>EXCP</td>
          <td>IFU查询ITLB出现异常时，应当将异常信息发送到IBuffer，然后等待ROB提交完成</td>
      </tr>
      <tr>
          <td>11.3.2.2</td>
          <td>IFU_MMIO_RESEND_ITLB</td>
          <td>PADDR</td>
          <td>IFU查询ITLB正常返回物理地址时，IFU继续向PMP请求检查</td>
      </tr>
      <tr>
          <td>11.3.3.1</td>
          <td>IFU_MMIO_PMP_RECHECK</td>
          <td>STATUS_DIFF</td>
          <td>IFU检查PMP之后如果发现重发请求状态和上一条请求状态不一致，是访问异常，需要将异常直接发送到IBuffer</td>
      </tr>
      <tr>
          <td>11.3.3.2</td>
          <td>IFU_MMIO_PMP_RECHECK</td>
          <td>EXCP</td>
          <td>PMP检查出现异常的情况下，也需要将异常直接发送到IBuffer并等待ROB提交。</td>
      </tr>
      <tr>
          <td>11.3.3.3</td>
          <td>IFU_MMIO_PMP_RECHECK</td>
          <td>RESEND_UNCACHE</td>
          <td>PMP检查若无异常，则向Instr Uncache发送请求获取指令码的后半部分。</td>
      </tr>
      <tr>
          <td>11.4</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#114-%e5%90%91ibuffer%e5%8f%91%e9%80%81%e6%8c%87%e4%bb%a4">IFU_MMIO_TO_IBUFFER</a></td>
          <td>INSTR</td>
          <td>IFU在获得完整数据后，截取获得指令码，以每个预测块一条指令的形式发送给IBuffer</td>
      </tr>
      <tr>
          <td>11.5.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#115-%e6%8c%87%e4%bb%a4%e5%86%b2%e5%88%b7">IFU_MMIO_FLUSH_NON_CFI</a></td>
          <td>RVI</td>
          <td>如果是RVI指令，传递给FTQ的冲刷请求应该重定向到PC+4</td>
      </tr>
      <tr>
          <td>11.5.2</td>
          <td>IFU_MMIO_FLUSH_NON_CFI</td>
          <td>RVC</td>
          <td>如果是RVC指令，传递给FTQ的冲刷请求应该重定向到PC+2</td>
      </tr>
      <tr>
          <td>12.1.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#121-%e8%ae%be%e7%bd%ae%e6%96%ad%e7%82%b9%e5%92%8c%e6%96%ad%e7%82%b9%e6%a3%80%e6%9f%a5">IFU_FRONTEND_TRIGGER</a></td>
          <td>SELECT1</td>
          <td>给定tdata1的select位为1，随机构造其它输入，检查断点是否没有触发</td>
      </tr>
      <tr>
          <td>12.1.2.1</td>
          <td>IFU_FRONTEND_TRIGGER_SELECT0</td>
          <td>MATCH</td>
          <td>给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位匹配的输入，检查断点是否触发</td>
      </tr>
      <tr>
          <td>12.1.2.2</td>
          <td>IFU_FRONTEND_TRIGGER_SELECT0</td>
          <td>NOT_MATCH</td>
          <td>给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位不匹配的输入，检查断点是否触发</td>
      </tr>
      <tr>
          <td>12.2.1</td>
          <td><a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/#122-%e9%93%be%e5%bc%8f%e6%96%ad%e7%82%b9">IFU_FRONTEND_TRIGGER_CHAIN</a></td>
          <td>SELF</td>
          <td>对每个trigger，在满足PC断点触发条件的情况下，设置chain位，检查断点是否一定不触发。</td>
      </tr>
      <tr>
          <td>12.2.2.1</td>
          <td>IFU_FRONTEND_TRIGGER_CHAIN</td>
          <td>NOT_HIT</td>
          <td>对两个trigger，仅设置前一个trigger的chain位，设置后一个trigger命中而前一个未命中，检查后一个trigger是否一定不触发。</td>
      </tr>
      <tr>
          <td>12.2.2.2</td>
          <td>IFU_FRONTEND_TRIGGER_CHAIN</td>
          <td>HIT</td>
          <td>对两个trigger，仅设置前一个trigger的chain位且均命中，检查后一个trigger是否触发。</td>
      </tr>
  </tbody>
</table>
</mrs-testpoints>
</div><div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>需要特别指出的是，Svpbmt 扩展增加了一个 <code>NC</code> 属性，其代表该内存区域是不可缓存的、但是幂等的，这意味着我们可以对 <code>NC</code> 的区域进行推测执行，也就是不需要“等待前面的指令提交”就可以向总线发送取指请求，表现为状态机跳过等待状态。实现见 <a href="https://github.com/OpenXiangShan/XiangShan/pull/3944">#3944</a>。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>截至本文档撰写的版本，这个功能尚未实现（不过在比较新的提交里已经实现了），后续新的rtl加入后会去掉该下划线，或者读者可以自行编译香山源码生成rtl以支持这一特性。&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>在过去（riscv-debug-spec-draft，对应 XiangShan 2024.10.05 合入的 <a href="https://github.com/OpenXiangShan/XiangShan/pull/3693">PR#3693</a> 前）的版本中，Chain 还需要满足两个 Trigger 的 <code>mcontrol.timing</code> 是相同的。而在新版（riscv-debug-spec-v1.0.0）中，<code>mcontrol.timing</code> 被移除。目前 XiangShan 的 scala 实现仍保留了这一位，但其值永远为 0 且不可写入，编译生成的 verilog 代码中没有这一位。参考：<a href="https://github.com/riscv/riscv-debug-spec/pull/807">https://github.com/riscv/riscv-debug-spec/pull/807</a>。&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b6043999ec4323fa2a7093430cf55927">12.2.3.1 - F3PreDecoder</h1>
    
	<div class="ifu-ctx">
<h1 id="子模块f3predecoder模块简介">子模块：F3PreDecoder模块简介</h1>
<p>这个模块是从PreDecoder中时序优化出来的，负责判定CFI指令的类型</p>
<h2 id="f3predecoder功能介绍">F3PreDecoder功能介绍</h2>
<h3 id="cfi指令类型判定">CFI指令类型判定</h3>
<p>要想确定CFI指令类型，只需要分别尝试匹配JAL、JALR、BR和他们的RVC版本即可，注意，RVC的EBREAK
不应该被视为CFI指令。在匹配的过程中，自然CFI指令的类型就被甄别出来了。在这一步中，我们将所有指令分到如下四类brType中：</p>
<table>
  <thead>
      <tr>
          <th>CFI指令类型</th>
          <th>brType类型编码</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>非CFI</td>
          <td>00</td>
      </tr>
      <tr>
          <td>branch指令</td>
          <td>01</td>
      </tr>
      <tr>
          <td>jal指令</td>
          <td>10</td>
      </tr>
      <tr>
          <td>jalr指令</td>
          <td>11</td>
      </tr>
  </tbody>
</table>
<h3 id="retcall判定">ret、call判定</h3>
<p>然后，我们需要判断是否为call或者ret，这可以通过rd和rs的取值来考察，具体来说，RISCV的RVI指令中，提供了对rd和rs取值的约定，
当二者取到link寄存器的序号（x1为标准的返回地址寄存器，x5为备用的link寄存器），分别对应着压栈和弹栈。详细的对应情况如下：</p>
<p><img src="linkjal.png" alt="links"></p>
<h2 id="f3predecoder接口说明">F3Predecoder接口说明</h2>
<p>in_instr: 传递 16 x 4B的拼接指令码</p>
<p>out_pd：每条指令的预译码信息，在F3Predecoder分析得到的是brType、isCall和isRet</p>
<h2 id="f3predecoder子模块测试点和功能点">F3PreDecoder子模块测试点和功能点</h2>
<h3 id="功能点1-cfi指令类型判定">功能点1 CFI指令类型判定</h3>
<p>要想确定CFI指令类型，只需要分别尝试匹配JAL、JALR、BR和他们的RVC版本即可，注意，RVC的EBREAK
不应该被视为CFI指令。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>非CFI判定</td>
          <td>对传入的非CFI指令（包括RVC.EBREAK），应该判定为类型0</td>
      </tr>
      <tr>
          <td>1.2</td>
          <td>BR判定</td>
          <td>对传入的BR指令，应该判定为类型1</td>
      </tr>
      <tr>
          <td>1.3</td>
          <td>JAL判定</td>
          <td>对传入的JAL指令，应该判定为类型2</td>
      </tr>
      <tr>
          <td>1.4</td>
          <td>JALR判定</td>
          <td>对传入的JALR指令，应该判定为类型3</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点2-retcall判定">功能点2 ret、call判定</h3>
<p>然后，需要判断是否为call或者ret，这可以通过rd和rs的取值来考察。当然，首先必须得满足无条件跳转指令。</p>
<p>对于类型2，只有不为RVC指令且目的寄存器rd为link寄存器（x1或x5）时，才为Call。</p>
<p>对于类型3，在RVI指令下，当rd为link寄存器时，必为Call。当rs为link寄存器且rd不为时，必为Ret。
在RVC指令下，对C.JALR指令，为call，对C.JR指令，当rs1为link时，为Ret</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.1</td>
          <td>非CFI和BR不判定</td>
          <td>对传入的非CFI和BR指令，都不应判定为call或者ret</td>
      </tr>
      <tr>
          <td>2.2.1.1</td>
          <td>RVI.JAL判定call</td>
          <td>对传入的RVI.JAL指令，当rd设置为1或5，应当判定该指令为call</td>
      </tr>
      <tr>
          <td>2.2.1.2</td>
          <td>RVI.JAL例外</td>
          <td>对传入的RVI.JAL指令，当rd设置为1和5之外的值，不应当判定该指令为call或ret</td>
      </tr>
      <tr>
          <td>2.2.2</td>
          <td>RVC.JAL不判定</td>
          <td>对传入的RVC.JAL指令，无论什么情况都不能判定为call或ret</td>
      </tr>
      <tr>
          <td>2.3.1.1</td>
          <td>RVI.JALR和rd为link</td>
          <td>传入RVI.JALR指令，并且rd为1或5，无论其他取值，都应判定为call</td>
      </tr>
      <tr>
          <td>2.3.1.2</td>
          <td>RVI.JALR且仅rs为link</td>
          <td>传入RVI.JALR指令，rd不为1和5，rs为1或5，应判定为ret</td>
      </tr>
      <tr>
          <td>2.3.1.3</td>
          <td>RVI.JALR无link</td>
          <td>对传入的JALR指令，若rd和rs均不为link，则不应判定为ret和cal</td>
      </tr>
      <tr>
          <td>2.3.2.1</td>
          <td>RVC.JALR为Ret</td>
          <td>传入RVC.JALR指令，必定为call</td>
      </tr>
      <tr>
          <td>2.3.2.2.1</td>
          <td>RVC.JR且rs为link</td>
          <td>传入RVC.JR指令，rs为1或5，应判定为ret</td>
      </tr>
      <tr>
          <td>2.3.2.2.2</td>
          <td>RVC.JR且rs不为link</td>
          <td>传入RVC.JR指令，rs不为1或5，不应判定为ret</td>
      </tr>
  </tbody>
</table>
<h2 id="测试点汇总">测试点汇总</h2>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>CFI指令类型判定</td>
          <td>非CFI判定</td>
          <td>对传入的非CFI指令（包括RVC.EBREAK），应该判定为类型0</td>
      </tr>
      <tr>
          <td>1.2</td>
          <td>CFI指令类型判定</td>
          <td>BR判定</td>
          <td>对传入的BR指令，应该判定为类型1</td>
      </tr>
      <tr>
          <td>1.3</td>
          <td>CFI指令类型判定</td>
          <td>JAL判定</td>
          <td>对传入的JAL指令，应该判定为类型2</td>
      </tr>
      <tr>
          <td>1.4</td>
          <td>CFI指令类型判定</td>
          <td>JALR判定</td>
          <td>对传入的JALR指令，应该判定为类型3</td>
      </tr>
      <tr>
          <td>2.1</td>
          <td>ret、call判定</td>
          <td>非CFI和BR不判定</td>
          <td>对传入的非CFI和BR指令，都不应判定为call或者ret</td>
      </tr>
      <tr>
          <td>2.2.1.1</td>
          <td>ret、call判定</td>
          <td>RVI.JAL判定call</td>
          <td>对传入的RVC.JAL指令，当rd设置为1或5，应当判定该指令为call</td>
      </tr>
      <tr>
          <td>2.2.1.2</td>
          <td>ret、call判定</td>
          <td>RVI.JAL例外</td>
          <td>对传入的RVC.JAL指令，当rd设置为1和5之外的值，不应当判定该指令为call或ret</td>
      </tr>
      <tr>
          <td>2.2.2</td>
          <td>ret、call判定</td>
          <td>RVC.JAL不判定</td>
          <td>对传入的RVI.JAL指令，无论什么情况都不能判定为call或ret</td>
      </tr>
      <tr>
          <td>2.3.1.1</td>
          <td>ret、call判定</td>
          <td>RVI.JALR和rd为link</td>
          <td>传入RVI.JALR指令，并且rd为1或5，无论其他取值，都应判定为call</td>
      </tr>
      <tr>
          <td>2.3.1.2</td>
          <td>ret、call判定</td>
          <td>RVI.JALR且仅rs为link</td>
          <td>传入RVI.JALR指令，rd不为1和5，rs为1或5，应判定为ret</td>
      </tr>
      <tr>
          <td>2.3.1.3</td>
          <td>ret、call判定</td>
          <td>RVI.JALR无link</td>
          <td>对传入的JALR指令，若rd和rs均不为link，则不应判定为ret和cal</td>
      </tr>
      <tr>
          <td>2.3.2.1</td>
          <td>ret、call判定</td>
          <td>RVC.JALR为Ret</td>
          <td>传入RVC.JALR指令，必定为call</td>
      </tr>
      <tr>
          <td>2.3.2.2.1</td>
          <td>ret、call判定</td>
          <td>RVC.JR且rs为link</td>
          <td>传入RVC.JR指令，rs为1或5，应判定为ret</td>
      </tr>
      <tr>
          <td>2.3.2.2.2</td>
          <td>ret、call判定</td>
          <td>RVC.JR且rs不为link</td>
          <td>传入RVC.JR指令，rs不为1或5，不应判定为ret</td>
      </tr>
  </tbody>
</table>
</div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5f2f31e1befa41958bf77d99689773e7">12.2.3.2 - FrontendTrigger</h1>
    
	<div class="ifu-ctx">
<h1 id="frontendtrigger子模块">FrontendTrigger子模块</h1>
<p>该子模块的主要作用是在前端设置硬件断点和检查。</p>
<p>该模块的输入pc有一个隐含条件，那就是这个pc是通过ftq传递的startAddr计算出来的。</p>
<h2 id="frontendtrigger功能介绍">FrontendTrigger功能介绍</h2>
<h3 id="断点设置和断点检查">断点设置和断点检查</h3>
<p>在IFU的FrontendTrigger模块里共4个Trigger，编号为0,1,2,3，每个Trigger的配置信息（断点类型、匹配地址等）保存在tdata寄存器中。</p>
<p>当软件向CSR寄存器<code>tselect</code>、<code>tdata1/2</code>写入特定的值时，CSR会向IFU发送tUpdate请求，更新FrontendTrigger内的<code>tdata</code>寄存器中的配置信息。
目前前端的Trigger仅可以配置成PC断点<code>mcontrol.tdata1</code>寄存器的select位为0；当select=1时，该Trigger将永远不会命中，且不会产生异常）。</p>
<p>在取指时，IFU的F3流水级会向FrontendTrigger模块发起查询并在同一周期得到结果。后者会对取指块内每一条指令在每一个Trigger上做检查，
当指令的PC和<code>tdata2</code>寄存器内容的关系满足<code>mcontrol.match</code>位所指示的关系（香山支持match位为0、2、3，对应等于、大于等于、小于）时，
该指令会被标记为Trigger命中，随着执行在后端产生断点异常，进入M-Mode或调试模式。</p>
<h3 id="链式断点">链式断点</h3>
<p>根据RISCV的debug spec，香山实现的是mcontrol6。</p>
<p>当它们对应的Chain位被置时，只有当该Trigger和编号在它后面一位的Trigger同时命中，<del>且timing配置相同时</del>（在最新的手册中，这一要求已被删除），处理器才会产生异常。</p>
<p>在过去（riscv-debug-spec-draft，对应 XiangShan 2024.10.05 合入的 <a href="https://github.com/OpenXiangShan/XiangShan/pull/3693">PR#3693</a> 前）的版本中，Chain 还需要满足两个 Trigger 的 <code>mcontrol.timing</code> 是相同的。而在新版（riscv-debug-spec-v1.0.0）中，<code>mcontrol.timing</code> 被移除。目前 XiangShan 的 scala 实现仍保留了这一位，但其值永远为 0 且不可写入，编译生成的 verilog 代码中没有这一位。</p>
<h2 id="frontendtrigger-接口说明">FrontendTrigger 接口说明</h2>
<p>设计上并没有提供一个或一组对外的接口来查询某个断点的状态，因此，要在测试中检查断点状态，要么需要检查内部信号的情况（仓库中提供的构建脚本已经暴露了所有内部信号），要么通过具体执行过程中，断点的触发情况来判定。</p>
<h3 id="输入接口">输入接口</h3>
<p>主要分为控制接口和执行信息（目前执行信息只有pc）</p>
<h4 id="控制接口-io_frontendtrigger">控制接口 io_frontendTrigger</h4>
<p>本接口存储了frontendTrigger的控制信息，包含以下信号/信号组：</p>
<h5 id="debugmode">debugMode</h5>
<p>当前是否处于debug模式下</p>
<h5 id="tenablevec">tEnableVec</h5>
<p>对FrontendTrigger的每个断点，指示其是否有效。</p>
<h5 id="tupdate">tUpdate</h5>
<p>更新断点的控制信息，包含以下信号/信号组：</p>
<p>valid：此次更新是否有效/是否更新。</p>
<p>bits_addr：此次更新的是哪个断点（0~3）</p>
<p>bits_tdata_action：断点触发条件达成后的行为</p>
<p>bits_tdata_chain：断点是否链式传导</p>
<p>bits_tdata_matchType：断点匹配类型（等于、大于、小于三种）</p>
<p>bits_tdata_select：目前为止，select为0时为pc断点</p>
<p>bits_tdata_tdata2：用于和PC比较的基准值</p>
<h5 id="triggercanraisebpexp">triggerCanRaiseBpExp</h5>
<p>trigger是否可以引起异常</p>
<h4 id="pc">pc</h4>
<p>pc有一个隐含条件，就是16条指令的pc必定是连续的</p>
<h3 id="输出接口">输出接口</h3>
<p>triggered：16条指令的断点触发情况。</p>
<h2 id="frontendtrigger-测试点和功能点">FrontEndTrigger 测试点和功能点</h2>
<h3 id="功能点1-设置断点和断点检查">功能点1 设置断点和断点检查</h3>
<p>FrontEndTrigger目前仅支持设置PC断点，这通过设置断点的tdata1寄存器的select位为0实现。
同时，tdata2寄存器的mcontrol位负责设置指令PC和tdata2寄存器的地址需要满足的关系，
关系满足时，该指令会被标记为trigger命中。</p>
<p>所以，基于以上功能描述，我们需要测试：</p>
<p>select位为1时，断点是否永远不会触发。</p>
<p>select位为0时，当PC和tdata2的数据的关系满足tdata2的match位时，是否会设置断点。</p>
<p>select位为0时，当PC和tdata2的数据的关系不满足tdata2的match位时，断点是否一定不会触发。</p>
<p>综上所述，我们在这一功能点设计的测试点如下：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>select1判定</td>
          <td>给定tdata1的select位为1，随机构造其它输入，检查断点是否没有触发</td>
      </tr>
      <tr>
          <td>1.2.1</td>
          <td>select0关系匹配判定</td>
          <td>给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位匹配的输入，检查断点是否触发</td>
      </tr>
      <tr>
          <td>1.2.2</td>
          <td>select0关系不匹配判定</td>
          <td>给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位不匹配的输入，检查断点是否触发</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点2-链式断点">功能点2 链式断点</h3>
<p>当某一个trigger的chain位被置后，当其后的trigger的chain位未设置，且两个trigger均命中<del>并且两个trigger的timing相同</del>时，后一个trigger才会触发。</p>
<p>对0号trigger，不需要考虑链式的情况</p>
<p>由此，我们可以设置几种测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.1</td>
          <td>chain位测试</td>
          <td>对每个trigger，在满足PC断点触发条件的情况下，设置chain位，检查断点是否一定不触发。</td>
      </tr>
      <tr>
          <td>2.2.1</td>
          <td>未命中测试</td>
          <td>对两个trigger，仅设置前一个trigger的chain位<del>且两trigger的timing位相同</del>，设置后一个trigger命中而前一个未命中，检查后一个trigger是否一定不触发。</td>
      </tr>
      <tr>
          <td>2.2.2</td>
          <td>命中测试</td>
          <td>对两个trigger，仅设置前一个trigger的chain位<del>且两trigger的timing位相同</del>且均命中，检查后一个trigger是否触发。</td>
      </tr>
  </tbody>
</table>
<h2 id="测试点汇总"><strong>测试点汇总</strong></h2>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>断点设置和检查</td>
          <td>select1判定</td>
          <td>给定tdata1的select位为1，随机构造其它输入，检查断点是否没有触发</td>
      </tr>
      <tr>
          <td>1.2.1</td>
          <td>断点设置和检查</td>
          <td>select0关系匹配判定</td>
          <td>给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位匹配的输入，检查断点是否触发</td>
      </tr>
      <tr>
          <td>1.2.2</td>
          <td>断点设置和检查</td>
          <td>select0关系不匹配判定</td>
          <td>给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位不匹配的输入，检查断点是否触发</td>
      </tr>
      <tr>
          <td>2.1</td>
          <td>链式断点</td>
          <td>chain位测试</td>
          <td>对每个trigger，在满足PC断点触发条件的情况下，设置chain位，检查断点是否一定不触发</td>
      </tr>
      <tr>
          <td>2.2.1</td>
          <td>链式断点</td>
          <td>未命中测试</td>
          <td>对两个trigger，仅设置前一个trigger的chain位，设置后一个trigger命中而前一个未命中，检查后一个trigger是否一定不触发</td>
      </tr>
      <tr>
          <td>2.2.2</td>
          <td>链式断点</td>
          <td>命中测试</td>
          <td>对两个trigger，仅设置前一个trigger的chain位，检查后一个trigger是否触发</td>
      </tr>
  </tbody>
</table>
</div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-0d356cd150522df33f83d0453f191ac5">12.2.3.3 - PredChecker</h1>
    
	<div class="ifu-ctx">
<h1 id="子模块predchecker简介">子模块：PredChecker简介</h1>
<p>分支预测检查器PredChecker接收来自IFU的预测块信息（包括预测跳转指令在预测块的位置、预测的跳转目标、预译码得到的指令信息、指令PC以及预译码得到的跳转目标偏移等），在模块内部检查五种类型的分支预测错误。模块内部分为两个流水线stage，分别输出信息，第一个stage输出给IFU的f3阶段，用于修正预测块的指令范围和预测结果。第二个stage输出给wb阶段，用于在发现分支预测错误时产生前端重定向以及写回给FTQ（Fetch Target Queue）正确的预测信息。</p>
<h2 id="predchecker功能介绍">PredChecker功能介绍</h2>
<h3 id="jal预测错误检查">JAL预测错误检查</h3>
<p>jal指令预测错误的条件是，预测块中有一条有效jal指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条jal指令之后（即这条jal指令没有被预测跳转）。</p>
<h3 id="jalr预测错误检查">JALR预测错误检查</h3>
<p>jalr指令预测错误的条件是，预测块中有一条有效jalr指令（由预译码信息给出），而且这个指令不是ret指令，但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条jalr指令之后（即这条jalr指令没有被预测跳转）。</p>
<h3 id="ret预测错误检查">RET预测错误检查</h3>
<p>ret指令预测错误的条件是，预测块中有一条有效ret指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条ret指令之后（即这条ret指令没有被预测跳转）。</p>
<h3 id="更新指令有效范围向量">更新指令有效范围向量</h3>
<p>PredChecker在检查出Jal/Ret/JALR指令预测错误时，需要重新生成指令有效范围向量，有效范围截取到Jal/Ret指令的位置，之后的bit全部置为0。
需要注意的是，jal和ret指令的错误检查都会导致指令有效范围的缩短，
所以需要重新生成指令有效范伟fixedRange，同时修复预测结果。需要注意的是，这个修复只会针对RET预测错误和JAL预测错误导致的范围错误，对于后续要介绍的非CFI（控制流指令）预测错误和无效指令预测错误，尽管他们会造成预测块的范围偏小，但是不会进行修复，而是直接在这里进行重定向。这样，重定向后重新取的指令会从这个出错的指令开始。</p>
<h3 id="非cfi预测错误检查">非CFI预测错误检查</h3>
<p>非CFI预测错误的条件是被预测跳转的指令根据预译码信息显示不是一条CFI指令。</p>
<h3 id="无效指令预测错误检查">无效指令预测错误检查</h3>
<p>无效指令预测错误的条件是被预测的指令的位置根据预译码信息中的指令有效向量显示不是一条有效指令的开始。</p>
<h3 id="目标地址预测错误检查">目标地址预测错误检查</h3>
<p>目标地址预测错误的条件是，被预测的是一条有效的jal或者branch指令，同时预测的跳转目标地址和由指令码计算得到的跳转目标不一致。</p>
<h3 id="分级输出检查结果">分级输出检查结果</h3>
<p>以上PredChecker检查结果会分为两级分别输出，前面已经提到，Jal/Ret指令由于需要重新生成指令有效范围向量和重新指定预测位置，
所以需要在错误产生的当拍（F3）直接输出结果到Ibuffer用于及时更正进入后端的指令 。而由于时序的考虑，其他错误信息（比如五种错误的错误位置、正确的跳转地址等）则是等到下一拍（WB）阶段才返回给IFU做前端重定向。</p>
<h2 id="predchecker接口说明">PredChecker接口说明</h2>
<h3 id="输入接口">输入接口</h3>
<p>fire_in：这个信号可以简单认为是模块有效性的控制信号。</p>
<p>ftqOffset：来自BPU（分支预测单元）的预测信息，表示该预测块的跳转指令是否存在（valid），以及跳转指令的序号（bits）。</p>
<p>instrRange：来自PreDecode的预译码信息，对每条指令，表示该指令是否在预测块的有效指令范围内。</p>
<p>instrValid：来自PreDecode的预译码信息，表示的是对于每条32位的拼接指令，其是否为一条有效的指令（即低16位为一条RVC指令，或者整个32位为一条RVI指令）。</p>
<p>jumpOffset：来自PreDecode的预译码信息，如果某一指令为跳转指令，jumpOffset表示这个指令的跳转目标。</p>
<p>pc：指令的pc。</p>
<p>pds：来自PreDecode模块的预译码信息，包含指令的brType、是否为Ret（isRet）、是否为RVC指令（isRVC）。</p>
<p>target：来自BPU，下个预测块的开始地址。</p>
<h3 id="输出接口">输出接口</h3>
<h4 id="第一阶段输出">第一阶段输出</h4>
<p>fixedRange：修复的指令有效范围向量，对每条指令i，fixedRange_i为真表示这条指令是否在当前预测块的有效指令范围内</p>
<p>fixedTaken：修复过后的CFI指令选取情况，对每条指令，fixedTaken_i为真表示这条指令是否是这个预测块的第一条CFI指令</p>
<h4 id="第二阶段输出">第二阶段输出</h4>
<p>fixedMissPred：对每条指令，PredChecker检查出的存在预测错误的情况，fixedMissPred_i为真表示这条指令存在预测错误</p>
<p>fixedTarget：对每条指令，给出修复过的下一条指令的位置（可以是常规的pc+2或+4，或者如果是跳转指令，给出跳转目标）。</p>
<p>jalTarget：对每条指令，给出跳转目标。</p>
<p>faultType：每条指令的错误类型，取指范围包含noFault，jalFault，retFault，targetFault，notCFIFault，invalidTaken，jalrFault，分别对应数字0～6</p>
<h2 id="predchecker测试点和功能点">PredChecker测试点和功能点</h2>
<h3 id="功能点1-bpu预测信息的jal预测错误检查">功能点1 BPU预测信息的JAL预测错误检查</h3>
<p>PredChecker会对传入的预测块进行JAL预测错误预检查并修正指令有效范围向量和预测的跳转指令。</p>
<p>对这一模块的测试，我们分为两部分：正确的输入是否会误检和确有JAL检测错误的预测块输入能否检出。</p>
<p>对于误检，我们设计如下的测试点:</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1.1</td>
          <td>误检测试1</td>
          <td>预测块中没有JAL指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JAL预测错误。</td>
      </tr>
      <tr>
          <td>1.1.2</td>
          <td>误检测试2</td>
          <td>预测块中有JAL指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JAL预测错误。</td>
      </tr>
  </tbody>
</table>
<p>对于JAL预测错误的正确检验，我们设计如下的测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.2.1</td>
          <td>存在JAL未预测</td>
          <td>预测块中存在JAL指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出JAL预测错误。</td>
      </tr>
      <tr>
          <td>1.2.2</td>
          <td>预测的JAL并非第一条</td>
          <td>预测块中存在JAL指令，但是BPU预测信息取的跳转指令在第一条JAL指令之后，检查PredChecker是否能检测出JAL预测错误。</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点2-bpu预测信息的ret预测错误检查">功能点2 BPU预测信息的RET预测错误检查</h3>
<p>PredChecker会对传入的预测块进行RET预测错误预检查并修正指令有效范围向量和新的预测结果。</p>
<p>和JAL预测错误类似，我们也按照误检和正检来构造。</p>
<p>对于误检，我们设计如下的测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.1.1</td>
          <td>误检测试1</td>
          <td>预测块中没有RET指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报RET预测错误。</td>
      </tr>
      <tr>
          <td>2.1.2</td>
          <td>误检测试2</td>
          <td>预测块中有RET指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报RET预测错误。</td>
      </tr>
  </tbody>
</table>
<p>对于RET预测错误的正确检出，我们设计如下的测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.2.1</td>
          <td>存在RET未预测</td>
          <td>预测块中存在RET指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出RET预测错误。</td>
      </tr>
      <tr>
          <td>2.2.2</td>
          <td>预测的跳转并非第一条</td>
          <td>预测块中存在RET指令，但是BPU预测信息取的跳转指令在第一条RET指令之后，检查PredChecker是否能检测出RET预测错误。</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点3-bpu预测信息的jalr预测错误检查">功能点3 BPU预测信息的JALR预测错误检查</h3>
<p>PredChecker会对传入的预测块进行JALR预测错误预检查并修正指令有效范围向量和新的预测结果。</p>
<p>和JAL/RET预测错误类似，我们也按照误检和正检来构造。</p>
<p>对于误检，我们设计如下的测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>3.1.1</td>
          <td>误检测试1</td>
          <td>预测块中没有JALR指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JALR预测错误。</td>
      </tr>
      <tr>
          <td>3.1.2</td>
          <td>误检测试2</td>
          <td>预测块中有JALR指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JALR预测错误。</td>
      </tr>
  </tbody>
</table>
<p>对于JALR预测错误的正确检出，我们设计如下的测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>3.2.1</td>
          <td>存在JALR未预测</td>
          <td>预测块中存在JALR指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出RET预测错误。</td>
      </tr>
      <tr>
          <td>3.2.2</td>
          <td>预测的跳转并非第一条</td>
          <td>预测块中存在JALR指令，但是BPU预测信息取的跳转指令在第一条JALR指令之后，检查PredChecker是否能检测出JALR预测错误。</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点4-更新指令有效范围向量和预测跳转的指令">功能点4 更新指令有效范围向量和预测跳转的指令</h3>
<p>PredChecker在检查出Jal/Ret/Jalr指令预测错误时，需要重新生成指令有效范围向量，
有效范围截取到Jal/Ret/Jalr指令的位置，之后的bit全部置为0。
同时，还需要根据每条指令的预译码信息和BPU的预测信息修复预测跳转的结果。</p>
<p>所以，根据功能要求，我们可以划分出三类情况，分别是预测的有效范围和取用的跳转指令正确的情况，
由于RET和JAL预测错误引起的有效范围偏大和错判非跳转指令和无效指令引起的有效范围偏小。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>4.1</td>
          <td>有效范围无误</td>
          <td>不存在任何错误的情况下，PredChecker应当保留之前的预测结果。</td>
      </tr>
      <tr>
          <td>4.2</td>
          <td>RET、JAL、JALR预测错误引起的范围偏大</td>
          <td>如果检测到了JAL、RET、JALR类的预测错误，PredChecker应该将有效指令的范围修正为预测块开始至第一条跳转指令。同时，应该将预测跳转的指令位置修正为预测块中的第一条跳转指令。</td>
      </tr>
      <tr>
          <td>4.3</td>
          <td>非CFI和无效指令引起的预测范围偏小</td>
          <td>如果出现了非控制流指令和无效指令的误预测，不应该将预测跳转的指令重新修正到预测块中第一条跳转指令，因为后续会直接冲刷并重新从重定向的位置取指令，如果这里修正的话，会导致下一预测块传入重复的指令</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点5-非cfi预测错误检查">功能点5 非CFI预测错误检查</h3>
<p>非CFI预测错误的条件是被预测跳转的指令根据预译码信息显示不是一条CFI指令。</p>
<p>要检验这一功能，我们仍然按误检和正确检验来设计测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>5.1.1</td>
          <td>误检测试1</td>
          <td>构造不存在CFI指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检非CFI预测错误</td>
      </tr>
      <tr>
          <td>5.1.2</td>
          <td>误检测试2</td>
          <td>构造存在CFI指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检非CFI预测错误</td>
      </tr>
      <tr>
          <td>5.2</td>
          <td>正确检测测试</td>
          <td>构造不存在CFI指令但是预测了跳转的预测信息作为输入，测试PredChecker是否能检查出非CFI预测错误</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点6-无效指令预测错误检查">功能点6 无效指令预测错误检查</h3>
<p>无效指令预测错误的条件是被预测的指令的位置根据预译码信息中的指令有效向量显示不是一条有效指令的开始。</p>
<p>要检验这一功能，我们按照误检和正确检测来设计测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>6.1.1</td>
          <td>误检测试1</td>
          <td>构造不存在跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误</td>
      </tr>
      <tr>
          <td>6.1.2</td>
          <td>误检测试2</td>
          <td>构造存在无效跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误</td>
      </tr>
      <tr>
          <td>6.1.3</td>
          <td>误检测试3</td>
          <td>构造存在有效跳转指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误</td>
      </tr>
      <tr>
          <td>6.2</td>
          <td>正确检测测试</td>
          <td>构造无效指令但是预测了跳转的预测信息作为输入，测试PredChecker是否能检查出无效指令预测错误</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点7-目标地址预测错误检查">功能点7 目标地址预测错误检查</h3>
<p>目标地址预测错误的条件是，被预测的是一条有效的jal或者branch指令，
同时预测的跳转目标地址和由指令码计算得到的跳转目标不一致。</p>
<p>和先前的思路一样，我们仍然按误检和检出两类组织测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>7.1.1</td>
          <td>误检测试1</td>
          <td>构造不存在跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检目标地址预测错误</td>
      </tr>
      <tr>
          <td>7.1.2</td>
          <td>误检测试2</td>
          <td>构造存在有效跳转指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检目标地址预测错误</td>
      </tr>
      <tr>
          <td>7.2</td>
          <td>正确检测测试</td>
          <td>构造存在有效跳转指令的预测块和预测跳转但跳转目标计算错误的预测信息作为输入，测试PredChecker能否检出目标地址预测错误</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点8-生成跳转和顺序目标">功能点8 生成跳转和顺序目标</h3>
<p>PredChecker还需要负责生成跳转和顺序目标。</p>
<p>我们通过随机生成译码信息进行测试</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>8.1</td>
          <td>随机测试</td>
          <td>随机提供译码信息，检测生成的跳转目标和顺序目标。</td>
      </tr>
  </tbody>
</table>
<h2 id="测试点汇总"><a id="pred_checker_functions">测试点汇总</a></h2>
<p>综上所述，所有的测试点如下：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1.1</td>
          <td>BPU预测信息的JAL预测错误检查</td>
          <td>误检测试1</td>
          <td>预测块中没有JAL指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JAL预测错误。</td>
      </tr>
      <tr>
          <td>1.1.2</td>
          <td>BPU预测信息的JAL预测错误检查</td>
          <td>误检测试2</td>
          <td>预测块中有JAL指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JAL预测错误。</td>
      </tr>
      <tr>
          <td>1.2.1</td>
          <td>BPU预测信息的JAL预测错误检查</td>
          <td>存在JAL未预测</td>
          <td>预测块中存在JAL指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出JAL预测错误。</td>
      </tr>
      <tr>
          <td>1.2.2</td>
          <td>BPU预测信息的JAL预测错误检查</td>
          <td>预测的JAL并非第一条</td>
          <td>预测块中存在JAL指令，但是BPU预测信息取的跳转指令在第一条JAL指令之后，检查PredChecker是否能检测出JAL预测错误。</td>
      </tr>
      <tr>
          <td>2.1.1</td>
          <td>BPU预测信息的RET预测错误检查</td>
          <td>误检测试1</td>
          <td>预测块中没有RET指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报RET预测错误。</td>
      </tr>
      <tr>
          <td>2.1.2</td>
          <td>BPU预测信息的RET预测错误检查</td>
          <td>误检测试2</td>
          <td>预测块中有RET指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报RET预测错误。</td>
      </tr>
      <tr>
          <td>2.2.1</td>
          <td>BPU预测信息的RET预测错误检查</td>
          <td>存在RET未预测</td>
          <td>预测块中存在RET指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出RET预测错误。</td>
      </tr>
      <tr>
          <td>2.2.2</td>
          <td>BPU预测信息的RET预测错误检查</td>
          <td>预测的跳转并非第一条</td>
          <td>预测块中存在RET指令，但是BPU预测信息取的跳转指令在第一条RET指令之后，检查PredChecker是否能检测出RET预测错误。</td>
      </tr>
      <tr>
          <td>3.1.1</td>
          <td>BPU预测信息的JALR预测错误检查</td>
          <td>误检测试1</td>
          <td>预测块中没有JALR指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JALR预测错误。</td>
      </tr>
      <tr>
          <td>3.1.2</td>
          <td>BPU预测信息的JALR预测错误检查</td>
          <td>误检测试2</td>
          <td>预测块中有JALR指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JALR预测错误。</td>
      </tr>
      <tr>
          <td>3.2.1</td>
          <td>BPU预测信息的JALR预测错误检查</td>
          <td>存在JALR未预测</td>
          <td>预测块中存在JALR指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出RET预测错误。</td>
      </tr>
      <tr>
          <td>3.2.2</td>
          <td>BPU预测信息的JALR预测错误检查</td>
          <td>预测的跳转并非第一条</td>
          <td>预测块中存在JALR指令，但是BPU预测信息取的跳转指令在第一条JALR指令之后，检查PredChecker是否能检测出JALR预测错误。</td>
      </tr>
      <tr>
          <td>4.1</td>
          <td>更新指令有效范围向量和预测跳转的指令</td>
          <td>有效范围无误</td>
          <td>不存在任何错误的情况下，PredChecker应当保留之前的预测结果。</td>
      </tr>
      <tr>
          <td>4.2</td>
          <td>更新指令有效范围向量和预测跳转的指令</td>
          <td>RET和JAL预测错误引起的范围偏大</td>
          <td>如果检测到了JAL或RET类的预测错误，PredChecker应该将有效指令的范围修正为预测块开始至第一条跳转指令。同时，应该将预测跳转的指令位置修正为预测块中的第一条跳转指令。</td>
      </tr>
      <tr>
          <td>4.3</td>
          <td>更新指令有效范围向量和预测跳转的指令</td>
          <td>范围偏小不修正</td>
          <td>如果出现了非控制流指令和无效指令的误预测，不应该将预测跳转的指令重新修正到预测块中第一条跳转指令，因为后续会直接冲刷并重新从重定向的位置取指令，如果这里修正的话，会导致下一预测块传入重复的指令。</td>
      </tr>
      <tr>
          <td>5.1.1</td>
          <td>非CFI预测错误检查</td>
          <td>误检测试1</td>
          <td>构造不存在CFI指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检非CFI预测错误</td>
      </tr>
      <tr>
          <td>5.1.2</td>
          <td>非CFI预测错误检查</td>
          <td>误检测试2</td>
          <td>构造存在CFI指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检非CFI预测错误</td>
      </tr>
      <tr>
          <td>5.2</td>
          <td>非CFI预测错误检查</td>
          <td>正确检测测试</td>
          <td>构造不存在CFI指令但是预测了跳转的预测信息作为输入，测试PredChecker是否能检查出非CFI预测错误</td>
      </tr>
      <tr>
          <td>6.1.1</td>
          <td>无效指令预测错误检查</td>
          <td>误检测试1</td>
          <td>构造不存在跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误</td>
      </tr>
      <tr>
          <td>6.1.2</td>
          <td>无效指令预测错误检查</td>
          <td>误检测试2</td>
          <td>构造存在无效跳转指令并且未预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误</td>
      </tr>
      <tr>
          <td>6.1.3</td>
          <td>无效指令预测错误检查</td>
          <td>误检测试3</td>
          <td>构造存在有效跳转指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检无效指令预测错误</td>
      </tr>
      <tr>
          <td>6.2</td>
          <td>无效指令预测错误检查</td>
          <td>正确检测测试</td>
          <td>构造无效指令但是预测了跳转的预测信息作为输入，测试PredChecker是否能检查出无效指令预测错误</td>
      </tr>
      <tr>
          <td>7.1.1</td>
          <td>目标地址预测错误检查</td>
          <td>误检测试1</td>
          <td>构造不存在跳转指令并且未预测跳转的预测信息作输入，测试PredChecker是否会错检目标地址预测错误</td>
      </tr>
      <tr>
          <td>7.1.2</td>
          <td>目标地址预测错误检查</td>
          <td>误检测试2</td>
          <td>构造存在有效跳转指令并且正确预测跳转的预测信息作为输入，测试PredChecker是否会错检目标地址预测错误</td>
      </tr>
      <tr>
          <td>7.2</td>
          <td>目标地址预测错误检查</td>
          <td>正确检测测试</td>
          <td>构造存在有效跳转指令的预测块和预测跳转但跳转目标计算错误的预测信息作为输入，测试PredChecker能否检出目标地址预测错误</td>
      </tr>
      <tr>
          <td>8.1</td>
          <td>生成跳转和顺序目标</td>
          <td>随机测试</td>
          <td>随机提供译码信息，检测生成的跳转目标和顺序目标。</td>
      </tr>
  </tbody>
</table>
</div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-888bbeaad1aa779245a92ddc66145346">12.2.3.4 - PreDecode</h1>
    
	<div class="ifu-ctx">
<h1 id="子模块predecoder简介">子模块：PreDecoder简介</h1>
<p>预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。</p>
<p>所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。</p>
<p>预译码器的输出是：16x4B的拼接指令码；对每个4B指令码，该条指令是否为RVI或RVC指令（RVC指令只考虑该4B的低2B）；对每个4B指令码，该条指令的跳转偏移；两个16位的有效指令开始向量，其中第一种向量假定当前预测块的起始2字节为一条有效指令的开始，而第二种向量假定当前预测块的起始2字节为一条有效RVI指令的结束（但是由于第二种向量的前两位必然为0和1,所以编译优化后，第二种向量实际只有14个信号，表示2-15位；同理，第1种向量的第0位因为恒为1,所以也被优化）</p>
<h3 id="功能介绍">功能介绍</h3>
<h3 id="指令码生成">指令码生成</h3>
<p>预译码器接受来自IFU完成指令切分的17 × 2字节的初始指令码，并以4字节为窗口，2字节为步进长度，
从第1个2字节开始，直到第16个2字节，选出总共16个4字节的指令码。</p>
<h3 id="预译码信息生成">预译码信息生成</h3>
<p>预译码器根据指令码产生预译码信息，主要包括：是否是RVC指令、是否是CFI指令、
CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移。</p>
<p>首先是判断是否是RVC指令，RVC指令的具体格式参阅RISCV手册的描述：</p>
<p><img src="RVCtable.png" alt="RVC"></p>
<p>其中，决定指令是否为RVC的部分在于指令的[1, 0]两位，不为3的情况下都是RVC指令。</p>
<p>其余的指令性质判定功能（CFI类型、是否为call和ret）被时序优化到了F3PreDecoder中，不过也可以认为是PreDecoder的一部分，可以设置测试点进行测试</p>
<p>最后比较麻烦的是CFI指令的目标地址计算偏移，主要是对J和BR分支指令进行的计算，这需要综合RVI和RVC中jal和br指令的结构。
首先，是手册中对于C.J的描述</p>
<p><img src="JOP.png" alt="JOP"></p>
<p>这里对imm立即数的注解是，立即数的每一位最后对应到的是偏移的哪一位。</p>
<p>所以，可以认为立即数是这么重组的：</p>
<p>instr(12) + instr(8) + instr(10, 9) + instr(6) + instr(7) + instr(2) + instr(11) +instr(5,3) + &ldquo;0&rdquo;</p>
<p>而RVI中，对于JAL指令，是这么定义的：</p>
<p><img src="RVIJ.png" alt="RVIJ"></p>
<p>我们可以类似地计算立即数。</p>
<p>同样的，我们可以查询手册，参考BR类指令的立即数计算RVC和RVI指令对应的偏移。</p>
<p><img src="RVIBR.png" alt="RVIBR"></p>
<p><img src="RVCBR.png" alt="RVCBR"></p>
<h2 id="predecode接口说明">PreDecode接口说明</h2>
<h3 id="输入接口">输入接口</h3>
<p>in_bits_data 17 x 2B的初始指令码，其中，每2个字节既可以代表一条RVC指令，也可以代表一个RVI指令的一半。</p>
<h3 id="输出接口">输出接口</h3>
<p>instr：拼接后的 16 x 4B的初始指令码</p>
<p>jumpOffset：如果这条指令是跳转指令，则jumpOffset表示其跳转偏移</p>
<p>pd：每条指令预译码信息，包括valid、isRVC、brType、isRet、isCall。其中第0条指令的valid已经被优化了</p>
<p>hasHalfValid：这个信号需要和pd的valid结合起来看，PreDecode的一个功能是求出指令开始向量，也就是对每个4B的拼接指令，判断其低2B是否为一条有效指令的开始（即一条RVI指令的前半部分，或者一条RVC指令），但是需要分类讨论该预测块的第一个2B是否为一条有效指令的开始。hasHalfValid表示的是当前预测块的第一个2B指令为一条RVI指令的后半部分时，给出的指令开始向量。类似地，pd中的valid指的是当前预测块的第一个2B指令为一条指令的开始时，给出的指令开始向量。</p>
<h2 id="predecoder测试点和功能点">PreDecoder测试点和功能点</h2>
<h3 id="功能点1-生成指令码">功能点1 生成指令码</h3>
<p>子模块：PreDecoder简介</p>
<p>预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。</p>
<p>所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。</p>
<p>预译码器的输出是：16x4B的拼接指令码；对每个4B指令码，该条指令是否为RVI或RVC指令（RVC指令只考虑该4B的低2B）；对每个4B指令码，该条指令的跳转偏移；两个16位的有效指令开始向量，其中第一种向量假定当前预测块的起始2字节为一条有效指令的开始，而第二种向量假定当前预测块的起始2字节为一条有效RVI指令的结束（但是由于第二种向量的前两位必然为0和1,所以编译优化后，第二种向量实际只有14个信号，表示2-15位；同理，第1种向量的第0位因为恒为1,所以也被优化）
功能介绍
指令码生成</p>
<p>预译码器接受来自IFU完成指令切分的17 × 2字节的初始指令码，并以4字节为窗口，2字节为步进长度， 从第1个2字节开始，直到第16个2字节，选出总共16个4字节的指令码。
预译码信息生成</p>
<p>预译码器根据指令码产生预译码信息，主要包括：是否是RVC指令、是否是CFI指令、 CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移。</p>
<p>预译码器从IFU接收完成指令切分的17 x 2 字节的初始指令码，以4字节为窗口，2字节为步进长度，选出16 x 4字节的指令码</p>
<p>我们需要随机生成初始指令码，并测试拼接的结果。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>拼接测试</td>
          <td>随机生成17 x 2字节的初始指令码，检验PreDecoder拼接结果</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点2-生成预译码信息">功能点2 生成预译码信息</h3>
<p>预译码器会根据指令码产生预译码信息，包括RVC指令的判定和CFI指令的目标地址计算偏移。</p>
<p>CFI类型的判定则时序优化到了F3PreDecoder中。
可以设计测试点测试PreDecode对F3PreDecoder的使用。</p>
<p>据此，我们可以设计下述测试点。</p>
<p>首先是判定RVC指令，我们随机生成输入初始指令码，对返回的16位RVC判定结果进行检验。
具体来说，对每32位指令，考虑RVC和RVI两种情况。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.1.1</td>
          <td>RVC判定</td>
          <td>传入RVC指令，应该判断为RVC</td>
      </tr>
      <tr>
          <td>2.1.2</td>
          <td>RVI判定</td>
          <td>传入RVI指令，不应判断为RVC</td>
      </tr>
  </tbody>
</table>
<p>然后，需要分别根据手册构造RVC和RVI扩展下的J指令和BR指令们，所以有如下的测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.2.1</td>
          <td>RVC.J计算</td>
          <td>对传入RVC扩展的J指令，检查计算的偏移</td>
      </tr>
      <tr>
          <td>2.2.2</td>
          <td>RVI.J计算</td>
          <td>对传入RVI扩展的J指令，检查计算的偏移</td>
      </tr>
      <tr>
          <td>2.2.3</td>
          <td>RVC.BR计算</td>
          <td>对传入RVC扩展的BR指令，检查计算的偏移</td>
      </tr>
      <tr>
          <td>2.2.4</td>
          <td>RVI.BR计算</td>
          <td>对传入RVI扩展的BR指令，检查计算的偏移</td>
      </tr>
  </tbody>
</table>
<p>参照F3PreDecoder的测试点，设计如下测试点：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.3.1</td>
          <td>非CFI判定</td>
          <td>对传入的非CFI指令（包括RVC.EBREAK），应该判定为类型0</td>
      </tr>
      <tr>
          <td>2.3.2</td>
          <td>BR判定</td>
          <td>对传入的BR指令，应该判定为类型1</td>
      </tr>
      <tr>
          <td>2.3.3</td>
          <td>JAL判定</td>
          <td>对传入的JAL指令，应该判定为类型2</td>
      </tr>
      <tr>
          <td>2.3.4</td>
          <td>JALR判定</td>
          <td>对传入的JALR指令，应该判定为类型3</td>
      </tr>
      <tr>
          <td>2.4.1</td>
          <td>非CFI和BR不判定</td>
          <td>对传入的非CFI和BR指令，都不应判定为call或者ret</td>
      </tr>
      <tr>
          <td>2.4.2.1.1</td>
          <td>RVI.JAL判定call</td>
          <td>对传入的RVI.JAL指令，当rd设置为1或5，应当判定该指令为call</td>
      </tr>
      <tr>
          <td>2.4.2.1.2</td>
          <td>RVI.JAL例外</td>
          <td>对传入的RVI.JAL指令，当rd设置为1和5之外的值，不应当判定该指令为call或ret</td>
      </tr>
      <tr>
          <td>2.4.2.2</td>
          <td>RVC.JAL不判定</td>
          <td>对传入的RVC.JAL指令，无论什么情况都不能判定为call或ret</td>
      </tr>
      <tr>
          <td>2.4.3.1.1</td>
          <td>RVI.JALR和rd为link</td>
          <td>传入RVI.JALR指令，并且rd为1或5，无论其他取值，都应判定为call</td>
      </tr>
      <tr>
          <td>2.4.3.1.2</td>
          <td>RVI.JALR且仅rs为link</td>
          <td>传入RVI.JALR指令，rd不为1和5，rs为1或5，应判定为ret</td>
      </tr>
      <tr>
          <td>2.4.3.1.3</td>
          <td>RVI.JALR无link</td>
          <td>对传入的JALR指令，若rd和rs均不为link，则不应判定为ret和cal</td>
      </tr>
      <tr>
          <td>2.4.3.2.1</td>
          <td>RVC.JALR为Ret</td>
          <td>传入RVC.JALR指令，必定为call</td>
      </tr>
      <tr>
          <td>2.4.3.2.2.1</td>
          <td>RVC.JR且rs为link</td>
          <td>传入RVC.JR指令，rs为1或5，应判定为ret</td>
      </tr>
      <tr>
          <td>2.4.3.2.2.2</td>
          <td>RVC.JR且rs不为link</td>
          <td>传入RVC.JR指令，rs不为1或5，不应判定为ret</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点3-生成指令开始向量">功能点3 生成指令开始向量</h3>
<p>最后，预译码还需要生成两种指令开始向量：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>3.1</td>
          <td>有效指令开始向量计算1</td>
          <td>对预测块，假定第一条指令为一条有效指令的开始，对每条指令计算其是否为有效指令开始</td>
      </tr>
      <tr>
          <td>3.2</td>
          <td>有效指令开始向量计算2</td>
          <td>对预测块，假定第一条指令为一条有效指令的结束，对每条指令计算其是否为有效指令开始</td>
      </tr>
  </tbody>
</table>
<h2 id="测试点汇总"><strong>测试点汇总</strong><a id="pred_decoder_functions"> </a></h2>
<p>综上所述，对PredDecoder，所有的测试点为：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>拼接指令码</td>
          <td>拼接测试</td>
          <td>随机生成17 x 2字节的初始指令码，检验PreDecoder拼接结果</td>
      </tr>
      <tr>
          <td>2.1.1</td>
          <td>RVC判定</td>
          <td>RVC判定</td>
          <td>传入RVC指令，应该判断为RVC</td>
      </tr>
      <tr>
          <td>2.1.2</td>
          <td>RVC判定</td>
          <td>RVI判定</td>
          <td>传入RVI指令，不应判断为RVC</td>
      </tr>
      <tr>
          <td>2.2.1</td>
          <td>跳转目标计算</td>
          <td>RVC.J计算</td>
          <td>对传入RVC扩展的J指令，检查计算的偏移</td>
      </tr>
      <tr>
          <td>2.2.2</td>
          <td>跳转目标计算</td>
          <td>RVI.J计算</td>
          <td>对传入RVI扩展的J指令，检查计算的偏移</td>
      </tr>
      <tr>
          <td>2.2.3</td>
          <td>跳转目标计算</td>
          <td>RVC.BR计算</td>
          <td>对传入RVC扩展的BR指令，检查计算的偏移</td>
      </tr>
      <tr>
          <td>2.2.4</td>
          <td>跳转目标计算</td>
          <td>RVI.BR计算</td>
          <td>对传入RVI扩展的BR指令，检查计算的偏移</td>
      </tr>
      <tr>
          <td>2.3.1</td>
          <td>CFI指令类型判定</td>
          <td>非CFI判定</td>
          <td>对传入的非CFI指令（包括RVC.EBREAK），应该判定为类型0</td>
      </tr>
      <tr>
          <td>2.3.2</td>
          <td>CFI指令类型判定</td>
          <td>BR判定</td>
          <td>对传入的BR指令，应该判定为类型1</td>
      </tr>
      <tr>
          <td>2.3.3</td>
          <td>CFI指令类型判定</td>
          <td>JAL判定</td>
          <td>对传入的JAL指令，应该判定为类型2</td>
      </tr>
      <tr>
          <td>2.3.4</td>
          <td>CFI指令类型判定</td>
          <td>JALR判定</td>
          <td>对传入的JALR指令，应该判定为类型3</td>
      </tr>
      <tr>
          <td>2.4.1</td>
          <td>ret、call判定</td>
          <td>非CFI和BR不判定</td>
          <td>对传入的非CFI和BR指令，都不应判定为call或者ret</td>
      </tr>
      <tr>
          <td>2.4.2.1.1</td>
          <td>ret、call判定</td>
          <td>RVI.JAL判定call</td>
          <td>对传入的RVI.JAL指令，当rd设置为1或5，应当判定该指令为call</td>
      </tr>
      <tr>
          <td>2.4.2.1.2</td>
          <td>ret、call判定</td>
          <td>RVI.JAL例外</td>
          <td>对传入的RVI.JAL指令，当rd设置为1和5之外的值，不应当判定该指令为call或ret</td>
      </tr>
      <tr>
          <td>2.4.2.2</td>
          <td>ret、call判定</td>
          <td>RVC.JAL不判定</td>
          <td>对传入的RVC.JAL指令，无论什么情况都不能判定为call或ret</td>
      </tr>
      <tr>
          <td>2.4.3.1.1</td>
          <td>ret、call判定</td>
          <td>RVI.JALR和rd为link</td>
          <td>传入RVI.JALR指令，并且rd为1或5，无论其他取值，都应判定为call</td>
      </tr>
      <tr>
          <td>2.4.3.1.2</td>
          <td>ret、call判定</td>
          <td>RVI.JALR且仅rs为link</td>
          <td>传入RVI.JALR指令，rd不为1和5，rs为1或5，应判定为ret</td>
      </tr>
      <tr>
          <td>2.4.3.1.3</td>
          <td>ret、call判定</td>
          <td>RVI.JALR无link</td>
          <td>对传入的JALR指令，若rd和rs均不为link，则不应判定为ret和cal</td>
      </tr>
      <tr>
          <td>2.4.3.2.1</td>
          <td>ret、call判定</td>
          <td>RVC.JALR为Ret</td>
          <td>传入RVC.JALR指令，必定为call</td>
      </tr>
      <tr>
          <td>2.4.3.2.2.1</td>
          <td>ret、call判定</td>
          <td>RVC.JR且rs为link</td>
          <td>传入RVC.JR指令，rs为1或5，应判定为ret</td>
      </tr>
      <tr>
          <td>2.4.3.2.2.2</td>
          <td>ret、call判定</td>
          <td>RVC.JR且rs不为link</td>
          <td>传入RVC.JR指令，rs不为1或5，不应判定为ret</td>
      </tr>
      <tr>
          <td>3.1</td>
          <td>计算有效指令开始向量</td>
          <td>有效指令开始向量计算1</td>
          <td>对预测块，假定第一条指令为一条有效指令的开始，对每条指令计算其是否为有效指令开始</td>
      </tr>
      <tr>
          <td>3.2</td>
          <td>计算有效指令开始向量</td>
          <td>有效指令开始向量计算2</td>
          <td>对预测块，假定第一条指令为一条有效指令的结束，对每条指令计算其是否为有效指令开始</td>
      </tr>
  </tbody>
</table>
</div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7aee3086abe25d91883317856094fc76">12.2.3.5 - RVCExpander</h1>
    
	<div class="ifu-ctx">
<h1 id="子模块rvcexpander简介">子模块：RVCExpander简介</h1>
<p>RVCExpander是IFU的子模块，负责对传入的指令进行指令扩展，并解码计算非法信息。</p>
<p>该模块接收的输入量是两个：一条RVC指令或者RVI指令；CSR对fs.status的使能情况。</p>
<p>输出量也是两个：输入指令对应的RVI指令；RVC指令是否非法。</p>
<h2 id="指令扩展">指令扩展</h2>
<p>如果是RVI指令，则无需扩展。</p>
<p>否则对RVC指令，按照手册的约定进行扩展。</p>
<h2 id="非法指令判断">非法指令判断</h2>
<p>RVI指令永远判断为合法。</p>
<p>对于RVC指令的判定，详细内容参阅20240411的RISCV手册的26.8节表格列出的指令条件。</p>
<h2 id="常量说明">常量说明</h2>
<table>
  <thead>
      <tr>
          <th>常量名</th>
          <th>常量值</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>XLEN</td>
          <td>64</td>
          <td>通用寄存器位宽，决定指令扩展时使用rv32还是rv64还是rv128</td>
      </tr>
      <tr>
          <td>fLen</td>
          <td>64</td>
          <td>香山支持d扩展，故为64</td>
      </tr>
  </tbody>
</table>
<h2 id="rvcexpander接口说明">RVCExpander接口说明</h2>
<h3 id="输入接口">输入接口</h3>
<p>fsIsOff：表示CSR是否使能<code>fs.status</code></p>
<p>in：传入一个32位数据，其可以是一个完整的RVI指令，也可以是低16位RVC指令+高16位为RVI指令的一半（当然低16位也有可能是RVI指令的后半部分，但是RVCExpander不会区分，可以认为RVCExpander假定传入的32位数据的低16位一定为一条指令的开始）</p>
<h3 id="输出接口">输出接口</h3>
<p>ill：表示这条指令是否为非法指令</p>
<p>out_bits：对RVI指令，直接返回，对RVC指令，返回扩展后的32位指令。</p>
<h2 id="功能点和测试点">功能点和测试点</h2>
<h3 id="功能点1-指令扩展">功能点1 指令扩展</h3>
<p>RVCExpander负责接收预译码器拼接的指令码，并进行指令扩展，如果是16位RVC指令，需要按照RISCV手册的约定完成扩展</p>
<p>对此，我们需要随机生成RVI指令和RVC指令，送入预译码器：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>RVI指令保留</td>
          <td>构造RVI指令传入，检查保留情况</td>
      </tr>
      <tr>
          <td>1.2</td>
          <td>RVC指令扩展</td>
          <td>构造RVC指令传入，按手册检查扩展结果</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点2-非法指令判断">功能点2 非法指令判断</h3>
<p>RVCExpander在解析指令时，如发现指令违反了手册的约定，则需要判定该指令非法</p>
<p>对此，我们需要随机生成非法指令送入RVI中，并检测RVCExpander对合法位的校验；同时，我们还需要校验合法指令是否会被误判为非法指令：</p>
<p>此外，需要判定C.fp指令在CSR未使能fs.status的情况下，能否将这类指令判定为非法。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.1</td>
          <td>常规非法指令测试</td>
          <td>随机构造非法RVC指令传入，检查判断结果</td>
      </tr>
      <tr>
          <td>2.2</td>
          <td>合法指令测试</td>
          <td>随机构造合法RVC指令传入，检查判断结果</td>
      </tr>
      <tr>
          <td>2.3</td>
          <td>C.fp指令测试</td>
          <td>CSR未使能fs.status的情况下，C.fp指令应该为非法</td>
      </tr>
  </tbody>
</table>
<h2 id="测试点汇总">测试点汇总 <a id="rvc_expander_functions"> </a></h2>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能</th>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>指令扩展</td>
          <td>RVI指令保留</td>
          <td>构造RVI指令传入，检查保留情况</td>
      </tr>
      <tr>
          <td>1.2</td>
          <td>指令扩展</td>
          <td>RVC指令扩展</td>
          <td>构造RVC指令传入，按手册检查扩展结果</td>
      </tr>
      <tr>
          <td>2.1</td>
          <td>非法指令判断</td>
          <td>非法指令测试</td>
          <td>随机构造非法RVC指令传入，检查判断结果</td>
      </tr>
      <tr>
          <td>2.2</td>
          <td>非法指令判断</td>
          <td>合法指令测试</td>
          <td>随机构造合法RVC指令传入，检查判断结果</td>
      </tr>
      <tr>
          <td>2.3</td>
          <td>C.fp指令测试</td>
          <td>CSR未使能fs.status的情况下，C.fp指令应该为非法</td>
          <td></td>
      </tr>
  </tbody>
</table>
<h2 id="rvc扩展辅助阅读材料">RVC扩展辅助阅读材料</h2>
<p>为方便参考模型的书写，在这里根据20240411版本的手册内容整理了部分指令扩展的思路。</p>
<p>对于RVC指令来说，op = instr(1, 0)；funct = instr(15, 13)</p>
<table>
  <thead>
      <tr>
          <th>op\funct</th>
          <th>000</th>
          <th>001</th>
          <th>010</th>
          <th>011</th>
          <th>100</th>
          <th>101</th>
          <th>110</th>
          <th>111</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>00</td>
          <td>addi4spn</td>
          <td>fld</td>
          <td>lw</td>
          <td>ld</td>
          <td>lbu<br>lhu;lh<br>sb;sh</td>
          <td>fsd</td>
          <td>sw</td>
          <td>sd</td>
      </tr>
      <tr>
          <td>01</td>
          <td>addi</td>
          <td>addiw</td>
          <td>li</td>
          <td>lui<br>addi16sp<br>zcmop</td>
          <td>ARITHs<br>zcb</td>
          <td>j</td>
          <td>beqz</td>
          <td>bnez</td>
      </tr>
      <tr>
          <td>10</td>
          <td>slli</td>
          <td>fldsp</td>
          <td>lwsp</td>
          <td>ldsp</td>
          <td>jr;mv<br>ebreak<br>jalr;add</td>
          <td>fsdsp</td>
          <td>fwsp</td>
          <td>sdsp</td>
      </tr>
  </tbody>
</table>
<p>在开始阅读各指令的扩展规则时，需要了解一些RVC扩展的前置知识，比如：</p>
<p>rd&rsquo;, rs1&rsquo;和rs2&rsquo;寄存器：受限于16位指令的位宽限制，这几个寄存器只有3位来表示，他们对应到x8~x15寄存器。</p>
<h3 id="op--b00">op = b'00'</h3>
<h4 id="funct--b000-addi4spn">funct = b'000&rsquo;: ADDI4SPN</h4>
<image src="Caddi4spn.png" alter="addi4spn" width=600px />
<p>该指令将一个0扩展的非0立即数加到栈指针寄存器x2上，并将结果写入rd'</p>
<p>其中，nzuimm[5:4|9:6|2|3]的含义是：</p>
<p>这条指令的第12至11位是立即数的5至4位，第10至7位是立即数的9至6位，第6位是立即数的第2位，第7位是立即数的第3位。</p>
<p>这条指令最终扩展成为<strong>addi rd&rsquo;, x2, nzuimm[9:2]</strong></p>
<p>addi的格式形如：| imm[11:0] | rs1 | 000 | rd | 0010011 |</p>
<p>注意，该指令的立即数为0的时候，不合法。</p>
<h4 id="funct--b001-fld">funct = b'001&rsquo;: fld</h4>
<image src="Cfld.png" alter="fld" width=600px />
<p>该指令从内存加载一个双精度浮点数到rd&rsquo;寄存器。</p>
<p>offset的低三位是0，高位进行了0扩展。</p>
<p>这条指令最终扩展成为<strong>fld rd′,offset(rs1′)</strong></p>
<p>fld的格式形如： | imm[11:0] | rs1 | 011 | rd | 0000111 |</p>
<p>注意：在昆明湖环境下，该指令要求CSR使能fs.status，也即入参fsIsOff为假。</p>
<h4 id="funct--b010-lw">funct = b'010&rsquo;: lw</h4>
<image src="Cfld.png" alter="lw" width=600px />
<p>该指令从内存加载一个32位的值到rd&rsquo;寄存器。</p>
<p>offset的低两位是0，高位进行了0扩展。</p>
<p>这条指令最终扩展成为<strong>lw rd′,offset(rs1′)</strong></p>
<p>lw的格式形如： | imm[11:0] | rs1 | 010 | rd | 0000011 |</p>
<h4 id="funct--b011-ldsp">funct = b'011&rsquo;: ldsp</h4>
<image src="Cfld.png" alter="ld" width=600px />
<p>该指令从内存加载一个64位的值到rd&rsquo;寄存器。</p>
<p>offset的低两位是0，高位进行了0扩展。</p>
<p>这条指令最终扩展成为<strong>ld rd′,offset(rs1′)</strong></p>
<p>ld的格式形如： | imm[11:0] | rs1 | 011 | rd | 0000011 |</p>
<h4 id="funct--b100-zcb-extensions-1">funct = b'100&rsquo;: zcb extensions 1</h4>
<p>在RVC指令中，这部分对应的是zcb扩展中的5条指令：lbu,lhu,lh,sb,sh</p>
<p>在zcb扩展中，进一步地取instr[12:10]作为zcb扩展的指令码，我们记作funct_zcb</p>
<h5 id="funct_zcb--b000-lbu">funct_zcb = b'000&rsquo;: lbu</h5>
<p>| 100 | 000 | rs1&rsquo; | uimm[0|1] | rd&rsquo; | 00 |</p>
<p>这个指令从rs1&rsquo;+uimm的地址读取一字节，用0扩展并并加载到rd&rsquo;中。</p>
<p>最终翻译为 lb rd&rsquo;, uimm(rs1')</p>
<p>lb指令的格式形如：| imm[11:0] | rs1 | 000 | rd | 0000011 |</p>
<h5 id="funct_zcb--b001-instr6-0--lhu">funct_zcb = b'001&rsquo;, instr[6] =0 : lhu</h5>
<p>| 100 | 001 | rs1&rsquo; | 0 | uimm[1] | rd&rsquo; | 00 |</p>
<p>这个指令从地址rs1&rsquo; + uimm读取半word，用0扩展加载到rd&rsquo;中。</p>
<p>最终翻译为 lhu rd&rsquo;, uimm(rs1')</p>
<p>lhu指令的格式形如：| imm[11:0] | rs1 | 101 | rd | 0000011 |</p>
<h5 id="funct_zcb--b001-instr6-1--lh">funct_zcb = b'001&rsquo;, instr[6] =1 : lh</h5>
<p>| 100 | 001 | rs1&rsquo; | 1 | uimm[1] | rd&rsquo; | 00 |</p>
<p>这个指令从地址rs1&rsquo; + uimm读取半word，符号扩展并加载到rd&rsquo;中。</p>
<p>最终翻译为 lh rd&rsquo;, uimm(rs1')</p>
<p>lh指令的格式形如：| imm[11:0] | rs1 | 001 | rd | 0000011 |</p>
<h5 id="funct_zcb--b010-sb">funct_zcb = b'010&rsquo;： sb</h5>
<p>| 100 | 010 | rs1&rsquo; | uimm[0 | 1] | rd&rsquo; | 00 |</p>
<p>这个指令把rs2&rsquo;的低字节存储到地址rs1&rsquo; + uimm指示的内存地址中。</p>
<p>最终翻译为 sb rs2, uimm(rs1')</p>
<p>RVI中sb指令的格式形如：|imm[11:5] | rs2 | rs1 | 000 | imm[4:0] | 0100011 |</p>
<h5 id="funct_zcb--b011-sh">funct_zcb = b'011&rsquo;: sh</h5>
<p>| 100 | 011 | rs1&rsquo; | 0 | uimm[1] | rd&rsquo; | 00 |</p>
<p>这个指令把rs2&rsquo;的低半字存储到地址rs1&rsquo; + uimmz指示的内存地址中。</p>
<p>最终翻译为 sh rd&rsquo;, uimm(rs1')</p>
<p>sh指令的格式形如：|imm[11:5] | rs2 | rs1 | 001 | imm[4:0] | 0100011 |</p>
<h4 id="funct--b101-fsd">funct = b'101&rsquo;: fsd</h4>
<image src="Cfsd.png" alter="fsd" width=600px />
<p>fsd将rs2&rsquo;中的双精度浮点数存储到rs1&rsquo; + imm指示的内存区域</p>
<p>该指令的立即数低3位为0，同时进行了0符号扩展。</p>
<p>最终这个指令将被扩展为<strong>fsd rs2′, offset(rs1′)</strong></p>
<p>RVI的FSD格式形如：| imm[11:5]| rs2 | rs1 | 011 | imm[4:0] | 0100011 |</p>
<p>注意：在昆明湖环境下，该指令要求CSR使能fs.status，也即入参fsIsOff为假。</p>
<h4 id="funct--b110-sw">funct = b'110&rsquo;: sw</h4>
<image src="Cfsd.png" alter="sw" width=600px />
<p>sw将rs2&rsquo;中的一个字存储到rs1&rsquo; + imm指示的内存区域</p>
<p>该指令的立即数低2位为0，同时进行了0符号扩展。</p>
<p>最终这个指令将被扩展为<strong>sw rs2′, offset(rs1′)</strong></p>
<p>RVI的SW格式形如：| imm[11:5]| rs2 | rs1 | 010 | imm[4:0] | 0100011 |</p>
<h4 id="funct--b111-sd">funct = b'111&rsquo;: sd</h4>
<image src="Cfsd.png" alter="sd" width=600px />
<p>fsd将rs2&rsquo;中的双字存储到rs1&rsquo; + imm指示的内存区域</p>
<p>该指令的立即数低3位为0，同时进行了0符号扩展。</p>
<p>最终这个指令将被扩展为<strong>sd rs2′, offset(rs1′)</strong></p>
<p>RVI的SD格式形如：| imm[11:5]| rs2 | rs1 | 011 | imm[4:0] | 0100111 |</p>
<h3 id="op--b01">op = b'01'</h3>
<h4 id="funct--b000-addi">funct = b'000&rsquo;: addi</h4>
<image src="Caddi.png" alter="addi" width=600px />
<p>该指令将一个符号扩展的非0立即数加到rd存储的数字上，并将结果写入rd。</p>
<p>尽管手册规定立即数和rd不为0，但是立即数和rd为0的情况仍可视为合法。前者是HINT指令，而后者是NOP。</p>
<p>这条指令最终扩展成为<strong>addi rd, rd, imm</strong></p>
<p>addi的格式形如：| imm[11:0] | rs1 | 000 | rd | 0010011 |</p>
<h4 id="funct--b001-addiw">funct = b'001&rsquo;: addiw</h4>
<image src="Caddi.png" alter="addiw" width=600px />
<p>该指令的功能和addi类似，但是先计算得到32位数，然后再符号扩展至64位。</p>
<p>该指令的rd为0时非法。</p>
<p>当立即数不为0时，该指令最终扩展成为<strong>addiw, rd, rd, imm</strong></p>
<p>addiw的指令格式为| imm[11:0] | rs1 | 000 | rd | 0011011 |</p>
<p>如果立即数为0,该指令将会扩展成为sext.w rd，不过和addiw的格式是一样的，因此可以将他们归为一类。</p>
<h4 id="funct--b010-li">funct = b'010&rsquo;: li</h4>
<image src="Cli.png" alter="li" width=600px />
<p>该指令将符号扩展的立即数加载到rd中。</p>
<p>当立即数为0时，该指令为hint，可以看作合法。</p>
<p>这条指令最终扩展成为<strong>addi rd, x0, imm</strong></p>
<p>addi的格式形如：| imm[11:0] | rs1 | 000 | rd | 0010011 |</p>
<h4 id="funct--b011-luiaddi16spzcm">funct = b'011&rsquo;: lui/addi16sp/zcm</h4>
<image src="Cli.png" alter="lui" width=600px />
<p>当rd不为0且不为2时，为lui指令，可以扩展为<strong>lui rd, imm</strong></p>
<p>lui指令的格式形如： | imm[31:12] | rd | 0110111 |</p>
<p>当立即数为0时，这一字段reserved</p>
<p>当rd为0时，为hint，也可当作cli进行译码。</p>
<p>当rd为2时，为addi16sp指令：</p>
<image src="Caddi.png" alter="addi16sp" width=600px />
<p>扩展为<strong>addi x2, x2, nzimm[9:4]</strong></p>
<p>addi的格式形如：| imm[11:0] | rs1 | 000 | rd | 0010011 |</p>
<p>对addi16sp，立即数为0时非法。</p>
<p>此外，当第12至11位皆为0，第7位是1且第6至2位为0时，为zcmop，可以直接翻译为一个不起效的指令，比如与立即数0。</p>
<h4 id="funct--b100-arith--zcb-extension2">funct = b'100&rsquo;: arith &amp; zcb extension2</h4>
<p>在RVC指令中，这部分对应的是数学运算指令和zcb扩展中的另一部分指令，数学计算指令的对应如下：</p>
<image src="op01funct100.png" alter="arith" width=600px />
<p>其中SRLI64和SRAI64在昆明湖环境下可以不考虑。</p>
<h5 id="srli">srli</h5>
<image src="Csrli.png" alter="srli" width=600px />
<p>当funct2为00时，为srli。</p>
<p>最终可翻译为<strong>srli rd′, rd′, 64</strong></p>
<p>srli的格式形如：|0000000|shamt|rs1|101|rd|0010011|</p>
<h5 id="srai">srai</h5>
<image src="Csrli.png" alter="srai" width=600px />
<p>当funct2为01时，为srai。</p>
<p>最终可翻译为<strong>srai rd′, rd′, 64</strong></p>
<p>SRAI的格式形如：|0100000|shamt|rs1|101|rd|0010011|</p>
<h5 id="andi">andi</h5>
<image src="Candi.png" alter="andi" width=600px />
<p>该指令最终扩展为<strong>andi rd′, rd′, imm</strong></p>
<p>andi的格式形如|imm[11:0]|rs1|111|rd|0010011|</p>
<h5 id="sub">sub</h5>
<image src="Csub.png" alter="sub" width=600px />
<p>这条指令最终可以扩展为：<strong>sub rd′, rd′, rs2′</strong></p>
<p>sub指令的格式形如：|0100000|rs2|rs1|000|rd|0110011|</p>
<h5 id="xor">xor</h5>
<image src="Csub.png" alter="xor" width=600px />
<p>这条指令最终可以扩展为：<strong>xor rd′, rd′, rs2′</strong></p>
<p>xor指令的格式形如：|0000000|rs2|rs1|100|rd|0110011|</p>
<h5 id="or">or</h5>
<image src="Csub.png" alter="or" width=600px />
<p>这条指令最终可以扩展为：<strong>or rd′, rd′, rs2′</strong></p>
<p>or指令的格式形如：|0000000|rs2|rs1|110|rd|0110011|</p>
<h5 id="and">and</h5>
<image src="Csub.png" alter="and" width=600px />
<p>这条指令最终可以扩展为：<strong>and rd′, rd′, rs2′</strong></p>
<p>and指令的格式形如：|0000000|rs2|rs1|111|rd|0110011|</p>
<h5 id="subw">subw</h5>
<image src="Csub.png" alter="subw" width=600px />
<p>这条指令最终可以扩展为：<strong>subw rd′, rd′, rs2′</strong></p>
<p>subw指令的格式形如：|0100000|rs2|rs1|000|rd|0111011|</p>
<h5 id="addw">addw</h5>
<image src="Csub.png" alter="addw" width=600px />
<p>这条指令最终可以扩展为：<strong>addw rd′, rd′, rs2′</strong></p>
<p>addw指令的格式形如：|0000000|rs2|rs1|000|rd|0111011|</p>
<h5 id="mul">mul</h5>
<p>从mul开始的一部分指令属于zcb扩展。</p>
<p>zcb扩展中，当instr(12, 10) == &ldquo;111&rdquo;，且instr(6, 5)为&quot;10&quot;时，为mul指令。</p>
<p>zcb扩展中，当instr(12, 10) == &ldquo;111&rdquo;，且instr(6, 5)为&quot;11&quot;时，根据instr(4,2)，
共有000的zext.b，001的sext.b，010的zext.h，011的sext.h，100的zext.w和101的not。</p>
<image src="mul.png" alter="mul" width=600px />
<p>该指令可扩展为mul rd, rd, rs2</p>
<p>mul的格式为：|0000001|rs2|rs1|000|rd|0110011|</p>
<h5 id="zextb">zext.b</h5>
<image src="zextb.png" alter="mul" width=600px />
<p>这条指令可以翻译为：<strong>andi rd&rsquo;/rs1&rsquo;, rd&rsquo;/rs1&rsquo;, 0xff</strong></p>
<p>andi的格式形如|imm[11:0]|rs1|111|rd|0010011|</p>
<h5 id="sextb">sext.b</h5>
<image src="Csextb.png" alter="Csextb" width=600px />
<p>该指令翻译为<strong>sext.b rd, rd</strong></p>
<p>sext.b指令在RVI下形如:</p>
<image src="Isextb.png" alter="Isextb" width=600px />
<h5 id="zexth">zext.h</h5>
<image src="Czexth.png" alter="Czexth" width=600px />
<p>该指令翻译为<strong>zext.h rd, rd</strong></p>
<p>zext.h指令在RVI下形如:</p>
<image src="Izexth.png" alter="Izexth" width=600px />
<h5 id="sexth">sext.h</h5>
<image src="Csexth.png" alter="Csexth" width=600px />
<p>该指令翻译为<strong>sext.h rd, rd</strong></p>
<p>sext.h指令在RVI下形如:</p>
<image src="Isexth.png" alter="Isexth" width=600px />
<h5 id="zextw">zext.w</h5>
<image src="zextw.png" alter="zextw" width=600px />
<p>该指令等价为<strong>add.uw rd&rsquo;/rs1&rsquo;, rd&rsquo;/rs1&rsquo;, zero</strong></p>
<p>add.uw指令在RVI下形如:</p>
<image src="adduw.png" alter="adduw" width=600px />
<h5 id="not">not</h5>
<image src="not.png" alter="not" width=600px />
<p>该指令等价为<strong>xori rd&rsquo;/rs1&rsquo;, rd&rsquo;/rs1&rsquo;, -1</strong></p>
<p>xori指令在RVI下形如： | imm[11:0] | rs1| 100 | rd | 0010011 |</p>
<h4 id="funct--b101-j">funct = b'101&rsquo;: j</h4>
<image src="Cj.png" alter="j" width=600px />
<p>最终这个指令将被扩展为<strong>jal x0, offset</strong></p>
<p>jal的格式形如：| imm[20|10:1|11|19:12] | rd | 1101111 |</p>
<h4 id="funct--b110-beqz">funct = b'110&rsquo;: beqz</h4>
<image src="Cbnez.png" alter="beqz" width=600px />
<p>该指令可以扩展到<strong>beq rs1‘, x0, offset</strong></p>
<p>beq指令形如： |imm[12|10:5]|rs2|rs1|000|imm[4:1|11]|1100011|
imm[12|10:5]rs2rs1001imm[4:1|11]1100011BNE</p>
<h4 id="funct--b111-bnez">funct = b'111&rsquo;: bnez</h4>
<image src="Cbnez.png" alter="bnez" width=600px />
<p>最终这个指令将被扩展为<strong>bne rs1′, x0, offset</strong></p>
<p>bne指令形如：|imm[12|10:5]| rs2 | rs1 | 001 | imm[4:1|11] | 1100011|</p>
<h3 id="op--b10">op = b'10'</h3>
<h4 id="funct--b000-slli">funct = b'000&rsquo;: slli</h4>
<image src="Cslli.png" alter="slli" width=600px />
<p>该指令将一个符号扩展的非0立即数加到rd存储的数字上，并将结果写入rd。</p>
<p>尽管手册规定立即数和rd不为0，但是立即数和rd为0的情况仍可视为合法。前者是HINT指令，而后者是NOP。</p>
<p>这条指令最终扩展成为<strong>slli rd, rd, shamt[5:0]</strong></p>
<p>slli的格式形如：|000000|shamt|rs1|001|rd|0010011|</p>
<h4 id="funct--b001-fldsp">funct = b'001&rsquo;: fldsp</h4>
<image src="Cfldsp.png" alter="fldsp" width=600px />
<p>该指令最终扩展成为<strong>fld rd, offset(x2)</strong></p>
<p>fld的格式形如： | imm[11:0] | rs1 | 011 | rd | 0000111 |</p>
<p>该指令要求CSR使能fs.status</p>
<h4 id="funct--b010-lwsp">funct = b'010&rsquo;: lwsp</h4>
<image src="Cfldsp.png" alter="lwsp" width=600px />
<p>rd为0时非法。</p>
<p>这条指令最终扩展成为<strong>lw rd, offset(x2)</strong></p>
<p>lw的格式形如： | imm[11:0] | rs1 | 010 | rd | 0000011 |</p>
<h4 id="funct--b011-ldsp-1">funct = b'011&rsquo;: ldsp</h4>
<image src="Cfldsp.png" alter="ldsp" width=600px />
<p>rd为0时非法。</p>
<p>这条指令最终扩展成为<strong>ld rd, offset(x2)</strong></p>
<p>lw的格式形如： | imm[11:0] | rs1 | 011 | rd | 0000011 |</p>
<h4 id="funct--b100-jrmvebreakjalradd">funct = b'100&rsquo;: jr/mv/ebreak/jalr/add</h4>
<image src="op10funct100.png" alter="jrmvebreakjalradd" width=600px />
<h5 id="jr">jr</h5>
<image src="Cjr.png" alter="jr" width=600px />
<p>当rd为0时，非法。</p>
<p>该指令最终可以扩展为<strong>jalr x0, 0(rs1)</strong></p>
<p>jalr指令的格式为：|imm[11:0]|rs1|000|rd|1100111|</p>
<h5 id="mv">mv</h5>
<image src="Cmv.png" alter="mv" width=600px />
<p>rd为0时，是hint指令。</p>
<p>该指令最终可以扩展为<strong>add rd, x0, rs2</strong></p>
<p>add指令形如：|0000000|rs2|rs1|000|rd|0110011|</p>
<h5 id="ebreak">ebreak</h5>
<p>可以扩展为ebreak指令。</p>
<p>形如：|00000000000100000000000001110011|</p>
<h5 id="jalr">jalr</h5>
<image src="Cjr.png" alter="jalr" width=600px />
<p>该指令最终可以扩展为<strong>jalr x1, 0(rs1)</strong></p>
<p>jalr指令的格式为：|imm[11:0]|rs1|000|rd|1100111|</p>
<h5 id="add">add</h5>
<image src="Cmv.png" alter="mv" width=600px />
<p>该指令最终可以扩展为<strong>add rd, rd, rs2</strong></p>
<p>add指令形如：|0000000|rs2|rs1|000|rd|0110011|</p>
<h4 id="funct--b101-fsdsp">funct = b'101&rsquo;: fsdsp</h4>
<image src="Cfsdsp.png" alter="fsdsp" width=600px />
<p>这条指令最终扩展成为<strong>fsd rs2, offset(x2)</strong></p>
<p>RVI的FSD格式形如：| imm[11:5]| rs2 | rs1 | 011 | imm[4:0] | 0100011 |</p>
<p>该指令要求CSR使能fs.status</p>
<h4 id="funct--b110-swsp">funct = b'110&rsquo;: swsp</h4>
<image src="Cfsdsp.png" alter="swsp" width=600px />
<p>这条指令最终扩展成为<strong>sw rs2, offset(x2)</strong></p>
<p>RVI的SW格式形如：| imm[11:5]| rs2 | rs1 | 010 | imm[4:0] | 0100011 |</p>
<h4 id="funct--b111-sdsp">funct = b'111&rsquo;: sdsp</h4>
<image src="Cfsdsp.png" alter="sdsp" width=600px />
<p>该指令最终扩展成为<strong>sd rd, offset(x2)</strong></p>
<p>RVI的SD格式形如：| imm[11:5]| rs2 | rs1 | 011 | imm[4:0] | 0100111 |</p>
</div>
</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-645785e2f920783aa88dc445517a7128">12.2.4 - ITLB</h1>
    
	<h2 id="tlb-功能概述">TLB 功能概述</h2>
<p>现代操作系统通常采用虚拟内存管理机制（Virtual Memory Management），在处理器中对应需要内存管理单元（MMU，Memory Management Unit）来进行虚实地址的映射。MMU 负责处理 CPU 的内存访问请求，其功能包括虚实地址的映射、内存保护、CPU 高速缓存控制等。</p>
<p>虚实地址的映射是以页（Page）为单位的。在物理内存管理中，内核会将整个物理内存空间划分为一个一个的页帧（Page Frame），一般情况下页帧大小为 4KB，称为一个物理页帧，内核会将每一个物理页帧进行编号（PFN，Page Frame Number），每个页帧有唯一确定的 PFN。对于一个进程来说，如果它直接使用物理地址构建自己的地址空间，那么作为进程就需要关心每一个变量存放在哪一个物理地址，也就是说程序员需要清楚数据在内存中的具体布局，还需要每次都要考虑内存的分配问题；同时，对于多个进程同时进行的情况，哪些数据是共享的，如何避免地址冲突等等都会成为问题。</p>
<p><img src="address_space.png" alt="进程地址空间"></p>
<p>MMU 为每个进程创建自己的虚拟地址空间，存储虚实地址的映射，在进程的视角看来它独享一段确定的（通常是连续的）地址，避免了其它进程的干扰；同时提供了虚实地址转换功能，这使得进程不必关心实际的物理地址在哪里，只需要对自己的地址空间进行操作。同时，对于一个进程来说，每次访问内存时并不是访问整个虚拟内存空间，因此进程实际需要占用的物理内存大小可以小于其虚拟地址空间的大小，由操作系统来决定要把哪一部分留在内存中，将剩余部分保存在磁盘中，在需要时再加载进入内存，极大的扩展了可用内存空间。</p>
<i>
<p><strong>程序局部性原理</strong>，是计算机科学术语，指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。局部性原理又表现为：<strong>时间局部性</strong>和<strong>空间局部性</strong>。</p>
<ul>
<li><strong>时间局部性</strong>是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。</li>
<li><strong>空间局部性</strong>是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。</li>
</ul>
</i>
<p><img src="virtual2real_pagetable_mapping.png" alt="虚实页表映射"></p>
<p>这样的由 MMU 创建的并负责维护的由虚拟地址指向物理地址的映射也将成为一项存储在一个物理页帧中，MMU 为了访问这样的物理页帧也需要一个根页表，根页表中存储着指向这些物理页帧的页表项（PTE），称为叶子 PTE。一个 PTE 的长度一般为 64 Bit（8 Bytes），而每一个一般物理页帧的大小为 4KB，这也就意味着一个物理页帧最多可以存储 4KB/8B = 2^9 个 PTE，因此根页表可以索引的范围即为 2^9 × 4KB = 2MB。2MB 的页表并不能满足内存日益增大的需要，在香山中实现的 SV48 即采用了四级页表的形式，通过四级的查询最终得到物理地址，每一级页表都能够索引 2^9 个下一级页表，最终找到需要的映射。四级页表下能够索引的地址范围达到了 2^9 × 2^9 × 2^9 × 2MB = 256TB。而页表本身也会比较大，如果存满的话大小会达到 4KB + 2^9 × 4KB + 2^9 × 2^9 × 4KB + 2^9 × 2^9 × 2^9 × 4KB = 537921540KB ≈ 513GB。当然，不是说每一级页表都要填满，页表的四级结构可以理解为一个多叉树形结构，只有需要用到的才会实际使用，很多的分支都不需要使用，因此页表的大小是可变的。</p>
<p>页表一般很大，需要存放在内存中，而处理器每一次访问内存的请求都需要先访问页表查找对应的物理页号然后再去读取所需数据，因此在不发生缺页的情况下，每次访存操作都需要两次访问内存才能得到物理地址，然后再次访问才能得到需要的数据。为了减少多次访存造成的开销，引入了地址转换后援缓存器（TLB，Translation Lookaside Buffer）。MMU 通常借助 TLB 来进行虚实地址的转换。TLB 一般是相连高速缓存（associative cache），相当于页表的 Cache，负责将最可能会用到的页表项对应的映射（虚拟地址与对应的物理地址）存储下来；在查找页表时首先查找 TLB 内存储的映射，如果没有命中再去查找内存中存储的完整页表。</p>
<p>同 Cache 一样，TLB 中页表项的组织方式一般有直接映射、全相联映射、组相连映射三种方式。直接映射一般通过模运算匹配，例如对昆明湖 48 行的 TLB 来说，其第 1 块只能对应内存的第 1/49/97/&hellip;/(n×48+1) 块，硬件结构简单、成本低、转换速度快，但是 TLB 表项利用率低，TLB miss 频繁，只适用于 TLB 大小与页表大小较接近的情况。全相联映射则不同，内存中的所有表项可以存放在 TLB 中的任意一项中，可以充分利用 TLB 的空间，冲突概率更低，但因此查找开销较高，适用于小容量 TLB。组相联映射是一种折中，可以二路组相联、四路组相联等。在香山的 TLB 模块中提供了丰富的参数配置，其中即包括采取哪一种相连方式，可以通过传入参数自行配置。本次验证的 ITLB 即采用 48 项全相联的结构。</p>
<p><img src="2waygroup.png" alt="二路组相联示意图">
<img src="4waygroup.png" alt="四路组相联示意图"></p>
<p>香山的 MMU 模块由 TLB、Repeator、L2TLB、PMP&amp;PMA 组成，其中 L2TLB 又包含了 Page Cache、Page Table Walker、Last Level Page Table Walker、Miss Queue 和 Prefetcher。在核内每次进行内存的操作（读写）时都需要通过 MMU 模块进行虚实地址的翻译，而 TLB 将被实例化为 ITLB（前端取指）和 DTLB（后端访存）。以 ITLB 为例，每当 ICache 或 IFU 需要进行取指操作，会先向 ITLB 发送一个地址转换请求，把需要转换的虚拟地址发给 ITLB；ITLB 接收到请求后就要查找自己存储的表项里有没有这个虚拟地址对应的映射，如果有的话就输出对应物理地址（paddr），之后由 PMP&amp;PMA 模块检查对该物理地址的访问是否有效（包括地址是否有效、访问者是否有访问权限、页表属性等，其中对 ITLB 来说由于取出来的物理地址是待执行的指令，需要检查是否可以执行），检查通过后就可以把物理地址返回给前端。如果 ITLB 发现自己没有存储这样的表项，那么立即回应 miss，并同时发起 PTW 请求。前端接收到 miss 信号后会通过一些调度策略重新发起访问，在香山中体现为 miss 后不断重新给 TLB 发请求直到 hit。PTW 请求将交由 Page Table Walker 来执行，通过一些策略访问 L2TLB、Page Cache、内存中的完整页表，之后把访问到的 PTE（页表项）发回给 TLB（如果 PTW 都找不到那么会发生 Page Fault，同样返回给 TLB，TLB 收到 Page Fault 后会上报并由操作系统等从磁盘中加载页面）。TLB 接收到 PTE 的同时将 PTE 填充进自己的缓存中并向前端返回物理地址，前端才能通过该物理地址找到对应的指令。</p>
<p><img src="TLBfunc.png" alt="TLB功能示意图"></p>
<p>香山实现了二级 TLB，包括 TLB 与 L2TLB。同样类似于 Cache 与 L2Cache，TLB（一级 TLB）通常是小容量、高速缓存，直接与处理器核心连接，用于加速最近访问过的虚拟地址到物理地址的转换；L2TLB（二级 TLB）容量较大，速度稍慢，但比直接访问内存要快。L2TLB 用来缓存更多的页表项，减少一级 TLB 未命中（TLB Miss）时对内存的频繁访问，香山目前有 1 个 ITLB 和 3 个 DTLB，都与同一个 L2TLB 连接。在这种二级结构下，TLB 未命中时将会首先查找 L2TLB，之后如果再次未命中才去访问内存，可以有效提高地址转换的命中率和性能。由于在 TLB 与 L2TLB 之间有着一定的物理距离，因此在 TLB 向 L2TLB 发出读取请求的时候需要进行加拍，这项工作交给了 MMU 中的 repeater 进行，是 TLB 与 L2TLB 之间的一个请求缓冲。同时，repeator 还需要负责对 TLB 向 L2TLB 发送的请求进行过滤（即 Filter 的功能），把重复的请求过滤掉，以减少 L2TLB 性能损失。</p>
<p>昆明湖架构支持 RISC-V 手册中定义的 Hypervisor 扩展，即 H 扩展。H 扩展为处理器提供了虚拟化的支持，即允许虚拟机运行在主机上，此时虚拟机将与主机共享 TLB，那么在 MMU 中也需要进行相应的调整与支持。TLB 需要能够同时容纳多个虚拟机的条目并做到隔离，同时需要引入 Hypervisor Page Table Walker（HPTW）用于遍历虚拟机的页表。</p>
<p>在 MMU 模块中还需要实现 PMP（Physical Memory Protection）与 PMA（Physical Memory Access）检查，不过这与 TLB 无关，在实现中无论请求是否有效或有足够权限，都会通过 TLB 先进行地址转换，之后再把转换的结果（物理地址）送到 PMP&amp;PMA 模块进行权限检查。</p>
<h2 id="验证功能点列表及说明">验证功能点列表及说明</h2>
<p>此处将给出划分功能点及测试点的示例。如果您划分了新的功能点，请及时与我们沟通，我们会根据沟通结果修正功能点列表。测试点原则上可根据验证实际情况自行划分，此处仅给出示例。</p>
<h3 id="功能点1tlb接收请求">功能点1：TLB接收请求</h3>
<h4 id="功能说明">功能说明</h4>
<p>TLB 应当正常接收来自 IFU 与 ICache 的取指令请求，查找自身页表并作出适当的反应：miss 情况下返回 miss 并同时向 PTW 发送遍历请求，hit 情况返回正确结果。验证时此处应关注 TLB 做出的反应，无需关注请求本身的多种情况。</p>
<h4 id="测试点示例">测试点示例</h4>
<table>
  <thead>
      <tr>
          <th>No.</th>
          <th>名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>接收来自 ICache 请求（requestor0、1）</td>
          <td>ITLB 根据请求查找自身缓存 TLBuffer，返回 hit/miss 结果</td>
      </tr>
      <tr>
          <td>1.2</td>
          <td>接收来自 IFU 请求（requestor2）</td>
          <td>注意此处为阻塞式访问，每次访问后若 miss 应当 reset 后再次访问</td>
      </tr>
      <tr>
          <td>1.3</td>
          <td>接收条件判断（requestor0、1）</td>
          <td>valid 信号</td>
      </tr>
      <tr>
          <td>1.4</td>
          <td>接受条件判断（requestor2）</td>
          <td>valid-ready 信号</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点2tlb-miss-处理">功能点2：TLB miss 处理</h3>
<h4 id="功能说明-1">功能说明</h4>
<p>miss 情况下发送页表遍历请求，额外需要注意边界情况下的请求处理，保证 TLB 发送的 PTW 请求正确。</p>
<h4 id="测试点示例-1">测试点示例</h4>
<table>
  <thead>
      <tr>
          <th>No.</th>
          <th>名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.1</td>
          <td>返回 miss 结果</td>
          <td>比对后发现 miss 并返回</td>
      </tr>
      <tr>
          <td>2.2</td>
          <td>发起 PTW req（同时检验 PTW req valid 0/1）</td>
          <td>从端口 0/1 发起页表遍历请求</td>
      </tr>
      <tr>
          <td>2.3</td>
          <td>发起 PTW req（同时检验 PTW req valid-ready 2）</td>
          <td>从端口 2 发起页表遍历请求</td>
      </tr>
      <tr>
          <td>2.4</td>
          <td>不同情况下发起 PTW req</td>
          <td>改变 CSR（vsatp、hgatp），依然能够正常发送请求</td>
      </tr>
      <tr>
          <td>2.5</td>
          <td>PTW resp valid 信号有效</td>
          <td>检验该信号是否正常</td>
      </tr>
      <tr>
          <td>2.6</td>
          <td>重填 nonStage 条目，之后能正确访问</td>
          <td>无</td>
      </tr>
      <tr>
          <td>2.7</td>
          <td>重填 OnlyStage1 条目，之后能正确访问</td>
          <td>无</td>
      </tr>
      <tr>
          <td>2.8</td>
          <td>重填 OnleStage2 条目，之后能正确访问</td>
          <td>无</td>
      </tr>
      <tr>
          <td>2.9</td>
          <td>重填 allStage 条目，之后能正确访问</td>
          <td>无</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点3tlb-hit-处理">功能点3：TLB hit 处理</h3>
<h4 id="功能说明-2">功能说明</h4>
<p>hit 情况下返回查询到的物理地址。requestor2 应当结束阻塞。</p>
<h4 id="测试点示例-2">测试点示例</h4>
<table>
  <thead>
      <tr>
          <th>No.</th>
          <th>名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>3.1</td>
          <td>主机查询得到物理地址</td>
          <td>paddr</td>
      </tr>
      <tr>
          <td>3.2</td>
          <td>虚拟机查询得到物理地址</td>
          <td>gpaddr</td>
      </tr>
      <tr>
          <td>3.3</td>
          <td>虚拟机查询得到中间物理地址</td>
          <td>IPA</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点4替换策略">功能点4：替换策略</h3>
<h4 id="功能说明-3">功能说明</h4>
<p>根据文档说明，香山的 ITLB 使用 PLRU 替换策略，具体实现时使用的是外部提供的库。验证时可自学 PLRU 算法，并设计合理策略。</p>
<h4 id="测试点示例-3">测试点示例</h4>
<table>
  <thead>
      <tr>
          <th>No.</th>
          <th>名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>4.1</td>
          <td>填满后持续重填随机次数</td>
          <td>建议建立参考模型进行对比</td>
      </tr>
      <tr>
          <td>4.2</td>
          <td>随机 hit/miss 一段时间</td>
          <td>建议建立参考模型进行对比</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点5tlb-缓存大小">功能点5：TLB 缓存大小</h3>
<h4 id="功能说明-4">功能说明</h4>
<p>检验 TLB 是否能够支持理论最大（48*8）项页表条目的存储。注意 PLRU 替换策略将导致一定情况下不能填满，验证中无需考虑因为该策略导致的未填充满。</p>
<h4 id="测试点示例-4">测试点示例</h4>
<table>
  <thead>
      <tr>
          <th>No.</th>
          <th>名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>5.1</td>
          <td>顺序填充至满</td>
          <td>检验最终能够存储的最大条目数，这将直接影响 TLB 加速取指的效率</td>
      </tr>
      <tr>
          <td>5.2</td>
          <td>乱序随机</td>
          <td>模拟应用场景，记录并检验条目数</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点6tlb-压缩">功能点6：TLB 压缩</h3>
<h4 id="功能说明-5">功能说明</h4>
<p>支持 TLB 压缩，具体可见文档。注意保证随机性。</p>
<h4 id="测试点示例-5">测试点示例</h4>
<table>
  <thead>
      <tr>
          <th>No.</th>
          <th>名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>6.1</td>
          <td>压缩 8 项条目</td>
          <td>一个压缩条目内的 8 项页表项都可以正常 hit</td>
      </tr>
      <tr>
          <td>6.2</td>
          <td>全满压力测试</td>
          <td>全部填满时可连续命中</td>
      </tr>
      <tr>
          <td>6.3</td>
          <td>idx 随机测试</td>
          <td>检测对应 idx 信号是否有效</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点7刷新">功能点7：刷新</h3>
<h4 id="功能说明-6">功能说明</h4>
<p>TLB 模块需要在进程切换等场景下频繁刷新，也需要接收定向刷新指令刷新指定条目。验证中要建立填入-刷新-检验miss情况的流程，建议自定义函数完成。注意页表属性 Global 的影响，自行制定合适的策略。</p>
<h4 id="测试点示例-6">测试点示例</h4>
<table>
  <thead>
      <tr>
          <th>No.</th>
          <th>名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>7.1</td>
          <td>SFENCE  rs1=0 rs2=0</td>
          <td>刷新全部条目</td>
      </tr>
      <tr>
          <td>7.2</td>
          <td>SFENCE  rs1=0 rs2=1</td>
          <td>刷新指定条目</td>
      </tr>
      <tr>
          <td>7.3</td>
          <td>SFENCE  rs1=1 rs2=0</td>
          <td>刷新指定地址空间</td>
      </tr>
      <tr>
          <td>7.4</td>
          <td>SFENCE  rs1=1 rs2=1</td>
          <td>刷新指定地址空间的指定条目</td>
      </tr>
      <tr>
          <td>7.5</td>
          <td>带 flushpipe 的 Sfence</td>
          <td>清空流水线</td>
      </tr>
      <tr>
          <td>7.6</td>
          <td>SFENCE hv=1/hg=1</td>
          <td>刷新虚拟机的条目</td>
      </tr>
      <tr>
          <td>7.7</td>
          <td>flushPipe0</td>
          <td>清空流水线0</td>
      </tr>
      <tr>
          <td>7.8</td>
          <td>flushPipe1</td>
          <td>清空流水线1</td>
      </tr>
      <tr>
          <td>7.9</td>
          <td>flushPipe2</td>
          <td>清空流水线2</td>
      </tr>
      <tr>
          <td>7.10</td>
          <td>satp.changed</td>
          <td>按一定策略刷新</td>
      </tr>
      <tr>
          <td>7.11</td>
          <td>vsatp.changed</td>
          <td>按一定策略刷新</td>
      </tr>
      <tr>
          <td>7.12</td>
          <td>hgatp.changed</td>
          <td>按一定策略刷新</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点8reset">功能点8：Reset</h3>
<h4 id="功能说明-7">功能说明</h4>
<p>保证正常复位。TLB 工作流程涉及多个周期，需保证在各个阶段中执行 reset 均能正常复位。</p>
<h4 id="测试点示例-7">测试点示例</h4>
<table>
  <thead>
      <tr>
          <th>No.</th>
          <th>名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>8.1</td>
          <td>Reset 复位</td>
          <td>检查所有信号按预期复位</td>
      </tr>
      <tr>
          <td>8.2</td>
          <td>请求同时复位</td>
          <td>检查所有信号按预期复位</td>
      </tr>
      <tr>
          <td>8.3</td>
          <td>resp 同时复位</td>
          <td>检查所有信号按预期复位</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点9权限检查">功能点9：权限检查</h3>
<h4 id="功能说明-8">功能说明</h4>
<p>TLB 并不涉及复杂的页属性检查，仅涉及用户态/内核态的权限。由于 ITLB 存储的全部为指令页，页属性必须全部可执行。</p>
<h4 id="测试点示例-8">测试点示例</h4>
<table>
  <thead>
      <tr>
          <th>No.</th>
          <th>名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>9.1</td>
          <td>主机状态下（U/S）访问权限检查</td>
          <td>U 只能访问 U=1，S 只能访问 U=0</td>
      </tr>
      <tr>
          <td>9.2</td>
          <td>虚拟机状态下（VU/VS）访问权限检查</td>
          <td>VU 只能访问 U=1，VS 只能访问 U=0</td>
      </tr>
      <tr>
          <td>9.3</td>
          <td>权限切换时的行为</td>
          <td>IT级别验证时报告权限切换时会出现一个信号异常，可重点关注</td>
      </tr>
      <tr>
          <td>9.4</td>
          <td>X=0</td>
          <td>页面不可执行时的行为</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点10异常处理">功能点10：异常处理</h3>
<h4 id="功能说明-9">功能说明</h4>
<p>ITLB 在异常方面承担的主要职责就是上报。当下层模块报告 GPF 时，由于 ITLB 不存储中间物理地址，此时重填需要首先发送一个带 GetGPA 标志的重填，标志当前重填请求是请求的虚拟机物理地址，PTW 会把这个请求标志发送回来，带该标志的 PTW resp 不会被存入 TLBuffer。</p>
<h4 id="测试点示例-9">测试点示例</h4>
<table>
  <thead>
      <tr>
          <th>No.</th>
          <th>名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>10.1</td>
          <td>s1-pf</td>
          <td>主机缺页异常</td>
      </tr>
      <tr>
          <td>10.2</td>
          <td>s1-af</td>
          <td>主机访问权限异常</td>
      </tr>
      <tr>
          <td>10.3</td>
          <td>s2-gpf</td>
          <td>虚拟机缺页异常</td>
      </tr>
      <tr>
          <td>10.4</td>
          <td>s2-gaf</td>
          <td>虚拟机访问权限异常</td>
      </tr>
      <tr>
          <td>10.5</td>
          <td>getGPA 信号相关</td>
          <td>验证中自行拆分</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点11隔离">功能点11：隔离</h3>
<h4 id="功能说明-10">功能说明</h4>
<p>地址空间隔离，通过 asid、vmid 实现进程、虚拟机之间的隔离。</p>
<h4 id="测试点示例-10">测试点示例</h4>
<table>
  <thead>
      <tr>
          <th>No.</th>
          <th>名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>11.1</td>
          <td>进程间隔离</td>
          <td>无</td>
      </tr>
      <tr>
          <td>11.2</td>
          <td>虚拟机间隔离</td>
          <td>无</td>
      </tr>
      <tr>
          <td>11.3</td>
          <td>虚拟机的进程间隔离</td>
          <td>无</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点12并行访问">功能点12：并行访问</h3>
<h4 id="功能说明-11">功能说明</h4>
<p>模块包含 3 个端口，其访问是可以同时接收的，但是TLB的查询必须按序。TLB会将接收的请求暂存，以队列形式处理，当然 requestor2 作为阻塞式访问不参与这个过程。在实际场景下，对与 TLB miss 的情况，ICache 会自行组织重新持续发送请求。</p>
<h4 id="测试点示例-11">测试点示例</h4>
<table>
  <thead>
      <tr>
          <th>No.</th>
          <th>名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>12.1</td>
          <td>同时 hit</td>
          <td>三个预期会 hit 的请求同一拍进入 TLB</td>
      </tr>
      <tr>
          <td>12.2</td>
          <td>同时 miss</td>
          <td>三个预期会 miss 的请求同一拍进入 TLB</td>
      </tr>
      <tr>
          <td>12.3</td>
          <td>随机顺序回填</td>
          <td>模拟实际场景持续发送请求，并以随机顺序回填</td>
      </tr>
      <tr>
          <td>12.4</td>
          <td>发送请求同时回填请求的地址</td>
          <td>在同一拍对同一个地址发送请求&amp;回填</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点13大小页支持">功能点13：大小页支持</h3>
<h4 id="功能说明-12">功能说明</h4>
<p>TLB 支持保存全部大小页，不同 level 的页面都应该可以存入 TLB 中。</p>
<h4 id="测试点示例-12">测试点示例</h4>
<table>
  <thead>
      <tr>
          <th>No.</th>
          <th>名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>13.1</td>
          <td>level=0</td>
          <td>无</td>
      </tr>
      <tr>
          <td>13.2</td>
          <td>level=1</td>
          <td>无</td>
      </tr>
      <tr>
          <td>13.3</td>
          <td>level=2</td>
          <td>无</td>
      </tr>
      <tr>
          <td>13.4</td>
          <td>level=3</td>
          <td>无</td>
      </tr>
  </tbody>
</table>
<h3 id="功能点14时序">功能点14：时序</h3>
<h4 id="功能点说明">功能点说明</h4>
<p>检验 TLB 时序，保证每拍的信号级别行为正确。</p>
<h4 id="测试点示例-13">测试点示例</h4>
<table>
  <thead>
      <tr>
          <th>No.</th>
          <th>名称</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>14.1</td>
          <td>请求命中时序（requestor0、1）</td>
          <td>无</td>
      </tr>
      <tr>
          <td>14.2</td>
          <td>请求命中时序（requestor2）</td>
          <td>无</td>
      </tr>
      <tr>
          <td>14.3</td>
          <td>请求miss时序（requestor0、1）</td>
          <td>无</td>
      </tr>
      <tr>
          <td>14.4</td>
          <td>请求miss时序（requestor2）</td>
          <td>无</td>
      </tr>
  </tbody>
</table>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-822b35c9edec39da6ca0fd8aa11c9d2a">12.2.4.1 - IO接口说明</h1>
    
	<h1 id="香山实例化-tlbsv-接口说明itlb">香山实例化 TLB.sv 接口说明（ITLB）</h1>
<h2 id="基本控制信号">基本控制信号</h2>
<ul>
<li><code>clock</code>: 时钟信号，驱动 <code>TLB</code> 的时序逻辑。</li>
<li><code>reset</code>: 复位信号，用于重置 <code>TLB</code> 的状态。</li>
</ul>
<h2 id="刷新sfence接口信号">刷新（SFENCE）接口信号</h2>
<ul>
<li><code>io_sfence_valid</code>: <code>SFENCE</code> 操作的有效性标志。</li>
<li><code>io_sfence_bits_rs1</code>: <code>SFENCE</code> 操作是否使用寄存器 <code>rs1</code> 的值。</li>
<li><code>io_sfence_bits_rs2</code>: <code>SFENCE</code> 操作是否使用寄存器 <code>rs2</code> 的值。</li>
<li><code>io_sfence_bits_addr</code>: <code>SFENCE</code> 操作指定的地址，用于选择性刷新特定地址的 <code>TLB</code> 条目。</li>
<li><code>io_sfence_bits_id</code>: 刷新操作指定的 <code>asid/vmid</code>，用于选择性刷新特定地址空间的 <code>TLB</code> 条目。</li>
<li><code>io_sfence_bits_flushPipe</code>: 刷新整个管道。</li>
<li><code>io_sfence_bits_hv</code>: 指示指令是否为 <code>HFENCE.VVMA</code>，即是否刷新虚拟化下由 <code>vsatp</code> 寄存器控制的条目。</li>
<li><code>io_sfence_bits_hg</code>: 指示指令是否为 <code>HFENCE.GVMA</code>，即是否刷新由 <code>hgatp</code> 寄存器控制的条目。</li>
</ul>
<h2 id="控制与状态寄存器csr接口信号">控制与状态寄存器（CSR）接口信号</h2>
<ul>
<li><code>io_csr_satp_mode</code>: <code>SATP</code> 寄存器的模式字段（如裸模式、<code>Sv32</code>、<code>Sv39</code> 等）。</li>
<li><code>io_csr_satp_asid</code>: 当前 <code>SATP</code> 寄存器的 <code>ASID</code>（地址空间标识符）。</li>
<li><code>io_csr_satp_changed</code>: 指示 <code>SATP</code> 寄存器的值是否已更改。</li>
<li><code>io_csr_vsatp_mode</code>: <code>VSATP</code> 寄存器的模式字段。</li>
<li><code>io_csr_vsatp_asid</code>: <code>VSATP</code> 寄存器的 <code>ASID</code>。</li>
<li><code>io_csr_vsatp_changed</code>: 指示 <code>VSATP</code> 寄存器的值是否已更改。</li>
<li><code>io_csr_hgatp_mode</code>: <code>HGATP</code> 寄存器的模式字段。</li>
<li><code>io_csr_hgatp_vmid</code>: <code>HGATP</code> 寄存器的 <code>VMID</code>（虚拟机标识符）。</li>
<li><code>io_csr_hgatp_changed</code>: 指示 <code>HGATP</code> 寄存器的值是否已更改。</li>
<li><code>io_csr_priv_virt</code>: 指示是否在虚拟模式下运行。</li>
<li><code>io_csr_priv_imode</code>: 指令模式的特权级（如用户态、内核态等）。</li>
</ul>
<h2 id="请求者requestor接口信号">请求者（Requestor）接口信号</h2>
<h3 id="requestor-0-信号">Requestor 0 信号</h3>
<ul>
<li><code>io_requestor_0_req_valid</code>: <code>requestor0</code> 的请求有效信号。</li>
<li><code>io_requestor_0_req_bits_vaddr</code>: <code>requestor0</code> 的请求虚拟地址。</li>
<li><code>io_requestor_0_resp_bits_paddr_0</code>: <code>requestor0</code> 的物理地址响应信号。</li>
<li><code>io_requestor_0_resp_bits_gpaddr_0</code>: <code>requestor0</code> 的物理地址转换为 <code>GPA</code>（<code>Guest Physical Address</code>）的响应信号。</li>
<li><code>io_requestor_0_resp_bits_miss</code>: <code>requestor0</code> 请求的地址未命中的信号。</li>
<li><code>io_requestor_0_resp_bits_excp_0_gpf_instr</code>: <code>requestor0</code> 出现 <code>General Protection Fault</code> (<code>GPF</code>) 异常的信号。</li>
<li><code>io_requestor_0_resp_bits_excp_0_pf_instr</code>: <code>requestor0</code> 出现 <code>Page Fault</code> (<code>PF</code>) 异常的信号。</li>
<li><code>io_requestor_0_resp_bits_excp_0_af_instr</code>: <code>requestor0</code> 出现 <code>Access Fault</code> (<code>AF</code>) 异常的信号。</li>
</ul>
<h3 id="requestor-1-信号">Requestor 1 信号</h3>
<ul>
<li><code>io_requestor_1_req_valid</code>: <code>requestor1</code> 的请求有效信号。</li>
<li><code>io_requestor_1_req_bits_vaddr</code>: <code>requestor1</code> 的请求虚拟地址。</li>
<li><code>io_requestor_1_resp_bits_paddr_0</code>: <code>requestor1</code> 的物理地址响应信号。</li>
<li><code>io_requestor_1_resp_bits_gpaddr_0</code>: <code>requestor1</code> 的 <code>GPA</code> 响应信号。</li>
<li><code>io_requestor_1_resp_bits_miss</code>: <code>requestor1</code> 的未命中信号。</li>
<li><code>io_requestor_1_resp_bits_excp_0_gpf_instr</code>: <code>requestor1</code> 出现 <code>GPF</code> 异常的信号。</li>
<li><code>io_requestor_1_resp_bits_excp_0_pf_instr</code>: <code>requestor1</code> 出现 <code>PF</code> 异常的信号。</li>
<li><code>io_requestor_1_resp_bits_excp_0_af_instr</code>: <code>requestor1</code> 出现 <code>AF</code> 异常的信号。</li>
</ul>
<h3 id="requestor-2-信号">Requestor 2 信号</h3>
<ul>
<li><code>io_requestor_2_req_ready</code>: <code>requestor2</code> 的请求就绪信号。</li>
<li><code>io_requestor_2_req_valid</code>: <code>requestor2</code> 的请求有效信号。</li>
<li><code>io_requestor_2_req_bits_vaddr</code>: <code>requestor2</code> 的请求虚拟地址。</li>
<li><code>io_requestor_2_resp_ready</code>: <code>requestor2</code> 的响应就绪信号。</li>
<li><code>io_requestor_2_resp_valid</code>: <code>requestor2</code> 的响应有效信号。</li>
<li><code>io_requestor_2_resp_bits_paddr_0</code>: <code>requestor2</code> 的物理地址响应信号。</li>
<li><code>io_requestor_2_resp_bits_gpaddr_0</code>: <code>requestor2</code> 的 <code>GPA</code> 响应信号。</li>
<li><code>io_requestor_2_resp_bits_excp_0_gpf_instr</code>: <code>requestor2</code> 出现 <code>GPF</code> 异常的信号。</li>
<li><code>io_requestor_2_resp_bits_excp_0_pf_instr</code>: <code>requestor2</code> 出现 <code>PF</code> 异常的信号。</li>
<li><code>io_requestor_2_resp_bits_excp_0_af_instr</code>: <code>requestor2</code> 出现 <code>AF</code> 异常的信号。</li>
</ul>
<h2 id="刷新管道flush-pipe信号">刷新管道（Flush Pipe）信号</h2>
<ul>
<li><code>io_flushPipe_0</code>: 刷新管道 <code>0</code> 的信号。</li>
<li><code>io_flushPipe_1</code>: 刷新管道 <code>1</code> 的信号。</li>
<li><code>io_flushPipe_2</code>: 刷新管道 <code>2</code> 的信号。</li>
</ul>
<h2 id="页表遍历page-table-walker-ptw接口信号">页表遍历（Page Table Walker, PTW）接口信号</h2>
<h3 id="ptw-请求信号">PTW 请求信号</h3>
<ul>
<li><code>io_ptw_req_0_valid</code>: <code>PTW req0</code> 有效信号。</li>
<li><code>io_ptw_req_0_bits_vpn</code>: <code>PTW req0</code> 的虚拟页号（<code>VPN</code>）。</li>
<li><code>io_ptw_req_0_bits_s2xlate</code>: 指示 <code>PTW req0</code> 的转换模式。</li>
<li><code>io_ptw_req_0_bits_getGpa</code>: <code>PTW req0</code> 的获取 <code>GPA</code> 信号。</li>
<li><code>io_ptw_req_1_valid</code>: <code>PTW req1</code> 有效信号。</li>
<li><code>io_ptw_req_1_bits_vpn</code>: <code>PTW req1</code> 的虚拟页号。</li>
<li><code>io_ptw_req_1_bits_s2xlate</code>: 指示 <code>PTW req1</code> 的转换模式。</li>
<li><code>io_ptw_req_1_bits_getGpa</code>: <code>PTW req1</code> 的获取 <code>GPA</code> 信号。</li>
<li><code>io_ptw_req_2_ready</code>: <code>PTW req2</code> 就绪信号。</li>
<li><code>io_ptw_req_2_valid</code>: <code>PTW req2</code> 有效信号。</li>
<li><code>io_ptw_req_2_bits_vpn</code>: <code>PTW req2</code> 的虚拟页号。</li>
<li><code>io_ptw_req_2_bits_s2xlate</code>: 指示 <code>PTW req2</code> 的转换模式。</li>
<li><code>io_ptw_req_2_bits_getGpa</code>: <code>PTW req2</code> 的获取 <code>GPA</code> 信号。</li>
</ul>
<h3 id="ptw-响应信号">PTW 响应信号</h3>
<ul>
<li><code>io_ptw_resp_valid</code>: <code>PTW resp</code> 有效信号。</li>
<li><code>io_ptw_resp_bits_s2xlate</code>: 指示 <code>PTW resp</code> 的地址转换类型。</li>
<li><code>io_ptw_resp_bits_s1_entry_tag</code>: <code>PTW resp</code> 的第一阶段页表条目标签。</li>
<li><code>io_ptw_resp_bits_s1_entry_asid</code>: <code>PTW resp</code> 的第一阶段页表条目 <code>ASID</code>。</li>
<li><code>io_ptw_resp_bits_s1_entry_vmid</code>: <code>PTW resp</code> 的第一阶段页表条目 <code>VMID</code>。</li>
<li><code>io_ptw_resp_bits_s1_entry_perm_d</code>: <code>PTW resp</code> 的第一阶段页表条目可写位。</li>
<li><code>io_ptw_resp_bits_s1_entry_perm_a</code>: <code>PTW resp</code> 的第一阶段页表条目已访问位。</li>
<li><code>io_ptw_resp_bits_s1_entry_perm_g</code>: <code>PTW resp</code> 的第一阶段页表条目全局位。</li>
<li><code>io_ptw_resp_bits_s1_entry_perm_u</code>: <code>PTW resp</code> 的第一阶段页表条目用户模式位。</li>
<li><code>io_ptw_resp_bits_s1_entry_perm_x</code>: <code>PTW resp</code> 的第一阶段页表条目可执行位。</li>
<li><code>io_ptw_resp_bits_s1_entry_perm_w</code>: <code>PTW resp</code> 的第一阶段页表条目可写位。</li>
<li><code>io_ptw_resp_bits_s1_entry_perm_r</code>: <code>PTW resp</code> 的第一阶段页表条目可读位。</li>
<li><code>io_ptw_resp_bits_s1_entry_level</code>: <code>PTW resp</code> 的第一阶段页表条目级别。</li>
<li><code>io_ptw_resp_bits_s1_entry_ppn</code>: <code>PTW resp</code> 的第一阶段页表条目物理页号（<code>PPN</code>）。</li>
<li><code>io_ptw_resp_bits_s1_addr_low</code>: <code>PTW resp</code> 的第一阶段页表条目地址低位。</li>
<li><code>io_ptw_resp_bits_s1_ppn_low_*</code>: <code>PTW resp</code> 的第一阶段页表条目 <code>PPN</code> 低位。</li>
<li><code>io_ptw_resp_bits_s1_valididx_*</code>: <code>PTW resp</code> 的第一阶段页表条目有效索引。</li>
<li><code>io_ptw_resp_bits_s1_pteidx_*</code>: <code>PTW resp</code> 的第一阶段页表条目 <code>PTE</code> 索引。</li>
<li><code>io_ptw_resp_bits_s1_pf</code>: <code>PTW resp</code> 的第一阶段页表条目出现 <code>PF</code>。</li>
<li><code>io_ptw_resp_bits_s1_af</code>: <code>PTW resp</code> 的第一阶段页表条目出现 <code>AF</code>。</li>
<li><code>io_ptw_resp_bits_s2_entry_tag</code>: <code>PTW resp</code> 的第二阶段页表条目标签。</li>
<li><code>io_ptw_resp_bits_s2_entry_vmid</code>: <code>PTW resp</code> 的第二阶段页表条目 <code>VMID</code>。</li>
<li><code>io_ptw_resp_bits_s2_entry_ppn</code>: <code>PTW resp</code> 的第二阶段页表条目 <code>PPN</code>。</li>
<li><code>io_ptw_resp_bits_s2_entry_perm_*</code>: <code>PTW resp</code> 的第二阶段页表条目的权限位。</li>
<li><code>io_ptw_resp_bits_s2_entry_level</code>: <code>PTW resp</code> 的第二阶段页表条目级别。</li>
<li><code>io_ptw_resp_bits_s2_gpf</code>: <code>PTW resp</code> 的第二阶段页表条目 <code>GPF</code> 信号。</li>
<li><code>io_ptw_resp_bits_s2_gaf</code>: <code>PTW resp</code> 的第二阶段页表条目 <code>GAF</code> 信号。</li>
<li><code>io_ptw_resp_bits_getGpa</code>: <code>PTW resp</code> 的获取 <code>GPA</code> 信号。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-41bd3132649e65462a6efff11c317d7b">12.2.4.2 - 功能详述</h1>
    
	<h2 id="支持-sv48-分页机制">支持 SV48 分页机制</h2>
<p><code>SV48</code> （<code>Supervisor-mode Virtual Memory</code>）是一种基于 <code>RISC-V</code> 的页表虚拟内存寻址模式，指定了 <code>48</code> 位虚拟地址空间的结构，支持 <code>256TB</code> 的虚拟内存地址空间。使用四级页表结构：</p>
<p><img src="Sv48_vaddr.png" alt="Sv48_vaddr"></p>
<p><img src="Sv48_paddr.png" alt="Sv48_paddr"></p>
<p><img src="Sv48_pagetable.png" alt="Sv48_pagetable"></p>
<p>在 <code>SV48</code> 的一个 <code>PTE</code> 中包含了如下字段：</p>
<ul>
<li>
<p><code>N</code>:</p>
<ul>
<li>指示是否为 <code>NAPOT PTE</code>。供 <code>Svnapot</code> 扩展使用，如果未实现 <code>Svnapot</code> 则该位必须由软件置 <code>0</code>，否则应当出现 <code>Page Fault</code>。目前香山昆明湖架构尚未支持此扩展。</li>
</ul>
</li>
<li>
<p><code>PBMT</code>:</p>
<ul>
<li><code>Page-Based Memory Types</code>，即基于页面的内存类型，供 <code>Svpbmt</code> 扩展使用，允许操作系统为每个页面指定不同的内存访问属性。
<ul>
<li><code>0</code>: <code>None</code>，没有特定的内存属性。</li>
<li><code>1</code>: <code>NC</code>，非缓存、幂等、弱序（<code>RVWMO</code>），适用于主存。</li>
<li><code>2</code>: <code>IO</code>，非缓存、非幂等、强序（<code>I/O</code> 排序），适用于 <code>I/O</code> 设备。</li>
<li><code>3</code>: <code>Reserved</code>，保留供将来标准使用。</li>
</ul>
</li>
</ul>
<p>同样的，如果未实现 <code>Svpbmt</code> 则这两位必须由软件置 <code>0</code>，否则应当出现 <code>Page Fault</code>。</p>
</li>
<li>
<p><code>Reserved</code>:</p>
<ul>
<li>保留位，供未来的标准使用。如果有任意一位不是 <code>0</code> 则会触发 <code>PF</code> 异常。</li>
</ul>
</li>
<li>
<p><code>PPN</code>:</p>
<ul>
<li>表示物理页框号，指向实际的物理内存页。<code>PPN</code> 与页面内偏移结合形成完整的物理地址，用于地址转换。</li>
</ul>
</li>
<li>
<p><code>RSW</code>:</p>
<ul>
<li>保留供软件使用的位，通常用于特定的标志或操作，以便在软件实现中提供灵活性。</li>
</ul>
</li>
<li>
<p><code>D</code>:</p>
<ul>
<li>脏位，指示该页面是否被写入。如果该位为 <code>1</code>，表示该页的数据已被修改，需在换出时写回到存储设备。</li>
</ul>
</li>
<li>
<p><code>A</code>:</p>
<ul>
<li>访问位，指示该页是否被访问过。如果该位为 <code>1</code>，表示该页已被读取或写入，用于页面替换算法。</li>
</ul>
</li>
<li>
<p><code>G</code>:</p>
<ul>
<li>全局页位，指示该页是否是全局页。如果该位为 <code>1</code>，表示该页对所有进程可见，用于共享代码或数据。</li>
</ul>
</li>
<li>
<p><code>U</code>:</p>
<ul>
<li>用户访问权限位，指示该页是否可被用户（<code>U</code>）模式访问。如果该位为 <code>1</code>，用户模式可以访问该页；若为 <code>0</code>，则仅限于特权模式。</li>
</ul>
</li>
<li>
<p><code>X</code>:</p>
<ul>
<li>可执行位，指示该页是否可执行。如果该位为 <code>1</code>，表示该页可以执行代码；若为 <code>0</code>，则不可执行。</li>
</ul>
</li>
<li>
<p><code>W</code>:</p>
<ul>
<li>可写位，指示该页是否可写。如果该位为 <code>1</code>，表示该页可以写入数据；若为 <code>0</code>，则不可写。</li>
</ul>
</li>
<li>
<p><code>R</code>:</p>
<ul>
<li>可读位，指示该页是否可读。如果该位为 <code>1</code>，表示该页可以读取数据；若为 <code>0</code>，则不可读。</li>
</ul>
</li>
<li>
<p><code>V</code>:</p>
<ul>
<li>有效位，指示该页表项是否有效。如果该位为 <code>1</code>，表示该项有效，可以进行地址转换；若为 <code>0</code>，则表示该项无效。</li>
</ul>
</li>
</ul>
<p>值得一提的是，如果该 <code>PTE</code> 并不是叶子 <code>PTE</code>，即它所存储的 <code>PPN</code> 用来指向下一级页表，那么它的 <code>X</code>、<code>W</code>、<code>R</code> 位应全为零。在手册中的要求如下：</p>
<p><img src="XWR.png" alt="XWR 示意图"></p>
<p><code>RISC-V H</code> 扩展即 <code>Hypervisor</code> 扩展，增加了对虚拟化和 <code>hypervisor</code> 模式的支持，将会允许虚拟机监控程序和虚拟机的管理程序，允许操作系统运行在虚拟机上，并可以通过 <code>hypervisor</code> 调度虚拟机的运行。在 <code>hypervisor</code> 下使用 <code>SV48x4</code> 寻址模式，支持四倍页表扩展。</p>
<p><img src="Sv48x4.png" alt="Sv48x4 虚拟地址"></p>
<p><code>VPN[3]</code> 进行了两位的扩展，也即大小从原来的 <code>4KB</code> 变为 <code>16KB</code>，支持 $2^{11}$ 个 <code>PTE</code>。值得注意的是，<code>SV48x4</code> 作用于虚拟机物理地址 <code>VPA</code>，在虚拟机上创建进程地址空间时仍然采用的是 <code>SV48</code>。也正是因此，虚拟机进行虚实地址转换的时候，首先将 <code>48</code> 位的虚拟机虚拟地址（<code>GVA</code>）转换为 <code>50</code> 位的虚拟机物理地址（<code>GPA</code>），之后再将 <code>GPA</code>（相当于主机的 <code>HVA</code>）转换为主机物理地址（<code>HPA</code>）。在页表项中存储的是 <code>44</code> 位的 <code>PPN</code>，这是由 <code>56</code> 位的物理地址去掉 <code>12</code> 位的页内偏移得到的，因此完全可以存的下扩展了两位（<code>38</code> 位）的 <code>VPN</code>。</p>
<p>出于对面积等的优化考虑，在香山中采用 <code>48</code> 位的主机物理地址，而不是 <code>Sv48</code> 要求的 <code>56</code> 位物理地址，这是因为 <code>48</code> 位的物理地址已经可以索引 <code>256TB</code> 的物理地址空间，目前来说已经足够使用。但是由于 <code>TLB</code> 对虚拟机的支持，在虚拟机两阶段地址转换过程中（两阶段地址转换可见支持两阶段虚实地址翻译过程部分），虚拟机通过 <code>VS</code> 阶段转换的结果仍然是 <code>56</code> 位的虚拟机物理地址，只不过在进入 <code>G</code> 阶段地址转换时，<code>G</code> 阶段要求传入的 <code>GPA</code> 的高 <code>6</code> 位必须为 <code>0</code>，这是因为在 <code>Sv48x4</code> 中客户机物理地址要求为 <code>50</code> 位，而 <code>VS</code> 阶段得到的物理地址是 <code>56</code> 位。为了保持 <code>gpaddr</code> 的完整性，<code>PTW</code> 传入 <code>TLB</code> 的 <code>ppn</code> 信号的位宽依然为 <code>44</code> 位，然而由于 <code>TLB</code> 不存储中间转换结果（中间物理地址 <code>IPA</code>），也就不需要存储 <code>44</code> 位的 <code>ppn</code>，在 <code>TLB</code> 表项中存储的只有主机的 <code>ppn</code>，也即 <code>36</code> 位的 <code>ppn</code>。</p>
<h2 id="支持缓存映射条目">支持缓存映射条目</h2>
<p><code>TLB</code> 中存储的条目并不是页表项 <code>PTE</code>，而是一个映射，一个从虚拟地址（来自于请求）到物理地址（来自于查找结果）的映射，当然还有一些访问所必须的信息。在目前的香山中 <code>TLB</code> 所存储的条目包含 <code>tag[35]</code>、<code>asid[16]</code>、<code>vmid[14]</code>、<code>level[2]</code>、<code>ppn[33]</code>、<code>8 × ppn_low[3]</code>、<code>8 × valididx</code>、<code>8 × pteidx</code>、<code>s2xlate</code>、<code>perm[6]</code>、<code>g_perm[4]</code>。为供以后使用 <code>svpbmt</code> 扩展，还存储了 <code>pbmt</code> 与 <code>g_pbmt</code> 字段。</p>
<p><img src="TLBstore.png" alt="TLB 缓存条目"></p>
<ul>
<li>
<p><strong>tag[34:0]</strong></p>
<ul>
<li><code>tag</code>，用于匹配条目。来源于 <code>VPN</code> 的高 <code>35</code> 位，在匹配的过程中，输入一个 <code>38</code> 位的 <code>VPN</code>，通过将输入的 <code>VPN</code> 的前 <code>35</code> 位与 <code>tag</code> 比较找到对应的条目，可以看到在一个条目中存储了 <code>PPN</code> 的高位部分和 <code>8</code> 个 <code>ppn_low</code>，之后将 <code>VPN</code> 的后三位作为索引，可以索引这 <code>8</code> 个 <code>ppn_low</code>，即可将 <code>ppn</code> 与 <code>ppn_low[vpn_low]</code> 拼接得到物理页框号。</li>
</ul>
</li>
<li>
<p><strong>asid[15:0]</strong></p>
<ul>
<li>地址空间标识符，用于区分不同的进程地址空间。</li>
</ul>
</li>
<li>
<p><strong>vmid[13:0]</strong></p>
<ul>
<li>虚拟机标识符，用于区分不同的虚拟机。</li>
</ul>
</li>
<li>
<p><strong>level[1:0]</strong></p>
<ul>
<li>指示页面的大小。<code>0</code>：<code>4KB</code>，<code>1</code>：<code>2MB</code>，<code>2</code>：<code>1GB</code>，<code>3</code>：<code>512GB</code>。</li>
</ul>
</li>
<li>
<p><strong>ppn[32:0]</strong></p>
<ul>
<li>物理页框号的高 <code>33</code> 位。在 <code>Sv48</code> 要求下本该是 <code>41</code> 位，出于面积考虑优化至 <code>33</code> 位（见支持 <code>Sv48</code> 分页机制部分）。</li>
</ul>
</li>
<li>
<p><strong>ppn_low[2:0]×8</strong></p>
<ul>
<li>物理页框号的低 <code>3</code> 位。用于 <code>TLB</code> 压缩（见支持 <code>TLB</code> 压缩部分）。</li>
</ul>
</li>
<li>
<p><strong>valididx×8</strong></p>
<ul>
<li>指示对应的 <code>ppn_low</code> 是否有效。用于 <code>TLB</code> 压缩，为 <code>0</code> 表示条目无效，即对应物理地址没有存储页表条目。</li>
</ul>
</li>
<li>
<p><strong>pteidx×8</strong></p>
<ul>
<li>指示原始请求对应压缩条目的哪一项。例如 <code>vpn</code> 低三位为 <code>010</code>，那么 <code>pteidx[3]</code> 为 <code>1</code>，其它 <code>7</code> 位为 <code>0</code>。</li>
</ul>
</li>
<li>
<p><strong>s2xlate[1:0]</strong></p>
<ul>
<li>指示是否启用两阶段地址转换。<code>0b00</code>：不启用，<code>0b01</code>：仅使用第一阶段，<code>0b10</code>：仅使用第二阶段，<code>0b11</code>：启用两阶段地址转换。</li>
</ul>
</li>
<li>
<p><strong>perm[5:0]</strong></p>
<ul>
<li>指示主机的权限以及异常信息，包括 <code>pf</code>、<code>af</code>、<code>a</code>、<code>g</code>、<code>u</code>、<code>x</code> 六位。其中 <code>pf</code>（<code>page fault</code>）指示是否发生缺页异常；<code>af</code>（<code>access fault</code>）指示是否发生地址错误等访问错误异常；<code>a</code>（<code>access</code>）指示该表项是否最近被访问过，任何形式的访问（包括读、写、取指）均会将 <code>a</code> 位置 <code>1</code>，用于页面替换算法；<code>g</code>（<code>global</code>）指示该条目指向的页面是否为全局页面；<code>u</code>（<code>user</code>）指示该条目指向的页面是否可以被用户模式访问，<code>u</code> 位为 <code>1</code> 说明可以被 <code>UMode</code> 访问，为 <code>0</code> 说明可以被 <code>SMode</code> 访问；<code>x</code>（执行）指示该条目指向的页面是否可执行，<code>itlb</code> 用于取指的加速，所有取出的条目必须是可执行的。</li>
</ul>
</li>
<li>
<p><strong>g_perm[3:0]</strong></p>
<ul>
<li>指示虚拟机的权限以及异常信息，包括 <code>gpf</code>、<code>gaf</code>、<code>a</code>、<code>x</code> 四位，虚拟机的 <code>g</code> 和 <code>u</code> 两位不单独存储，与主机共用。一般情况下虚拟机对全局页、用户模式的处理与主机相同，而替换策略与访问权限控制可能不同，所以共用了 <code>g</code>、<code>u</code> 而不共用 <code>a</code>、<code>x</code>。<code>gpf</code>（<code>guest page fault</code>）为虚拟机缺页异常，<code>gaf</code>（<code>guest access fault</code>）为虚拟机访问错误异常。</li>
</ul>
</li>
</ul>
<p>香山的 <code>ITLB</code> 采用 <code>48</code> 项全相联的结构，保存全部大小页，共能存储 <code>48</code> 条映射。</p>
<p>在支持 <code>H</code> 扩展的前提下，对于不同的 <code>s2xlate</code> 的状态 <code>TLB</code> 中存储的条目的值代表的意义也会有所区别：</p>
<table>
  <thead>
      <tr>
          <th>类型</th>
          <th>s2xlate</th>
          <th>tag</th>
          <th>ppn</th>
          <th>perm</th>
          <th>g_perm</th>
          <th>level</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>noS2xlate</td>
          <td>b00</td>
          <td>非虚拟化下的虚拟页号</td>
          <td>非虚拟化下的物理页号</td>
          <td>非虚拟化下的页表项 perm</td>
          <td>不使用</td>
          <td>非虚拟化下的页表项 level</td>
      </tr>
      <tr>
          <td>allStage</td>
          <td>b11</td>
          <td>第一阶段页表的虚拟页号</td>
          <td>第二阶段页表的物理页号</td>
          <td>第一阶段页表的 perm</td>
          <td>第二阶段页表的 perm</td>
          <td>两阶段翻译中最大的 level</td>
      </tr>
      <tr>
          <td>onlyStage1</td>
          <td>b01</td>
          <td>第一阶段页表的虚拟页号</td>
          <td>第一阶段页表的物理页号</td>
          <td>第一阶段页表的 perm</td>
          <td>不使用</td>
          <td>第一阶段页表的 level</td>
      </tr>
      <tr>
          <td>onlyStage2</td>
          <td>b10</td>
          <td>第二阶段页表的虚拟页号</td>
          <td>第二阶段页表的物理页号</td>
          <td>不使用</td>
          <td>第二阶段页表的 perm</td>
          <td>第二阶段页表的 level</td>
      </tr>
  </tbody>
</table>
<p>支持 <code>H</code> 扩展后 <code>TLB</code> 中缓存的条目会有所变化（表中未提及的条目即没有变化）：</p>
<table>
  <thead>
      <tr>
          <th>支持 H 扩展</th>
          <th>vmid</th>
          <th>s2xlate</th>
          <th>g_perm</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>否</td>
          <td>不保存</td>
          <td>不保存</td>
          <td>不保存</td>
      </tr>
      <tr>
          <td>是</td>
          <td>14位</td>
          <td>2位</td>
          <td>4位</td>
      </tr>
  </tbody>
</table>
<h2 id="支持保存全部大小页">支持保存全部大小页</h2>
<p>在 <code>RISC-V</code> 架构中，大小页机制旨在优化虚拟内存的使用效率和性能。<code>Sv48</code> 支持多种页面大小，包括 <code>4KB</code>、<code>2MB</code>、<code>1GB</code> 页，在标准的设计中没有定义 <code>512GB</code> 的页，理论上可行，但目前并没有这样的需要，<code>512GB</code> 的页也无法加载进内存，因此标准不做要求。但是出于对完整性的考虑，香山中依然实现了对 <code>512GB</code> 大页的支持。</p>
<p><img src="Sv48%E5%A4%A7%E5%B0%8F%E9%A1%B5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Sv48 大小页示意图"></p>
<p>在一般的应用程序需求中，<code>4KB</code> 的页面足够满足日常的使用，可以存储较小的数据结构以及程序等，常用于大多数应用程序中。然而，有的程序可能会需要频繁访问大的数据结构或数据集，这时引入大页可以提升内存访问效率。每个大页覆盖的虚拟地址空间更大，可以显著减少页表条目的数量；在映射相同数量的内存时，所需的页表条目会大幅降低，这可以减少内存开销、减少页表查找频率，从而优化内存访问速度，尤其对频繁访问大块内存的应用，能够显著提升性能。大页通常包含连续的数据，可以提高命中率，更有效地利用缓存资源。</p>
<p>当然，由于大页覆盖的地址空间较大，可能导致内存碎片，而未被使用的大页空间无法被其他请求有效利用，也会浪费一定的内存资源。同时，管理不同大小的页面为内存管理带来了额外的复杂性。在混合使用小页和大页时，操作系统需要复杂的算法来优化内存分配和使用。现代操作系统通常采用混合使用大小页的模式以满足不同应用的不同需求。</p>
<p>在香山的 <code>TLB</code> 中，支持保存任意大小的页面，这是通过保存页面的 <code>level</code> 来实现的。根据不同的 <code>level</code>，可以决定最终生成物理地址的方法（<code>index</code> 为页内偏移，来源于 <code>vaddr</code> 的低 <code>12</code> 位；<code>ppn</code>、<code>ppn_low</code>、<code>tag</code> 来源于 <code>TLB</code> 中存储的映射条目）：</p>
<table>
  <thead>
      <tr>
          <th>level</th>
          <th>页面大小</th>
          <th>paddr[47:0]</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>4KB</td>
          <td>ppn[32:0] + ppn_low[2:0] + index[11:0]</td>
      </tr>
      <tr>
          <td>1</td>
          <td>2MB</td>
          <td>ppn[32:6] + tag[8:0] + index[11:0]</td>
      </tr>
      <tr>
          <td>2</td>
          <td>1GB</td>
          <td>ppn[32:15] + tag[17:0] + index[11:0]</td>
      </tr>
      <tr>
          <td>3</td>
          <td>512GB</td>
          <td>ppn[32:24] + tag[26:0] + index[11:0]</td>
      </tr>
  </tbody>
</table>
<h2 id="支持-tlb-压缩">支持 TLB 压缩</h2>
<p>随着虚拟地址空间的不断扩展，传统 <code>TLB</code> 的大小和效率面临挑战，可能不足以覆盖应用程序的需求，导致频繁的缺失（<code>TLB miss</code>），从而影响系统性能，导致性能瓶颈。为了应对这一问题，<code>TLB</code> 压缩技术应运而生，旨在提高 <code>TLB</code> 的有效性和性能。</p>
<p>在操作系统分配内存的时候，由于使用伙伴地址分配策略等原因，会倾向于将连续的物理页分配给连续的虚拟页。虽然随着程序的不断运行，页分配逐渐的从有序趋向于无序，但是这种页的相连性普遍存在，因此可以通过将多个连续的页表项在 <code>TLB</code> 硬件中合成为一个 <code>TLB</code> 项，以增大 <code>TLB</code> 容量。<code>TLB</code> 压缩通过优化页表结构，支持连续的映射，通过引入范围映射（<code>range mapping</code>）机制，一个 <code>TLB</code> 条目可以映射一段连续的虚拟地址到一段连续的物理地址。</p>
<p>在实际中，以香山昆明湖架构为例，在 <code>TLB</code> 中存储 <code>35</code> 位的 <code>vpn_high</code>（即 <code>tag</code>），剩下的三位用于索引对应的 <code>ppn_low</code>（一共有 <code>8</code> 个所以需要 <code>3</code> 位来索引）。每次匹配中，<code>TLB</code> 用传入的 <code>vaddr[49:15]</code>（高 <code>35</code> 位）与 <code>tag</code> 进行匹配，找到对应的条目，这个条目中可以存储 <code>8</code> 个 <code>PTE</code>，再根据 <code>vaddr[14:12]</code> 找到对应的 <code>ppn_low</code>，之后检查对应的 <code>valididx</code> 是否有效，如果有效说明 <code>hit</code>，将 <code>ppn_low</code> 与 <code>ppn_high</code> 拼接得到 <code>PPN</code>，再与 <code>vaddr[11:0]</code> 拼接得到 <code>paddr</code>。</p>
<p><img src="TLB%E5%8E%8B%E7%BC%A9.png" alt="香山 TLB 压缩示意图"></p>
<p>在支持了 <code>H</code> 扩展后（见支持两阶段虚实地址翻译），<code>TLB</code> 压缩仅在 <code>OnlyStage1</code> 和 <code>noS2xlate</code> 下启用，在其他情况下不启用。</p>
<p>支持 <code>TLB</code> 压缩后 <code>TLB</code> 中缓存的条目会有所变化（表中未提及的条目即没有变化）：</p>
<table>
  <thead>
      <tr>
          <th>是否压缩</th>
          <th>tag</th>
          <th>ppn</th>
          <th>valididx</th>
          <th>pteidx</th>
          <th>ppn_low</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>否</td>
          <td>38位</td>
          <td>36位</td>
          <td>不保存</td>
          <td>不保存</td>
          <td>不保存</td>
      </tr>
      <tr>
          <td>是</td>
          <td>35位</td>
          <td>33位</td>
          <td>8位</td>
          <td>8位</td>
          <td>8×3位</td>
      </tr>
  </tbody>
</table>
<p>在支持了大小页的情况下，<code>TLB</code> 压缩在大页情况下（<code>2MB/1GB/512GB</code>）不启用，仅在查询结果为小页（<code>4KB</code>）情况下启用。大页在返回时会将 <code>valididx</code> 的 <code>8</code> 位全部设置为 <code>1</code>，而由于大页的查询过程中只需要 <code>PPN</code> 的高位，大页下不使用 <code>ppn_low</code>，<code>ppn_low</code> 的值在此时是未定义的。</p>
<h2 id="支持-hypervisor-扩展与两阶段虚实地址翻译">支持 Hypervisor 扩展与两阶段虚实地址翻译</h2>
<p>在 <code>RISC-V</code> 特权指令手册中定义了虚实地址的翻译过程：</p>
<ol>
<li>
<p>设 <code>a</code> 为 <code>satp.ppn</code> × <code>PAGESIZE</code>，并设 <code>i = LEVELS - 1</code>。（对于 <code>Sv48</code>，<code>PAGESIZE = 2^{12}</code>，<code>LEVELS = 4</code>）此时，<code>satp</code> 寄存器必须处于活动状态，即有效的特权模式必须是 <code>S</code> 模式或 <code>U</code> 模式。</p>
</li>
<li>
<p>设 <code>pte</code> 为地址 <code>a + va.vpn[i]</code> × <code>PTESIZE</code> 处的 <code>PTE</code> 值。（对于 <code>Sv48</code>，<code>PTESIZE = 8</code>）如果访问 <code>pte</code> 违反了 <code>PMA</code> 或 <code>PMP</code> 检查，则引发与原始访问类型相应的访问错误异常。</p>
</li>
<li>
<p>如果 <code>pte.v = 0</code>，或者 <code>pte.r = 0</code> 且 <code>pte.w = 1</code>，或者 <code>pte</code> 中设置了任何为未来标准使用保留的位或编码，则停止并引发与原始访问类型相应的页面错误异常。</p>
</li>
<li>
<p>否则，<code>PTE</code> 是有效的。如果 <code>pte.r = 1</code> 或 <code>pte.x = 1</code>，则转到步骤 5。否则，此 <code>PTE</code> 是指向下一级页面表的指针。设 <code>i = i - 1</code>。如果 <code>i &lt; 0</code>，则停止并引发与原始访问类型相应的页面错误异常。否则，设 <code>a = pte.ppn</code> × <code>PAGESIZE</code> 并转到步骤 2。</p>
</li>
<li>
<p>找到了叶子 <code>PTE</code>。根据当前特权模式和 <code>mstatus</code> 寄存器的 <code>SUM</code> 和 <code>MXR</code> 字段的值，确定请求的内存访问是否被 <code>pte.r</code>、<code>pte.w</code>、<code>pte.x</code> 和 <code>pte.u</code> 位允许。如果不允许，则停止并引发与原始访问类型相应的页面错误异常。</p>
</li>
<li>
<p>如果 <code>i &gt; 0</code> 且 <code>pte.ppn[i-1 : 0] = 0</code>，则这是一个未对齐的大页；停止并引发与原始访问类型相应的页面错误异常。</p>
</li>
<li>
<p>如果 <code>pte.a = 0</code>，或者如果原始内存访问是存储且 <code>pte.d = 0</code>，则引发与原始访问类型相应的页面错误异常，或者执行以下操作：</p>
<ul>
<li>如果对 <code>pte</code> 的存储将违反 <code>PMA</code> 或 <code>PMP</code> 检查，则引发与原始访问类型相应的访问错误异常。</li>
<li>以原子方式执行以下步骤：
<ul>
<li>比较 <code>pte</code> 与地址 <code>a + va.vpn[i]</code> × <code>PTESIZE</code> 处的 <code>PTE</code> 值。</li>
<li>如果值匹配，将 <code>pte.a</code> 设为 <code>1</code>，并且如果原始内存访问是存储，还将 <code>pte.d</code> 设为 <code>1</code>。</li>
<li>如果比较失败，返回步骤 2。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>翻译成功。翻译后的物理地址如下：</p>
<ul>
<li><code>pa.pgoff = va.pgoff</code>。</li>
<li>如果 <code>i &gt; 0</code>，则这是一个大页翻译，且 <code>pa.ppn[i - 1 : 0] = va.vpn[i - 1 : 0]</code>。</li>
<li><code>pa.ppn[LEVELS - 1 : i] = pte.ppn[LEVELS - 1 : i]</code>。</li>
</ul>
</li>
</ol>
<p>在一般的虚实地址翻译过程中，将按照如上所述的过程进行转换，由 satp 寄存器控制进行地址翻译。其中，前端取指通过 <code>ITLB</code> 进行地址翻译，后端访存通过 <code>DTLB</code> 进行地址翻译。<code>ITLB</code> 和 <code>DTLB</code> 如果 <code>miss</code>，会通过 <code>Repeater</code> 向 <code>L2TLB</code> 发送请求。在目前设计中，前端取指和后端访存对 <code>TLB</code> 均采用非阻塞式访问，即一个请求 <code>miss</code> 后，会将请求 <code>miss</code> 的信息返回，请求来源调度重新发送 <code>TLB</code> 查询请求，直至命中。也就是说，<code>TLB</code> 本体是非阻塞的，可以向它连续发送请求，无论结果都可以在下一拍发送任意的请求，但是总体上由于前端的调度，体现为阻塞访问。</p>
<p>在支持了 <code>H</code> 扩展的前提下，香山的虚拟化地址翻译过程会经历两个阶段的地址转换，可以将它划分为 <code>VS</code> 阶段和 <code>G</code> 阶段。<code>VS</code> 阶段的地址转换由 <code>vsatp</code> 寄存器控制，其实与主机的 <code>satp</code> 寄存器非常相似。</p>
<p><img src="GVA-GPA.png" alt="VS 阶段：GVA 至 GPA"></p>
<p>页表项（<code>PTE</code>）的长度为 <code>64 bit</code>，也即每个 <code>4KB</code> 的页面可以存储 $2^9$ 个 <code>PTE</code>。在 <code>vsatp</code> 寄存器中存储了第一级页表（即根页表）的物理地址 <code>PPN</code>，通过这个 <code>PPN</code> 可以找到根页表，并根据 <code>GVA</code> 中的 <code>VPN[3]</code> 找到对应页表项 <code>PTE</code>，在 <code>PTE</code> 中存储了指向下一级页表的 <code>PPN</code> 以及权限位等。以此方式通过逐级的查找最终达到叶子 <code>PTE</code> 并得到 <code>PPN</code>，与 <code>offset</code> 合成后得到 <code>GPA</code>。注意这里的 <code>GPA</code> 应当是 <code>50</code> 位的，最后一级的 <code>PPN</code> 应当是 <code>38</code> 位的，这是因为支持 <code>SV48x4</code> 的原因，虚拟机的物理地址被拓宽了两位。这样的拓宽并不难实现，只需要在主机分配虚拟机内存空间的时候分配一个 <code>16KB</code> 的大页作为根页表即可；通过多使用 <code>12KB</code>（本来分配的根页表大小是 <code>4KB</code>）的物理内存就可以实现虚拟机地址空间增大四倍。至于页表项能否放下多了两位的 <code>PPN</code>，观察 <code>PTE</code> 中 <code>PPN</code> 的位数为 <code>44</code> 位，不需要担心这个问题。<code>44</code> 位的 <code>PPN</code> 放 <code>38</code> 位，前六位并没有清零要求，但是是被忽略的。</p>
<p><img src="GPA-HPA.png" alt="G 阶段：GPA 至 HPA"></p>
<p><code>G</code> 阶段的地址翻译则不同，由于支持了 <code>SV48x4</code>，其根页表被扩展为 <code>11</code> 位 <code>16KB</code>，因此需要特别注意 <code>hgatp</code> 寄存器中存储的 <code>PPN</code> 应当对齐 <code>16KB</code> 页，在标准情况下 <code>PPN</code> 的最后两 <code>bit</code> 应当被固定为零，意味着 <code>hgatp</code> 寄存器应当指向一个 <code>16KB</code> 页的起始地址，以避免根页表在不同的小页面内。</p>
<p>在实际的实现中，地址的翻译并不是这样理想化的先查虚拟机的页表得到 <code>GPA</code> 再使用这个 <code>GPA</code> 查主机的页表得到 <code>HPA</code>。事实上的实现中，我们通过虚拟机的页表查到的下一级页表的物理地址是 <code>GPA</code>，并不能通过它访问到下一级页表，每次访问虚拟机的下一级页表都需要进行一次 <code>GPA</code> 到 <code>HPA</code> 的转换。比如此时给定一个 <code>GVA</code>，之后在虚拟机的一级页表（根页表）中根据 <code>GVA[2]</code>（<code>11 bit</code>）查找得到一个 <code>PTE</code>，这个 <code>PTE</code> 存储的是二级页表的 <code>GPA</code>，得到这个 <code>GPA</code> 并不能找到二级页表，因此需要将它转换为 <code>HPA</code>，也就是 <code>G</code> 阶段的地址翻译。依次查找直到找到最终需要的那个 <code>HPA</code>，共需要经历五次 <code>G</code> 阶段地址翻译，才能得到最终的 <code>HPA</code>。</p>
<p><img src="%E9%A6%99%E5%B1%B1%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E8%BF%87%E7%A8%8B.png" alt="香山昆明湖架构 TLB 两阶段地址翻译过程"></p>
<h2 id="支持阻塞式与非阻塞式访问">支持阻塞式与非阻塞式访问</h2>
<p>阻塞式访问代表着 <code>TLB</code> 的端口同时仅支持一个请求，阻塞端口带 <code>valid-ready</code> 握手信号。在 <code>TLB</code> 准备好接收请求时，会将 <code>ready</code> 置 <code>1</code>，由外部检测到 <code>ready</code> 后会发送请求。请求到达 <code>TLB</code> 时 <code>valid</code> 为 <code>1</code> 则 <code>TLB</code> 接收请求并将 <code>ready</code> 置 <code>0</code>，不再接受新的请求。之后 <code>TLB</code> 会对请求进行匹配，查找结果，如果 <code>miss</code> 则发送 <code>ptw</code> 请求（同样为阻塞），等待直到 <code>ptw</code> 返回结果（物理地址或 <code>pf</code> 异常），然后 <code>TLB</code> 将结果保存并上报给请求方，再将 <code>ready</code> 置 <code>1</code>。</p>
<p>对于非阻塞式请求，仅带 <code>valid</code> 信号，每当 <code>valid</code> 置 <code>1</code>，<code>TLB</code> 即接受请求并在下一拍返回结果（<code>hit/miss/异常</code>），无论是否命中都能在请求下一拍得到结果。如果 <code>miss</code> 的话，<code>TLB</code> 在返回 <code>miss</code> 结果同时会发起 <code>PTW</code> 请求（非阻塞），<code>PTW</code> 接收到请求则进行处理，在处理完成后回填进 <code>TLB</code> 中，然后如果请求方再次发起请求就可以命中。在香山 <code>ITLB</code> 的具体实现中，<code>TLB</code> 本体虽然是非阻塞的，不存储请求的信息，但当前端发起的取指请求 <code>miss</code> 后，将会由前端进行调度不断发起相同取指请求直到 <code>hit</code>，才能将指令送到处理器进行处理，因此会体现出阻塞的效果。</p>
<table>
  <thead>
      <tr>
          <th>请求来源</th>
          <th>iCache</th>
          <th>IFU</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>请求数量</td>
          <td>2</td>
          <td>1</td>
      </tr>
      <tr>
          <td>请求类型</td>
          <td>非阻塞请求</td>
          <td>阻塞请求</td>
      </tr>
      <tr>
          <td>握手信号</td>
          <td>仅带 valid 信号</td>
          <td>带 valid 和 ready 信号</td>
      </tr>
      <tr>
          <td>处理方式</td>
          <td>可以继续处理其他指令</td>
          <td>等待 iTLB 响应后继续处理指令</td>
      </tr>
  </tbody>
</table>
<h2 id="支持读取-ptw-返回条目">支持读取 PTW 返回条目</h2>
<p>每次 <code>TLB</code> 发生 <code>miss</code> 之后，会向 <code>L2TLB</code> 发送 <code>Page Table Walk</code> 请求。由于 <code>TLB</code> 与 <code>L2TLB</code> 之间有比较长的物理距离，需要在中间加拍，这项工作由 <code>repeator</code> 完成。同时，<code>repeator</code> 还需要对 <code>PTW</code> 请求进行过滤，以避免 <code>TLB</code> 中出现重复项，因此也被称为 <code>filter</code>。目前香山中 <code>TLB</code> 发出的 <code>PTW</code> 请求的内容包含 <code>VPN</code>、<code>s2xlate</code>、<code>getGPA</code> 三个信号以及必要的控制信号：</p>
<ul>
<li>
<p><strong>VPN</strong>：</p>
<ul>
<li>虚拟页框号，<code>TLB</code> 在 <code>miss</code> 之后会将 <code>VPN</code> 发送给 <code>PTW</code> 用于索引对应的物理页，<code>PTW</code> 会将叶子页表的 <code>PPN</code> 返回给 <code>TLB</code>，下次 <code>TLB</code> 查询的时候就可以找到该页并可以通过页内偏移找到物理地址。</li>
</ul>
</li>
<li>
<p><strong>s2xlate</strong>：</p>
<ul>
<li>两阶段地址转换标志，指示当前的两阶段地址转换模式。<code>TLB</code> 中该标志将通过 <code>vsatp</code> 与 <code>hgatp</code> 寄存器的 <code>mode</code> 域进行判断：</li>
</ul>
<table>
  <thead>
      <tr>
          <th>s2xlate</th>
          <th>vsatp.mode</th>
          <th>hgatp.mode</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0b00</td>
          <td>0</td>
          <td>0</td>
      </tr>
      <tr>
          <td>0b01</td>
          <td>1</td>
          <td>0</td>
      </tr>
      <tr>
          <td>0b10</td>
          <td>0</td>
          <td>1</td>
      </tr>
      <tr>
          <td>0b11</td>
          <td>1</td>
          <td>1</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><strong>getGPA</strong>：</p>
<ul>
<li>指示当前 <code>PTW</code> 请求是否为请求客户机物理地址。用于客户机缺页等情况的处理（详见支持发生 <code>GPF</code> 时重新发起请求部分）。</li>
</ul>
</li>
</ul>
<p>在支持了 <code>TLB</code> 压缩后，<code>PTW</code> 返回的结果主要包括 <code>resp_valid</code>、<code>tag[33:0]</code>、<code>asid[15:0]</code>、<code>perm[6:0]</code>、<code>level[1:0]</code>、<code>ppn[35:0]</code>、<code>addr_low[2:0]</code>、<code>ppn_low[2:0]</code> × <code>8</code>、<code>valididx</code> × <code>8</code>、<code>pteidx</code> × <code>8</code>、<code>pf</code>、<code>af</code>（各个信号的含义可见支持缓存映射条目部分）。<code>TLB</code> 接收到有效的 <code>PTW resp</code> 后即将这些条目存进自己的缓存中。</p>
<p>在支持了 <code>H</code> 扩展后，<code>TLB</code> 压缩仅在 <code>noS2xlate</code> 和 <code>onlyStage1</code> 时启用，需要添加 <code>s2xlate</code> 信号指示两阶段地址转换的类型，并分开返回 <code>s1</code> 和 <code>s2</code>。其中，<code>s1</code> 阶段可以与之前的主机地址转换合并，在主机地址转换中，<code>s1</code> 添加的部分信号以及位宽不适用，添加或扩充的信号如下所示：</p>
<table>
  <thead>
      <tr>
          <th>支持 H 扩展</th>
          <th>s2xlate[1:0]</th>
          <th>tag</th>
          <th>vmid[13:0]</th>
          <th>ppn</th>
          <th>s2</th>
          <th>getGPA</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>否</td>
          <td>无</td>
          <td>[32:0]</td>
          <td>无</td>
          <td>[32:0]</td>
          <td>无</td>
          <td>无</td>
      </tr>
      <tr>
          <td>是</td>
          <td>有</td>
          <td>[34:0]</td>
          <td>有</td>
          <td>[40:0]</td>
          <td>有</td>
          <td>有</td>
      </tr>
  </tbody>
</table>
<p>其中，<code>tag</code> 扩充的两位是由于虚拟机采用 <code>Sv48x4</code>，将 <code>hypervisor</code> 下的虚拟地址从 <code>48</code> 位扩充为 <code>50</code> 位，因此 <code>tag</code> 相应需要多两位。<code>vmid</code> 指示虚拟机号。<code>ppn</code> 多的 <code>8</code> 位是因为主机采用 <code>48</code> 位物理地址，而第一阶段转换出来的虚拟机物理地址为 <code>56</code> 位（在进入下一阶段时要求前 <code>6</code> 位是 <code>0</code>，变为 <code>50</code> 位），<code>getGPA</code> 可见后面支持发生 <code>GPF</code> 时重新发起请求部分。</p>
<p><code>s2</code> 部分用于第二阶段地址转换，即从虚拟机物理地址到主机物理地址的转换，此时 <code>asid</code> 无效，<code>resp</code> 的信号包括 <code>tag[37:0]</code>、<code>vmid[13:0]</code>、<code>ppn[37:0]</code>、<code>perm[6:0]</code>、<code>level</code>、<code>gpf</code>、<code>gaf</code>。由于不考虑 <code>TLB</code> 压缩，<code>tag</code> 即为 <code>38</code> 位，来自 <code>50</code> 位虚拟地址的高 <code>38</code> 位。值得注意，在目前的香山昆明湖架构中，这里的 <code>ppn</code> 有效的位数仅有后 <code>36</code> 位，之所以 <code>ppn</code> 位宽为 <code>38</code> 位是出于优化的需要，香山 <code>TLB</code> 中通过 <code>readResult</code> 方法从 <code>PTW</code> 中读取信息，<code>s1</code>、<code>s2</code> 阶段复用了 <code>readResult</code> 方法，由于在 <code>s1</code> 阶段的需要用到 <code>50</code> 位的物理地址，<code>readResult.ppn</code> 被定义为 <code>38</code> 位，以至于在 <code>verilog</code> 文件中传入 <code>s2.ppn</code> 时也需要额外多传 <code>2</code> 位，事实上这两位仅仅传进 <code>TLB</code> 中而不起作用，可以忽略。</p>
<table>
  <thead>
      <tr>
          <th>支持 H 扩展</th>
          <th>s2_tag[37:0]</th>
          <th>s2_vmid[14:0]</th>
          <th>s2_ppn[37:0]</th>
          <th>s2_perm[6:0]</th>
          <th>s2_level[1:0]</th>
          <th>gpf</th>
          <th>gaf</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>否</td>
          <td>无</td>
          <td>无</td>
          <td>无</td>
          <td>无</td>
          <td>无</td>
          <td>无</td>
          <td>无</td>
      </tr>
      <tr>
          <td>是</td>
          <td>有</td>
          <td>有</td>
          <td>有</td>
          <td>有</td>
          <td>有</td>
          <td>有</td>
          <td>有</td>
      </tr>
  </tbody>
</table>
<p>添加了 <code>H</code> 拓展后的 <code>MMU</code>，<code>PTW</code> 返回的结构分为三部分，第一部分 <code>s1</code> 是原先设计中的 <code>PtwSec-torResp</code>，存储第一阶段翻译的页表，第二部分 <code>s2</code> 是 <code>HptwResp</code>，存储第二阶段翻译的页表，第三部分是 <code>s2xlate</code>，代表这次 <code>resp</code> 的类型，仍然分为 <code>noS2xlate</code>、<code>allStage</code>、<code>onlyStage1</code> 和 <code>onlyStage2</code>。如下图。其中 <code>PtwSectorEntry</code> 是采用了 <code>TLB</code> 压缩技术的 <code>PtwEntry</code>。</p>
<p><img src="PTW_resp%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F.png" alt="PTW resp 结构示意图"></p>
<h2 id="支持回填条目与两阶段条目融合">支持回填条目与两阶段条目融合</h2>
<p>参照支持缓存映射条目与支持读取 <code>PTW</code> 返回条目，对于主机地址转换（<code>nos2xlate</code>）的情况对应填入 <code>entry</code> 中的对应表项即可，此时访客有关信号无效。注意大页时，即 <code>level</code> 不为 <code>0</code> 时，<code>ppn_low</code> 无效。</p>
<table>
  <thead>
      <tr>
          <th>TLB entry</th>
          <th>填入的来自 PTW 的信号</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>s2xlate[1:0]</td>
          <td>0b00 (nos2xlate)</td>
      </tr>
      <tr>
          <td>tag[34:0]</td>
          <td>s1.tag[34:0]</td>
      </tr>
      <tr>
          <td>asid[15:0]</td>
          <td>s1.asid[15:0]</td>
      </tr>
      <tr>
          <td>vmid[13:0]</td>
          <td>无效</td>
      </tr>
      <tr>
          <td>level[1:0]</td>
          <td>s1.level[1:0]</td>
      </tr>
      <tr>
          <td>ppn[32:0]</td>
          <td>s1.ppn[32:0]</td>
      </tr>
      <tr>
          <td>ppn_low[2:0]×8</td>
          <td>s1.ppn_low_*</td>
      </tr>
      <tr>
          <td>valididx×8</td>
          <td>s1.valididx_*</td>
      </tr>
      <tr>
          <td>pteidx×8</td>
          <td>s1.pteidx_*</td>
      </tr>
      <tr>
          <td>perm_pf</td>
          <td>s1.pf</td>
      </tr>
      <tr>
          <td>perm_af</td>
          <td>s1.af</td>
      </tr>
      <tr>
          <td>perm_a</td>
          <td>s1.perm.a</td>
      </tr>
      <tr>
          <td>perm_g</td>
          <td>s1.perm.g</td>
      </tr>
      <tr>
          <td>perm_u</td>
          <td>s1.perm.u</td>
      </tr>
      <tr>
          <td>perm_x</td>
          <td>s1.perm.x</td>
      </tr>
      <tr>
          <td>gperm_gpf</td>
          <td>无效</td>
      </tr>
      <tr>
          <td>gperm_gaf</td>
          <td>无效</td>
      </tr>
      <tr>
          <td>gperm_a</td>
          <td>无效</td>
      </tr>
      <tr>
          <td>gperm_x</td>
          <td>无效</td>
      </tr>
      <tr>
          <td><em>s2xlate=0b00 时填入 TLB entry 示意表</em></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>在 <code>OnlyStage1</code> 的情况下，主机的异常信号以及部分不可复用的权限位无效，其余均与主机地址转换一致。</p>
<table>
  <thead>
      <tr>
          <th>TLB entry</th>
          <th>填入的来自 PTW 的信号</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>s2xlate[1:0]</td>
          <td>0b01 (OnlyStage1)</td>
      </tr>
      <tr>
          <td>tag[34:0]</td>
          <td>s1.tag[34:0]</td>
      </tr>
      <tr>
          <td>asid[15:0]</td>
          <td>s1.asid[15:0]</td>
      </tr>
      <tr>
          <td>vmid[13:0]</td>
          <td>s1.vmid[13:0]</td>
      </tr>
      <tr>
          <td>level[1:0]</td>
          <td>s1.level[1:0]</td>
      </tr>
      <tr>
          <td>ppn[32:0]</td>
          <td>s1.ppn[32:0]</td>
      </tr>
      <tr>
          <td>ppn_low[2:0]×8</td>
          <td>s1.ppn_low_*</td>
      </tr>
      <tr>
          <td>valididx×8</td>
          <td>s1.valididx_*</td>
      </tr>
      <tr>
          <td>pteidx×8</td>
          <td>s1.pteidx_*</td>
      </tr>
      <tr>
          <td>perm_pf</td>
          <td>s1.pf</td>
      </tr>
      <tr>
          <td>perm_af</td>
          <td>s1.af</td>
      </tr>
      <tr>
          <td>perm_a</td>
          <td>s1.perm.a</td>
      </tr>
      <tr>
          <td>perm_g</td>
          <td>s1.perm.g</td>
      </tr>
      <tr>
          <td>perm_u</td>
          <td>s1.perm.u</td>
      </tr>
      <tr>
          <td>perm_x</td>
          <td>s1.perm.x</td>
      </tr>
      <tr>
          <td>gperm_gpf</td>
          <td>无效</td>
      </tr>
      <tr>
          <td>gperm_gaf</td>
          <td>无效</td>
      </tr>
      <tr>
          <td>gperm_a</td>
          <td>无效</td>
      </tr>
      <tr>
          <td>gperm_x</td>
          <td>无效</td>
      </tr>
      <tr>
          <td><em>s2xlate=0b01 时填入 TLB entry 示意表</em></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>对于 <code>OnlyStage2</code> 的情况，<code>asid</code> 无效，<code>vmid</code> 使用 <code>s1.vmid</code>（由于 <code>PTW</code> 模块无论什么情况都会填写这个字段，所以可以直接使用这个字段写入），<code>pteidx</code> 根据 <code>s2</code> 的 <code>tag</code> 的低 <code>3</code> 位来确定。如果 <code>s2</code> 是大页，那么 <code>TLB</code> 项的 <code>valididx</code> 均为有效，否则 <code>TLB</code> 项的 <code>pteidx</code> 对应 <code>valididx</code> 有效。<code>ppn</code> 的填写复用了 <code>allStage</code> 的逻辑，将在 <code>allStage</code> 的情况下介绍。</p>
<table>
  <thead>
      <tr>
          <th>TLB entry</th>
          <th>填入的来自 PTW 的信号</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>s2xlate[1:0]</td>
          <td>0b10 (OnlyStage2)</td>
      </tr>
      <tr>
          <td>tag[34:0]</td>
          <td>s2.tag[37:3]</td>
      </tr>
      <tr>
          <td>asid[15:0]</td>
          <td>无效</td>
      </tr>
      <tr>
          <td>vmid[13:0]</td>
          <td>s1.vmid[13:0]</td>
      </tr>
      <tr>
          <td>level[1:0]</td>
          <td>s2.level[1:0]</td>
      </tr>
      <tr>
          <td>ppn[32:0]</td>
          <td>s2.ppn[35:3]</td>
      </tr>
      <tr>
          <td>ppn_low[2:0]×8</td>
          <td>{ s2.ppn[2:0], 无效×7 }</td>
      </tr>
      <tr>
          <td>valididx×8</td>
          <td>{ 1， 0×7 }</td>
      </tr>
      <tr>
          <td>pteidx×8</td>
          <td>s2.tag[2:0]</td>
      </tr>
      <tr>
          <td>perm_pf</td>
          <td>无效</td>
      </tr>
      <tr>
          <td>perm_af</td>
          <td>无效</td>
      </tr>
      <tr>
          <td>perm_a</td>
          <td>无效</td>
      </tr>
      <tr>
          <td>perm_g</td>
          <td>无效</td>
      </tr>
      <tr>
          <td>perm_u</td>
          <td>无效</td>
      </tr>
      <tr>
          <td>perm_x</td>
          <td>无效</td>
      </tr>
      <tr>
          <td>gperm_gpf</td>
          <td>s2.gpf</td>
      </tr>
      <tr>
          <td>gperm_gaf</td>
          <td>s2.gaf</td>
      </tr>
      <tr>
          <td>gperm_a</td>
          <td>s2.perm.a</td>
      </tr>
      <tr>
          <td>gperm_x</td>
          <td>s2.perm.x</td>
      </tr>
      <tr>
          <td><em>s2xlate=0b10 时填入 TLB entry 示意表</em></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>如果两阶段地址转换均启用，<code>TLB</code> 将两阶段的结果合并存储，并丢弃中间物理地址（<code>s1</code> 阶段的 <code>ppn</code>），仅存储最终物理地址。<code>level</code> 需要取 <code>s1.level</code> 与 <code>s2.level</code> 中的较大值，此时需要注意，当 <code>s1</code> 阶段为大页，而 <code>s2</code> 阶段为小页的情况下，例如中间物理地址指向一个 <code>2MB</code> 页，而 <code>s2</code> 阶段转换的结果却是一个 <code>4KB</code> 页，在这种情况下，需要特殊处理，将 <code>s1.tag</code> 的高位（在此例子中为高 <code>11+9+9=29</code> 位）和 <code>s2.tag</code> 的低位（在此例子中为低 <code>9</code> 位）共 <code>38</code> 位合并存储到 <code>tag</code> 与 <code>pteidx</code> 中，如果不足 <code>38</code> 位则在后面补 <code>0</code>（例如中间物理地址指向 <code>1GB</code> 页而 <code>s2</code> 阶段指向 <code>2MB</code> 页，此时 <code>tag[34:0] = {s1.tag[34:15], s2.tag[17:9], 6'b0}</code>）。在这种情况（<code>s1</code> 大页 <code>s2</code> 小页）下 <code>ppn</code> 也需要处理后存储，根据 <code>s2.level</code> 将 <code>s2.ppn</code> 与 <code>s2.tag</code> 进行拼接后存储。</p>
<table>
  <thead>
      <tr>
          <th>TLB entry</th>
          <th>填入的来自 PTW 的信号</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>s2xlate[1:0]</td>
          <td>0b11 (allStage)</td>
      </tr>
      <tr>
          <td>tag[34:0]</td>
          <td>根据策略选择 s1.tag/s2.tag 的部分位</td>
      </tr>
      <tr>
          <td>asid[15:0]</td>
          <td>s1.asid</td>
      </tr>
      <tr>
          <td>vmid[13:0]</td>
          <td>s1.vmid</td>
      </tr>
      <tr>
          <td>level[1:0]</td>
          <td>s1.level 与 s2.level 的较大者</td>
      </tr>
      <tr>
          <td>ppn[32:0]</td>
          <td>s2.ppn 与 s2.tag 根据 s2.level 的拼接的高位</td>
      </tr>
      <tr>
          <td>ppn_low[2:0]×8</td>
          <td>s2.ppn 与 s2.tag 根据 s2.level 的拼接的低位</td>
      </tr>
      <tr>
          <td>valididx×8</td>
          <td>根据 level 确定</td>
      </tr>
      <tr>
          <td>pteidx×8</td>
          <td>tag 的低位</td>
      </tr>
      <tr>
          <td>perm_pf</td>
          <td>s1.pf</td>
      </tr>
      <tr>
          <td>perm_af</td>
          <td>s1.af</td>
      </tr>
      <tr>
          <td>perm_a</td>
          <td>s1.perm.a</td>
      </tr>
      <tr>
          <td>perm_g</td>
          <td>s1.perm.g</td>
      </tr>
      <tr>
          <td>perm_u</td>
          <td>s1.perm.u</td>
      </tr>
      <tr>
          <td>perm_x</td>
          <td>s1.perm.x</td>
      </tr>
      <tr>
          <td>gperm_gpf</td>
          <td>s2.gpf</td>
      </tr>
      <tr>
          <td>gperm_gaf</td>
          <td>s2.gaf</td>
      </tr>
      <tr>
          <td>gperm_a</td>
          <td>s2.perm.a</td>
      </tr>
      <tr>
          <td>gperm_x</td>
          <td>s2.perm.x</td>
      </tr>
      <tr>
          <td><em>s2xlate=0b11 时填入 TLB entry 示意表</em></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h2 id="支持发生-gpf-时重新发起-ptw-请求">支持发生 GPF 时重新发起 PTW 请求</h2>
<p>在香山的 <code>TLB</code> 中并不会保存中间物理地址。在两阶段地址转换过程中，如果第一阶段发生缺页异常，即 <code>PTW</code> 返回 <code>gpf</code>，此时 <code>TLB</code> 将 <code>PTW</code> 返回的结果存入 <code>TLB</code> 项内，请求方再次请求的时候发现 <code>gpf</code>，此时 <code>TLB</code> 会返回 <code>miss</code>，即使已经存储了这个映射。同时，<code>TLB</code> 将发起带 <code>getGPA</code> 标志的 <code>PTW</code> 请求，请求这个虚拟地址，并维护一组寄存器暂存相关信号：</p>
<table>
  <thead>
      <tr>
          <th>信号</th>
          <th>作用</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>need_gpa</td>
          <td>表示此时有一个请求正在获取 gpaddr</td>
      </tr>
      <tr>
          <td>need_gpa_robidx</td>
          <td>存储请求的 ROB（Reorder Buffer）索引，用于跟踪请求来源，目前未使用</td>
      </tr>
      <tr>
          <td>need_gpa_vpn[37:0]</td>
          <td>存储请求的 vpn，即 50 位虚拟地址的高 38 位</td>
      </tr>
      <tr>
          <td>need_gpa_gvpn[43:0]</td>
          <td>存储获取的 gpaddr 的 gvpn，虚拟机通过转换得到的 56 位虚拟机物理地址的高 44 位，前六位在第二阶段地址转换中被要求为全 0</td>
      </tr>
      <tr>
          <td>need_gpa_refill</td>
          <td>表示该请求的 gpaddr 已经被填入 need_gpa_gvpn</td>
      </tr>
  </tbody>
</table>
<p>每当 <code>TLB</code> 发起带 <code>getGPA</code> 标志的请求时，就会将 <code>need_gpa</code> 置 <code>1</code>，并将请求的 <code>vpn</code> 填入到 <code>need_gpa_vpn</code> 中，同时将 <code>need_gpa_refill</code> 置 <code>0</code>。当 <code>PTW</code> 返回结果的时候，<code>TLB</code> 将 <code>PTW resp</code> 中的 <code>vpn</code> 提取出来与 <code>need_gpa_vpn</code> 进行比较，判断是否是对之前 <code>getGPA</code> 请求的回应。如果是，那么将 <code>PTW resp</code> 中的 <code>s2 tag</code> 填入到 <code>need_gpa_gvpn</code> 中并将 <code>need_gpa_refill</code> 置 <code>1</code>，表示已经获取到需要的 <code>gvpn</code>。下一次 <code>TLB</code> 接收到相同请求时就可以通过 <code>need_gpa_gvpn</code> 得到 <code>gpaddr</code>，之后 <code>TLB</code> 会将 <code>need_gpa</code> 置 <code>0</code>，但保留其它寄存器，因此下次其它的请求发生 <code>gpf</code> 时也可以再次使用相同的 <code>need_gpa_vpn</code> 找到 <code>paddr</code> 而无需再次发起 <code>PTW</code> 请求。</p>
<p>注意这里的 <code>gvpn</code> 是 <code>44</code> 位的，这是由于客户机采用 <code>56</code> 位物理地址，为了维护 <code>gpaddr</code> 的完整性，所以在这里需要存储 <code>44</code> 位的 <code>gvpn</code>，但是事实上 <code>gvpn</code> 的前 <code>6</code> 位一定会是 <code>0</code>，否则说明第一阶段产生了错误的物理地址，会触发 <code>gpf</code>，在此时需要将错误信息保存在 <code>mtval2/htval</code> 寄存器中，因此需要完整的 <code>gpaddr</code>，正常情况下并不需要。（当发生页面错误时，<code>mtval2</code> 将被填充为生成错误的物理地址，帮助异常处理程序；<code>htval</code> 将被填充为导致异常的虚拟地址，帮助 <code>hypervisor</code> 识别问题）</p>
<p>如果发生了 <code>redirect</code>，即重定向（可能触发了跳转/分支指令等或发生异常），此时之前的指令可能不会再访问 <code>TLB</code>，<code>TLB</code> 需要根据 <code>robidx</code> 跟踪请求来源，有选择性地刷新相关的寄存器（即上表中提到的）。目前香山昆明湖架构中尚未实现，而是通过在需要 <code>redirect</code> 的时候发送 <code>flushPipe</code> 指令来实现的，无论哪一个请求端口被刷新均会导致这些寄存器被刷新。</p>
<p><code>getGPA</code> 标志并不用于判断指令是否是请求 <code>gpaddr</code>，<code>PTW</code> 不需要关心请求是干什么的，只需要负责查找并返回结果；<code>TLB</code> 内会通过一系列寄存器的比较来判断。这个信号的作用在于防止 <code>TLB</code> 重填，每次 <code>TLB</code> 发送带 <code>getGPA</code> 标志的请求时，<code>PTW</code> 在返回时会将 <code>getGPA</code> 信号传递回 <code>TLB</code>，从而使 <code>TLB</code> 不进行重填，不存储此项 <code>gpaddr</code>。</p>
<h2 id="支持-plru-替换算法">支持 PLRU 替换算法</h2>
<p><code>LRU</code>（<code>Least Recently Used</code>）算法核心思想就是替换掉最近最少使用的页，也就是最长时间没有访问的页。<code>LRU</code> 算法将内存中的每个页组织成了一个链表的形式，如图所示：</p>
<p><img src="LRU%E7%AE%97%E6%B3%95.png" alt="LRU 算法示意图"></p>
<p>链表有两端，一端是最近最少使用的页，可以称为 <code>LRU</code> 端，另一端是最近刚刚使用的页，即最近使用最频繁的页，称之为 <code>MRU</code>（<code>Most Recently Used</code>）端。每次访问的时候如果命中，那么就将命中的页移动到 <code>MRU</code> 端，如果 <code>miss</code> 则触发缺页，此时需要加载页面。如果这时候内存已满，那么就需要进行页面替换，选择 <code>LRU</code> 端的页进行替换，并把新访问的页放在 <code>MRU</code> 端。这就是 <code>LRU</code> 替换算法，是 <code>cache</code> 替换的经典算法。</p>
<p>但是由于 <code>LRU</code> 需要为 <code>cache</code> 行维护一个链表数据结构，在多路组相联的 <code>cache</code> 行中需要为每一路配置链表并跟踪每一行的使用时间，<code>LRU</code> 算法有着巨大的开销。因此虽然 <code>LRU</code> 在页面替换中表现出色，也依然不常使用。</p>
<p>在香山的昆明湖架构中，<code>TLB</code> 采用 <code>PLRU</code>（<code>pseudo-LRU</code>）替换算法，详细来说是 <code>tree-based PLRU</code> 算法。假设当前 <code>Cache</code> 是 <code>n</code> 路组相联（<code>n</code> 一般是 <code>2</code> 的整数幂）的结构，那么需要定义 <code>n-1</code> 位用来进行二叉树索引，假设为 <code>0</code> 表示左，为 <code>1</code> 表示右，如图所示：</p>
<p><img src="PLRU%E7%B4%A2%E5%BC%95.png" alt="PLRU 二叉索引示意图"></p>
<p>对目前的香山昆明湖架构来说，采用每路 <code>48 cache</code> 行的二路组相联结构下，<code>PLRU</code> 需要维护一个 <code>48</code> 项的链表和一个一级的二叉树（<code>1</code> 位），而采用 <code>LRU</code> 将需要维护一个 <code>48</code> 项的链表和 <code>48</code> 个 <code>2</code> 项的链表，有一定的开销优势，随着路数的增加，优势会更加明显；同时，对二叉树的维护成本也比链表更低。</p>
<p>当然，<code>PLRU</code> 多级二叉树的选择策略下并不能做到与 <code>LRU</code> 一样精确控制，每次二分地排除掉一半不一定能找到绝对 <code>LRU</code> 的条目。</p>
<h2 id="支持-sfencevma-指令">支持 SFENCE.VMA 指令</h2>
<p><code>SFENCE.VMA</code> 指令（<code>Supervisor Memory-Management Fence Instruction</code>）是定义在 <code>RISC-V</code> 指令架构的指令：</p>
<p><img src="SFENCE_VMA.png" alt="SFECE.VMA 指令"></p>
<p>在内存管理中，页表负责将虚拟地址映射到物理地址。当修改了页表后，这些修改不会自动在处理器的缓存中生效。为了确保后续的指令能使用更新后的页表，必须通过 <code>SFENCE.VMA</code> 指令来刷新这些缓存。此外，处理器在执行指令时，可能隐式地对内存管理数据结构进行读取和写入操作，但这些隐式操作和显式的内存操作通常是无序的。<code>SFENCE.VMA</code> 指令可以强制处理器将某些隐式操作在显式操作之前完成，从而确保操作的顺序性。</p>
<p><code>SFENCE.VMA</code> 是 <code>RISC-V</code> 架构中的一条特权指令，用于刷新与地址翻译相关的本地硬件缓存，处理内存管理数据结构的同步，特别是当需要确保对这些数据结构的修改在不同的硬件组件之间保持一致时需要频繁使用该指令。<code>SFENCE.VMA</code> 只影响本地核心（<code>hart</code>），如果需要在多个核心之间同步，则需要核间中断等额外机制。虽然 <code>SFENCE.VMA</code> 指令对于维护一致性至关重要，但频繁调用可能会影响系统性能，因此，应根据实际需要合理使用，以平衡一致性和性能之间的关系。</p>
<p><code>SFENCE.VMA</code> 的行为依赖于 <code>rs1</code> 和 <code>rs2</code>，在 <code>RISC-V</code> 特权指令集中如下所述：</p>
<table>
  <thead>
      <tr>
          <th>条件</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>- 如果 <code>rs1=x0</code> 且 <code>rs2=x0</code>，栅栏会对所有地址空间的页面表的所有读写进行排序，并将所有地址翻译缓存条目标记为 invalid。</td>
      </tr>
      <tr>
          <td>- 如果 <code>rs1=x0</code> 且 <code>rs2</code> 不是 <code>x0</code>，栅栏会对指定的地址空间的页面表的所有读写进行排序，但不对全局映射进行排序。它还会失效与指定地址空间匹配的地址翻译缓存条目，但不包括全局映射的条目。</td>
      </tr>
      <tr>
          <td>- 如果 <code>rs1</code> 不是 <code>x0</code> 且 <code>rs2=x0</code>，栅栏会对所有地址空间的与 <code>rs1</code> 对应的虚拟地址的叶子页面表条目的读写进行排序，并失效包含该虚拟地址的所有叶子页面表条目的地址翻译缓存条目。</td>
      </tr>
      <tr>
          <td>- 如果 <code>rs1</code> 不是 <code>x0</code> 且 <code>rs2</code> 不是 <code>x0</code>，栅栏会对与 <code>rs1</code> 对应的虚拟地址在指定地址空间的叶子页面表条目的读写进行排序，并失效与 <code>rs1</code> 对应的虚拟地址并匹配指定地址空间的所有叶子页面表条目的地址翻译缓存条目，但不包括全局映射的条目。</td>
      </tr>
      <tr>
          <td>- 如果 <code>rs1</code> 中的值不是有效的虚拟地址，则 <code>SFENCE.VMA</code> 指令没有效果，且不会引发异常。</td>
      </tr>
      <tr>
          <td>- 当 <code>rs2=x0</code> 时，<code>rs2</code> 中的值的 <code>SXLEN-1:ASIDMAX</code> 位保留供将来标准使用。在标准扩展定义其用法之前，这些位应由软件置为零并被当前实现忽略。此外，如果 <code>ASIDLEN &lt; ASIDMAX</code>，则实现应忽略 <code>rs2</code> 中值的 <code>ASIDMAX-1:ASIDLEN</code> 位。</td>
      </tr>
  </tbody>
</table>
<p><code>SFENCE.VMA</code> 指令的作用是确保在执行该指令之前的所有写入操作已经被提交到内存。这意味着 <code>Store Buffer</code> 中的所有未完成写入都会被写入到 <code>DCache</code> 或最终的内存地址中；<code>SFENCE.VMA</code> 发出刷新信号，通知 <code>MMU</code>（内存管理单元）更新 <code>TLB</code>（转换后备缓冲区）等内部状态。这一刷新信号是瞬时的，并且没有返回确认信号。在验证时需要通过再次访问观察是否 <code>miss</code> 的形式来进行，也可以通过分析波形文件观察 <code>TLB</code> 内部寄存器行为。</p>
<table>
  <thead>
      <tr>
          <th>Store Buffer（存储缓冲区）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Store Buffer 用于提高内存写入效率，允许 CPU 在发出写入操作后，立即继续执行后续指令，而不需要等待内存系统确认写入完成。这有助于减少 CPU 的闲置时间，提高指令执行的整体效率。写回时，写入数据首先被放入 Store Buffer，随后，数据会按某种策略写入主内存（如 DCache 或其他存储层级）。Store Buffer 维护写入操作的顺序，但不保证这些写入操作立即反映在内存中。在多核处理器中，Store Buffer 可以帮助降低缓存一致性协议的复杂性。</td>
      </tr>
  </tbody>
</table>
<h2 id="支持-hfencevvma-与-hfencegvma-指令">支持 HFENCE.VVMA 与 HFENCE.GVMA 指令</h2>
<p>事实上，对 <code>hv</code>（<code>SFENCE Bundle</code> 中的信号，用于刷新第一阶段地址转换的条目）和 <code>hg</code>（<code>SFENCE Bundle</code> 中的信号，用于刷新第二阶段地址转换的条目）信号不为 <code>0</code> 的情况执行的指令并不是 <code>SFENCE.VMA</code>，而是 <code>HFENCE.VVMA</code> 和 <code>HFENCE.GVMA</code>：</p>
<p><img src="HFENCE.png" alt="HFENCE.VVMA 与 HFENCE.GVMA"></p>
<p>这两个指令与 <code>SFENCE.VMA</code> 功能很相似，区别在于 <code>HFENCE.VVMA</code> 适用于由 <code>vsatp</code> 控制的 <code>VS</code> 级别内存管理数据结构；<code>HFENCE.GVMA</code> 适用于由 <code>hgatp</code> 控制的虚拟机监管程序 <code>G</code> 阶段内存管理数据结构。</p>
<p><code>HFENCE.VVMA</code> 仅在 <code>M</code> 模式或 <code>HS</code> 模式生效，类似于暂时进入 <code>VS</code> 模式并执行 <code>SFENCE.VMA</code> 指令，可以保证当前 <code>hart</code> 之前的所有存储操作在后续的隐式读取 <code>VS</code> 级别内存管理数据结构之前都已经排序；注意这里所说的隐式读取指的仅有在 <code>HFENCE.VVMA</code> 之后执行的，并且 <code>hgatp.VMID</code> 与执行 <code>HFENCE.VVMA</code> 相同的时候，简单来说就是仅对当前这一个虚拟机生效。<code>rs1</code> 与 <code>rs2</code> 的功能与 <code>SFENCE.VMA</code> 相同。</p>
<p>对 <code>HFENCE.GVMA</code> 来说，<code>rs1</code> 指定的是客机的物理地址。由于主机采用 <code>SV48</code> 而虚拟机采用 <code>SV48x4</code>，客机物理地址比主机物理地址多两位，因此此时需要将 <code>rs1</code> 对应的客机物理地址右移两位。如果某一个虚拟机的地址翻译模式更改了，也即 <code>hgatp.MODE</code> 对某个 <code>VMID</code> 更改了，则必须使用 <code>HFENCE.GVMA</code> 指令，将 <code>rs1</code> 设为 <code>0</code>，<code>rs2</code> 设为 <code>0</code> 或 <code>VMID</code> 进行刷新。</p>
<p>在香山中，由于 <code>TLB</code> 本身不存储中间物理地址，也即 <code>TLB</code> 并不存储 <code>VS</code> 阶段转换出来的虚拟机物理地址，也无法单独提供 <code>G</code> 阶段地址转换请求。在 <code>TLB</code> 中存储的是两阶段地址翻译的最终结果，因此 <code>HFENCE.VVMA</code> 与 <code>HFENCE.GVMA</code> 在 <code>TLB</code> 中作用相同，均为刷新掉两阶段地址翻译的结果。无论 <code>hv</code> 与 <code>hg</code> 哪一个信号为 <code>1</code> 都将刷新两阶段的条目。</p>
<h2 id="支持-sinval-扩展">支持 SINVAL 扩展</h2>
<p>在 <code>RISC-V</code> 特权指令集中定义了 <code>Svinval</code> 扩展（<code>Supervisor Virtual Address Invalidation</code>），在香山昆明湖架构实现了该扩展。<code>Svinval</code> 扩展的意义在于将 <code>SFENCE.VMA</code> 指令更加细化为 <code>SFENCE.W.INVAL</code>、<code>SINVAL.VMA</code>、<code>SFENCE.INVAL.IR</code> 三条指令（<code>HFENCE.VVMA</code> 和 <code>HFENCE.GVMA</code> 同理）。</p>
<p><code>SINVAL.VMA</code> 指令事实上与 <code>SFENCE.VMA</code> 指令的功能基本一致，只是添加了对 <code>SFENCE.W.INVAL</code> 与 <code>SFENCE.INVAL.IR</code> 两个指令的相互排序，可以理解为需要在两个指令中间进行。<code>SFENCE.W.INVAL</code> 指令用于确保当前 <code>RISC-V hart</code> 可见的任何先前存储在后续由同一个 <code>hart</code> 执行的 <code>SINVAL.VMA</code> 指令之前被重新排序。<code>SFENCE.INVAL.IR</code> 指令确保当前 <code>hart</code> 执行的任何先前 <code>SINVAL.VMA</code> 指令在后续隐式引用内存管理数据结构之前被排序。当由单个 <code>hart</code> 按顺序（不一定连续）执行 <code>SFENCE.W.INVAL</code>、<code>SINVAL.VMA</code> 和 <code>SFENCE.INVAL.IR</code> 时，可以相当于执行了 <code>SFENCE.VMA</code> 指令。</p>
<p><img src="SINVAL_VMA.png" alt="SINVAL.VMA"></p>
<p><img src="SFENCE_W_INVAL&amp;INVAL_IR.png" alt="SFENCE.W.INVAL 和 SFENCE.INVAL.IR"></p>
<h2 id="支持软件更新-ad-位">支持软件更新 A/D 位</h2>
<p><code>A</code> 位（<code>Access</code>）用于指示某一页面是否被访问过。如果处理器对该页面进行任何形式的访问（读/写/取指），则 <code>A</code> 位会被设置为 <code>1</code>。每当 <code>CPU</code> 访问某个页面时，操作系统或硬件会自动将 <code>A</code> 位设置为 <code>1</code>，这种更新通常是硬件支持的，由处理器在地址转换时自动进行。</p>
<p><code>D</code> 位（<code>Dirty</code>）指示页面是否被修改。如果页面在内存中被写入，则 <code>D</code> 位会被设置为 <code>1</code>，表示该页面的内容已被更改。当处理器对页面进行写操作时，通常会自动将 <code>D</code> 位设置为 <code>1</code>，这种更新通常也是由硬件支持的。在页面替换过程中，操作系统会检查 <code>D</code> 位，如果 <code>D</code> 位为 <code>1</code>，操作系统会将页面写回到磁盘，并在写回后清除 <code>D</code> 位，以表示页面已经被保存且不再是“脏”的。</p>
<p>在香山昆明湖架构中，并不支持硬件更新 <code>A/D</code> 位，而是在需要更新的时候通过 <code>Page Fault</code> 通知软件进行页表更新。具体来说，每当处理器访问某一页时检查该页 <code>A</code> 位如果是 <code>0</code>，那么会发生 <code>PF</code>；同样的，每当处理器写入某一页时检查该页的 <code>D</code> 位如果是 <code>0</code>，同样会发生 <code>PF</code>。在软件处理异常后，操作系统会允许处理器再次访问页面，只有在页表得到更新且相关状态位（<code>A</code> 和 <code>D</code> 位）被正确设置后，处理器才能继续进行后续的内存访问。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8bca4e6bf58524f8693521bd6ceaf50b">12.2.4.3 - 关键信号说明</h1>
    
	<h2 id="相关-csr-寄存器">相关 CSR 寄存器</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">csr</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Input</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">TlbCsrBundle</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span></code></pre></div><p><code>csr</code>：包含 <code>satp</code>、<code>vsatp</code>、<code>hgatp</code> 三个寄存器的信息以及一些权限信息。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">class</span> <span style="color:#000">TlbCsrBundle</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">implicit</span> <span style="color:#000">p</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Parameters</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">extends</span> <span style="color:#000">XSBundle</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">satp</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">TlbSatpBundle</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">vsatp</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">TlbSatpBundle</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">hgatp</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">TlbHgatpBundle</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">priv</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">Bundle</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">mxr</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Bool</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>		<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">sum</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Bool</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>		<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">vmxr</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Bool</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>		<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">vsum</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Bool</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>		<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">virt</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Bool</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>		<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">spvp</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">UInt</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#0000cf;font-weight:bold">1.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>		<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">imode</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">UInt</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#0000cf;font-weight:bold">2.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>		<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">dmode</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">UInt</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#0000cf;font-weight:bold">2.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ce5c00;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">override</span> <span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">toPrintable</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Printable</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">p</span><span style="color:#4e9a06">&#34;Satp mode:0x${Hexadecimal(satp.mode)} asid:0x${Hexadecimal(satp.asid)} ppn:0x${Hexadecimal(satp.ppn)} &#34;</span> <span style="color:#ce5c00;font-weight:bold">+</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">p</span><span style="color:#4e9a06">&#34;Priv mxr:${priv.mxr} sum:${priv.sum} imode:${priv.imode} dmode:${priv.dmode}&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ce5c00;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">}</span>
</span></span></code></pre></div><p><code>TlbCsrBundle</code> 中包含了 <code>satp</code>、<code>vsatp</code>、<code>hgatp</code> 以及 <code>priv</code> 特权标志。其中 <code>satp</code> 与 <code>vsatp</code> 通过 <code>TlbSatpBundle</code> 实现，包括 <code>mode</code>、<code>asid</code>、<code>ppn</code>、<code>changed</code> 以及一个 <code>apply</code> 方法：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">class</span> <span style="color:#000">SatpStruct</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">implicit</span> <span style="color:#000">p</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Parameters</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">extends</span> <span style="color:#000">XSBundle</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">mode</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">UInt</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#0000cf;font-weight:bold">4.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">asid</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">UInt</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#0000cf;font-weight:bold">16.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">ppn</span>  <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">UInt</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#0000cf;font-weight:bold">44.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">class</span> <span style="color:#000">TlbSatpBundle</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">implicit</span> <span style="color:#000">p</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Parameters</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">extends</span> <span style="color:#000">SatpStruct</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">changed</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Bool</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#8f5902;font-style:italic">// Todo: remove it
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>	<span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">apply</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">satp_value</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">UInt</span><span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Unit</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">require</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">satp_value</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">getWidth</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#000">XLEN</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>		<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">sa</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">satp_value</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">asTypeOf</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">SatpStruct</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">mode</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">sa</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">mode</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">asid</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">sa</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">asid</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">ppn</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">sa</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">ppn</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">changed</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">DataChanged</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">sa</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">asid</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic">// when ppn is changed, software need do the flush
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>	<span style="color:#ce5c00;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">}</span>
</span></span></code></pre></div><p><code>hgatp</code> 通过 <code>TlbHgatpBundle</code> 实现，区别在于将 <code>asid</code> 替换为 <code>vmid</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">class</span> <span style="color:#000">HgatpStruct</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">implicit</span> <span style="color:#000">p</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Parameters</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">extends</span> <span style="color:#000">XSBundle</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">mode</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">UInt</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#0000cf;font-weight:bold">4.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">vmid</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">UInt</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#0000cf;font-weight:bold">16.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">ppn</span>  <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">UInt</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#0000cf;font-weight:bold">44.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">class</span> <span style="color:#000">TlbHgatpBundle</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">implicit</span> <span style="color:#000">p</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Parameters</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">extends</span> <span style="color:#000">HgatpStruct</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">changed</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Bool</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#8f5902;font-style:italic">// Todo: remove it
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>	<span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">apply</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">hgatp_value</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">UInt</span><span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Unit</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">require</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">hgatp_value</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">getWidth</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#000">XLEN</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>		<span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">sa</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">hgatp_value</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">asTypeOf</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">HgatpStruct</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">mode</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">sa</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">mode</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">vmid</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">sa</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">vmid</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">ppn</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">sa</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">ppn</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000">changed</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">DataChanged</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">sa</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">vmid</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic">// when ppn is changed, software need do the flush
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>	<span style="color:#ce5c00;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">}</span>
</span></span></code></pre></div><h4 id="satp"><code>SATP</code></h4>
<ul>
<li><code>satp (Supervisor Address Translation and Protection)</code> 用于内核态（<code>Supervisor mode</code>）进行虚拟地址到物理地址的转换管理，通常在非虚拟化环境或作为虚拟机监控程序（<code>VMM</code>）时使用。</li>
<li><code>mode</code>：地址转换模式，控制虚拟地址的转换，位宽为 <code>4</code>。其允许的值包含 <code>0</code>、<code>8</code>、<code>9</code>，如果是其它值应当触发 <code>illegal instruction fault</code>。
<ul>
<li><code>0</code>: <code>Bare</code> 模式，不进行地址转换。</li>
<li><code>8</code>: <code>SV39</code> 模式，使用三级页表支持 <code>39</code> 位虚拟地址空间。</li>
<li><code>9</code>: <code>SV48</code> 模式，使用四级页表支持 <code>48</code> 位虚拟地址空间。</li>
</ul>
</li>
<li><code>asid</code>：地址空间标识符，用于区分不同进程，香山昆明湖架构使用的 <code>SV48</code> 中最大长度为 <code>16</code>。</li>
<li><code>ppn</code>：<code>Page Table Pointer</code>，根页表的物理页框号，其位宽为 <code>44</code> 位，由物理地址右移 <code>12</code> 位得到。</li>
</ul>
<p><img src="satp.png" alt="SATP"></p>
<h4 id="vsatp"><code>VSATP</code></h4>
<ul>
<li><code>vsatp (Virtual Supervisor Address Translation and Protection)</code> 是虚拟机中客体操作系统的地址转换寄存器，提供虚拟机的虚拟地址到中间物理地址（<code>IPA</code>）的转换。</li>
<li><code>mode</code>：页表模式，控制虚拟地址的转换，模式值与 <code>satp</code> 中的类似。</li>
<li><code>asid</code>：虚拟机内地址空间标识符。</li>
<li><code>ppn</code>：虚拟机页表的物理基地址。</li>
</ul>
<p><img src="vsatp.png" alt="VSATP"></p>
<h4 id="hgatp"><code>HGATP</code></h4>
<ul>
<li><code>hgatp (Hypervisor Guest Address Translation and Protection)</code> 是虚拟机监控程序（<code>Hypervisor</code>）的二级地址转换寄存器，用于将虚拟机的中间物理地址（<code>IPA</code>）转换为主机物理地址（<code>HPA</code>）。</li>
<li><code>mode</code>：页表模式，如 <code>SV39x4</code> 或 <code>SV48x4</code>，用于虚拟机的二级地址转换。
<ul>
<li><code>0</code>: <code>Bare</code> 模式，不进行二级地址转换。</li>
<li><code>8</code>: <code>SV39x4</code> 模式，即 <code>39</code> 位虚拟地址空间，允许四倍页表扩展。</li>
<li><code>9</code>: <code>SV48x4</code> 模式，即 <code>48</code> 位虚拟地址空间，允许四倍页表扩展。</li>
</ul>
</li>
<li><code>vmid</code>：虚拟机标识符，区分不同虚拟机。</li>
<li><code>ppn</code>：二级页表的物理基地址。</li>
</ul>
<p><img src="hgatp.png" alt="HGATP"></p>
<p><code>satp</code> 管理主机地址空间的虚拟地址到物理地址的转换，<code>vsatp</code> 用于虚拟机中的虚拟地址到中间物理地址（<code>IPA</code>）的转换，而 <code>hgatp</code> 则负责虚拟机二级地址转换，将 <code>IPA</code> 转换为主机物理地址。</p>
<h4 id="priv"><code>PRIV</code></h4>
<ul>
<li>
<p><strong>mxr</strong> : <code>Bool()</code><br>
机器可执行只读（MXR）位。控制在用户模式下是否允许执行某些在机器层面被标记为只读的页面。</p>
</li>
<li>
<p><strong>sum</strong> : <code>Bool()</code><br>
特权模式可访问用户（SUM）位。控制特权模式下对用户模式地址的访问权限。</p>
</li>
<li>
<p><strong>vmxr</strong> : <code>Bool()</code><br>
虚拟机器可执行只读（<code>VMXR</code>）位。控制虚拟机内的用户是否可以执行只读页面。</p>
</li>
<li>
<p><strong>vsum</strong> : <code>Bool()</code><br>
虚拟特权模式可访问用户（<code>VSUM</code>）位。控制虚拟化环境中特权模式对用户模式地址的访问权限。</p>
</li>
<li>
<p><strong>virt</strong> : <code>Bool()</code><br>
虚拟化状态位。指示当前系统是否处于虚拟化模式。</p>
</li>
<li>
<p><strong>spvp</strong> : <code>UInt(1.W)</code><br>
超级特权虚拟模式（<code>SPVP</code>）。指示当前是否处于虚拟化环境中的超级特权模式。</p>
</li>
<li>
<p><strong>imode</strong> : <code>UInt(2.W)</code><br>
指示当前（<code>ITLB</code>）指令的处理模式：</p>
<ul>
<li><code>0x3</code> : <strong>ModeM</strong>（机器模式）</li>
<li><code>0x2</code> : <strong>ModeH</strong>（虚拟机监控程序模式，已删除）</li>
<li><code>0x1</code> : <strong>ModeS</strong>（特权模式）</li>
<li><code>0x0</code> : <strong>ModeU</strong>（用户模式）</li>
</ul>
</li>
<li>
<p><strong>dmode</strong> : <code>UInt(2.W)</code><br>
指示当前（<code>DTLB</code>）数据的处理模式。</p>
</li>
</ul>
<h4 id="changed"><code>changed</code></h4>
<ul>
<li>用于标志对应 <code>CSR</code> 中的信息是否更改，一旦 <code>Mode</code> 或 <code>Asid</code>（<code>Vmid</code>）更改则必须同步将 <code>changed</code> 置 <code>1</code>，<code>TLB</code> 在检测到 <code>changed</code> 为 <code>1</code> 时将会执行刷新操作，刷新掉旧的 <code>Asid</code>（<code>Vmid</code>）的映射。</li>
</ul>
<h4 id="base_connect">base_connect()</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">base_connect</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">sfence</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">SfenceBundle</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">csr</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">TlbCsrBundle</span><span style="color:#ce5c00;font-weight:bold">)</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Unit</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">this</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">sfence</span> <span style="color:#ce5c00;font-weight:bold">&lt;&gt;</span> <span style="color:#000">sfence</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">this</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">csr</span> <span style="color:#ce5c00;font-weight:bold">&lt;&gt;</span> <span style="color:#000">csr</span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// overwrite satp. write satp will cause flushpipe but csr.priv won&#39;t
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// satp will be delayed several cycles from writing, but csr.priv won&#39;t
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// so inside mmu, these two signals should be divided
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">base_connect</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">sfence</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">SfenceBundle</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">csr</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">TlbCsrBundle</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">satp</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">TlbSatpBundle</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">this</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">sfence</span> <span style="color:#ce5c00;font-weight:bold">&lt;&gt;</span> <span style="color:#000">sfence</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">this</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">csr</span> <span style="color:#ce5c00;font-weight:bold">&lt;&gt;</span> <span style="color:#000">csr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#204a87;font-weight:bold">this</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">csr</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">satp</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">satp</span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">}</span>
</span></span></code></pre></div><h2 id="sfence">sfence</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">sfence</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Input</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">SfenceBundle</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span></code></pre></div><p><code>sfence</code>：用于传入 <code>SfenceBundle</code>，执行 <code>SFENCE</code> 指令刷新 <code>TLB</code> 缓存。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">class</span> <span style="color:#000">SfenceBundle</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">implicit</span> <span style="color:#000">p</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Parameters</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">extends</span> <span style="color:#000">XSBundle</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">valid</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Bool</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">bits</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">Bundle</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">rs1</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Bool</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">rs2</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Bool</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">addr</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">UInt</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">VAddrBits</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">id</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">UInt</span><span style="color:#ce5c00;font-weight:bold">((</span><span style="color:#000">AsidLength</span><span style="color:#ce5c00;font-weight:bold">).</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic">// asid or vmid
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>        <span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">flushPipe</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Bool</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">hv</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Bool</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">hg</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Bool</span><span style="color:#ce5c00;font-weight:bold">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">override</span> <span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">toPrintable</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Printable</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#000">p</span><span style="color:#4e9a06">&#34;valid:0x${Hexadecimal(valid)} rs1:${bits.rs1} rs2:${bits.rs2} addr:${Hexadecimal(bits.addr)}, flushPipe:${bits.flushPipe}&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">}</span>
</span></span></code></pre></div><h4 id="valid"><code>valid</code></h4>
<ul>
<li>有效标志信号，指示 <code>SFENCE.VMA</code> 操作的请求是否有效。如果该信号为高（<code>1</code>），表示当前的 <code>SFENCE.VMA</code> 操作需要执行；如果为低（<code>0</code>），则没有操作需要执行。</li>
</ul>
<h4 id="rs1"><code>rs1</code></h4>
<ul>
<li>表示需要使用 <code>SFENCE.VMA</code> 指令中的 <code>rs1</code> 寄存器的值，这个值通过信号 <code>addr</code> 传入，标记了需要刷新的虚拟地址。</li>
<li>当 <code>rs1</code> 为非零时，表示 <code>SFENCE.VMA</code> 只针对该虚拟地址所对应的页表条目进行刷新操作；如果 <code>rs1</code> 为零，则表示刷新所有虚拟地址的映射。</li>
</ul>
<h4 id="rs2"><code>rs2</code></h4>
<ul>
<li>表示需要使用 <code>SFENCE.VMA</code> 指令中的 <code>rs2</code> 寄存器的值，其中存储着需要刷新的 <code>ASID</code>，通过信号 <code>id</code> 传入。</li>
<li>当 <code>rs2</code> 为非零时，表示 <code>SFENCE.VMA</code> 只对指定的 <code>ASID</code> 进行刷新操作；如果 <code>rs2</code> 为零，则表示刷新所有地址空间的映射。这个信号主要用于区分不同进程的地址空间。</li>
</ul>
<h4 id="addr"><code>addr</code></h4>
<ul>
<li>表示 <code>SFENCE.VMA</code> 指令中 <code>rs1</code> 对应的虚拟地址（可能是部分地址）。该信号提供了具体的虚拟地址信息，当 <code>rs1</code> 为非零时，<code>TLB</code> 将使用该地址作为参考，刷新与该地址对应的页表条目。它用于精细控制哪些地址映射需要被刷新。</li>
<li>信号的位宽为 <code>VAddrBits</code>，即虚拟地址的位宽，可见于 \ref{subsec:consts}，大小被定义为 <code>50</code>，其中事实上使用的只有 <code>addr[47:12]</code>，也即四级页表的四级索引部分，用于找到对应虚拟地址的页表项。</li>
</ul>
<h4 id="id"><code>id</code></h4>
<ul>
<li>表示 <code>SFENCE.VMA</code> 操作涉及的地址空间标识符（<code>ASID</code>）。用于指定某个具体的 <code>ASID</code>。它允许在多地址空间的场景下（例如多个进程共享一个处理器），只刷新某个特定进程的地址映射。</li>
<li>信号位宽为 <code>AsidLength</code>，可见于 \ref{subsec:consts}，大小为 <code>16</code>，意味着同时支持 $2^{16}$ 个虚拟地址空间。</li>
</ul>
<h4 id="flushpipe"><code>flushPipe</code></h4>
<ul>
<li>控制是否需要 <strong>清空流水线</strong>。<code>SFENCE.VMA</code> 操作不仅可能涉及刷新 <code>TLB</code>，还可能需要清空流水线以确保所有未完成的指令（可能依赖旧的地址映射）不会继续使用过时的页表映射。这个信号为高时，表示需要清空流水线。</li>
</ul>
<h4 id="hv"><code>hv</code></h4>
<ul>
<li>表示当前指令是否为 <code>HFENCE.VVMA</code>。</li>
</ul>
<h4 id="hg"><code>hg</code></h4>
<ul>
<li>表示当前指令是否为 <code>HFENCE.GVMA</code>。</li>
</ul>
<h2 id="外部传入参数">外部传入参数</h2>
<h4 id="参数说明">参数说明</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">class</span> <span style="color:#000">TLB</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Width</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Int</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">nRespDups</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Int</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">1</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">Block</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Seq</span><span style="color:#ce5c00;font-weight:bold">[</span><span style="color:#204a87;font-weight:bold">Boolean</span><span style="color:#ce5c00;font-weight:bold">],</span> <span style="color:#000">q</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">TLBParameters</span><span style="color:#ce5c00;font-weight:bold">)(</span><span style="color:#204a87;font-weight:bold">implicit</span> <span style="color:#000">p</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Parameters</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">extends</span> <span style="color:#000">TlbModule</span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">with</span> <span style="color:#000">HasCSRConst</span>
</span></span><span style="display:flex;"><span>  <span style="color:#204a87;font-weight:bold">with</span> <span style="color:#000">HasPerfEvents</span>
</span></span></code></pre></div><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>Width: Int</code></td>
          <td>指示 <code>requestor</code> 的数量</td>
      </tr>
      <tr>
          <td><code>nRespDups: Int = 1</code></td>
          <td>需要复制 <code>response</code> 的数目，默认为 <code>1</code>（不复制）</td>
      </tr>
      <tr>
          <td><code>Block: Seq[Boolean]</code></td>
          <td>指示每个 <code>requestor</code> 是否被阻塞</td>
      </tr>
      <tr>
          <td><code>q: TLBParameters</code></td>
          <td>TLB 使用的参数</td>
      </tr>
      <tr>
          <td><code>p: Parameter</code></td>
          <td>全局参数（香山架构参数）</td>
      </tr>
  </tbody>
</table>
<p>实例化 <code>TLB</code> 时以香山架构的 <code>itlb</code> 为例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">itlb</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">Module</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">TLB</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">coreParams</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">itlbPortNum</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">nRespDups</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">1</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">Seq</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">fill</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">PortNumber</span><span style="color:#ce5c00;font-weight:bold">)(</span><span style="color:#204a87;font-weight:bold">false</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">++</span> <span style="color:#000">Seq</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">true</span><span style="color:#ce5c00;font-weight:bold">),</span> <span style="color:#000">itlbParams</span><span style="color:#ce5c00;font-weight:bold">))</span>
</span></span></code></pre></div><ul>
<li>
<p><code>Width</code> 值为 <code>coreParams.itlbParams</code>（实际计算逻辑）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#000">itlbPortNum</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Int</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">ICacheParameters</span><span style="color:#ce5c00;font-weight:bold">().</span><span style="color:#000">PortNumber</span> <span style="color:#ce5c00;font-weight:bold">+</span> <span style="color:#0000cf;font-weight:bold">1</span>  <span style="color:#8f5902;font-style:italic">// Parameters.scala: line 276
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000">ICacheParameters</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">PortNumber</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Int</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">2</span>                 <span style="color:#8f5902;font-style:italic">// ICache.scala: line 43
</span></span></span></code></pre></div><p>最终 <code>Width = 3</code></p>
</li>
<li>
<p><code>Block</code> 参数说明：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#000">Seq</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">fill</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">PortNumber</span><span style="color:#ce5c00;font-weight:bold">)(</span><span style="color:#204a87;font-weight:bold">false</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">++</span> <span style="color:#000">Seq</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">true</span><span style="color:#ce5c00;font-weight:bold">)</span>  <span style="color:#8f5902;font-style:italic">// 前 2 端口不阻塞，第 3 端口阻塞
</span></span></span></code></pre></div><p>对应 <code>itlb</code> 的三个 <code>requestor</code>：<code>requestor0/1</code> 不阻塞，<code>requestor2</code> 阻塞。</p>
</li>
</ul>
<h2 id="vaddrbits">VAddrBits</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">VAddrBits</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">HasHExtension</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">EnableSv48</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000">coreParams</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">GPAddrBitsSv48x4</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000">coreParams</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">GPAddrBitsSv39x4</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">}</span> <span style="color:#204a87;font-weight:bold">else</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">EnableSv48</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000">coreParams</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">VAddrBitsSv48</span>
</span></span><span style="display:flex;"><span>        <span style="color:#204a87;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#000">coreParams</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">VAddrBitsSv39</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ce5c00;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span><span style="color:#ce5c00;font-weight:bold">}</span> <span style="color:#8f5902;font-style:italic">// Parameters.scala: line 596~608
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// 相关参数定义
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">HasHExtension</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">coreParams</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">HasHExtension</span>  <span style="color:#8f5902;font-style:italic">// Parameters.scala: line582
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000">coreParams</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">HasHExtension</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Boolean</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">true</span>      <span style="color:#8f5902;font-style:italic">// Parameters.scala: line66
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000">coreParams</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">EnableSv48</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Boolean</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">true</span>         <span style="color:#8f5902;font-style:italic">// Parameters.scala: line91
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic">// 地址位宽定义
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000">coreParams</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">VAddrBitsSv39</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Int</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">39</span>
</span></span><span style="display:flex;"><span><span style="color:#000">coreParams</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">GPAddrBitsSv39x4</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Int</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">41</span>
</span></span><span style="display:flex;"><span><span style="color:#000">coreParams</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">VAddrBitsSv48</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Int</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">48</span>
</span></span><span style="display:flex;"><span><span style="color:#000">coreParams</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">GPAddrBitsSv48x4</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Int</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">50</span>        <span style="color:#8f5902;font-style:italic">// Parameters.scala: line71~74
</span></span></span></code></pre></div><ul>
<li><strong>香山昆明湖架构下的值</strong>：<code>50</code></li>
<li><strong>地址处理逻辑</strong>：
<ul>
<li>主机地址转换时仅使用后 48 位（前两位忽略）</li>
<li>支持虚拟机时，物理地址扩展为 50 位（符合 <code>Sv48x4</code> 规范）</li>
</ul>
</li>
</ul>
<h2 id="asidlength">AsidLength</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">AsidLength</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#000">coreParams</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">AsidLength</span>  <span style="color:#8f5902;font-style:italic">// Parameters.scala: line 619
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000">AsidLength</span><span style="color:#204a87;font-weight:bold">:</span> <span style="color:#204a87;font-weight:bold">Int</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">16</span>                    <span style="color:#8f5902;font-style:italic">// Parameters.scala: line 79
</span></span></span></code></pre></div><ul>
<li><strong>ASID 位宽</strong>：16 位</li>
<li><strong>作用</strong>：标识地址空间，防止进程/虚拟机虚拟地址冲突</li>
<li><strong>支持规模</strong>：
<ul>
<li>最大 <code>65536</code> 个并发进程（16 位）</li>
<li>虚拟机通过 <code>vmid</code> 标识（14 位，支持 <code>16384</code> 个虚拟机，符合手册要求）</li>
</ul>
</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-281abdcb1782ae5b04b47c9045b8633a">12.2.4.4 - 环境配置</h1>
    
	<h2 id="wsl2ubuntu2204gtkwavewindows用户推荐使用">WSL2+Ubuntu22.04+GTKWave（Windows用户推荐使用）</h2>
<p>我们推荐 Windows10/11 用户通过 WSL2 进行开发，在此给出通过此方法进行环境配置的教程集锦，仅供参考。如环境安装过程中出现任何问题，欢迎在QQ群（群号：<b>976081653</b>）中提出，我们将尽力帮助解决。此页面将收集大家提出的所有环境配置相关问题并提供解决方案，欢迎随时向我们提问！</p>
<h3 id="1在-windows-下安装-wsl2ubuntu2204">1、在 Windows 下安装 WSL2（Ubuntu22.04）</h3>
<p>参考资源：</p>
<p>&mdash; 微软官方教程：<a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">如何使用 WSL 在 Windows 上安装 Linux</a></p>
<p>&mdash; 其它资源：<a href="https://blog.csdn.net/HHHBan/article/details/126843786">安装WSL2和Ubuntu22.04版本</a></p>
<h3 id="2打开-wsl换源">2、打开 WSL，换源</h3>
<p>推荐使用清华源：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源软件镜像站-Ubuntu软件仓库</a></p>
<h3 id="3配置验证环境">3、配置验证环境</h3>
<p>请参照<a href="https://open-verify.cc/mlvp/docs/quick-start/installer/">开放验证平台学习资源-快速开始-搭建验证环境</a>配置环境。</p>
<p>以下是示例方法：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 基本工具包</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87">cd</span> ~ <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> sudo apt-get update
</span></span><span style="display:flex;"><span>sudo apt-get install -y build-essential cmake git wget curl lcov autoconf flex bison libgoogle-perftools-dev gcc python3.11 python3.11-dev python3.11-distutils python3-pip python-is-python3
</span></span><span style="display:flex;"><span>rm -rf /var/lib/apt/lists/*
</span></span><span style="display:flex;"><span>sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.11 <span style="color:#0000cf;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>curl -sS https://bootstrap.pypa.io/get-pip.py <span style="color:#000;font-weight:bold">|</span> python3.11
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># verilator</span>
</span></span><span style="display:flex;"><span>git clone https://github.com/verilator/verilator.git
</span></span><span style="display:flex;"><span><span style="color:#204a87">cd</span> verilator
</span></span><span style="display:flex;"><span>git checkout v4.218 <span style="color:#8f5902;font-style:italic"># 4.218为最低需求版本，可自行查看并选择新版本</span>
</span></span><span style="display:flex;"><span>autoconf <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> ./configure <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> make -j<span style="color:#204a87;font-weight:bold">$(</span>nproc<span style="color:#204a87;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> make install
</span></span><span style="display:flex;"><span><span style="color:#204a87">cd</span> .. <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> rm -rf verilator
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># verible</span>
</span></span><span style="display:flex;"><span>curl -sS https://github.com/chipsalliance/verible/releases/download/v0.0-3946-g851d3ff4/verible-v0.0-3946-g851d3ff4-linux-static-x86_64.tar.gz -o /tmp/
</span></span><span style="display:flex;"><span>tar -zxvf /tmp/verible-v0.0-3946-g851d3ff4-linux-static-x86_64.tar.gz -C /tmp/
</span></span><span style="display:flex;"><span>copy /tmp/verible-v0.0-3946-g851d3ff4/bin/verible-* /usr/local/bin/
</span></span><span style="display:flex;"><span>sudo chmod +x /usr/local/bin/verible-*
</span></span><span style="display:flex;"><span>rm /tmp/verible-*
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># pcre2</span>
</span></span><span style="display:flex;"><span>curl -sS https://github.com/PCRE2Project/pcre2/releases/download/pcre2-10.45/pcre2-10.45.tar.gz -o /tmp/
</span></span><span style="display:flex;"><span>tar -zxvf /tmp/pcre2-10.45.tar.gz -C /tmp/
</span></span><span style="display:flex;"><span><span style="color:#204a87">cd</span> /tmp/pcre2-10.45
</span></span><span style="display:flex;"><span>./configure --prefix<span style="color:#ce5c00;font-weight:bold">=</span>/usr/local <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> make -j<span style="color:#204a87;font-weight:bold">$(</span>nproc<span style="color:#204a87;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> make install
</span></span><span style="display:flex;"><span>rm -rf /tmp/pcre2* <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#204a87">cd</span> ~
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># swig </span>
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 注意不要使用 apt install swig，将会下载不符合最低要求的版本 4.0.2</span>
</span></span><span style="display:flex;"><span>curl -sS http://prdownloads.sourceforge.net/swig/swig-4.3.0.tar.gz -o /tmp/
</span></span><span style="display:flex;"><span>tar -zxvf /tmp/swig-4.3.0.tar.gz -C /tmp/
</span></span><span style="display:flex;"><span><span style="color:#204a87">cd</span> /tmp/swig-4.3.0
</span></span><span style="display:flex;"><span>./configure --prefix<span style="color:#ce5c00;font-weight:bold">=</span>/usr/local <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> make -j<span style="color:#204a87;font-weight:bold">$(</span>nproc<span style="color:#204a87;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> make install
</span></span><span style="display:flex;"><span>rm -rf /tmp/swig* <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#204a87">cd</span> ~
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># 更新本地包</span>
</span></span><span style="display:flex;"><span>apt-get update <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> apt-get -y upgrade
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># picker</span>
</span></span><span style="display:flex;"><span>git clone https://github.com/XS-MLVP/picker.git --depth<span style="color:#ce5c00;font-weight:bold">=</span><span style="color:#0000cf;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87">cd</span> picker
</span></span><span style="display:flex;"><span>make init <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> make <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> make install
</span></span><span style="display:flex;"><span><span style="color:#204a87">cd</span> .. <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> rm -rf picker
</span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"># UnityChipForXiangShan</span>
</span></span><span style="display:flex;"><span>git clone https://github.com/XS-MLVP/UnityChipForXiangShan.git
</span></span><span style="display:flex;"><span><span style="color:#204a87">cd</span> UnityChipForXiangShan
</span></span><span style="display:flex;"><span>pip3 install --no-cache-dir -r requirements.txt
</span></span></code></pre></div><h3 id="4使用-gtkwave-查看波形文件">4、使用 GTKWave 查看波形文件</h3>
<p>使用<a href="https://co.ccslab.cn/tips/win-gtkwave/">重庆大学硬件综合设计实验文档-Windows原生GTKWave</a>给出的方法，可以通过在WSL中输入 <code>gtkwave.exe wave.fst</code> 打开在 Windows 下安装的 GTKWave。请注意，gtkwave在使用中需要进入 fst 文件所在文件夹，否则会出现无法
initialize 的情况。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gtkwave.exe /out/<span style="color:#ce5c00;font-weight:bold">{</span>test_name<span style="color:#ce5c00;font-weight:bold">}</span>.fst
</span></span></code></pre></div><h3 id="5使用-vscode-插件-live-server-查看验证报告">5、使用 VSCode 插件 Live Server 查看验证报告</h3>
<p>成功安装插件Live Server后，打开文件列表，定位到 <code>/out/report/2025*-itlb-doc-*/index.html</code> 右键并选择 <code>Open With Live Server</code>，之后在浏览器中打开提示的端口（默认为<code>//localhost:5500</code>）即可。</p>
<h2 id="docker一键部署方案mac用户可用">docker一键部署方案（MAC用户可用）</h2>
<p>我们提供了 MAC 可用的 docker 环境，已在 Docker Hub 发布，名称为 <code>unitychip-env</code>。安装 Docker Desktop 后在命令行使用以下命令即可获取并打开开发环境。需下载约 500MB 的镜像，展开后约占用 1GB 空间。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker search unitychip-env
</span></span><span style="display:flex;"><span>docker pull dingjunbi/unitychip-env <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> docker run unitychip-env
</span></span><span style="display:flex;"><span><span style="color:#204a87">cd</span> UnityChipForXiangShan <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> git pull
</span></span></code></pre></div><p><a href="https://docs.docker.com/docker-hub/">Docker Hub使用文档</a></p>
<p><a href="https://blog.csdn.net/sj349781478/article/details/105267887/">Docker：docker 拉取镜像及查看pull下来的image在哪里</a></p>

</div>



    
	
  

    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6031fdd6c9ad34a8373b09e559c59778">12.3 - Backend</h1>
    
	<p>后端模块验证文档</p>

</div>



    
      
  
  
  
  

  
  

  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-758903f793d925071c9e0df49f07dc3f">12.4 - Mem Block</h1>
    
	<p>访存模块验证文档</p>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-8e01ee1a953553bff1b3873e6247576f">12.4.1 - LSQ</h1>
    
	<p><strong>本文档参考<a href="https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ">香山LSQ设计文档</a>写成</strong></p>
<p>本文档撰写的内容截至[ca892e73]</p>
<p>请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！</p>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c714e6fc3c1c9ea3ab166d48ea03e3f6">12.4.1.1 - LoadQueueRAR</h1>
    
	<p><strong>本文档参考<a href="https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ">香山LSQ设计文档</a>写成</strong></p>
<p>本文档撰写的内容截至[ca892e73]</p>
<p>请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！</p>
<h1 id="loadqueuerar-简介">LoadQueueRAR 简介</h1>
<p>LoadQueueRAR用于保存已经完成的load指令的用于load to load违例检测的信息。</p>
<p>多核环境下会出现load to load违例。单核环境下相同地址的load乱序执行本来是不关心的，但是如果两个load之间有另外一个核做了相同地址的store，并且本身这个核的两个load做了乱序调度，就有可能导致新的load没有看到store更新的结果，但是旧的load看到了，出现了顺序错误。</p>
<p>多核环境下的load-load违例有一个特征，当前DCache一定会收到L2 cache发来的Probe请求，使得DCache主动释放掉这个数据副本，这时DCache会通知load queue，将相同地址的load queue中已经完成访存的项做一个release标记。后续发往流水线的load指令会查询load queue中在它之后相同地址的load指令，如果存在release标记，就发生了load-load违例。</p>
<h2 id="术语说明">术语说明</h2>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>L2Cache</td>
          <td>二级高速缓存</td>
      </tr>
      <tr>
          <td>DCache</td>
          <td>数据缓存</td>
      </tr>
      <tr>
          <td>ROB</td>
          <td>重排序缓冲区</td>
      </tr>
      <tr>
          <td>CAM</td>
          <td>内容可寻址存储器</td>
      </tr>
      <tr>
          <td>FTQ</td>
          <td>取指目标队列</td>
      </tr>
  </tbody>
</table>
<h2 id="ld-ld违例">ld-ld违例</h2>
<p>多核环境下，可能会出现load to load违例：在单核环境中，相同地址的load乱序执行通常不被关注，因为它们在同一核内执行，不会影响其他核的状态，也不会被其他核的操作影响。但是，当两个load操作之间有另一个核对相同地址进行了store操作，情况就变得复杂。</p>
<p>考虑以下指令序列：</p>
<pre tabindex="0"><code>load1（core1）
store（core2） 
load2（core1）
</code></pre><p>指令的实际执行顺序为：</p>
<pre tabindex="0"><code>load2（core1）
store（core2） 
load1（core1）
</code></pre><p>由于指令的乱序执行，可能导致以下情况：旧的 load1 指令在执行时读取到了 store 修改后的新数据，而新的 load2 指令却读取到了未被修改的旧数据。这种执行顺序的变化会导致数据的不一致性，进而引发访存错误。</p>
<p>因此，在多核环境中，正确处理指令的执行顺序和内存一致性是至关重要的，以确保所有核都能看到一致的内存状态。</p>
<h2 id="整体框图">整体框图</h2>
<div>			
    <center>	
    <img src="../LoadQueueRAR_structure.svg"
         alt="LoadQueueRAR结构示意图"
         style="zoom:100%"/>
    <br>
    图1：LoadQueueRAR结构示意图<br><br>
    </center>
</div>
<p>LoadQueueRAR最多能够存储72条指令（为了同VirtualLoadQueue的大小保持一致），每条指令占用一个条目。每个条目包含指令的物理地址（paddr）、与指令相关的信息（uop）、以及标记为已释放（released）和已分配（allocated）的状态寄存器。</p>
<p>该模块通过 FreeList 子模块管理 entry 资源，FreeList 中存储的是 entry 的编号。当一条指令满足入队条件时，FreeList 会为其分配一个 entry 编号，并将该指令存放在相应的 entry 中。指令出队时，需要释放所占用的 entry 资源，并将条目编号重新放回 FreeList 中，以供后续指令使用。</p>
<p>PaddrModule 的实现基于内容可寻址存储器（CAM），其深度为 72，数据宽度为 48。CAM 为每条流水线提供一个写端口，其中物理地址（paddr）作为写数据（wdata），条目编号作为写地址（waddr）。此外，CAM 还为每条流水线提供了一个地址查询端口（releaseViolationMdata），并为数据缓存（DCache）提供另一个地址查询端口（releaseMdata）。</p>
<mrs-functions>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="功能1发生ld-ld违例的指令请求入队">功能1：发生ld-ld违例的指令请求入队</h3>
<p>当query到达load流水线的s2时，判断是否满足入队条件，如果在当前load指令之前有未完成的load指令,且当前指令没有被flush时，当前load可以入队。</p>
<p>具体入队条件如下：</p>
<ol>
<li>
<p>指令的入队请求必须有效，具体通过检查 <code>query.req.valid</code> 是否等于 1。如果该条件满足，系统将继续处理指令的入队。</p>
</li>
<li>
<p>指令必须确认尚未写回到重排序缓冲区（ROB）。这一条件通过比较指令在 VirtualLoadQueue 中的写回指针与该指令分配的 <code>lqIdx</code> 来验证。指令只有在到达 VirtualLoadQueue 的队头，并且其地址和数据均已准备好后，才能被写回到 ROB。这一机制确保了指令执行的顺序性和数据的有效性。</p>
</li>
<li>
<p>指令不能处于冲刷状态。为此，系统需要比较重定向指针所指向的指令与该指令的 <code>robIdx</code>、<code>ftqidx</code>及 FTQ 内的偏移（<code>ftqoffset</code>）。如果两者不相同，则说明该指令可以安全入队，从而避免潜在的冲突和数据不一致性。</p>
</li>
</ol>
<p>在 LoadQueueRAR 指令成功入队后，系统会执行一系列响应操作，以确保指令被正确管理和处理。具体的入队响应操作如下：</p>
<ol>
<li>
<p>拉高 allocated 寄存器。系统将指令的 <code>allocated</code> 寄存器设置为高电平。这一操作的目的是明确标识该指令已成功分配到 LoadQueueRAR 中。通过将 <code>allocated</code> 寄存器拉高，后续的处理逻辑能够迅速识别出该指令的状态，从而避免对未分配指令的误操作。</p>
</li>
<li>
<p>写入指令相关信息到 uop。指令的相关信息将被写入到微操作（<code>uop</code>）中。这些信息包括指令的类型、目标寄存器、操作数等关键信息。将这些信息存储在 <code>uop</code> 中，确保后续的执行阶段能够准确获取和使用这些数据，从而执行相应的操作。这一过程对于指令的正确执行至关重要。</p>
</li>
<li>
<p>物理地址写入 PaddrModule。指令的物理地址将被写入到 PaddrModule 中。这一操作的主要目的是为后续的地址查询和管理提供支持。</p>
</li>
<li>
<p>检测 Release 的 Valid 信号。系统将检测 <code>release</code> 的有效信号是否被拉高。如果该信号有效，将进一步比较物理地址是否相同。如果物理地址一致，则对应条目的 <code>released</code> 信号将被设置为高电平，可以用于后续操作。</p>
</li>
</ol>
<h3 id="功能2检测ld-ld违例条件">功能2：检测ld-ld违例条件</h3>
<p>在 Load 指令的处理过程中，为了确保数据的一致性和正确性，系统需要检测潜在的 Load-Load 违例。当 load 到达流水线的 s2 时，会检查RAR队列中是否存在与当前load指令物理地址相同且比当前指令年轻的load指令，如果这些 load 已经拿到了数据，并且被标记了release，说明发生 load - load 违例，被标记release的指令需要从取指重发。 该检测过程主要涉及将查询指令的物理地址和相关信息与队列中存储的指令进行对比。具体流程如下：</p>
<ol>
<li>对比 ROB 索引。通过对比两条指令的robidx识别队列中是否存在比查询指令更年轻的指令。</li>
<li>物理地址匹配。检查这两条指令的物理地址是否相同。这一对比通过 <code>releaseViolationMmask(w)(i)</code> 来进行，以确定两条指令是否访问了相同的内存位置。</li>
<li>检查 Released 标记。如果该条指令的 <code>released</code> 寄存器被拉高，表明该指令已被标记为释放，说明它可以被重新使用。</li>
</ol>
<p>一旦检测到 Load-Load 违例，系统将在下一个时钟周期内将 <code>resp.rep_rm_fetch</code> 信号拉高，以通知其他组件发生了违例。触发 Load-Load 违例的 Load 指令将被标记为需要重新从取指阶段执行。重定向请求将在这些指令到达 ROB 队列的尾部时发出，确保指令能够在合适的时机得到正确的处理。</p>
<p>该过程分为两个时钟周期进行：</p>
<ul>
<li>第一拍进行条件匹配，对比物理地址和指令状态，得到mask。</li>
<li>第二拍生成是否发生违例的响应信号（<code>resp.rep_rm_fetch</code> ）。</li>
</ul>
<p>由于 Load-Load 违例出现的频率相对较低，因此系统会选择在指令到达 ROB 的头部时才进行处理。这种处理方式类似于异常处理，确保系统能够在合适的时机对潜在的违例情况进行响应。</p>
<h3 id="功能3released寄存器更新">功能3：released寄存器更新</h3>
<p>released寄存器需要更新的三种情况：</p>
<ol>
<li>missQueue模块的replace_req在mainpipe流水线的s3栈发起release释放dcache块，release信号在下一拍进入loadqueue。</li>
<li>probeQueue模块的probe_req在mainpipe流水线的s3栈发起release释放dcache块，release信号在下一拍进入loadqueue。</li>
<li>atomicsUnit模块的请求在mainpipe流水线的s3栈发生miss时需要释放dcache块，release信号在下一拍进入loadQueue。</li>
</ol>
<p>release信号的到达时机可以分为以下两种情况：</p>
<ol>
<li>指令入队时到达。如果查询指令传来的paddr的高42位信号与paddr的高位信号相同，并且该指令能够成功入队将对应entry的released寄存器信号拉高</li>
<li>指令入队后到达。如果paddrmodule中存放的paddr的高42位信号与paddr的高位信号相同,将对应的released寄存器信号拉高</li>
</ol>
<p>值得注意的是，dcache release 信号在更新 load queue 中 <code>released</code> 状态位时, 会与正常 load 流水线中的 load-load 违例检查争用 load paddr cam 端口. release 信号更新 load queue 有更高的优先级. 如果争用不到资源, 流水线中的 load 指令将立刻被从保留站重发.</p>
<h3 id="功能4指令的出队">功能4：指令的出队</h3>
<p>Load指令的出队需要满足以下条件其中之一：</p>
<ol>
<li>当比队列entry中存放的指令更老的指令已经全部写回到ROB时，该指令可以出队。</li>
<li>当这条指令需要被冲刷时，通常是出现数据依赖性问题、预测错误、异常或错误的情况下，迫使系统强制性地移除该指令，以保证处理器能够恢复到一个稳定的状态。</li>
</ol>
<p>出队执行的操作：</p>
<ol>
<li>将指令对应的 <code>allocated</code> 寄存器设置为低电平。这一操作的目的是标识该指令不再占用 LoadQueueRAR 的资源，从而为后续指令的入队和处理腾出空间。</li>
<li>将entry对应的<code>free</code>掩码拉高，表示该条目已被释放并可供后续使用。</li>
</ol>
<p>在load流水线的s3阶段可以向队列发送revoke信号撤销上一拍的请求。如果指令当前周期的revoke信号拉高（revoke ==1），并且在上一个周期已经入队，需要执行撤销操作：</p>
<ol>
<li>该entry对应的allocated寄存器清零</li>
<li>该entry对应的free掩码拉高</li>
</ol>
</mrs-functions>
<h2 id="接口说明">接口说明</h2>
<table>
  <thead>
      <tr>
          <th></th>
          <th>name</th>
          <th>I/O</th>
          <th>width</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>redirect</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>io.redirect.valid</td>
          <td>input</td>
          <td>1</td>
          <td>后端重定向的有效位</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>io.redirect.bits.robIdx.flag</td>
          <td>input</td>
          <td>1</td>
          <td>后端重定向的flag，用于在循环列表中判断先后</td>
      </tr>
      <tr>
          <td></td>
          <td>io.redirect.bits.robIdx.value</td>
          <td>input</td>
          <td>8</td>
          <td>后端重定向的位置value</td>
      </tr>
      <tr>
          <td></td>
          <td>io.redirect.bits.level</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>1</td>
          <td>后端重定向的level：</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>1’b0：冲刷之后的指令；</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>1‘b1：冲刷这条指令本身</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>vecFeedback</td>
          <td>io.vecFeedback_0/1.valid</td>
          <td>input</td>
          <td>1</td>
          <td>来自两条流水线的向量反馈信息有效位</td>
      </tr>
      <tr>
          <td></td>
          <td>io.vecFeedback_0/1.bits</td>
          <td>input</td>
          <td>17</td>
          <td>来自两条流水线的向量反馈信息</td>
      </tr>
      <tr>
          <td>query</td>
          <td>io.query_0/1/2.req.ready</td>
          <td>output</td>
          <td>1</td>
          <td>能否接收3条数据通路中load违例检查请求</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.req.valid</td>
          <td>input</td>
          <td>1</td>
          <td>3条数据通路中load违例检查有效位</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.req.bits.uop.robIdx.flag</td>
          <td>input</td>
          <td>1</td>
          <td>3条数据通路中load违例检查uop在rob中的flag</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.req.bits.uop.robIdx.value</td>
          <td>input</td>
          <td>8</td>
          <td>3条数据通路中load违例检查uop在rob中的value</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.req.bits.uop.lqIdx.flag</td>
          <td>input</td>
          <td>1</td>
          <td>3条数据通路中load违例检查uop在LoadQueue中的flag</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.req.bits.uop.lqIdx.value</td>
          <td>input</td>
          <td>7</td>
          <td>3条数据通路中load违例检查uop在LoadQueue中的value</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.req.bits.paddr</td>
          <td>input</td>
          <td>48</td>
          <td>3条数据通路中load违例检查的物理地址</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.req.bits.data.valid</td>
          <td>input</td>
          <td>1</td>
          <td>3条数据通路中load违例检查data的有效</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.resp.valid</td>
          <td>output</td>
          <td>1</td>
          <td>3条数据通路中load违例检查响应的有效位</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.resp.bits.rep.frm.fetch</td>
          <td>output</td>
          <td>1</td>
          <td>3条数据通路中load违例检查的响应</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.revoke</td>
          <td>input</td>
          <td>1</td>
          <td>3条数据通路中load违例检查的撤销</td>
      </tr>
      <tr>
          <td>release</td>
          <td>io.release.valid</td>
          <td>input</td>
          <td>1</td>
          <td>Dcache释放块有效位</td>
      </tr>
      <tr>
          <td></td>
          <td>io.release.bits.paddr</td>
          <td>input</td>
          <td>48</td>
          <td>Dcache释放块的物理地址</td>
      </tr>
      <tr>
          <td>ldwbptr</td>
          <td>io.ldWbPtr.flag</td>
          <td>input</td>
          <td>1</td>
          <td>VirtualLoadQueue中writeback的flag</td>
      </tr>
      <tr>
          <td></td>
          <td>io.ldWbPtr.value</td>
          <td>input</td>
          <td>7</td>
          <td>VirtualLoadQueue中writeback的位置value</td>
      </tr>
      <tr>
          <td>Lqfull</td>
          <td>io.lqFull</td>
          <td>output</td>
          <td>1</td>
          <td>表示loadqueue RAR满了</td>
      </tr>
      <tr>
          <td>performance</td>
          <td>io.perf_0/1_value</td>
          <td>output</td>
          <td>6</td>
          <td>性能计数器</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9a032f0cfdc8a7fe72dfec1c535356c4">12.4.1.2 - LoadQueueRAW</h1>
    
	<p><strong>本文档参考<a href="https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ">香山LSQ设计文档</a>写成</strong></p>
<p>本文档撰写的内容截至[ca892e73]</p>
<p>请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！</p>
<h1 id="loadqueueraw-简介">LoadQueueRAW 简介</h1>
<p>LoadQueueRAW是用于处理store-load违例的。由于load和store在流水线中都是乱序执行，会经常出现load越过了更老的相同地址的store，即这条load本应该前递store的数据，但是由于store地址或者数据没有准备好，导致这条load没有前递到store的数据就已经提交，后续使用这条load结果的指令也都发生了错误，于是产生store to load forwarding违例。</p>
<p>当store address通过STA保留站发射出来进入store流水线时，会去查询LQRAW中在这条store后面的所有已经完成访存的相同地址的load，以及load流水线中正在进行的在该条store之后的相同地址的load，一旦发现有，就发生了store to load forwarding违例，可能有多个load发生了违例，需要找到离store最近的load，也就是最老的违例的load，然后给RedirectGenerator部件发送重定向请求，冲刷最老的违例的load及之后的所有指令。</p>
<p>当store流水线执行cbo zero指令时，也需要进行store-load违例检查。</p>
<h2 id="st-ld违例">st-ld违例</h2>
<p>在现代处理器中，Load 和 Store 指令通常采用乱序执行的方式进行处理。这种执行策略旨在提高处理器的并行性和整体性能。然而，由于 Load 和 Store 指令在流水线中的乱序执行，常常会出现 Load 指令越过更早的相同地址的 Store 指令的情况。这意味着，Load 指令本应通过前递（forwarding）机制从 Store 指令获取数据，但由于 Store 指令的地址或数据尚未准备好，导致 Load 指令未能成功前递到 Store 的数据，而 Store 指令已被提交。由此，后续依赖于该 Load 指令结果的指令可能会出现错误，这就是 st-ld 违例。</p>
<p>考虑以下伪代码示例：</p>
<pre tabindex="0"><code>ST R1, 0(R2)  ; 将 R1 的值存储到 R2 指向的内存地址
LD R3, 0(R2)  ; 从 R2 指向的内存地址加载值到 R3
ADD R4, R3, R5 ; 使用 R3 的值进行计算
</code></pre><p>假设在这个过程中，Store 指令由于某种原因（如缓存未命中）未能及时完成，而 Load 指令已经执行并读取了旧的数据（例如，从内存中读取到的值为 <code>0</code>）。此时，Load 指令并未获得 Store 指令更新后的值，导致后续计算的数据错误。</p>
<p>通过上述例子，可以清楚地看到 Store-to-Load 违例如何在乱序执行的环境中导致数据一致性问题。这种问题强调了在指令调度和执行过程中，确保正确的数据流动的重要性。现代处理器通过多种机制来检测和解决这种违例，以维护程序的正确性和稳定性。</p>
<h2 id="整体框图">整体框图</h2>
<div>			
    <center>	
    <img src="../LoadQueueRAW_structure.svg"
         alt="LoadQueueRAW结构示意图"
         style="zoom:100%"/>
    <br>
    图1：LoadQueueRAW结构示意图<br><br>
    </center>
</div>
<p>LoadQueueRAW最多能够存储64条指令，通过FreeList子模块管理空闲资源。FreeList 中存储的是 entry 的编号。当一条指令满足入队条件时，FreeList 会为其分配一个 entry 编号，并将该指令存放在相应的 entry 中。指令出队时，需要释放所占用的 entry 资源，并将条目编号重新放回 FreeList 中，以供后续指令使用。Load指令在s2阶段在 LoadQueueRAR 中查询 store-to-load 违例，在s3阶段返回响应。</p>
<mrs-functions>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="功能1发生st-ld违例的指令请求入队">功能1：发生st-ld违例的指令请求入队</h3>
<p>当query到达load流水线的s2时，判断是否满足入队条件，如果在当前load指令之前有地址未准备好的store指令，且当前指令没有被flush时，当前load可以入队。具体流程如下：</p>
<ol>
<li>判断入队条件：检查在当前 Load 指令之前是否存在未准备好的 Store 指令。如果存在这样的 Store 指令，并且当前 Load 指令尚未被冲刷（flush），则当前 Load 指令可以入队。</li>
<li>分配 Entry 和 Index：在 Freelist 中，系统将获得一个可分配的 Entry 及其对应的 Index，以便为 Load 指令分配资源。</li>
<li>保存物理地址：在 PaddrModule 中将入队的 Load 指令的物理地址保存到对应的 Entry。这一操作确保在后续访问中能够正确引用该地址。</li>
<li>保存掩码信息：在 MaskModule 中，系统将入队的 Load 指令的掩码信息保存到对应的 Entry。掩码信息用于后续的地址匹配和数据访问。</li>
<li>写入uop：将 Load 指令的uop信息写入到相应的结构中，以完成入队过程。</li>
</ol>
<h3 id="功能2检测st-ld违例条件">功能2：检测st-ld违例条件</h3>
<p>在 Store 指令到达 Store 流水线的 s1 阶段时，系统会进行 Store-to-Load 违例检查。此时，Store 指令需要与 Load Queue 中已经完成访存的 Load 指令，以及在 Load 流水线 s1 和 s2 阶段正在访存的 Load 指令进行比较。这些 Load 指令可能尚未通过前递（forwarding）机制获取 Store 指令执行的结果。</p>
<p>具体的违例检查流程如下：</p>
<ol>
<li>物理地址匹配：在第一拍中，系统将进行物理地址匹配，并检查条件。此时，将匹配在当前 Store 指令之后的所有新的 Load 指令。如果这些 Load 指令已经成功获取了数据（<code>datavalid</code>），或者由于缓存未命中正在等待数据回填（<code>dcache miss</code>），则可以确定这些 Load 指令不会将数据前递给当前的 Store 指令。</li>
<li>匹配 Load 指令：在第二拍中，Store 流水线中的 Store 指令根据匹配结果中的掩码（mask），在 Load Queue 的 RAW（Read After Write）结构中查找所有匹配的 Load 指令。Load Queue 中共有 32 项，这些项将被平分为4组。每组从 8 项中选出一个最老的 Load 指令，最多可得到 4 个候选最老的 Load 指令。</li>
<li>选择最老的 Load：在第三拍中，从上述 4 个候选最老的 Load 指令中，系统将选出一个最老的 Load 指令，作为最终的目标。</li>
<li>处理违例情况：在第四拍中，如果在两条 Store 流水线中均发生了 Store-to-Load 违例，系统将从各自的 Queue 中匹配到的最老 Load 指令中选出一个更老的 Load 指令，以产生回滚请求并发送给重定向模块（Redirect）。此时，违例的条件包括：
<ul>
<li>Load 和 Store 的地址相同。</li>
<li>Load 指令比 Store 指令年轻。</li>
<li>Load 指令已经成功获取了数据。</li>
</ul>
</li>
</ol>
<h3 id="功能3指令的出队">功能3：指令的出队</h3>
<p>Load指令的出队需要满足以下条件其中之一：</p>
<ol>
<li>当比队列entry中存放的指令更老的指令已经全部写回到ROB时，该指令可以出队。</li>
<li>当这条指令需要被冲刷时，通常是出现数据依赖性问题、预测错误、异常或错误的情况下，迫使系统强制性地移除该指令，以保证处理器能够恢复到一个稳定的状态。</li>
</ol>
<p>出队执行的操作：</p>
<ol>
<li>将指令对应的 <code>allocated</code> 寄存器设置为低电平。这一操作的目的是标识该指令不再占用 LoadQueueRAR 的资源，从而为后续指令的入队和处理腾出空间。</li>
<li>将entry对应的<code>free</code>掩码拉高，表示该条目已被释放并可供后续使用。</li>
</ol>
<p>在load流水线的s3阶段可以向队列发送revoke信号撤销上一拍的请求。如果指令当前周期的revoke信号拉高（revoke ==1），并且在上一个周期已经入队，需要执行撤销操作：</p>
<ol>
<li>该entry对应的allocated寄存器清零</li>
<li>该entry对应的free掩码拉高</li>
</ol>
</mrs-functions>
<h2 id="接口说明">接口说明</h2>
<table>
  <thead>
      <tr>
          <th></th>
          <th>name</th>
          <th>I/O</th>
          <th>width</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>redirect</td>
          <td>io.redirect.valid</td>
          <td>input</td>
          <td>1</td>
          <td>后端重定向的有效位</td>
      </tr>
      <tr>
          <td></td>
          <td>io.redirect.bits.robIdx.flag</td>
          <td>input</td>
          <td>1</td>
          <td>后端重定向的flag，用于在循环列表中判断先后</td>
      </tr>
      <tr>
          <td></td>
          <td>io.redirect.bits.robIdx.value</td>
          <td>input</td>
          <td>8</td>
          <td>后端重定向的位置value</td>
      </tr>
      <tr>
          <td></td>
          <td>io.redirect.bits.level</td>
          <td>input</td>
          <td>1</td>
          <td>后端重定向的level：1’b0：冲刷之后的指令；1‘b1：冲刷这条指令本身</td>
      </tr>
      <tr>
          <td>vecFeedback</td>
          <td>io.vecFeedback_0/1.valid</td>
          <td>input</td>
          <td>1</td>
          <td>来自两条流水线的向量反馈信息有效位</td>
      </tr>
      <tr>
          <td></td>
          <td>io.vecFeedback_0/1.bits</td>
          <td>input</td>
          <td>17</td>
          <td>来自两条流水线的向量反馈信息</td>
      </tr>
      <tr>
          <td>query</td>
          <td>io.query_0/1/2.req.ready</td>
          <td>output</td>
          <td>1</td>
          <td>能否接收3条数据通路中load违例检查请求</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.req.valid</td>
          <td>input</td>
          <td>1</td>
          <td>3条数据通路中load违例检查有效位</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.req.bits.uop.robIdx.flag</td>
          <td>input</td>
          <td>1</td>
          <td>3条数据通路中load违例检查uop在rob中的flag</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.req.bits.uop.robIdx.value</td>
          <td>input</td>
          <td>8</td>
          <td>3条数据通路中load违例检查uop在rob中的value</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.req.bits.uop.lqIdx.flag</td>
          <td>input</td>
          <td>1</td>
          <td>3条数据通路中load违例检查uop在LoadQueue中的flag</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.req.bits.uop.lqIdx.value</td>
          <td>input</td>
          <td>7</td>
          <td>3条数据通路中load违例检查uop在LoadQueue中的value</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.req.bits.paddr</td>
          <td>input</td>
          <td>48</td>
          <td>3条数据通路中load违例检查的物理地址</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.req.bits.data.valid</td>
          <td>input</td>
          <td>1</td>
          <td>3条数据通路中load违例检查data的有效</td>
      </tr>
      <tr>
          <td></td>
          <td>io.query_0/1/2.revoke</td>
          <td>input</td>
          <td>1</td>
          <td>3条数据通路中load违例检查的撤销</td>
      </tr>
      <tr>
          <td>storeIn</td>
          <td>storeIn_0/1.bits</td>
          <td>input</td>
          <td>84</td>
          <td>两条store流水线store指令相关信息</td>
      </tr>
      <tr>
          <td></td>
          <td>storeIn_0/1.valid</td>
          <td>input</td>
          <td>1</td>
          <td>两条store流水线store指令相关信息有效位</td>
      </tr>
      <tr>
          <td>rollback</td>
          <td>rollback_0/1.valid</td>
          <td>output</td>
          <td>1</td>
          <td>两条store流水线回滚信息的有效性</td>
      </tr>
      <tr>
          <td></td>
          <td>rollback_0/1.bits</td>
          <td>output</td>
          <td>31</td>
          <td>两条store流水线回滚信息</td>
      </tr>
      <tr>
          <td>stAddrReadySqPtr</td>
          <td>stAddrReadySqPtr</td>
          <td>input</td>
          <td>7</td>
          <td>指向 store 队列中已准备好的地址条目</td>
      </tr>
      <tr>
          <td>stIssuePtr</td>
          <td>stIssuePtr</td>
          <td>input</td>
          <td>7</td>
          <td>指向 store 队列中准备发射执行的指令条目</td>
      </tr>
      <tr>
          <td>lqFull</td>
          <td>lqFull</td>
          <td>output</td>
          <td>1</td>
          <td>判断队列是否满</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-35dc1dc6afba5e734160023fd9acf073">12.4.1.3 - LoadQueueReplay</h1>
    
	<p><strong>本文档参考<a href="https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ">香山LSQ设计文档</a>写成</strong></p>
<p>本文档撰写的内容截至[ca892e73]</p>
<p>请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！</p>
<h1 id="loadqueuereplay-简介">LoadQueueReplay 简介</h1>
<p>LoadQueueReplay 模块是现代处理器架构中用于处理 Load 指令重发的重要组成部分。它负责管理因各种原因而需要重发的 Load 指令，确保指令执行的正确性和高效性。</p>
<h2 id="整体框图">整体框图</h2>
<div>			
    <center>	
    <img src="../LoadQueueReplay_structure.png"
         alt="LoadQueueReplay结构示意图"
         style="zoom:100%"/>
    <br>
    图1：LoadQueueReplay结构示意图<br><br>
    </center>
</div>
<p>LoadQueueReplay 最多存放72条指令，涉及多个状态和存储的信息。其关键组成部分如下：</p>
<ul>
<li><strong>Allocated</strong>：
<ul>
<li>表示某个 Load 重发队列项是否已经被分配，反映该项的有效性。</li>
</ul>
</li>
<li><strong>Scheduled</strong>：
<ul>
<li>指示某个 Load 重发队列项是否已被调度，意味着该项已经被选出，并将被发送至 Load Unit 进行重发。</li>
</ul>
</li>
<li><strong>Uop</strong>：
<ul>
<li>该队列项对应的 Load 指令执行信息，包括微操作（uop）。</li>
</ul>
</li>
<li><strong>Cause</strong>：指示该 Load 指令重发的原因，主要包括以下几种情况：
<ul>
<li><strong>C_MA</strong>：存储-加载（st-ld）违反重新执行。</li>
<li><strong>C_TM</strong>：TLB（翻译后备页表）缺失。</li>
<li><strong>C_FF</strong>：存储-加载转发。</li>
<li><strong>C_DR</strong>：数据缓存（dcache）需要重发。</li>
<li><strong>C_DM</strong>：数据缓存缺失。</li>
<li><strong>C_WF</strong>：路径预测失败。</li>
<li><strong>C_BC</strong>：数据缓存路径冲突。</li>
<li><strong>C_RAR</strong>：读取-读取（RAR）队列无法接收。</li>
<li><strong>C_RAW</strong>：读取-写入（RAW）队列无法接收。</li>
<li><strong>C_NK</strong>：存储-加载违反。</li>
</ul>
</li>
<li><strong>Blocking</strong>：指示该 Load 指令因等待条件而被阻塞，不能被调度重发。阻塞的原因和解除阻塞的条件包括：
<ul>
<li><strong>C_MA</strong>：存储指令的地址就绪。</li>
<li><strong>C_TM</strong>：TLB 回填完毕，并发送 Hint 信号。</li>
<li><strong>C_FF</strong>：存储指令的数据就绪。</li>
<li><strong>C_DM</strong>：数据缓存回填完毕。</li>
<li><strong>C_RAR</strong>：RAR 队列未满，且 Load 指令比 Load Queue 的写回项更老。</li>
<li><strong>C_RAW</strong>：RAW 队列未满，且 Load 指令比 Store Queue 中所有地址准备好的项都更老。</li>
</ul>
</li>
</ul>
<p>LoadReplayQueue 通过 FreeList 管理队列的空闲状态。FreeList 的大小等于 LoadReplayQueue 的项数，分配宽度为3（Load Unit 的数量），释放宽度为 4。同时，Free List 可以反馈 Load Replay Queue 的空余项数量以及是否已满的信息。除了FreeList，LoadQueueReplay还包含两个子模块：AgeDetector 和 LqVAddrModule，其中 AgeDetector 用于寻找一系列load replay queue项中最早入队的一项。</p>
<p>例如昆明湖V1的Load宽度为2，则会将load replay queue分为两半，从偶数项和奇数项中分别挑选一项最老的进行重发。LqVAddrModule 用于保存load replay queue项数个虚拟地址，读口和写口的数量均为Load的宽度（LoadUnit的数量）。</p>
<h2 id="loadqueuereplay-存储信息">LoadQueueReplay 存储信息</h2>
<table>
  <thead>
      <tr>
          <th>Field</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>allocated</td>
          <td>是否已经被分配，也代表是否该项是否有效。</td>
      </tr>
      <tr>
          <td>scheduled</td>
          <td>是否已经被调度，代表该项已经被选出，已经或即将被发送至LoadUnit进行重发。</td>
      </tr>
      <tr>
          <td>uop</td>
          <td>load指令执行包括的uop信息。</td>
      </tr>
      <tr>
          <td>vecReplay</td>
          <td>向量load指令相关信息。</td>
      </tr>
      <tr>
          <td>vaddrModule</td>
          <td>Load指令的虚拟地址。</td>
      </tr>
      <tr>
          <td>cause</td>
          <td>某load replay queue项对应load指令重发的原因，包括：<br>- C_MA(位0): store-load预测违例<br>- C_TM(位1): tlb miss<br>- C_FF(位2): store-to-load-forwarding store数据为准备好，导致失败<br>- C_DR(位3): 出现DCache miss，但是无法分配MSHR<br>- C_DM(位4): 出现DCache miss<br>- C_WF(位5): 路预测器预测错误<br>- C_BC(位6): Bank冲突<br>- C_RAR(位7): LoadQueueRAR没有空间接受指令<br>- C_RAR(位8): LoadQueueRAW没有空间接受指令<br>- C_NK(位9): LoadUnit监测到store-to-load-forwarding违例<br>- C_MF(位10): LoadMisalignBuffer没用空间接受指令</td>
      </tr>
      <tr>
          <td>blocking</td>
          <td>Load指令正在被阻塞。</td>
      </tr>
      <tr>
          <td>strict</td>
          <td>访存依赖预测器判断指令是否需要等待它之前的所有store指令执行完毕进入调度阶段。</td>
      </tr>
      <tr>
          <td>blockSqIdx</td>
          <td>与load指令有相关性的store指令的StoreQueue Index。</td>
      </tr>
      <tr>
          <td>missMSHRId</td>
          <td>load指令的dcache miss请求接受ID。</td>
      </tr>
      <tr>
          <td>tlbHintId</td>
          <td>load指令的tlb miss请求接受ID。</td>
      </tr>
      <tr>
          <td>replacementUpdated</td>
          <td>DCache的替换算法是否已经更新。</td>
      </tr>
      <tr>
          <td>replayCarry</td>
          <td>DCache的路预测器预测信息。</td>
      </tr>
      <tr>
          <td>missDbUpdated</td>
          <td>ChiselDB中Miss相关情况更新。</td>
      </tr>
      <tr>
          <td>dataInLastBeatReg</td>
          <td>Load指令需要的数据在两笔回填请求的最后一笔。</td>
      </tr>
  </tbody>
</table>
<h1 id="功能简介">功能简介</h1>
<mrs-functions>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="功能1需要重发的指令请求入队">功能1：需要重发的指令请求入队</h3>
<p>根据是否满足以下条件以及freelist是否可以分配的空闲槽位决定能否直接入队：</p>
<ol>
<li><code>enq_X.valid</code> 信号有效。</li>
<li>即将入队的项不需要重定向。</li>
<li>该项被标记为需要重发(<code>enq.bits.rep_info.need_rep</code>)。</li>
<li>没有异常。在入队时，必须确保没有异常发生。如果当前指令处于异常状态，入队操作应被禁止，以防止无效指令的执行。</li>
</ol>
<h3 id="功能2指令重发解锁">功能2：指令重发解锁</h3>
<p>LoadQueueReplay 中的指令出队分三拍：</p>
<p>在重发过程中，根据重发的原因和当前条件解锁相应项。在不满足解锁条件时，将会被阻塞，无法参与重发仲裁。其中C_BC（Dcache 块冲突）、C_NK（oad_unit 在 S1、S2 阶段发生 store-load 违例）、C_DR（Dcache miss 且 MSHR 满）、C_WF（路径预测失败）<strong>无需条件即可立即重发</strong>。</p>
<p>其他重发原因和对应的解锁条件如下：</p>
<ol>
<li>C_MA（store_load 预测违例）：已经被分配入队并且store准备好了相应的地址，具体如下：
<ol>
<li>store unit 的地址信号有效，且 <code>sqIdx</code> 与被阻塞的 <code>Idx</code> 相同，store 地址未发生 TLB miss。</li>
<li>被阻塞的 <code>SeqIdx</code> 在 store_queue 发送的 <code>stAddrReadySqPtr</code> 之前。</li>
<li>非严格阻塞，且阻塞的 <code>SeqIdx</code> 在 <code>stAddrReadyVec</code> 的向量组内。</li>
<li>store queue 为空，无未处理项。</li>
</ol>
</li>
<li>C_TM（TLB Miss）：resp信号有效，并且输入的id号等于Tlb Hint的id号，或者replay_all信号有效。</li>
<li>C_FF（store_load 数据前递失败）：因为数据前递失败导致指令重发的释放条件有下面四条：
<ol>
<li>store unit 的数据信号有效，且 <code>sqIdx</code> 与被阻塞的 <code>Idx</code> 相同。</li>
<li>被阻塞的 <code>SqIdx</code> 在 store_queue 发送的 <code>stDataReadySqPtr</code> 之前。</li>
<li>阻塞的 <code>SeqIdx</code> 在 <code>stDataReadyVec</code> 的向量组内。</li>
<li>store queue 为空，无未处理项。</li>
</ol>
</li>
<li>C_DM（Dcache Miss）：Dcache 的信号有效，且 <code>tl_d_channel.mshrid</code> 与阻塞的 <code>missMSHRId</code> 相同。</li>
<li>C_RAR（RAR queue 没有回应）：RAR 未满，或 <code>lqIdx</code> 在 <code>ldWbPtr</code> 之前。</li>
<li>C_RAW（RAW 没有回应）：RAW 未满，或 <code>lqIdx</code> 在 <code>stAddrReadySqPtr</code> 之前。</li>
</ol>
<h3 id="功能3指令重发优先级">功能3：指令重发优先级</h3>
<p>LoadQueueReplay有3种选择调度方式：</p>
<ol>
<li>
<p>根据入队年龄</p>
<p>LoadQueueReplay使用3个年龄矩阵(每一个Bank对应一个年龄矩阵)，来记录入队的时间。年龄矩阵会从已经准备好可以重发的指令中，选择一个入队时间最长的指令调度重发。</p>
</li>
<li>
<p>根据Load指令的年龄</p>
<p>LoadQueuReplay可以根据LqPtr判断靠近最老的load指令重发，判断宽度为OldestSelectStride=4。</p>
</li>
<li>
<p>DCache数据相关的load指令优先调度</p>
<ul>
<li>
<p>LoadQueueReply首先调度因L2 Hint调度的重发（当dcache miss后，需要继续查询下级缓存L2 Cache。在L2 Cache回填前的2或3拍，L2 Cache会提前给LoadQueueReplay唤醒信号，称为L2 Hint）当收到L2 Hint后，LoadQueueReplay可以更早地唤醒这条因dcache miss而阻塞的Load指令进行重发。</p>
</li>
<li>
<p>如果不存在L2 Hint情况，会将其余Load Replay的原因分为高优先级和低优先级。高优先级包括因dcache缺失或st-ld forward导致的重发，而将其他原因归纳为低优先级。如果能够从LoadQueueReplay中找出一条满足重发条件的Load指令（有效、未被调度、且不被阻塞等待唤醒），则选择该Load指令重发，否则按照入队顺序，通过AgeDetector模块寻找一系列load replay queue项中最早入队的一项进行重发。</p>
</li>
</ul>
</li>
</ol>
<h3 id="功能4指令重发逻辑">功能4：指令重发逻辑</h3>
<ol>
<li>
<p>Load_unit s3过来的请求根据enq.bits.isLoadReplay判断是否是已经从replay_queue出队的序列，如果是已经出队的序列，根据是否needReplay和有异常做下一步的判断，如果有异常或者不需要重发则释放这个槽位，并从agedetector里面把该项出队，如果需要重发则将这个项对应的scheduled位置为false来参与后续的出队仲裁竞争。</p>
</li>
<li>
<p>从freelist中选出发给load unit的有效项，项数为load unit的宽度（即有几条load unit的流水线），根据优先级来进行出队。</p>
</li>
<li>
<p>第0拍将数据传递给第1拍由s0_can_go控制，当s0_can_go为1时才能将0拍得到的数据发给第一拍，s0_can_go有效的条件是s0被重定向或者s1_can_go为1。</p>
</li>
<li>
<p>第一拍从vaddr内部取出需要的虚拟地址，发给下一拍流水线。 ColdCouter的值在0到12之间，上一拍没有被阻塞并且整个过程没有发生重定向的时候，向load unit发送请求。</p>
</li>
<li>
<p>发送给下一拍流水线的数据受s1_can_go控制，s1_can_go为1的条件是:</p>
</li>
</ol>
<ul>
<li>
<p>ColdCouter的值在0到12之间 且 上一拍完成操作(未被阻塞)或者不需要发送数据两者之一。</p>
</li>
<li>
<p>发生数据的重定向。</p>
</li>
</ul>
<ol start="6">
<li>第二拍将收到第一拍的数据发送给对应的load unit,获取仲裁权限，完成重发指令的任务。</li>
</ol>
</mrs-functions>
<h2 id="接口说明">接口说明</h2>
<table>
  <thead>
      <tr>
          <th>name</th>
          <th>I/O</th>
          <th>description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>redirect</td>
          <td>input</td>
          <td>后端重定向相关信息</td>
      </tr>
      <tr>
          <td>vecFeedback</td>
          <td>input</td>
          <td>来自两条流水线的向量反馈信息</td>
      </tr>
      <tr>
          <td>enq</td>
          <td>input</td>
          <td>表示外部模块希望将 load 指令传递给当前模块，来自 load 指令流水线的 s3 级</td>
      </tr>
      <tr>
          <td>storeAddrIn</td>
          <td>input</td>
          <td>在一个时钟周期内接收多条 store 指令的地址信息，用于判断指令存储的地址是否已经准备好</td>
      </tr>
      <tr>
          <td>storeDataIn</td>
          <td>input</td>
          <td>在一个时钟周期内接收多条 store 指令的数据信息，用于判断指令存储的数据是否已准备好</td>
      </tr>
      <tr>
          <td>replay</td>
          <td>output</td>
          <td>用于处理 load 指令的重发请求，每个元素对应一个重发接口</td>
      </tr>
      <tr>
          <td>tl_d_channel</td>
          <td>input</td>
          <td>用于接收来自数据缓存（Dcache）的信息，在处理 load 指令时会使用该端口进行数据转发</td>
      </tr>
      <tr>
          <td>stAddrReadySqPtr</td>
          <td>input</td>
          <td>指向当前准备好地址的 store 指令</td>
      </tr>
      <tr>
          <td>stAddrReadyVec</td>
          <td>input</td>
          <td>向量中对应 store 指令的地址是否已经准备好</td>
      </tr>
      <tr>
          <td>stDataReadySqPtr</td>
          <td>input</td>
          <td>指向当前准备好数据的 store 指令</td>
      </tr>
      <tr>
          <td>stDataReadyVec</td>
          <td>input</td>
          <td>向量中对应 store 指令的数据是否已经准备好</td>
      </tr>
      <tr>
          <td>sqEmpty</td>
          <td>input</td>
          <td>当前 store 队列是否为空</td>
      </tr>
      <tr>
          <td>lqFull</td>
          <td>output</td>
          <td>当前 load 队列是否已满</td>
      </tr>
      <tr>
          <td>ldWbPtr</td>
          <td>input</td>
          <td>指向当前写回的load指令</td>
      </tr>
      <tr>
          <td>rarFull</td>
          <td>input</td>
          <td>rar 队列是否已满</td>
      </tr>
      <tr>
          <td>rawFull</td>
          <td>input</td>
          <td>raw 队列是否已满</td>
      </tr>
      <tr>
          <td>l2_hint</td>
          <td>input</td>
          <td>当 dcache miss 后，需要继续查询下级缓存 L2 Cache。在 L2 Cache 回填前的 2 或 3 拍，L2 Cache 会提前给 LoadQueueReplay 唤醒信号，称为 L2 Hint</td>
      </tr>
      <tr>
          <td>tlb_hint</td>
          <td>input</td>
          <td>作用类似于 l2_hint，接收当前的 TLB 提示信息</td>
      </tr>
      <tr>
          <td>tlbReplayDelayCycleCtrl</td>
          <td>input</td>
          <td>控制 TLB 重发的延迟周期</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-17df67412d57fff58f56428e76c07bdb">12.4.1.4 - LoadQueueUncache</h1>
    
	<p><strong>本文档参考<a href="https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ">香山LSQ设计文档</a>写成</strong></p>
<p>本文档撰写的内容截至[66e9b546]</p>
<p>请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！</p>
<h1 id="loadqueueuncache-简介">LoadQueueUncache 简介</h1>
<p>LoadQueueUncache 和 Uncache 模块，对于 uncache load 访问请求来说，起到一个从 LoadUnit 流水线到总线访问的中间站作用。其中 Uncache 模块，作为靠近总线的一方，主要用于处理 uncache 访问到总线的请求和响应。LoadQueueUncache 作为靠近流水线的一方，需要承担以下责任：</p>
<ol>
<li>
<p>接收 LoadUnit 流水线传过来的 uncache load 请求。</p>
</li>
<li>
<p>选择已准备好 uncache 访问的 uncache load 请求 发送到 Uncache Buffer。</p>
</li>
<li>
<p>接收来自 Uncache Buffer 的处理完的 uncache load 请求。</p>
</li>
<li>
<p>将处理完的 uncache load 请求 返回给 LoadUnit。</p>
</li>
</ol>
<p>LoadQueueUncache 结构上，目前有 4 项（项数可配）UncacheEntry，每一项独立负责一个请求并利用一组状态寄存器控制其具体处理流程；有一个 FreeList，管理各项分配和回收的情况。而 LoadQueueUncache 主要是协同 4 项的新项分配、请求选择、响应分派、出队等统筹逻辑。</p>
<h2 id="整体框图">整体框图</h2>
<div>			
    <center>	
    <img src="../LoadQueueUncache_structure.svg"
         alt="LoadQueueUncache结构示意图"
         style="zoom:100%"/>
    <br>
    图1：LoadQueueUncache结构示意图
    </center>
</div>
<p>UnCacheBuffer 最多存放4条指令，除了 FreeList 之外，另一个重要的子模块是 UncacheEntry，管理每个Uncahce请求，负责发起Uncache，写回Uncache数据。每个Entry内维护一个用于发起Uncache请求的状态机，状态机的状态转换图如下：</p>
<div>			
    <center>	
    <img src="../UncacheEntry.png"
         alt="UncacheEntry结构示意图"
         style="zoom:100%"/>
    <br>
    图2：UncacheEntry状态转换图
    </center>
</div>
<ul>
<li>
<p>s_idl:该项还未发起一个MMIO请求。</p>
</li>
<li>
<p>s_req:向uncache模块发起MMIO请求，等待请求被接收。</p>
</li>
<li>
<p>s_resp:等待uncache模块的MMIO响应。</p>
</li>
<li>
<p>s_wait:等待将MMIO结果写回流水线。</p>
</li>
</ul>
<h1 id="功能简介">功能简介</h1>
<mrs-functions>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="功能1uncache指令请求入队">功能1：Uncache指令请求入队</h3>
<p>LoadQueueUncache 负责接收来自 LoadUnit 0、1、2 三个模块的请求，这些请求可以是 MMIO 请求，也可以是 NC 请求。</p>
<ol>
<li>
<p>首先，系统会根据请求的 robIdx 按照时间顺序（从最老到最新）对请求进行排序，以确保最早的请求能优先分配到空闲项，避免特殊情况下因老项回滚（rollback）而导致死锁。</p>
</li>
<li>
<p>进入入队处理的条件是：请求没有重发、没有异常，并且系统会根据 FreeList 中可分配的空闲项依次为请求分配项。</p>
</li>
<li>
<p>当 LoadQueueUncache 达到容量上限，且仍有请求未分配到项时，系统会从这些未分配的请求中选择最早的请求进行 rollback。</p>
</li>
</ol>
<p>UncacheBuffer 的入队分为 s1 和 s2 两个阶段：</p>
<p>s1：</p>
<ul>
<li>
<p><strong>请求收集</strong>：通过 <code>io.req.map(_.bits)</code> 收集所有请求的内容，形成 <code>s1_req</code> 向量。</p>
</li>
<li>
<p><strong>有效性标记</strong>：通过 <code>io.req.map(_.valid)</code> 收集所有请求的有效性，形成 <code>s1_valid</code> 向量。</p>
</li>
</ul>
<p>s2：</p>
<p>执行入队操作，主要分为以下几步：</p>
<ul>
<li>
<p>使用 <code>RegEnable</code> 将 <strong>s1</strong> 阶段的请求 <code>s1_req</code> 注册到 <code>s2_req</code>，确保在请求有效时保持其状态。</p>
</li>
<li>
<p>通过以下条件生成<code>s2_valid</code>向量，判断每个请求是否有效：</p>
<ol>
<li>
<p><code>RegNext(s1_valid(i))</code>：确保请求在 <strong>s1</strong> 阶段有效。</p>
</li>
<li>
<p><code>!s2_req(i).uop.robIdx.needFlush(RegNext(io.redirect))</code>：确保请求的 ROB 索引不需要因重定向而被刷新。</p>
</li>
<li>
<p><code>!s2_req(i).uop.robIdx.needFlush(io.redirect)</code>：确保请求的 ROB 索引不需要因当前重定向而被刷新。</p>
</li>
</ol>
</li>
<li>
<p>检查每个请求是否需要重发，结果存储在 <code>s2_need_replay</code> 向量中。</p>
</li>
<li>
<p>在 <strong>s2</strong> 阶段，使用 <code>s2_enqueue</code> 向量来决定哪些请求成功入队。入队条件包括：</p>
<ul>
<li>
<p><code>s2_valid(w)</code>：请求在 <strong>s2</strong> 阶段有效。</p>
</li>
<li>
<p><code>!s2_has_exception(w)</code>：请求没有异常。</p>
</li>
<li>
<p><code>!s2_need_replay(w)</code>：请求不需要重发。</p>
</li>
<li>
<p><code>s2_req(w).mmio</code>：请求是一个内存映射 IO（MMIO）请求。</p>
</li>
</ul>
</li>
<li>
<p>通过 <code>enqValidVec</code> 和 <code>enqIndexVec</code> 的有效管理，确保每个加载请求在满足有效性和可分配条件时能够正确地申请和分配FreeList槽位。</p>
</li>
</ul>
<h3 id="功能2uncache指令的出队">功能2：Uncache指令的出队</h3>
<ol>
<li>
<p>当一个项完成 Uncache 访问操作并返回给 LoadUnit ，或被 redirect 刷新时，则该项出队并释放 FreeList 中该项的标志。</p>
<p>具体流程如下：</p>
<ul>
<li>
<p>计算<code>freeMaskVec</code>掩码，用于标记每个槽位的释放状态，指示相应槽位是否可用。</p>
</li>
<li>
<p>如果当前条目被选择 (<code>e.io.select</code>) 且其输出信号有效 (<code>e.io.ldout.fire</code>)，则对应槽位的释放状态被标记为 <code>true</code>，表示该槽位可用。</p>
</li>
<li>
<p>如果接收到刷新信号 (<code>e.io.flush</code>)，同样将对应槽位的释放状态设置为 <code>true</code>。</p>
</li>
</ul>
</li>
<li>
<p>同一拍可能有多个项出队。返回给 LoadUnit 的请求，会在第一拍中选出，第二拍返回。</p>
</li>
<li>
<p>其中，可供处理 uncache 返回请求的 LoadUnit 端口是预先设定的。当前，MMIO 只返回到 LoadUnit 2；NC 可返回到 LoadUnit 1\2。在多个端口返回的情况下，利用 uncache entry id 与端口数的余数，来指定每个项可以返回到的 LoadUnit 端口，并从该端口的候选项中选择一个项进行返回。</p>
</li>
</ol>
<h3 id="功能3uncache交互逻辑">功能3：Uncache交互逻辑</h3>
<ol>
<li>发送 req</li>
</ol>
<p>第一拍先从当前已准备好 uncache 访问中选择一个，第二拍将其发送给 Uncache Buffer。发送的请求中，会标记选中项的 id，称为 mid 。其中是否被成功接收，可根据 req.ready 判断。</p>
<ol start="2">
<li>接收 idResp</li>
</ol>
<p>如果发送的请求被 Uncache Buffer 接收，那么会在接收的下一拍收到 Uncache 的 idResp。该响应中，包含 mid 和 Uncache Buffer 为该请求分配 entry id（称为 sid）。LoadQueueUncache 利用 mid 找到内部对应的项，并将 sid 存储在该项中。</p>
<ol start="3">
<li>接收 resp</li>
</ol>
<p>待 Uncache Buffer 完成该请求的总线访问后，会将访问结果返回给 LoadQueueUncache。该响应中，包含 sid。考虑到 Uncache Buffer 的合并特性（详细入队合并逻辑见 Uncache），一个 sid 可能对应 LoadQueueUncache 的多个项。LoadQueueUncache 利用 sid 找到内部所有相关项，并将访问结果传递给这些项。</p>
<h3 id="功能4uncache回滚检测">功能4：Uncache回滚检测</h3>
<p>freelist 没有空闲表现导致 MMIO Load 进入 UncacheBuffer 失败时需要进行 rollback，此
时需要根据 robidx 选择不能入队的 MMIO 中最老的指令进行 rollback。整个流程分为以下几个周期：</p>
<ul>
<li>
<p>Cycle 0：进行 uncache 请求入队。</p>
</li>
<li>
<p>Cycle 1：选择最旧的 uncache 加载请求。</p>
</li>
<li>
<p>Cycle 2：发出重定向请求。</p>
<ul>
<li>
<p>从 load 流水线中选择最旧的 load 请求。</p>
</li>
<li>
<p>根据检测到的拒绝情况准备重定向请求。</p>
</li>
<li>
<p>如果重定向请求有效，则发出请求。</p>
</li>
</ul>
</li>
</ul>
<p>使用 <code>selectOldestRedirect</code> 函数来选择最旧的重定向请求，具体步骤如下：</p>
<ul>
<li>
<p>比较向量生成：</p>
<ul>
<li>创建一个比较向量 <code>compareVec</code>，用于判断请求的顺序，比较每个请求的 ROB 索引。</li>
</ul>
</li>
<li>
<p>生成独热编码结果：</p>
<ul>
<li><code>resultOnehot</code> 向量根据有效性和比较结果生成，标记出最旧的可重定向请求。</li>
</ul>
</li>
</ul>
</mrs-functions>
<h2 id="接口说明">接口说明</h2>
<table>
  <thead>
      <tr>
          <th>name</th>
          <th>I/O</th>
          <th>description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>redirect</td>
          <td>input</td>
          <td>后端重定向相关信息</td>
      </tr>
      <tr>
          <td>req</td>
          <td>input</td>
          <td>接收写入请求</td>
      </tr>
      <tr>
          <td>ldout</td>
          <td>output</td>
          <td>写回 MMIO 数据接口，输出 MemExuOutput 类型的数据，处理与 MMIO 的写回操作</td>
      </tr>
      <tr>
          <td>ld_raw_data</td>
          <td>output</td>
          <td>读取原始数据输出接口</td>
      </tr>
      <tr>
          <td>rob</td>
          <td>input</td>
          <td>接收来自 ROB 的信号或数据</td>
      </tr>
      <tr>
          <td>uncache</td>
          <td>output</td>
          <td>发送数据或信号给 uncache 模块</td>
      </tr>
      <tr>
          <td>rollback</td>
          <td>output</td>
          <td>当 uncache 缓存满时，从前端进行回滚</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f3cd9f0b7554ba3e703118e43b113fbb">12.4.1.5 - StoreQueue</h1>
    
	<p><strong>本文档参考<a href="https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ">香山LSQ设计文档</a>写成</strong></p>
<p>本文档撰写的内容截至[ca892e73]</p>
<p>请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！</p>
<h1 id="storequeue-简介">StoreQueue 简介</h1>
<p>StoreQueue是一个队列，用来装所有的 store 指令，功能如下：</p>
<ul>
<li>
<p>在跟踪 store 指令的执行状态</p>
</li>
<li>
<p>存储 store 的数据，跟踪数据的状态（是否到达）</p>
</li>
<li>
<p>为load提供查询接口，让load可以forward相同地址的store</p>
</li>
<li>
<p>负责 MMIO store和NonCacheable store的执行</p>
</li>
<li>
<p>将被 ROB 提交的 store 写到 sbuffer 中</p>
</li>
<li>
<p>维护地址和数据就绪指针，用于LoadQueueRAW的释放和LoadQueueReplay的唤醒</p>
</li>
</ul>
<p>store进行了地址与数据分离发射的优化，即 StoreUnit 是 store 的地址发射出来走的流水线，StdExeUnit 是 store 的数据发射出来走的流水线，是两个不同的保留站，store 的数据就绪了就可以发射到 StdExeUnit，store 的地址就绪了就可以发射到 StoreUnit。</p>
<h2 id="整体框图">整体框图</h2>
<div>			
    <center>	
    <img src="../StoreQueue_structure.svg"
         alt="StoreQueue结构示意图"
         style="zoom:100%"/>
    <br>
    图1：StoreQueue结构示意图<br><br>
    </center>
</div>
<p>StoreQueue最多可以存放64条指令，<strong>store queue 中重要的状态位有：</strong></p>
<ul>
<li>allocated：RS在storeQueue队列有空闲时，会设置这个entry的allocated状态，开始记录这条store 的生命周期。同时发射到StoreUnit/ StdExeUnit 2条流水。当这条store指令被提交到Sbuffer时，allocated状态被清除。</li>
<li>addrvalid：在StoreUnit的S1更新，表示是否已经经过了地址转换得到物理地址，用于 load forward 检查时的 cam 比较。</li>
<li>datavalid：在StdExeUnit 的S1更新，表示store 的数据是否已经被发射出来，是否已经可用</li>
<li>committed：在store 是否已经被 ROB commit 了</li>
<li>pending：在StoreUnit的S2更新，在这条 store 是否是 MMIO 空间的 store，主要是用于控制 MMIO 的状态机</li>
<li>mmio：在StoreUnit的S2更新，这条 store 是否是 MMIO 空间的 store，主要是用于控制对 sbuffer 的写</li>
</ul>
<h2 id="非对齐store指令">非对齐store指令</h2>
<p>StoreQueue支持处理非对齐的Store指令，每一个非对齐的Store指令占用一项，并在写入dataBuffer对地址和数据对齐后写入。</p>
<h2 id="向量store指令">向量store指令</h2>
<p>如图2所示，StoreQueue会给向量store指令预分配一些项。</p>
<p>StoreQueue通过vecMbCommit控制向量store的提交：</p>
<ol>
<li>
<p>针对每个 store，从反馈向量 fbk 中获取相应的信息。</p>
</li>
<li>
<p>判断该 store 是否符合提交条件（valid 且标记为 commit 或 flush），并且检查该 store 是否与 uop(i) 对应的指令匹配（通过 robIdx 和 uopIdx）。只有当满足所有条件时，才会将该 store 标记为提交。判断VecStorePipelineWidth内是否有指令满足条件，满足则判断该向量store提交，否则不提交。</p>
</li>
<li>
<p>特殊情况处理（跨页 store 指令）:</p>
</li>
</ol>
<p>在特殊情况下（当 store 跨页且 storeMisalignBuffer 中有相同的 uop），如果该 store 符合条件<code>io.maControl.toStoreQueue.withSameUop</code>，会强制将 vecMbCommit设置为 true，表示该 store 无论如何都已提交。</p>
<div>			
    <center>	
    <img src="../StoreQueue_Vector.svg"
         alt="向量store指令示意图"
         style="zoom:100%"/>
    <br>
    图2：向量store指令<br><br>
    </center>
</div>
<h1 id="功能简介">功能简介</h1>
<mrs-functions>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="功能1store指令请求入队">功能1：store指令请求入队</h3>
<ol>
<li>
<p>StoreQueue 每次最多会有 2 个 entry 入队，通过入队指针 enqPtrExt 控制。在 dispatch 阶段最多可以分配2个 entry，指针每次右移 1 位或 2 位。</p>
</li>
<li>
<p>通过比较入队指针 enqPtrExt 和出队指针 deqPtrExt 得出已经在队列中有效 entry。只有空闲的 entry 大于需要请求入队的指令时才会分配 entry 入队。</p>
</li>
<li>
<p>入队时设置 entry 的状态位 allocated 为 true，其他状态位都为 false。</p>
</li>
</ol>
<h3 id="功能2指令的出队">功能2：指令的出队</h3>
<ol>
<li>
<p>StoreQueue 每次最多会有2个 entry 出队释放，通过输出指针 deqPtrExt 控制，每次指针右移一位或 2 位。</p>
</li>
<li>
<p>STQ 出队的触发信号是isbuffer(i).fire延后一拍的信号，因为 sbuffer 的写动作要用 2 拍完成，在 sbuffer 写完成之前 entry 不释放可以继续 forward 数据。</p>
</li>
</ol>
<h3 id="功能3从store的地址流水线写回结果">功能3：从store的地址流水线写回结果</h3>
<p>store 的地址从保留站发出来后会经过 StoreUnit 流水线，通过lsq/lsq_replenish总线接口在S1/S2把地址信息更新到store queue 中：</p>
<ol>
<li>
<p>在store流水线s1阶段，获得 DTLB hit/miss 的信息, 以及指令的虚拟地址vaddr和物理地址paddr</p>
</li>
<li>
<p>在store流水线s2阶段，获得 mmio/pmp 信息，以及是否是mmio地址空间操作等信息</p>
</li>
</ol>
<h3 id="功能4接收-store-的数据到stq的datamodule">功能4：接收 store 的数据到STQ 的Datamodule</h3>
<p>store 的数据是从与地址不同的保留站发出来的后经过<code>StdExeUnit</code>流水线，通过<code>storeDataIn</code>接口在S0/S1把数据写到对应的entry的<code>datamodule</code>里:</p>
<ol>
<li>
<p>S0：给<code>datamodule</code>发写请求</p>
</li>
<li>
<p>S1：写入数据到<code>datamodule</code>同时更新 entry 的<code>datavalid</code>属性为True，接收 store 的mask到STQ 的<code>Datamodule</code></p>
</li>
</ol>
<p>store 的地址从保留站发出来之后会经过<code>StoreUnit</code>流水线，<code>s0_mask_out</code>在S0把地址中的mask信息更新到对应entry的<code>datamodule</code>里。</p>
<h3 id="功能5为-load-提供-forward-查询">功能5：为 load 提供 forward 查询</h3>
<ol>
<li>load 需要查询 store queue 来找到在它之前相同地址的与它最近的那个 store 的数据。
<ul>
<li>查询总线(<code>io.forwrd.sqIdx</code>) 和 StoreQueue 的出栈指针比较，找出所有比 load 指令老的 storeQueue 中的 entry。以 flag 相同或不同分为2种情况：</li>
</ul>
</li>
</ol>
<p>(1)same flag-&gt; older Store范围是 (tail, sqIdx)，如图3(a)所示</p>
<p>(2)different flags-&gt; older Store范围是(tail, VirtualLoadQueueSize) +(0, sqIdx)，如图3(b)所示</p>
<div>			
    <center>	
    <img src="../StoreQueue_Forward_Mask.svg"
         alt="StoreQueue前递范围生成"
         style="zoom:100%"/>
    <br>
    图3：StoreQueue前递范围生成<br><br>
    </center>
</div>
<ol start="2">
<li>
<p>查询总线用va 和pa同时查询，如果发现物理地址匹配但是虚拟地址不匹配；或者虚拟地址匹配但是物理地址不匹配的情况就需要将那条 load 设置为 replayInst，等 load 到 ROB head 后replay。</p>
</li>
<li>
<p>如果只发现一笔 entry 匹配且数据准备好，则直接 forward</p>
</li>
<li>
<p>如果只发现一笔 entry 匹配且数据没有准备好，就需要让保留站负责重发</p>
</li>
<li>
<p>如果发现多笔匹配，则选择最老的一笔 store forward，StoreQueue以1字节为单位，采用树形数据选择逻辑,如图4</p>
</li>
</ol>
<div>			
    <center>	
    <img src="../StoreQueue_Forward.svg"
         alt="StoreQueue前递数据选择"
         style="zoom:100%"/>
    <br>
    图4：StoreQueue前递数据选择<br><br>
    </center>
</div>
<ol start="6">
<li>
<p>store 指令能被 load forward的条件：</p>
<ul>
<li>allocated：这条 store 还在 store queue 内，还没有写到 sbuffer</li>
<li>datavalid：这条 store 的数据已经就绪</li>
<li>addrvalid：这条 store 已经完成了虚实地址转换，得到了物理地址</li>
</ul>
</li>
<li>
<p>SSID (Store-Set-ID) 标记了之前 load 预测执行失败历史信息，如果当前 load 命中之前历史中的SSID，会等之前所有 older 的 store 都执行完；如果没有命中就只会等pa相同的 older Store 执行完成。</p>
</li>
</ol>
<h3 id="功能6mmio与noncacheable-store指令">功能6：MMIO与NonCacheable Store指令</h3>
<ul>
<li><strong>MMIO Store指令执行</strong>:</li>
</ul>
<ol>
<li>
<p>MMIO 空间的 store 也只能等它到达 ROB 的 head 时才能执行，但是跟 load 稍微有些不同，store 到达 ROB 的 head 时，它不一定位于 store queue 的尾部，有可能有的 store 已经提交，但是还在 store queue 中没有写入到 sbuffer，需要等待这些 store 写到 sbuffer 之后，才能让这条 MMIO 的 store 去执行。</p>
</li>
<li>
<p>利用一个状态机去控制MMIO的store执行</p>
<ul>
<li>
<p>s_idle：空闲状态，接收到MMIO的store请求后进入到s_req状态;</p>
</li>
<li>
<p>s_req：给MMIO通道发请求，请求被MMIO通道接受后进入s_resp状态;</p>
</li>
<li>
<p>s_resp：MMIO通道返回响应，接收后记录是否产生异常，并进入到 s_wb 状态</p>
</li>
<li>
<p>s_wb：将结果转化为内部信号，写回给 ROB，成功后,如果有异常，则进入s_idle, 否则进入到 s_wait 状态</p>
</li>
<li>
<p>s_wait：等待 ROB 将这条 store 指令提交，提交后重新回到 s_idle 状态</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>NonCacheable Store指令执行</strong>：</li>
</ul>
<ol>
<li>
<p>NonCacheable空间的store指令，需要等待上一个NonCacheable Store指令提交之后，才能从StoreQueue按序发送请求</p>
</li>
<li>
<p>利用一个状态机去控制NonCacheable的store执行</p>
<ul>
<li>
<p>nc_idle：空闲状态，接收到NonCacheable的store请求后进入到nc_req状态;</p>
</li>
<li>
<p>nc_req：给NonCacheable通道发请求，请求被NonCachable通道接受后, 如果启用uncacheOutstanding功能，则进入nc_idle，否则进入nc_resp状态;</p>
</li>
<li>
<p>nc_resp：接受NonCacheable通道返回响应，并进入到nc_idle状态</p>
</li>
</ul>
</li>
</ol>
<h3 id="功能7store指令提交以及写入sbuffer">功能7：store指令提交以及写入SBuffer</h3>
<p>StoreQueue采用提前提交的方式进行提交。</p>
<ul>
<li><strong>提前提交规则</strong>:</li>
</ul>
<ol>
<li>
<p>检查进入提交阶段的条件</p>
<p>(1)指令有效。</p>
<p>(2)指令的ROB对头指针不超过待提交指针。</p>
<p>(3)指令不需要取消。</p>
<p>(4)指令不等待Store操作完成，或者是向量指令</p>
</li>
<li>
<p>如果是CommitGroup的第一条指令, 则</p>
<p>(1)检查MMIO状态: 没有MMIO操作或者有MMIO操作并且MMIO store以及提交。</p>
<p>(2)如果是向量指令，需满足vecMbCommit条件。</p>
</li>
<li>
<p>如果不是CommitGroup的第一条指令，则：</p>
<p>(1)提交状态依赖于前一条指令的提交状态。</p>
<p>(2)如果是向量指令，需满足vecMbCommit条件。</p>
</li>
</ol>
<p>提交之后可以按顺序写到 sbuffer, 先将这些 store 写到 dataBuffer 中，dataBuffer 是一个两项的缓冲区（0，1通道），用来处理从大项数 store queue 中的读出延迟。只有0通道可以编写未对齐的指令,同时为了简化设计，即使两个端口出现异常，但仍然只有一个未对齐出队。</p>
<ul>
<li><strong>写入sbuffer的过程</strong>：</li>
</ul>
<ol>
<li>
<p>写入有效信号生成</p>
</li>
<li>
<p>0通道指令存在非对齐且跨越16字节边界时：</p>
<p>(1) 0通道的指令已分配和提交</p>
<p>(2) dataBuffer的0，1通道能同时接受指令，</p>
<p>(3) 0通道的指令不是向量指令，并且地址和数据有效；或者是向量且vsMergeBuffer以及提交。</p>
<p>(4) 没有跨越4K页表；或者跨越4K页表但是可以被出队,并且1）如果是0通道：允许有异常的数据写入; 2）如果是1通道：不允许有异常的数据写入。</p>
<p>(5) 之前的指令没有NonCacheable指令，如果是第一条指令，自身不能是Noncacheable指令</p>
</li>
<li>
<p>否则，需要满足：</p>
<p>(1) 指令已分配和提交。</p>
<p>(2) 不是向量且地址和数据有效，或者是向量且vsMergeBuffer以及提交。</p>
<p>(3) 之前的指令没有NonCacheable和MMIO指令，如果是第一条指令，自身不能是Noncacheable和MMIO指令。</p>
<p>(4) 如果未对齐store，则不能跨越16字节边界，且地址和数据有效或有异常</p>
</li>
</ol>
<ul>
<li><strong>地址和数据生成</strong>：</li>
</ul>
<ol>
<li>
<p>地址拆分为高低两部分：</p>
<p>(1) 低位地址：8字节对齐地址</p>
<p>(2) 高位地址：低位地址加上8偏移量</p>
</li>
<li>
<p>数据拆分为高低两部分：</p>
<p>(1) 跨16字节边界数据：原始数据左移地址低4位偏移量包含的字节数</p>
<p>(2) 低位数据：跨16字节边界数据的低128位；</p>
<p>(3) 高位数据：跨16字节边界数据的高128位；</p>
</li>
<li>
<p>写入选择逻辑：</p>
<p>如果dataBuffer能接受非对齐指令写入,通道0的指令是非对齐并且跨越了16字节边界，则检查：</p>
<p>(1) 是否跨4K页表同时跨4K页表且可以出队: 通道0使用低位地址和低位数据写入dataBuffer; 通道1使用StoreMisaligBuffer的物理地址和高位数据写入dataBuffer</p>
<p>(2) 否则: 通道0使用低位地址和低位数据写入dataBuffer; 通道1使用高位地址和高位数据写入dataBuffer</p>
<p>(3) 如果通道指令没有跨越16字节并且非对齐，则使用16字节对齐地址和对齐数据写入dataBuffer</p>
<p>(4) 否则，将原始数据和地址写给dataBuffer</p>
</li>
</ol>
<h3 id="功能8强制刷新sbuffer">功能8：强制刷新sbuffer</h3>
<p>StoreQueue采用双阈值的方法控制强制刷新Sbuffer：上阈值和下阈值。</p>
<ol>
<li>当StoreQueue的有效项数大于上阈值时， StoreQueue强制刷新Sbuffer</li>
<li>直到StoreQueue的有效项数小于下阈值时，停止刷新Sbuffer。</li>
</ol>
</mrs-functions>
<h2 id="接口说明">接口说明</h2>
<table>
  <thead>
      <tr>
          <th>name</th>
          <th>description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>enq</td>
          <td>接收来自外部模块的信息，包含入队请求、控制信号等</td>
      </tr>
      <tr>
          <td>brqRedirect</td>
          <td>分支重定向信号</td>
      </tr>
      <tr>
          <td>vecFeedback</td>
          <td>向量反馈信息</td>
      </tr>
      <tr>
          <td>storeAddrIn</td>
          <td>store指令的地址</td>
      </tr>
      <tr>
          <td>storeAddrInRe</td>
          <td>store指令的地址，用于处理MMIO 和异常情况</td>
      </tr>
      <tr>
          <td>storeDataIn</td>
          <td>store指令的数据</td>
      </tr>
      <tr>
          <td>storeMaskIn</td>
          <td>传递store掩码，从保留站（RS）发送到 Store Queue（SQ）。store掩码通常用于指示哪些字节在store操作中是有效的。</td>
      </tr>
      <tr>
          <td>sbuffer</td>
          <td>存储已提交的 Store 请求到sbuffer</td>
      </tr>
      <tr>
          <td>uncacheOutstanding</td>
          <td>指示是否有未完成的uncached请求</td>
      </tr>
      <tr>
          <td>cmoOpReg</td>
          <td>发送缓存管理操作请求</td>
      </tr>
      <tr>
          <td>cmoOpResp</td>
          <td>接收缓存管理操作的响应</td>
      </tr>
      <tr>
          <td>mmioStout</td>
          <td>写回uncache的存储操作的结果</td>
      </tr>
      <tr>
          <td>forward</td>
          <td>查询forwarding信息</td>
      </tr>
      <tr>
          <td>rob</td>
          <td>接收来自 ROB 的信号或数据</td>
      </tr>
      <tr>
          <td>uncache</td>
          <td>发送数据或信号给 uncache 模块</td>
      </tr>
      <tr>
          <td>flushSbuffer</td>
          <td>冲刷sbuffer缓冲区</td>
      </tr>
      <tr>
          <td>sqEmpty</td>
          <td>标识store queue为空</td>
      </tr>
      <tr>
          <td>stAddrReadySqPtr</td>
          <td>指向当前准备好地址的 store 指令</td>
      </tr>
      <tr>
          <td>stAddrReadyVec</td>
          <td>向量中对应 store 指令的地址是否已经准备好</td>
      </tr>
      <tr>
          <td>stDataReadySqPtr</td>
          <td>指向当前准备好数据的 store 指令</td>
      </tr>
      <tr>
          <td>stDataReadyVec</td>
          <td>向量中对应 store 指令的数据是否已经准备好</td>
      </tr>
      <tr>
          <td>stIssuePtr</td>
          <td>跟踪当前发出的store请求</td>
      </tr>
      <tr>
          <td>sqCancelCnt</td>
          <td>指示在store queue中可以被取消的请求数量</td>
      </tr>
      <tr>
          <td>sqDeq</td>
          <td>当前store queue中出队的请求位置</td>
      </tr>
      <tr>
          <td>force_write</td>
          <td>是否强制写入存储操作</td>
      </tr>
      <tr>
          <td>maControl</td>
          <td>与存储管理缓冲区（MA）进行控制信号的交互</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-366929e8b710d65054748c1a2afe5b56">12.4.1.6 - VirtualLoadQueue</h1>
    
	<p><strong>本文档参考<a href="https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ">香山LSQ设计文档</a>写成</strong></p>
<p>本文档撰写的内容截至[ca892e73]</p>
<p>请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！</p>
<h1 id="virtualloadqueue-简介">VirtualLoadQueue 简介</h1>
<p>Virtualloadqueue是一个队列，用于存储所有load指令的微操作(MicroOp)，并维护这些load指令之间的顺序，它的功能类似于重排序缓冲区（Reorder Buffer, ROB），但专注于load指令的管理。其主要功能是跟踪Load指令执行状态，以确保在并发执行的环境中，加载操作能够正确、有序地完成。</p>
<h2 id="整体框图">整体框图</h2>
<div>			
    <center>	
    <img src="../VirtualLoadQueue_structure.png"
         alt="VirtualLoadQueue结构示意图"
         style="zoom:100%"/>
    <br>
    图1：VirtualLoadQueue结构示意图
    </center>
</div>
<p>Virtualloadqueue最多可以存放72条指令，dispatch阶段最多支持6条指令同时入队，最多支持8条指令出队。Virtualloadqueue对于每一个 entry 中的 load 指令都有若干状态位来标识这个 load 处于什么状态：</p>
<p><strong>allocated</strong>：该项是否分配了load，用于确定load指令的生命周期。</p>
<p><strong>isvec</strong>：该指令是否是向量load指令。</p>
<p><strong>committed</strong>: 该项是否提交。</p>
<h1 id="功能简介">功能简介</h1>
<mrs-functions>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="功能1load指令请求入队">功能1：load指令请求入队</h3>
<p>在调度阶段，保留站通过入队（enq）总线向VirtualLoadQueue发起入队请求，最多支持六组并发请求。成功入队的条件包括以下几点：</p>
<ol>
<li>StoreQueue 和 LoadQueue 有预留空间：确保LoadQueue有足够的容量来接收新的加载指令，以避免队列溢出。确保StoreQueu有预留空间则是基于数据一致性和避免指令阻塞的考虑，因为store指令入队阻塞可能会导致load指令无法正确读取或forward到数据。</li>
<li>入队请求有效：入队请求必须是合法的，确保指令在调度过程中可以被正确处理。</li>
<li>指令未被冲刷：确保指令在入队时没有被系统标记为无效或被撤销。</li>
</ol>
<p>成功入队之后，系统会执行以下操作：</p>
<ol>
<li>将指令的lqidx作为索引，将对应的allocated寄存器置1，bits信息写入uop寄存器。</li>
<li>计算新的lqidx值，作为enq_resp传送给保留站。</li>
</ol>
<h3 id="功能2接收load流水线写回的数据">功能2：接收load流水线写回的数据</h3>
<p>在 load 流水线的s3阶段，load unit会将指令执行的信息通过总线 ldin 写回到 VirtualLoadQueue。具体写回信息包括：</p>
<ol>
<li>是否发生了异常以及异常类型</li>
<li>dcache是否命中</li>
<li>tlb是否命中</li>
<li>是否为mmio指令</li>
<li>是否为软件预取或者硬件预取</li>
<li>是否需要重发以及重发的原因</li>
<li>写uop的使能信号</li>
</ol>
<p>写回需要满足的条件如下：</p>
<ol>
<li>ldin 总线的 valid 信号需要拉高，表明当前正在进行有效的数据传输。</li>
<li>指令不应需要重发（即 <code>need_rep</code> 信号为 0），否则将影响写回的正常进行。</li>
</ol>
<p>在满足写回条件后，系统将生成相应的写回响应，具体包括以下几个方面：</p>
<ol>
<li>如果在执行过程中发生了异常、TLB命中或软件预取操作，<code>addrvalid</code> 信号将被置为 1，表示地址信息有效。</li>
<li>如果在执行过程中发生了异常、MMIO操作、DCACHE命中并且不需要重发，或是软件预取操作，<code>datavalid</code> 信号将被置为 1，表示数据有效。</li>
<li>指令在流水线的 S3 阶段有效（注意：不能是硬件预取指令）。当 <code>ldin</code> 总线的写使能信号 <code>data_wen_dup</code> 拉高时，将更新队列中的uop信息，以确保指令的状态及时反映。</li>
</ol>
<p>系统将<code>addrvalid</code>和<code>datavalid</code>分开进行处理是考虑到在一些情况下，地址可以被重用，而数据可能需要重新请求（如dcache miss/mmio/软件预取等）。分开标识可以减少流水线停顿，允许处理器在地址有效时继续执行其他指令，而不必等待数据有效性确认，从而优化整体性能。</p>
<h3 id="功能3load指令的出队提交">功能3：load指令的出队(提交)</h3>
<ol>
<li>出队时机：当被分配的entries（allocated为高）到达队头，同时allocated与committed都为1时，表示可以出队，如果是向量load，需要每个元素都committed。</li>
</ol>
</mrs-functions>
<h2 id="接口说明">接口说明</h2>
<table>
  <thead>
      <tr>
          <th></th>
          <th>name</th>
          <th>I/O</th>
          <th>width</th>
          <th>description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>redirect</td>
          <td>io.redirect.valid</td>
          <td>input</td>
          <td>1</td>
          <td>后端重定向有效位</td>
      </tr>
      <tr>
          <td></td>
          <td>io.redirect.bits.robIdx.flag</td>
          <td>input</td>
          <td>1</td>
          <td>后端重定向相关信息</td>
      </tr>
      <tr>
          <td></td>
          <td>io.redirect.bits.robIdx.value</td>
          <td>input</td>
          <td>8</td>
          <td>后端重定向相关信息</td>
      </tr>
      <tr>
          <td></td>
          <td>io.redirect.bits.level</td>
          <td>input</td>
          <td>1</td>
          <td>后端重定向相关信息</td>
      </tr>
      <tr>
          <td>enq</td>
          <td>io.enq.canAccept</td>
          <td>output</td>
          <td>1</td>
          <td>Lq能否接收派遣指令</td>
      </tr>
      <tr>
          <td></td>
          <td>io.enq.sqcanAccept</td>
          <td>input</td>
          <td>1</td>
          <td>sq能否接收派遣至零</td>
      </tr>
      <tr>
          <td></td>
          <td>io.enq.needAlloc_0~5</td>
          <td>input</td>
          <td>1</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>io.enq.req_0~5.valid</td>
          <td>input</td>
          <td>1</td>
          <td>入队请求的有效信号</td>
      </tr>
      <tr>
          <td></td>
          <td>io.enq.req_0~5.bits.robIdx.flag</td>
          <td>input</td>
          <td>1</td>
          <td>入队请求ROB指针的flag</td>
      </tr>
      <tr>
          <td></td>
          <td>io.enq.req_0~5.bits.robIdx.value</td>
          <td>input</td>
          <td>8</td>
          <td>入队请求ROB指针的value</td>
      </tr>
      <tr>
          <td></td>
          <td>io.enq.req_0~5.bits.lqIdx.value</td>
          <td>input</td>
          <td>7</td>
          <td>入队请求lqidx的value</td>
      </tr>
      <tr>
          <td></td>
          <td>io.enq.req_0~5.bits.numLsElem</td>
          <td>input</td>
          <td>5</td>
          <td>1. 向量寄存器的总位宽为128位，每个向量元素的大小为8位，因此每个向量寄存器可以存储16个，numLsElem表示向量寄存器中元素的个数，因此位宽为5。 2. 如果是标量值零，numLsElem的值恒为5‘b1 3. 如果是向量指令，每个端口的numLsElem的最大值为[16 2 2 2 2 2]</td>
      </tr>
      <tr>
          <td>ldin</td>
          <td>io.ldin_0/1/2.valid</td>
          <td>input</td>
          <td>1</td>
          <td>load写回到loadqueue的信息有效</td>
      </tr>
      <tr>
          <td></td>
          <td>io.ldin_0/1/2.bits.uop.cf.exceptionVec_3/4/5/13/21</td>
          <td>input</td>
          <td>1</td>
          <td>Load写回到流水线的指令发生异常</td>
      </tr>
      <tr>
          <td></td>
          <td>io.ldin_0/1/2.bits.uop.robIdx_flag</td>
          <td>input</td>
          <td>1</td>
          <td>load写回lq指令的rob指针的flag</td>
      </tr>
      <tr>
          <td></td>
          <td>io.ldin_0/1/2.bits.uop.robIdx_value</td>
          <td>input</td>
          <td>8</td>
          <td>load写回lq指令的rob指针的value</td>
      </tr>
      <tr>
          <td></td>
          <td>io.ldin_0/1/2.bits.uop.lqIdx.value</td>
          <td>input</td>
          <td>7</td>
          <td>load写回lq指令的lq指针的value</td>
      </tr>
      <tr>
          <td></td>
          <td>io.ldin_0/1/2.bits.miss</td>
          <td>input</td>
          <td>1</td>
          <td>Load写回到Lq的指令发生cacheMiss</td>
      </tr>
      <tr>
          <td></td>
          <td>io.ldin_0/1.bits.tlbMiss</td>
          <td>input</td>
          <td>1</td>
          <td>Load写回到Lq的指令发生tlbMiss</td>
      </tr>
      <tr>
          <td></td>
          <td>io.ldin_0/1/2.bits.mmio</td>
          <td>input</td>
          <td>1</td>
          <td>Load写回到Lq的指令是MMIO指令</td>
      </tr>
      <tr>
          <td></td>
          <td>io.ldin_0/1/2.bits.isPrefetch</td>
          <td>input</td>
          <td>1</td>
          <td>指令为预取操作，预取分为软件预取和硬件预取</td>
      </tr>
      <tr>
          <td></td>
          <td>io.ldin_0/1/2.bits.isHWPrefetch</td>
          <td>input</td>
          <td>1</td>
          <td>指令为硬件预取</td>
      </tr>
      <tr>
          <td></td>
          <td>io.ldin_0/1/2.bits.dcacheRequireReplay</td>
          <td>input</td>
          <td>1</td>
          <td>Load写回到Lq的指令需要replay</td>
      </tr>
      <tr>
          <td></td>
          <td>io.ldin_0/1/2.bits.rep.info.cause_0~9</td>
          <td>input</td>
          <td>1</td>
          <td>Load写回到Lq的指令需要replay的原因： =0：st-ld violention predirect =1：tlb miss =2：st-ld forward =3：dcache replay =4：dcache miss =5：wpu predict fail =6：dcache bank conflict =7：RAR queue nack =8：RAW queue nack =9：st-ld violention</td>
      </tr>
      <tr>
          <td></td>
          <td>io.ldin_0/1/2.bits.data_wen_dup_1</td>
          <td>input</td>
          <td>1</td>
          <td>uop信息的写入使能信号</td>
      </tr>
      <tr>
          <td>ldWbPtr</td>
          <td>io.ldWbPtr.flag</td>
          <td>output</td>
          <td>1</td>
          <td>writeback指针的flag</td>
      </tr>
      <tr>
          <td></td>
          <td>io.ldWbPtr.value</td>
          <td>output</td>
          <td>7</td>
          <td>writeback指针的value</td>
      </tr>
      <tr>
          <td>lqEmpty</td>
          <td>io.lqEmpty</td>
          <td>output</td>
          <td>1</td>
          <td>Lq是否空</td>
      </tr>
      <tr>
          <td>lqDeq</td>
          <td>io.lqDeq</td>
          <td>output</td>
          <td>3</td>
          <td>出队表项数量</td>
      </tr>
      <tr>
          <td>lqCancelCnt</td>
          <td>io.lqCancelCnt</td>
          <td>output</td>
          <td>7</td>
          <td>后端发生重定向时取消的load数量</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c6606764ae0dd34ef700d409c04fd9eb">12.4.2 - LSU</h1>
    
	<p><strong>本文档参考<a href="https://github.com/OpenXiangShan/XiangShan-Design-Doc/blob/master/docs/zh/memblock/LSU/index.md">香山LSQ设计文档</a>写成</strong></p>
<p>请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！</p>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-cae277314de45b24dc43679a076417b4">12.4.2.1 - StoreUnit</h1>
    
	<h4 id="本文档参考香山storeunit设计文档写成">本文档参考<a href="https://github.com/OpenXiangShan/XiangShan-Design-Doc/blob/master/docs/zh/memblock/LSU/index.md">香山StoreUnit设计文档</a>写成</h4>
<p>请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！</p>
<h1 id="storeunit说明文档">StoreUnit说明文档</h1>
<h2 id="文档概述">文档概述</h2>
<p>本文档描述了StoreUnit的结构与功能，并根据功能给出测试点参考，方便测试的参与者理解测试需求，编写相关测试用例。
StoreUnit 是存储指令执行单元 ，由多个协同工作的子模块组成，包括其五级流水线处理流程、支持的三种类型store指令（标量、向量、非对齐）、接口设计与信号交互逻辑。该模块用于执行Store类指令的地址生成与处理，是Load/Store流水线中的关键组成部分。</p>
<h2 id="术语说明">术语说明</h2>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>定义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>TLB（Translation Lookaside Buffer）</td>
          <td>地址转换旁路缓冲器，用于虚拟地址到物理地址的快速转换</td>
      </tr>
      <tr>
          <td>PMP（Physical Memory Protection）</td>
          <td>物理内存访问权限检查机制</td>
      </tr>
      <tr>
          <td>RAW（Read After Write）违例</td>
          <td>写后读违例，表示一个load指令读取尚未写入的store数据</td>
      </tr>
      <tr>
          <td>MMIO（Memory-Mapped Input/Output）</td>
          <td>内存映射IO</td>
      </tr>
  </tbody>
</table>
<h3 id="存储指令执行">存储指令执行</h3>
<p>内存单元里包含2条Store地址流水线与2条Store数据流水线。各流水线独立接收并执行对应发射队列派发的指令。</p>
<h4 id="存储地址流水线">存储地址流水线</h4>
<p><img src="../scalar.png" alt="sw指令流水示意图"></p>
<p>由4级结构组成：</p>
<p>​Store地址流水线（4级结构）​​</p>
<ul>
<li>
<p>stage 0:</p>
<ul>
<li>
<p>计算VA地址</p>
</li>
<li>
<p>非对齐 &gt; 向量 &gt; 标量请求的优先级仲裁</p>
</li>
<li>
<p>地址非对齐检查更新到uop.exceptionVec</p>
</li>
<li>
<p>对地址的16字节边界检测</p>
</li>
<li>
<p>发出DTLB读请求到tlb</p>
</li>
<li>
<p>更新指令的掩码信息到s0_mask_out发送到StoreQueue</p>
</li>
<li>
<p>判断是否为数据宽度为128bits的store指令。</p>
</li>
</ul>
</li>
<li>
<p>stage 1:</p>
<ul>
<li>
<p>接收TLB地址转换响应，TLB若缺失则重试</p>
</li>
<li>
<p>查询LoadQueueRAW以进行违规检查</p>
</li>
<li>
<p>与加载单元s1和s2阶段的Load指令进行RAW冒险检测</p>
</li>
<li>
<p>如果DTLB hit，将store issue信息发送到后端</p>
</li>
</ul>
</li>
<li>
<p>stage 2:</p>
<ul>
<li>
<p>mmio/PMP检查、检查原子操作权限</p>
</li>
<li>
<p>更新storeQueue中标记为地址就绪状态</p>
</li>
<li>
<p>更新DTLB结果通过feedback_slow更新到后端</p>
</li>
</ul>
</li>
<li>
<p>stage 3:</p>
<ul>
<li>
<p>标量store发起写回，通过stout发送给后端</p>
</li>
<li>
<p>StoreQueue条目释放与状态清理</p>
</li>
</ul>
</li>
</ul>
<h4 id="存储数据流水线">存储数据流水线</h4>
<ul>
<li>从发射队列（issue queue）接收数据</li>
<li>将数据写回StoreQueue</li>
<li>标记发射队列接收的数据为就绪状态</li>
</ul>
<h3 id="向量存储指令执行">向量存储指令执行</h3>
<p>对于除 SEG指令外的向量内存访问指令，VSSplit 负责接收向量内存访问指令发射队列发送的微操作（uop），并将该微操作拆分为多个元素。随后VSSplit 将这些元素发送至StoreUnit 执行，执行流程与标量内存访问指令相同。执行完成后，元素会被写回至 VSMerge，其中 Merge 模块会将这些元素收集并组合成微操作，最终写回向量寄存器文件。
SEG 指令则由独立的 VSegmentUnit 模块处理。</p>
<p><img src="../vector.png" alt="vse指令流水示意图"></p>
<p>StoreUnit处理非对齐Store指令流程和标量类似，特别的:</p>
<ul>
<li>
<p>stage 0:</p>
<ul>
<li>接受vsSplit的执行请求，优先级高于标量请求,并且不需要计算虚拟地址</li>
</ul>
</li>
<li>
<p>stage 1:</p>
<ul>
<li>计算vecVaddrOffset和vecTriggerMask</li>
</ul>
</li>
<li>
<p>stage 2:</p>
<ul>
<li>不需要向后端发送feedback_slow响应</li>
</ul>
</li>
<li>
<p>stage 3:</p>
<ul>
<li>向量store发起Writeback，通过vecstout发送给后端</li>
</ul>
</li>
</ul>
<h3 id="非对齐存储指令执行">非对齐存储指令执行</h3>
<p>香山核支持标量与向量内存指令对存储空间进行非对齐访问。</p>
<p>标量非对齐访问未跨越16B边界时可正常执行，无需特殊处理，而跨越16B边界的标量非对齐内存访问在MisalignBuffer中拆分为两次对齐内存操作，完成后由MisalignBuffer处理拼接与写回。</p>
<p>向量非Segment的Unit-stride指令访问连续地址空间，合并元素后一次访问16B，因此无需特殊处理。</p>
<p>非Unit-stride的非Segment向量指令由VSplit模块完成元素拆分与地址计算后发送至流水线。若元素非对齐则发送至MisalignBuffer，后续过程与非对齐标量相同，区别在于MisalignBuffer最终写回至VMerge而非直接后端</p>
<p>向量Segment指令的非对齐处理由VSegmentUnit独立完成，不复用标量内存访问路径，通过独立状态机完成</p>
<p>原子指令、MMIO与NC地址空间均不支持非对齐访问，这些情况将触发AccessFault异常。</p>
<p><img src="../misalign.png" alt="非对齐sd指令流水示意图"></p>
<p>StoreUnit处理非对齐Store指令流程和标量类似，特别的:</p>
<ul>
<li>
<p>stage 0:</p>
<ul>
<li>接受来自StoreMisalignBuffer的请求，优先级高于向量和标量请求,并且不需要计算虚拟地址</li>
</ul>
</li>
<li>
<p>stage 2:</p>
<ul>
<li>
<p>不需要向后端发送feedback响应</p>
</li>
<li>
<p>如果不是来自于StoreMisalignBuffer的请求并且没有跨越16字节边界的非对齐请求，那么需要进入StoreMisalignBuffer处理</p>
<ul>
<li>通过io_misalign_buf接口，向StoreMisalignBuffer发送入队请求</li>
</ul>
</li>
<li>
<p>如果是来自与StoreMisalignBuffer的请求并且没有跨越16字节边界请求，则需要向StoreMisliagnBuffer发送重发或者写回响应</p>
<ul>
<li>
<p>通过io_misalign_sout接口，向StoreMisalignBuffer发送响应</p>
</li>
<li>
<p>如果出现TLB miss，则需要重发，否则写回</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="raw违例">RAW违例</h3>
<p>RAW内存违例：处理器核执行的Load指令的结果应来源于当前处理器核观察到的全局内存顺序中最新的写操作。具体而言，若最新的写操作来自当前核的Store指令，则Load应获取该Store写入的数据。为优化Load指令性能，超标量乱序处理器会投机执行Loads。因此，Load指令可能早于地址相同的更早Store执行，从而获取到该Store之前的旧值，即构成RAW内存违例。</p>
<h2 id="整体框图及流水级">整体框图及流水级</h2>
<p>Store指令地址流水线分为S0/S1/S2/S3四级,如图所示：</p>
<p><img src="../StoreUnit.png" alt="整体框图"></p>
<p>接收store地址发射队列发来的请求，处理完成之后需要给后端和向量部分响应，处理过程中需要给发射队列反馈信息，给StoreQueue反馈信息，最后写回, 如果中间出现异常则从发射队列重新发射。</p>
<mrs-functions>
<h2 id="storeunit功能说明">StoreUnit功能说明</h2>
<p>StoreUnit是存储指令的逻辑，功能被解构并集成到了 ​Memory Dispatch Queue、STA、STD、Integer ALUs、StoreQueue、SBuffer、LoadQueueRAW/RAR以及 DTLB​ 等一系列子模块中。</p>
<h3 id="内存指令派发">内存指令派发</h3>
<p>Store指令存在复杂的控制机制（如顺序、转发、违例等），因此需要队列来保存Store指令的先进先出顺序以进行相关控制，该队列即StoreQueue。Store指令在完成译码、重命名等操作后，需要派发至ROB与LSQ，分配对应的robIdx、lqIdx与sqIdx，随后进入各自发射队列。在所有源操作数就绪后发射至MemBlock中的流水线。在MemBlock中的执行生命周期内，Store指令会携带lqIdx与sqIdx，用于内存违例检测与数据转发时的顺序维护。</p>
<p>对于标量内存访问指令，一条指令分配一个StoreQueue表项。</p>
<p>对于向量内存访问指令，一条指令在译码阶段会被拆分为多个uop，每个uop包含若干元素，相当于一次内存访问操作。在派发时，一个uop会分配与其包含元素数量相等的多个LSQ表项。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>SU_DISPATCH</td>
          <td>SCALAR_DISPATCH</td>
          <td>验证标量Store指令派发时分配一个StoreQueue条目。</td>
      </tr>
      <tr>
          <td>1.2</td>
          <td>SU_DISPATCH</td>
          <td>VECTOR_DISPATCH</td>
          <td>验证向量Store指令的一个uop分配多个LSQ条目（根据元素数量）。</td>
      </tr>
  </tbody>
</table>
<h3 id="地址流水线">地址流水线</h3>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>2.1</td>
          <td>SU_STORE</td>
          <td>S0_ADDRESS_CALC</td>
          <td>验证s0阶段地址计算和仲裁。</td>
      </tr>
      <tr>
          <td>2.2</td>
          <td>SU_STORE</td>
          <td>S1_RAW_CHECK</td>
          <td>验证s1阶段RAW冒险检测。</td>
      </tr>
      <tr>
          <td>2.3</td>
          <td>SU_STORE</td>
          <td>S2_SQ_MARK_READY</td>
          <td>验证s2阶段StoreQueue地址就绪标记。</td>
      </tr>
  </tbody>
</table>
<h3 id="向量内存指令执行">向量内存指令执行</h3>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>3.1</td>
          <td>SU_VECTOR</td>
          <td>SPLIT</td>
          <td>验证向量指令拆分正确性。</td>
      </tr>
      <tr>
          <td>3.2</td>
          <td>SU_VECTOR</td>
          <td>OFFSET</td>
          <td>元素偏移计算</td>
      </tr>
  </tbody>
</table>
<h3 id="重执行">重执行​</h3>
<p>存储指令会被发射队列重新传输，在一个存储指令被发射队列发射后，队列不会立即清除该指令，直到StoreUnit返回信号。StoreUnit根据TLB是否命中发送相应反馈。如果TLB未命中，则由指令发射队列负责重新发送该指令。</p>
<h3 id="raw处理">RAW处理</h3>
<p>RAW内存访问违例检测：LoadQueue中的LoadQueueRAW模块通过FreeList结构记录所有可能地址相同但尚未执行更早Store的Load指令。当Load指令在LoadUnit执行到s2阶段（此时地址转换与PMA/PMP检查已完成）时，会分配LoadQueueRAW表项。当StoreQueue中所有Store地址就绪后，LoadQueueRAW中的所有Load可释放；或当程序顺序早于它的所有Store地址就绪后，该Load可从LoadQueueRAW释放。若Store指令在查询LoadQueueRAW时发现存在地址相同的更晚Load，则发生RAW内存访问违例，需要回滚。</p>
<p>RAW内存访问违例恢复：检测到RAW违例时，由LoadQueueRAW发起回滚，从造成违例的Store指令的下一条指令开始清空流水线。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>5.1</td>
          <td>SU_RAW</td>
          <td>VIOLATION</td>
          <td>验证RAW违例检测。</td>
      </tr>
      <tr>
          <td>5.2</td>
          <td>SU_RAW</td>
          <td>RECOVERY_MECH</td>
          <td>验证检测到RAW违例后的恢复（流水线清空）。</td>
      </tr>
  </tbody>
</table>
<h3 id="sbuffer优化">SBuffer优化</h3>
<p>根据RVWMO模型，在多核场景下（无FENCE等栅栏语义指令时），一个核的Store指令可以比地址不同的更晚Load指令更晚对其他核可见。该内存模型规则主要优化Store指令性能。RVWMO等弱一致性模型允许处理器核包含SBuffer，暂时保存已提交的Store写操作，合并这些写操作后再写入DCache，从而减少Store指令对DCache SRAM端口的争用，提高Load指令执行带宽。</p>
<p>SBuffer为16×512B的全相联结构。当多个Store地址落在同一缓存块时，SBuffer会合并这些Store。</p>
<p>SBuffer每周期最多可写入2条Store指令，每条Store指令写数据位宽为16B（例外：cbo.zero指令按缓存块操作，一次操作一个缓存块）。</p>
<p>SBuffer换出：</p>
<p>当SBuffer容量超过一定阈值时，执行换出操作，按PLRU替换算法选择被替换块写入DCache</p>
<p>SBuffer支持被动清空机制；FENCE/atomic/向量Segment等指令执行时会清空SBuffer</p>
<p>SBuffer支持超时清空机制；超过2^20周期未被换出的数据块将被驱逐</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>6.1</td>
          <td>SU_SBUFFER</td>
          <td>WRITE_MERGE</td>
          <td>验证同一缓存块的多个Store在SBuffer中合并。</td>
      </tr>
      <tr>
          <td>6.2</td>
          <td>SU_SBUFFER</td>
          <td>PLRU_REPLACE</td>
          <td>验证SBuffer满时按PLRU策略替换。</td>
      </tr>
  </tbody>
</table>
<h3 id="mmio处理">MMIO处理</h3>
<p>香山核仅允许标量内存访问指令访问MMIO地址空间。MMIO访问与任何其他内存操作强顺序。因此，MMIO指令必须等待成为ROB头（即所有前序指令均完成）时才能执行。对于MMIO Store指令，需完成虚地址到实地址转换，通过实地址检查，且写数据就绪。随后LSQ将内存请求发送至Uncache模块，通过总线访问外设。结果返回LSQ后写回至ROB。</p>
<p>原子指令与向量指令不支持MMIO访问。若此类指令访问MMIO地址空间，将触发对应AccessFault异常。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>7.1</td>
          <td>SU_MMIO</td>
          <td>ORDER</td>
          <td>验证MMIO指令强顺序执行（成为ROB头）。</td>
      </tr>
      <tr>
          <td>7.2</td>
          <td>SU_MMIO</td>
          <td>EXCEPTION</td>
          <td>验证原子/向量指令访问MMIO触发异常。</td>
      </tr>
  </tbody>
</table>
<h3 id="uncache指令执行">Uncache指令执行</h3>
<p>香山核除支持访问非幂等、强顺序的MMIO地址空间外，还支持访问幂等、弱一致性（RVWMO）的Non-cacheable地址空间，简称NC。软件通过页表PBMT字段配置为NC以覆盖原有PMA属性。与MMIO访问不同，NC访问允许乱序内存操作。</p>
<p>在StoreUnit流水线中被识别为NC地址（PBMT = NC）的内存访问指令会在LSQ中标记。LSQ负责将NC访问发送至Uncache模块。Uncache支持同时处理多个NC请求，支持请求合并，并负责向正在LoadUnit执行的NC Load转发Stores。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>8.1</td>
          <td>SU_NC</td>
          <td>EXEC</td>
          <td>验证NC访问允许乱序执行。</td>
      </tr>
      <tr>
          <td>8.2</td>
          <td>SU_NC</td>
          <td>FORWARD</td>
          <td>验证Uncache模块的Store到Load转发。</td>
      </tr>
  </tbody>
</table>
<h3 id="非对齐内存访问">非对齐内存访问</h3>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>9.1</td>
          <td>SU_MISALIGN</td>
          <td>SCALAR_SPLIT</td>
          <td>验证标量非对齐访问跨越16B边界时拆分为两个对齐访问。</td>
      </tr>
      <tr>
          <td>9.2</td>
          <td>SU_MISALIGN</td>
          <td>SEG_HANDLE</td>
          <td>验证向量Segment指令的非对齐处理（独立路径）。</td>
      </tr>
      <tr>
          <td>9.3</td>
          <td>SU_MISALIGN</td>
          <td>EXCEPTION</td>
          <td>验证原子指令、MMIO、NC空间非对齐访问触发异常。</td>
      </tr>
  </tbody>
</table>
<h3 id="原子指令执行">原子指令执行</h3>
<p>香山核支持RVA与Zacas指令集。香山当前设计中，原子指令需先将访问的缓存块缓存至DCache，再进行原子操作。</p>
<p>内存访问单元监控Store发射队列发射的地址与数据，若为原子指令则进入AtomicsUnit。AtomicsUnit执行一系列操作，包括TLB地址转换、清空SBuffer、访问DCache等。</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>10.1</td>
          <td>SU_ATOMIC</td>
          <td>PRELOAD</td>
          <td>验证原子指令先将缓存块读入DCache。</td>
      </tr>
      <tr>
          <td>10.2</td>
          <td>SU_ATOMIC</td>
          <td>OPS</td>
          <td>验证原子操作（如AMO）执行正确性。</td>
      </tr>
  </tbody>
</table>
</mrs-functions>
<h2 id="常量说明">常量说明</h2>
<table>
  <thead>
      <tr>
          <th>常量名</th>
          <th>常量值</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>VAddrBits</td>
          <td>(Sv39) 39, (Sv48) 48</td>
      </tr>
      <tr>
          <td>GPAddr Bits</td>
          <td>(Sv39x4) 41, (Sv48x4) 50</td>
      </tr>
      <tr>
          <td>StoreExeUnit</td>
          <td>2</td>
      </tr>
      <tr>
          <td>StoreUnit</td>
          <td>2 x 8B/16B</td>
      </tr>
      <tr>
          <td>StoreQueue</td>
          <td>56</td>
      </tr>
      <tr>
          <td>StoreBuffer</td>
          <td>16 x 64B</td>
      </tr>
      <tr>
          <td>VSMergeBuffer</td>
          <td>16</td>
      </tr>
      <tr>
          <td>Store TLB</td>
          <td>48项全相联</td>
      </tr>
  </tbody>
</table>
<h2 id="接口说明">接口说明</h2>
<h3 id="输入接口">输入接口</h3>
<table>
  <thead>
      <tr>
          <th>信号名</th>
          <th>方向</th>
          <th>位宽</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>clock</td>
          <td>input</td>
          <td>1</td>
          <td>时钟信号，用于同步时序</td>
      </tr>
      <tr>
          <td>reset</td>
          <td>input</td>
          <td>1</td>
          <td>复位信号，用于重置模块状态</td>
      </tr>
      <tr>
          <td>io_redirect_valid</td>
          <td>input</td>
          <td>1</td>
          <td>重定向有效信号，指示是否有重定向操作</td>
      </tr>
      <tr>
          <td>io_redirect_bits_robIdx_flag</td>
          <td>input</td>
          <td>1</td>
          <td>重定向ROB索引标志，指示是否需要重定向</td>
      </tr>
      <tr>
          <td>io_redirect_bits_robIdx_value</td>
          <td>input</td>
          <td>8</td>
          <td>重定向ROB索引值</td>
      </tr>
      <tr>
          <td>io_redirect_bits_level</td>
          <td>input</td>
          <td>1</td>
          <td>重定向级别信号，表示重定向的优先级</td>
      </tr>
      <tr>
          <td>io_csrCtrl_hd_misalign_st_enable</td>
          <td>input</td>
          <td>1</td>
          <td>控制Misalign Store启用信号，指示是否启用未对齐存储</td>
      </tr>
      <tr>
          <td>io_stin_valid</td>
          <td>input</td>
          <td>1</td>
          <td>输入有效信号，指示是否有有效的存储指令</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_ftqPtr_flag</td>
          <td>input</td>
          <td>1</td>
          <td>指令FTQ指针标志，标记指令在队列中的位置</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_ftqPtr_value</td>
          <td>input</td>
          <td>6</td>
          <td>指令FTQ指针值，指示指令在队列中的位置</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_ftqOffset</td>
          <td>input</td>
          <td>4</td>
          <td>指令FTQ偏移量，指示指令在队列中的偏移</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_fuType</td>
          <td>input</td>
          <td>35</td>
          <td>功能单元类型，指示该指令使用的功能单元类型</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_fuOpType</td>
          <td>input</td>
          <td>9</td>
          <td>功能单元操作类型，指示该指令执行的操作类型</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_rfWen</td>
          <td>input</td>
          <td>1</td>
          <td>指令是否写入寄存器，表示是否更新寄存器值</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_imm</td>
          <td>input</td>
          <td>32</td>
          <td>指令立即数，包含该指令中的常数值</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_pdest</td>
          <td>input</td>
          <td>8</td>
          <td>指令目的寄存器编号，表示数据存储的目标寄存器</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_robIdx_flag</td>
          <td>input</td>
          <td>1</td>
          <td>ROB索引标志，表示是否使用ROB索引</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_robIdx_value</td>
          <td>input</td>
          <td>8</td>
          <td>ROB索引值，指示指令对应的ROB索引</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_debugInfo_eliminatedMove</td>
          <td>input</td>
          <td>1</td>
          <td>指令优化消除的移动，标识指令是否被优化</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_debugInfo_renameTime</td>
          <td>input</td>
          <td>64</td>
          <td>指令重命名时间，记录指令的重命名时间</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_debugInfo_dispatchTime</td>
          <td>input</td>
          <td>64</td>
          <td>指令调度时间，记录指令进入调度队列的时间</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_debugInfo_enqRsTime</td>
          <td>input</td>
          <td>64</td>
          <td>指令入队时间，记录指令进入执行队列的时间</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_debugInfo_selectTime</td>
          <td>input</td>
          <td>64</td>
          <td>指令选择时间，记录指令被选中执行的时间</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_debugInfo_issueTime</td>
          <td>input</td>
          <td>64</td>
          <td>指令发射时间，指示指令进入执行单元的时间</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_debugInfo_writebackTime</td>
          <td>input</td>
          <td>64</td>
          <td>指令回写时间，表示指令将结果回写到寄存器的时间</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_debugInfo_runahead_checkpoint_id</td>
          <td>input</td>
          <td>64</td>
          <td>预执行检查点ID，用于标记预执行阶段的检查点</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_debugInfo_tlbFirstReqTime</td>
          <td>input</td>
          <td>64</td>
          <td>TLB首次请求时间，记录指令发起首次TLB请求的时间</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_debugInfo_tlbRespTime</td>
          <td>input</td>
          <td>64</td>
          <td>TLB响应时间，记录指令收到TLB响应的时间</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_lqIdx_flag</td>
          <td>input</td>
          <td>1</td>
          <td>Load Queue索引标志，指示是否使用Load Queue</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_lqIdx_value</td>
          <td>input</td>
          <td>7</td>
          <td>Load Queue索引值，标识该指令在Load Queue中的位置</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_sqIdx_flag</td>
          <td>input</td>
          <td>1</td>
          <td>Store Queue索引标志，指示是否使用Store Queue</td>
      </tr>
      <tr>
          <td>io_stin_bits_uop_sqIdx_value</td>
          <td>input</td>
          <td>6</td>
          <td>Store Queue索引值，标识该指令在Store Queue中的位置</td>
      </tr>
      <tr>
          <td>io_stin_bits_src_0</td>
          <td>input</td>
          <td>64</td>
          <td>数据源0，提供给指令执行的数据源</td>
      </tr>
      <tr>
          <td>io_stin_bits_isFirstIssue</td>
          <td>input</td>
          <td>1</td>
          <td>是否是第一次发射，表示指令是否首次被发射</td>
      </tr>
      <tr>
          <td>io_misalign_stin_valid</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入有效信号，指示Misalign Store是否接收有效数据</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_0</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量0，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_1</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量1，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_2</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量2，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_4</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量4，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_5</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量5，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_8</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量8，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_9</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量9，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_10</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量10，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_11</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量11，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_12</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量12，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_13</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量13，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_14</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量14，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_16</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量16，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_17</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量17，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_18</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量18，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_19</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量19，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_20</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量20，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_21</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量21，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_exceptionVec_22</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入异常向量22，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_ftqPtr_flag</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入FTQ指针标志，表示指令位置</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_ftqPtr_value</td>
          <td>input</td>
          <td>6</td>
          <td>Misalign Store输入FTQ指针值，指示指令在队列中的位置</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_ftqOffset</td>
          <td>input</td>
          <td>4</td>
          <td>Misalign Store输入FTQ偏移量，表示指令在队列中的偏移</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_fuType</td>
          <td>input</td>
          <td>35</td>
          <td>Misalign Store输入功能单元类型，表示指令所需的功能单元</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_fuOpType</td>
          <td>input</td>
          <td>9</td>
          <td>Misalign Store输入功能单元操作类型，表示指令执行的操作类型</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_rfWen</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入是否写入寄存器，标识是否会更新寄存器</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_vpu_vstart</td>
          <td>input</td>
          <td>8</td>
          <td>Misalign Store输入VPU向量起始位置，标识向量操作的起始位置</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_vpu_nf</td>
          <td>input</td>
          <td>3</td>
          <td>Misalign Store输入VPU向量元素数，表示该向量操作的元素数量</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_vpu_veew</td>
          <td>input</td>
          <td>2</td>
          <td>Misalign Store输入VPU向量元素宽度，表示向量的元素宽度</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_uopIdx</td>
          <td>input</td>
          <td>7</td>
          <td>Misalign Store输入操作索引，表示该指令的操作索引</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_pdest</td>
          <td>input</td>
          <td>8</td>
          <td>Misalign Store输入目的寄存器，表示存储的目标寄存器</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_robIdx_flag</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入ROB索引标志，表示是否使用ROB索引</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_robIdx_value</td>
          <td>input</td>
          <td>8</td>
          <td>Misalign Store输入ROB索引值，表示该操作对应的ROB索引</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_debugInfo_eliminatedMove</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入优化消除的移动，表示该操作是否被优化消除</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_debugInfo_renameTime</td>
          <td>input</td>
          <td>64</td>
          <td>Misalign Store输入指令重命名时间，记录指令的重命名时间</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_debugInfo_dispatchTime</td>
          <td>input</td>
          <td>64</td>
          <td>Misalign Store输入指令调度时间，表示指令进入调度队列的时间</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_debugInfo_enqRsTime</td>
          <td>input</td>
          <td>64</td>
          <td>Misalign Store输入指令入队时间，表示指令加入执行队列的时间</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_debugInfo_selectTime</td>
          <td>input</td>
          <td>64</td>
          <td>Misalign Store输入指令选择时间，表示指令被选中执行的时间</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_debugInfo_issueTime</td>
          <td>input</td>
          <td>64</td>
          <td>Misalign Store输入指令发射时间，表示指令发射到执行单元的时间</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_debugInfo_writebackTime</td>
          <td>input</td>
          <td>64</td>
          <td>Misalign Store输入指令回写时间，表示指令回写结果的时间</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_debugInfo_runahead_checkpoint_id</td>
          <td>input</td>
          <td>64</td>
          <td>Misalign Store输入指令预执行检查点ID，标记指令的预执行检查点</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_debugInfo_tlbFirstReqTime</td>
          <td>input</td>
          <td>64</td>
          <td>Misalign Store输入指令TLB首次请求时间，表示该指令发起首次TLB请求的时间</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_debugInfo_tlbRespTime</td>
          <td>input</td>
          <td>64</td>
          <td>Misalign Store输入指令TLB响应时间，表示该指令收到TLB响应的时间</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_lqIdx_flag</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入Load Queue索引标志，表示是否使用Load Queue</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_lqIdx_value</td>
          <td>input</td>
          <td>7</td>
          <td>Misalign Store输入Load Queue索引值，标识该指令在Load Queue中的位置</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_sqIdx_flag</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入Store Queue索引标志，表示是否使用Store Queue</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_uop_sqIdx_value</td>
          <td>input</td>
          <td>6</td>
          <td>Misalign Store输入Store Queue索引值，标识该指令在Store Queue中的位置</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_vaddr</td>
          <td>input</td>
          <td>50</td>
          <td>Misalign Store输入虚拟地址，表示存储请求的虚拟地址</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_mask</td>
          <td>input</td>
          <td>16</td>
          <td>Misalign Store输入掩码，标识存储操作涉及的字节</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_isvec</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入是否为向量操作，指示是否为向量Store指令</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_is128bit</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入是否为128位操作，标识该操作是否为128位数据存储</td>
      </tr>
      <tr>
          <td>io_misalign_stin_bits_isFinalSplit</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign Store输入是否为最终分割，指示该操作是否为最后一次存储操作</td>
      </tr>
      <tr>
          <td>io_tlb_resp_valid</td>
          <td>input</td>
          <td>1</td>
          <td>TLB响应有效信号，指示是否收到有效的TLB响应</td>
      </tr>
      <tr>
          <td>io_tlb_resp_bits_paddr_0</td>
          <td>input</td>
          <td>48</td>
          <td>TLB响应物理地址0，表示TLB响应中的物理地址</td>
      </tr>
      <tr>
          <td>io_tlb_resp_bits_gpaddr_0</td>
          <td>input</td>
          <td>64</td>
          <td>TLB响应通用物理地址0，提供对应的物理地址</td>
      </tr>
      <tr>
          <td>io_tlb_resp_bits_fullva</td>
          <td>input</td>
          <td>64</td>
          <td>TLB响应完整虚拟地址，表示该指令请求的完整虚拟地址</td>
      </tr>
      <tr>
          <td>io_tlb_resp_bits_pbmt_0</td>
          <td>input</td>
          <td>2</td>
          <td>TLB响应页面映射类型0，指示TLB响应的页面映射类型</td>
      </tr>
      <tr>
          <td>io_tlb_resp_bits_miss</td>
          <td>input</td>
          <td>1</td>
          <td>TLB响应是否命中，指示TLB是否命中请求的地址</td>
      </tr>
      <tr>
          <td>io_tlb_resp_bits_isForVSnonLeafPTE</td>
          <td>input</td>
          <td>1</td>
          <td>TLB响应是否为非叶PTE，指示是否为虚拟化的非叶页面表项</td>
      </tr>
      <tr>
          <td>io_tlb_resp_bits_excp_0_vaNeedExt</td>
          <td>input</td>
          <td>1</td>
          <td>TLB响应是否需要扩展虚拟地址，表示是否需要扩展地址</td>
      </tr>
      <tr>
          <td>io_tlb_resp_bits_excp_0_isHyper</td>
          <td>input</td>
          <td>1</td>
          <td>TLB响应是否为Hypervisor模式的异常，表示TLB异常是否是超级管理模式</td>
      </tr>
      <tr>
          <td>io_tlb_resp_bits_excp_0_gpf_st</td>
          <td>input</td>
          <td>1</td>
          <td>TLB响应是否为一般保护异常，指示TLB请求是否发生一般保护错误</td>
      </tr>
      <tr>
          <td>io_tlb_resp_bits_excp_0_pf_st</td>
          <td>input</td>
          <td>1</td>
          <td>TLB响应是否为页面错误异常，指示TLB请求是否发生页面错误</td>
      </tr>
      <tr>
          <td>io_tlb_resp_bits_excp_0_af_st</td>
          <td>input</td>
          <td>1</td>
          <td>TLB响应是否为地址错误异常，指示TLB请求是否发生地址错误</td>
      </tr>
      <tr>
          <td>io_tlb_resp_bits_ptwBack</td>
          <td>input</td>
          <td>1</td>
          <td>TLB响应是否为物理地址翻译回写，表示TLB响应是否涉及物理地址回写</td>
      </tr>
      <tr>
          <td>io_tlb_resp_bits_memidx_idx</td>
          <td>input</td>
          <td>7</td>
          <td>TLB响应内存索引索引，指示TLB响应所在的内存块索引</td>
      </tr>
      <tr>
          <td>io_pmp_st</td>
          <td>input</td>
          <td>1</td>
          <td>PMP状态信号，表示是否为物理内存保护状态</td>
      </tr>
      <tr>
          <td>io_pmp_mmio</td>
          <td>input</td>
          <td>1</td>
          <td>PMP内存映射IO信号，表示是否涉及内存映射IO</td>
      </tr>
      <tr>
          <td>io_pmp_atomic</td>
          <td>input</td>
          <td>1</td>
          <td>PMP原子操作信号，表示是否为原子操作请求</td>
      </tr>
      <tr>
          <td>io_prefetch_req_bits_vaddr</td>
          <td>input</td>
          <td>50</td>
          <td>预取请求的虚拟地址，表示请求的虚拟地址</td>
      </tr>
      <tr>
          <td>io_vecstin_valid</td>
          <td>input</td>
          <td>1</td>
          <td>向量Store输入有效信号，指示是否有有效的输入数据</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_vaddr</td>
          <td>input</td>
          <td>64</td>
          <td>向量Store输入虚拟地址，表示该操作的虚拟地址</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_basevaddr</td>
          <td>input</td>
          <td>50</td>
          <td>向量Store输入基准虚拟地址，表示向量操作的基准虚拟地址</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_mask</td>
          <td>input</td>
          <td>16</td>
          <td>向量Store输入掩码，表示该向量操作涉及的字节</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_alignedType</td>
          <td>input</td>
          <td>3</td>
          <td>向量Store输入对齐类型，表示向量操作的对齐类型</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_vecActive</td>
          <td>input</td>
          <td>1</td>
          <td>向量Store输入是否为激活的向量操作</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_exceptionVec_4</td>
          <td>input</td>
          <td>1</td>
          <td>向量Store输入异常向量4，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_exceptionVec_5</td>
          <td>input</td>
          <td>1</td>
          <td>向量Store输入异常向量5，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_exceptionVec_6</td>
          <td>input</td>
          <td>1</td>
          <td>向量Store输入异常向量6，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_exceptionVec_13</td>
          <td>input</td>
          <td>1</td>
          <td>向量Store输入异常向量13，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_exceptionVec_21</td>
          <td>input</td>
          <td>1</td>
          <td>向量Store输入异常向量21，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_ftqPtr_flag</td>
          <td>input</td>
          <td>1</td>
          <td>向量Store输入FTQ指针标志，表示指令在队列中的位置</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_ftqPtr_value</td>
          <td>input</td>
          <td>6</td>
          <td>向量Store输入FTQ指针值，指示指令在队列中的位置</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_ftqOffset</td>
          <td>input</td>
          <td>4</td>
          <td>向量Store输入FTQ偏移量，表示指令在队列中的偏移</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_fuType</td>
          <td>input</td>
          <td>35</td>
          <td>向量Store输入功能单元类型，表示指令所需的功能单元</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_fuOpType</td>
          <td>input</td>
          <td>9</td>
          <td>向量Store输入功能单元操作类型，表示指令执行的操作类型</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_rfWen</td>
          <td>input</td>
          <td>1</td>
          <td>向量Store输入是否写入寄存器，表示该指令是否会更新寄存器值</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_vpu_vstart</td>
          <td>input</td>
          <td>8</td>
          <td>向量Store输入VPU向量起始位置，标识向量操作的起始位置</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_vpu_nf</td>
          <td>input</td>
          <td>3</td>
          <td>向量Store输入VPU向量元素数，表示该向量操作的元素数量</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_vpu_veew</td>
          <td>input</td>
          <td>2</td>
          <td>向量Store输入VPU向量元素宽度，表示向量的元素宽度</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_uopIdx</td>
          <td>input</td>
          <td>7</td>
          <td>向量Store输入操作索引，表示该指令的操作索引</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_pdest</td>
          <td>input</td>
          <td>8</td>
          <td>向量Store输入目的寄存器，表示存储的目标寄存器</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_robIdx_flag</td>
          <td>input</td>
          <td>1</td>
          <td>向量Store输入ROB索引标志，表示是否使用ROB索引</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_robIdx_value</td>
          <td>input</td>
          <td>8</td>
          <td>向量Store输入ROB索引值，表示该操作对应的ROB索引</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_debugInfo_eliminatedMove</td>
          <td>input</td>
          <td>1</td>
          <td>向量Store输入优化消除的移动，标识该操作是否被优化消除</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_debugInfo_renameTime</td>
          <td>input</td>
          <td>64</td>
          <td>向量Store输入指令重命名时间，表示该Store指令的重命名时间</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_debugInfo_dispatchTime</td>
          <td>input</td>
          <td>64</td>
          <td>向量Store输入指令调度时间，表示该Store指令的调度时间</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_debugInfo_enqRsTime</td>
          <td>input</td>
          <td>64</td>
          <td>向量Store输入指令入队时间，表示该Store指令的入队时间</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_debugInfo_selectTime</td>
          <td>input</td>
          <td>64</td>
          <td>向量Store输入指令选择时间，表示该Store指令的选择时间</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_debugInfo_issueTime</td>
          <td>input</td>
          <td>64</td>
          <td>向量Store输入指令发射时间，表示该Store指令的发射时间</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_debugInfo_writebackTime</td>
          <td>input</td>
          <td>64</td>
          <td>向量Store输入指令回写时间，表示该Store指令的回写时间</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_debugInfo_runahead_checkpoint_id</td>
          <td>input</td>
          <td>64</td>
          <td>向量Store输入指令预执行检查点ID，标记该Store指令的预执行阶段</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_debugInfo_tlbFirstReqTime</td>
          <td>input</td>
          <td>64</td>
          <td>向量Store输入指令TLB首次请求时间，表示该Store指令的首次TLB请求时间</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_debugInfo_tlbRespTime</td>
          <td>input</td>
          <td>64</td>
          <td>向量Store输入指令TLB响应时间，表示该Store指令的TLB响应时间</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_lqIdx_flag</td>
          <td>input</td>
          <td>1</td>
          <td>向量Store输入Load Queue索引标志，指示是否使用Load Queue</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_lqIdx_value</td>
          <td>input</td>
          <td>7</td>
          <td>向量Store输入Load Queue索引值，标识该指令在Load Queue中的位置</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_sqIdx_flag</td>
          <td>input</td>
          <td>1</td>
          <td>向量Store输入Store Queue索引标志，指示是否使用Store Queue</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_uop_sqIdx_value</td>
          <td>input</td>
          <td>6</td>
          <td>向量Store输入Store Queue索引值，标识该指令在Store Queue中的位置</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_mBIndex</td>
          <td>input</td>
          <td>4</td>
          <td>向量Store输入块索引，标识该向量操作的块索引</td>
      </tr>
      <tr>
          <td>io_vecstin_bits_elemIdx</td>
          <td>input</td>
          <td>8</td>
          <td>向量Store输入元素索引，标识该向量操作的元素索引</td>
      </tr>
      <tr>
          <td>io_misalign_buf_ready</td>
          <td>input</td>
          <td>1</td>
          <td>Misalign缓冲区准备信号，指示Misalign操作是否准备好接收数据</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_0_matchType</td>
          <td>input</td>
          <td>2</td>
          <td>从CSR触发器接收的数据向量0匹配类型，指示匹配类型</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_0_select</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量0选择标志，指示是否选择该向量</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_0_timing</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量0定时标志，表示触发的定时信息</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_0_action</td>
          <td>input</td>
          <td>4</td>
          <td>从CSR触发器接收的数据向量0动作类型，表示触发动作</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_0_chain</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量0链操作标志，指示是否为链操作</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_0_store</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量0存储标志，指示是否为存储操作</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_0_tdata2</td>
          <td>input</td>
          <td>64</td>
          <td>从CSR触发器接收的数据向量0附加数据2</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_1_matchType</td>
          <td>input</td>
          <td>2</td>
          <td>从CSR触发器接收的数据向量1匹配类型，指示匹配类型</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_1_select</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量1选择标志，指示是否选择该向量</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_1_timing</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量1定时标志，表示触发的定时信息</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_1_action</td>
          <td>input</td>
          <td>4</td>
          <td>从CSR触发器接收的数据向量1动作类型，表示触发动作</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_1_chain</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量1链操作标志，指示是否为链操作</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_1_store</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量1存储标志，指示是否为存储操作</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_1_tdata2</td>
          <td>input</td>
          <td>64</td>
          <td>从CSR触发器接收的数据向量1附加数据2</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_2_matchType</td>
          <td>input</td>
          <td>2</td>
          <td>从CSR触发器接收的数据向量2匹配类型，指示匹配类型</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_2_select</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量2选择标志，指示是否选择该向量</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_2_timing</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量2定时标志，表示触发的定时信息</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_2_action</td>
          <td>input</td>
          <td>4</td>
          <td>从CSR触发器接收的数据向量2动作类型，表示触发动作</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_2_chain</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量2链操作标志，指示是否为链操作</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_2_store</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量2存储标志，指示是否为存储操作</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_2_tdata2</td>
          <td>input</td>
          <td>64</td>
          <td>从CSR触发器接收的数据向量2附加数据2</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_3_matchType</td>
          <td>input</td>
          <td>2</td>
          <td>从CSR触发器接收的数据向量3匹配类型，指示匹配类型</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_3_select</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量3选择标志，指示是否选择该向量</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_3_timing</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量3定时标志，表示触发的定时信息</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_3_action</td>
          <td>input</td>
          <td>4</td>
          <td>从CSR触发器接收的数据向量3动作类型，表示触发动作</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_3_chain</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量3链操作标志，指示是否为链操作</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_3_store</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的数据向量3存储标志，指示是否为存储操作</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tdataVec_3_tdata2</td>
          <td>input</td>
          <td>64</td>
          <td>从CSR触发器接收的数据向量3附加数据2</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tEnableVec_0</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的启用信号0，指示是否启用该向量</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tEnableVec_1</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的启用信号1，指示是否启用该向量</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tEnableVec_2</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的启用信号2，指示是否启用该向量</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_tEnableVec_3</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的启用信号3，指示是否启用该向量</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_debugMode</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的调试模式标志，指示是否为调试模式</td>
      </tr>
      <tr>
          <td>io_fromCsrTrigger_triggerCanRaiseBpExp</td>
          <td>input</td>
          <td>1</td>
          <td>从CSR触发器接收的触发是否可以引发BP异常标志</td>
      </tr>
  </tbody>
</table>
<h3 id="输出接口">输出接口</h3>
<table>
  <thead>
      <tr>
          <th>信号名</th>
          <th>方向</th>
          <th>位宽</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>io_stin_ready</td>
          <td>output</td>
          <td>1</td>
          <td>输入准备信号，指示是否准备好接收数据</td>
      </tr>
      <tr>
          <td>io_issue_valid</td>
          <td>output</td>
          <td>1</td>
          <td>指令有效信号，指示该指令是否有效</td>
      </tr>
      <tr>
          <td>io_issue_bits_uop_robIdx_flag</td>
          <td>output</td>
          <td>1</td>
          <td>指令ROB索引标志，标示该指令是否使用ROB索引</td>
      </tr>
      <tr>
          <td>io_issue_bits_uop_robIdx_value</td>
          <td>output</td>
          <td>8</td>
          <td>指令ROB索引值，提供该指令的ROB索引</td>
      </tr>
      <tr>
          <td>io_misalign_stin_ready</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign Store输入准备信号，指示Misalign Store是否准备好接收数据</td>
      </tr>
      <tr>
          <td>io_misalign_stout_valid</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign Store输出有效信号，指示是否有有效的输出结果</td>
      </tr>
      <tr>
          <td>io_misalign_stout_bits_uop_exceptionVec_3</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign Store输出异常向量3，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_misalign_stout_bits_uop_exceptionVec_6</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign Store输出异常向量6，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_misalign_stout_bits_uop_exceptionVec_7</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign Store输出异常向量7，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_misalign_stout_bits_uop_exceptionVec_15</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign Store输出异常向量15，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_misalign_stout_bits_uop_exceptionVec_23</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign Store输出异常向量23，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_misalign_stout_bits_uop_trigger</td>
          <td>output</td>
          <td>4</td>
          <td>Misalign Store输出触发器，标记触发的异常类型</td>
      </tr>
      <tr>
          <td>io_misalign_stout_bits_paddr</td>
          <td>output</td>
          <td>48</td>
          <td>Misalign Store输出物理地址，表示该操作的目标物理地址</td>
      </tr>
      <tr>
          <td>io_misalign_stout_bits_mmio</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign Store输出是否为MMIO操作，标识是否为内存映射IO操作</td>
      </tr>
      <tr>
          <td>io_misalign_stout_bits_vecActive</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign Store向量激活标志，指示是否为有效的向量存储操作</td>
      </tr>
      <tr>
          <td>io_misalign_stout_bits_need_rep</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign Store输出是否需要重发标志，指示该操作是否需要重发</td>
      </tr>
      <tr>
          <td>io_tlb_req_valid</td>
          <td>output</td>
          <td>1</td>
          <td>TLB请求有效信号，指示是否有有效的TLB请求</td>
      </tr>
      <tr>
          <td>io_tlb_req_bits_vaddr</td>
          <td>output</td>
          <td>50</td>
          <td>TLB请求的虚拟地址，提供请求的虚拟地址</td>
      </tr>
      <tr>
          <td>io_tlb_req_bits_fullva</td>
          <td>output</td>
          <td>64</td>
          <td>TLB请求的完整虚拟地址，包含更多的地址信息</td>
      </tr>
      <tr>
          <td>io_tlb_req_bits_checkfullva</td>
          <td>output</td>
          <td>1</td>
          <td>TLB检查完整虚拟地址信号，指示是否检查完整地址</td>
      </tr>
      <tr>
          <td>io_tlb_req_bits_hyperinst</td>
          <td>output</td>
          <td>1</td>
          <td>TLB请求的超指令标志，表示是否为超指令请求</td>
      </tr>
      <tr>
          <td>io_tlb_req_bits_memidx_idx</td>
          <td>output</td>
          <td>7</td>
          <td>TLB请求的内存索引，标识内存请求的索引</td>
      </tr>
      <tr>
          <td>io_tlb_req_bits_debug_robIdx_flag</td>
          <td>output</td>
          <td>1</td>
          <td>TLB请求的ROB索引调试标志，调试用</td>
      </tr>
      <tr>
          <td>io_tlb_req_bits_debug_robIdx_value</td>
          <td>output</td>
          <td>8</td>
          <td>TLB请求的ROB索引值，调试用</td>
      </tr>
      <tr>
          <td>io_tlb_req_bits_debug_isFirstIssue</td>
          <td>output</td>
          <td>1</td>
          <td>TLB请求的首次发射标志，指示是否是第一次发射</td>
      </tr>
      <tr>
          <td>io_dcache_req_valid</td>
          <td>output</td>
          <td>1</td>
          <td>数据缓存请求有效信号，表示是否有有效的数据缓存请求</td>
      </tr>
      <tr>
          <td>io_lsq_valid</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue有效信号，表示是否有有效的Load/Store指令</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_0</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量0，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_1</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量1，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_2</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量2，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_3</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量3，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_4</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量4，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_5</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量5，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_6</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量6，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_7</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量7，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_8</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量8，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_9</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量9，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_10</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量10，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_11</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量11，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_12</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量12，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_13</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量13，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_14</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量14，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_15</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量15，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_16</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量16，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_17</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量17，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_18</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量18，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_19</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量19，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_20</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量20，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_21</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量21，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_22</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量22，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_exceptionVec_23</td>
          <td>output</td>
          <td>1</td>
          <td>LSQ异常向量23，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_trigger</td>
          <td>output</td>
          <td>4</td>
          <td>Load Store Queue操作触发器，表示触发的异常类型</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_ftqPtr_flag</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue FTQ指针标志，标记指令在队列中的位置</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_ftqPtr_value</td>
          <td>output</td>
          <td>6</td>
          <td>Load Store Queue FTQ指针值，指示指令在队列中的位置</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_ftqOffset</td>
          <td>output</td>
          <td>4</td>
          <td>Load Store Queue FTQ偏移量，表示指令在队列中的偏移</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_fuType</td>
          <td>output</td>
          <td>35</td>
          <td>Load Store Queue功能单元类型，表示指令所需的功能单元</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_fuOpType</td>
          <td>output</td>
          <td>9</td>
          <td>Load Store Queue功能单元操作类型，表示指令执行的操作类型</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_rfWen</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue是否写入寄存器，表示该指令是否会更新寄存器值</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_vpu_nf</td>
          <td>output</td>
          <td>3</td>
          <td>Load Store Queue VPU向量元素数，表示该向量操作的元素数量</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_vpu_veew</td>
          <td>output</td>
          <td>2</td>
          <td>Load Store Queue VPU向量元素宽度，表示向量的元素宽度</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_uopIdx</td>
          <td>output</td>
          <td>7</td>
          <td>Load Store Queue操作索引，表示该指令的操作索引</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_pdest</td>
          <td>output</td>
          <td>8</td>
          <td>Load Store Queue目的寄存器，表示存储的目标寄存器</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_robIdx_flag</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue ROB索引标志，表示是否使用ROB索引</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_robIdx_value</td>
          <td>output</td>
          <td>8</td>
          <td>Load Store Queue ROB索引值，表示该Store操作对应的ROB索引</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_debugInfo_eliminatedMove</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue优化消除的移动，标识该Store是否优化消除</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_debugInfo_renameTime</td>
          <td>output</td>
          <td>64</td>
          <td>Load Store Queue重命名时间，表示该指令的重命名时间</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_debugInfo_dispatchTime</td>
          <td>output</td>
          <td>64</td>
          <td>Load Store Queue调度时间，表示指令调度的时间</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_debugInfo_enqRsTime</td>
          <td>output</td>
          <td>64</td>
          <td>Load Store Queue入队时间，表示指令入队的时间</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_debugInfo_selectTime</td>
          <td>output</td>
          <td>64</td>
          <td>Load Store Queue选择时间，表示指令选择的时间</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_debugInfo_issueTime</td>
          <td>output</td>
          <td>64</td>
          <td>Load Store Queue发射时间，表示指令发射的时间</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_debugInfo_writebackTime</td>
          <td>output</td>
          <td>64</td>
          <td>Load Store Queue回写时间，表示指令回写的时间</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_debugInfo_runahead_checkpoint_id</td>
          <td>output</td>
          <td>64</td>
          <td>Load Store Queue预执行检查点ID，标记该指令的预执行阶段</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_debugInfo_tlbFirstReqTime</td>
          <td>output</td>
          <td>64</td>
          <td>Load Store Queue TLB首次请求时间，表示该指令发起TLB请求的时间</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_debugInfo_tlbRespTime</td>
          <td>output</td>
          <td>64</td>
          <td>Load Store Queue TLB响应时间，表示该指令接收到TLB响应的时间</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_sqIdx_flag</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue Store Queue索引标志，指示是否涉及Store Queue</td>
      </tr>
      <tr>
          <td>io_lsq_bits_uop_sqIdx_value</td>
          <td>output</td>
          <td>6</td>
          <td>Load Store Queue Store Queue索引值，标识该指令在Store Queue中的位置</td>
      </tr>
      <tr>
          <td>io_lsq_bits_vaddr</td>
          <td>output</td>
          <td>50</td>
          <td>Load Store Queue虚拟地址，表示请求的虚拟地址</td>
      </tr>
      <tr>
          <td>io_lsq_bits_fullva</td>
          <td>output</td>
          <td>64</td>
          <td>Load Store Queue完整虚拟地址，表示请求的完整虚拟地址</td>
      </tr>
      <tr>
          <td>io_lsq_bits_vaNeedExt</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue虚拟地址是否需要扩展，指示是否需要扩展虚拟地址</td>
      </tr>
      <tr>
          <td>io_lsq_bits_paddr</td>
          <td>output</td>
          <td>48</td>
          <td>Load Store Queue物理地址，表示指令执行后的物理地址</td>
      </tr>
      <tr>
          <td>io_lsq_bits_gpaddr</td>
          <td>output</td>
          <td>64</td>
          <td>Load Store Queue通用物理地址，表示指令执行后的物理地址</td>
      </tr>
      <tr>
          <td>io_lsq_bits_mask</td>
          <td>output</td>
          <td>16</td>
          <td>Load Store Queue掩码，指示数据存储操作涉及的字节</td>
      </tr>
      <tr>
          <td>io_lsq_bits_wlineflag</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue是否为写回标志，表示是否写回数据</td>
      </tr>
      <tr>
          <td>io_lsq_bits_miss</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue未命中标志，表示该存储请求是否命中</td>
      </tr>
      <tr>
          <td>io_lsq_bits_nc</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue非一致性标志，表示该操作是否为非一致性操作</td>
      </tr>
      <tr>
          <td>io_lsq_bits_isHyper</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue是否为超级管理模式，指示该操作是否为超级管理模式</td>
      </tr>
      <tr>
          <td>io_lsq_bits_isForVSnonLeafPTE</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue是否为非叶PTE，指示是否为非叶页面表项操作</td>
      </tr>
      <tr>
          <td>io_lsq_bits_isvec</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue是否为向量操作，指示是否为向量Store指令</td>
      </tr>
      <tr>
          <td>io_lsq_bits_isFrmMisAlignBuf</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue是否为误对齐缓存操作，指示是否为误对齐操作</td>
      </tr>
      <tr>
          <td>io_lsq_bits_isMisalign</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue是否为误对齐操作，指示是否为误对齐存储操作</td>
      </tr>
      <tr>
          <td>io_lsq_bits_misalignWith16Byte</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue是否为16字节对齐的误对齐操作</td>
      </tr>
      <tr>
          <td>io_lsq_bits_updateAddrValid</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue地址更新有效信号，指示是否有有效的地址更新</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_uop_exceptionVec_3</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue重新补充操作异常向量3，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_uop_exceptionVec_6</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue重新补充操作异常向量6，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_uop_exceptionVec_15</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue重新补充操作异常向量15，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_uop_exceptionVec_23</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue重新补充操作异常向量23，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_uop_uopIdx</td>
          <td>output</td>
          <td>7</td>
          <td>Load Store Queue重新补充操作索引，表示该指令的操作索引</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_uop_robIdx_flag</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue重新补充操作ROB索引标志，指示是否使用ROB索引</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_uop_robIdx_value</td>
          <td>output</td>
          <td>8</td>
          <td>Load Store Queue重新补充操作ROB索引值，表示该操作对应的ROB索引</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_fullva</td>
          <td>output</td>
          <td>64</td>
          <td>Load Store Queue重新补充操作完整虚拟地址，表示该操作的完整虚拟地址</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_vaNeedExt</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue重新补充操作是否需要扩展虚拟地址</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_gpaddr</td>
          <td>output</td>
          <td>64</td>
          <td>Load Store Queue重新补充操作物理地址，表示该操作的目标物理地址</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_af</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue重新补充操作是否为地址错误标志，表示是否发生地址错误</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_mmio</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue重新补充操作是否为MMIO操作，标示是否为内存映射IO操作</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_memBackTypeMM</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue重新补充操作是否为内存回写标志，表示是否为内存回写操作</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_atomic</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue重新补充操作是否为原子操作，指示是否为原子操作</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_hasException</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue重新补充操作是否包含异常，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_isHyper</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue重新补充操作是否为超级管理模式操作，表示是否为超级管理模式操作</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_isForVSnonLeafPTE</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue重新补充操作是否为非叶PTE，指示是否为非叶页面表项操作</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_isvec</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue重新补充操作是否为向量操作，表示是否为向量Store指令</td>
      </tr>
      <tr>
          <td>io_lsq_replenish_updateAddrValid</td>
          <td>output</td>
          <td>1</td>
          <td>Load Store Queue重新补充操作地址更新有效信号，指示是否有有效的地址更新</td>
      </tr>
      <tr>
          <td>io_feedback_slow_valid</td>
          <td>output</td>
          <td>1</td>
          <td>反馈慢操作有效信号，表示是否有有效的反馈慢操作</td>
      </tr>
      <tr>
          <td>io_feedback_slow_bits_robIdx_flag</td>
          <td>output</td>
          <td>1</td>
          <td>反馈慢操作ROB索引标志，指示是否涉及ROB索引</td>
      </tr>
      <tr>
          <td>io_feedback_slow_bits_robIdx_value</td>
          <td>output</td>
          <td>8</td>
          <td>反馈慢操作ROB索引值，表示该操作对应的ROB索引</td>
      </tr>
      <tr>
          <td>io_feedback_slow_bits_hit</td>
          <td>output</td>
          <td>1</td>
          <td>反馈慢操作命中标志，表示是否命中目标地址</td>
      </tr>
      <tr>
          <td>io_feedback_slow_bits_flushState</td>
          <td>output</td>
          <td>1</td>
          <td>反馈慢操作刷新状态标志，表示是否需要刷新状态</td>
      </tr>
      <tr>
          <td>io_feedback_slow_bits_sqIdx_flag</td>
          <td>output</td>
          <td>1</td>
          <td>反馈慢操作Store Queue索引标志，指示是否涉及Store Queue</td>
      </tr>
      <tr>
          <td>io_feedback_slow_bits_sqIdx_value</td>
          <td>output</td>
          <td>6</td>
          <td>反馈慢操作Store Queue索引值，标识该操作在Store Queue中的位置</td>
      </tr>
      <tr>
          <td>io_feedback_slow_bits_lqIdx_flag</td>
          <td>output</td>
          <td>1</td>
          <td>反馈慢操作Load Queue索引标志，指示是否涉及Load Queue</td>
      </tr>
      <tr>
          <td>io_feedback_slow_bits_lqIdx_value</td>
          <td>output</td>
          <td>7</td>
          <td>反馈慢操作Load Queue索引值，标识该操作在Load Queue中的位置</td>
      </tr>
      <tr>
          <td>io_stld_nuke_query_valid</td>
          <td>output</td>
          <td>1</td>
          <td>Store Load查询有效信号，表示是否有有效的Store Load查询</td>
      </tr>
      <tr>
          <td>io_stld_nuke_query_bits_robIdx_flag</td>
          <td>output</td>
          <td>1</td>
          <td>Store Load查询ROB索引标志，指示是否涉及ROB</td>
      </tr>
      <tr>
          <td>io_stld_nuke_query_bits_robIdx_value</td>
          <td>output</td>
          <td>8</td>
          <td>Store Load查询的ROB索引值</td>
      </tr>
      <tr>
          <td>io_stld_nuke_query_bits_paddr</td>
          <td>output</td>
          <td>48</td>
          <td>Store Load查询的物理地址</td>
      </tr>
      <tr>
          <td>io_stld_nuke_query_bits_mask</td>
          <td>output</td>
          <td>16</td>
          <td>Store Load查询的掩码</td>
      </tr>
      <tr>
          <td>io_stld_nuke_query_bits_matchLine</td>
          <td>output</td>
          <td>1</td>
          <td>Store Load查询的匹配行标志，表示是否匹配</td>
      </tr>
      <tr>
          <td>io_stout_valid</td>
          <td>output</td>
          <td>1</td>
          <td>Store操作有效信号，表示是否有有效的Store操作</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_exceptionVec_3</td>
          <td>output</td>
          <td>1</td>
          <td>Store输出异常向量3，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_exceptionVec_6</td>
          <td>output</td>
          <td>1</td>
          <td>Store输出异常向量6，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_exceptionVec_7</td>
          <td>output</td>
          <td>1</td>
          <td>Store输出异常向量7，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_exceptionVec_15</td>
          <td>output</td>
          <td>1</td>
          <td>Store输出异常向量15，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_exceptionVec_23</td>
          <td>output</td>
          <td>1</td>
          <td>Store输出异常向量23，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_trigger</td>
          <td>output</td>
          <td>4</td>
          <td>Store操作触发器，标记触发的异常类型</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_rfWen</td>
          <td>output</td>
          <td>1</td>
          <td>Store是否写入寄存器，表示该指令是否会更新寄存器</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_pdest</td>
          <td>output</td>
          <td>8</td>
          <td>Store目的寄存器，表示该操作的目标寄存器</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_robIdx_flag</td>
          <td>output</td>
          <td>1</td>
          <td>Store ROB索引标志，指示是否使用ROB索引</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_robIdx_value</td>
          <td>output</td>
          <td>8</td>
          <td>Store ROB索引值，表示该操作对应的ROB索引</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_debugInfo_eliminatedMove</td>
          <td>output</td>
          <td>1</td>
          <td>Store输出优化消除的移动，表示该Store是否优化消除</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_debugInfo_renameTime</td>
          <td>output</td>
          <td>64</td>
          <td>Store输出指令重命名时间，表示该Store指令的重命名时间</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_debugInfo_dispatchTime</td>
          <td>output</td>
          <td>64</td>
          <td>Store输出指令调度时间，表示该Store指令的调度时间</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_debugInfo_enqRsTime</td>
          <td>output</td>
          <td>64</td>
          <td>Store输出指令入队时间，表示该Store指令的入队时间</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_debugInfo_selectTime</td>
          <td>output</td>
          <td>64</td>
          <td>Store输出指令选择时间，表示该Store指令的选择时间</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_debugInfo_issueTime</td>
          <td>output</td>
          <td>64</td>
          <td>Store输出指令发射时间，表示该Store指令的发射时间</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_debugInfo_writebackTime</td>
          <td>output</td>
          <td>64</td>
          <td>Store输出指令回写时间，表示该Store指令的回写时间</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_debugInfo_runahead_checkpoint_id</td>
          <td>output</td>
          <td>64</td>
          <td>Store输出指令预执行检查点ID，标记该Store指令的预执行检查点</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_debugInfo_tlbFirstReqTime</td>
          <td>output</td>
          <td>64</td>
          <td>Store输出指令TLB首次请求时间，表示该Store指令的首次TLB请求时间</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_debugInfo_tlbRespTime</td>
          <td>output</td>
          <td>64</td>
          <td>Store输出指令TLB响应时间，表示该Store指令的TLB响应时间</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_sqIdx_flag</td>
          <td>output</td>
          <td>1</td>
          <td>Store输出Store Queue索引标志，指示是否使用Store Queue</td>
      </tr>
      <tr>
          <td>io_stout_bits_uop_sqIdx_value</td>
          <td>output</td>
          <td>6</td>
          <td>Store输出Store Queue索引值，标识该Store操作在Store Queue中的位置</td>
      </tr>
      <tr>
          <td>io_stout_bits_debug_isMMIO</td>
          <td>output</td>
          <td>1</td>
          <td>Store输出是否为MMIO操作，标示该Store操作是否为内存映射IO操作</td>
      </tr>
      <tr>
          <td>io_stout_bits_debug_isNC</td>
          <td>output</td>
          <td>1</td>
          <td>Store输出是否为非一致性操作，指示该操作是否为非一致性操作</td>
      </tr>
      <tr>
          <td>io_stout_bits_debug_paddr</td>
          <td>output</td>
          <td>48</td>
          <td>Store输出物理地址，表示该操作的目标物理地址</td>
      </tr>
      <tr>
          <td>io_stout_bits_debug_vaddr</td>
          <td>output</td>
          <td>50</td>
          <td>Store输出虚拟地址，表示该操作的目标虚拟地址</td>
      </tr>
      <tr>
          <td>io_vecstout_valid</td>
          <td>output</td>
          <td>1</td>
          <td>向量Store结果有效信号，表示是否有有效的向量Store结果</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_mBIndex</td>
          <td>output</td>
          <td>4</td>
          <td>向量Store块索引，标识该向量Store操作的块索引</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_hit</td>
          <td>output</td>
          <td>1</td>
          <td>向量Store命中标志，表示该向量Store操作是否命中目标地址</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_trigger</td>
          <td>output</td>
          <td>4</td>
          <td>向量Store触发器，标识触发的异常类型</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_exceptionVec_3</td>
          <td>output</td>
          <td>1</td>
          <td>向量Store异常向量3，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_exceptionVec_6</td>
          <td>output</td>
          <td>1</td>
          <td>向量Store异常向量6，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_exceptionVec_7</td>
          <td>output</td>
          <td>1</td>
          <td>向量Store异常向量7，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_exceptionVec_15</td>
          <td>output</td>
          <td>1</td>
          <td>向量Store异常向量15，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_exceptionVec_23</td>
          <td>output</td>
          <td>1</td>
          <td>向量Store异常向量23，表示该异常是否发生</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_hasException</td>
          <td>output</td>
          <td>1</td>
          <td>向量Store是否有异常，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_vaddr</td>
          <td>output</td>
          <td>64</td>
          <td>向量Store虚拟地址，表示该操作的目标虚拟地址</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_vaNeedExt</td>
          <td>output</td>
          <td>1</td>
          <td>向量Store虚拟地址扩展标志，指示是否需要扩展虚拟地址</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_gpaddr</td>
          <td>output</td>
          <td>64</td>
          <td>向量Store物理地址，表示该操作的目标物理地址</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_isForVSnonLeafPTE</td>
          <td>output</td>
          <td>1</td>
          <td>向量Store是否为非叶PTE，表示是否为非叶页面表项操作</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_vstart</td>
          <td>output</td>
          <td>8</td>
          <td>向量Store起始位置，表示该向量操作的起始位置</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_elemIdx</td>
          <td>output</td>
          <td>8</td>
          <td>向量Store元素索引，标识该向量操作的元素索引</td>
      </tr>
      <tr>
          <td>io_vecstout_bits_mask</td>
          <td>output</td>
          <td>16</td>
          <td>向量Store掩码，标识该向量操作的有效位掩码</td>
      </tr>
      <tr>
          <td>io_st_mask_out_valid</td>
          <td>output</td>
          <td>1</td>
          <td>Store Mask操作有效信号，指示是否有有效的存储掩码操作</td>
      </tr>
      <tr>
          <td>io_st_mask_out_bits_sqIdx_value</td>
          <td>output</td>
          <td>6</td>
          <td>Store Mask操作Store Queue索引值，表示该掩码操作在Store Queue中的位置</td>
      </tr>
      <tr>
          <td>io_st_mask_out_bits_mask</td>
          <td>output</td>
          <td>16</td>
          <td>Store Mask操作掩码，表示存储操作涉及的字节掩码</td>
      </tr>
      <tr>
          <td>io_vecstin_ready</td>
          <td>output</td>
          <td>1</td>
          <td>向量Store输入准备信号，指示向量Store是否准备好接收数据</td>
      </tr>
      <tr>
          <td>io_misalign_buf_valid</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区有效信号，表示是否有有效的数据</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_0</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量0，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_1</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量1，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_2</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量2，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_4</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量4，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_5</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量5，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_8</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量8，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_9</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量9，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_10</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量10，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_11</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量11，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_12</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量12，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_13</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量13，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_14</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量14，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_16</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量16，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_17</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量17，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_18</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量18，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_19</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量19，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_20</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量20，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_21</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量21，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_exceptionVec_22</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区异常向量22，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_trigger</td>
          <td>output</td>
          <td>4</td>
          <td>Misalign缓冲区触发器，表示触发的异常类型</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_ftqPtr_flag</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区FTQ指针标志，表示指令位置</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_ftqPtr_value</td>
          <td>output</td>
          <td>6</td>
          <td>Misalign缓冲区FTQ指针值，指示指令在队列中的位置</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_ftqOffset</td>
          <td>output</td>
          <td>4</td>
          <td>Misalign缓冲区FTQ偏移量，表示指令在队列中的偏移</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_fuType</td>
          <td>output</td>
          <td>35</td>
          <td>Misalign缓冲区功能单元类型，表示指令所需的功能单元</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_fuOpType</td>
          <td>output</td>
          <td>9</td>
          <td>Misalign缓冲区功能单元操作类型，表示指令执行的操作类型</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_rfWen</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区是否写入寄存器，表示该指令是否会更新寄存器</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_vpu_vstart</td>
          <td>output</td>
          <td>8</td>
          <td>Misalign缓冲区VPU向量起始位置，表示向量操作的起始位置</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_vpu_nf</td>
          <td>output</td>
          <td>3</td>
          <td>Misalign缓冲区VPU向量元素数，表示该向量操作的元素数量</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_vpu_veew</td>
          <td>output</td>
          <td>2</td>
          <td>Misalign缓冲区VPU向量元素宽度，表示向量的元素宽度</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_uopIdx</td>
          <td>output</td>
          <td>7</td>
          <td>Misalign缓冲区操作索引，表示该指令的操作索引</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_pdest</td>
          <td>output</td>
          <td>8</td>
          <td>Misalign缓冲区目的寄存器，表示存储的目标寄存器</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_robIdx_flag</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区ROB索引标志，表示是否使用ROB索引</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_robIdx_value</td>
          <td>output</td>
          <td>8</td>
          <td>Misalign缓冲区ROB索引值，表示该操作对应的ROB索引</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_debugInfo_eliminatedMove</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区优化消除的移动，标识该操作是否被优化消除</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_debugInfo_renameTime</td>
          <td>output</td>
          <td>64</td>
          <td>Misalign缓冲区指令重命名时间，记录指令的重命名时间</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_debugInfo_dispatchTime</td>
          <td>output</td>
          <td>64</td>
          <td>Misalign缓冲区指令调度时间，记录指令调度的时间</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_debugInfo_enqRsTime</td>
          <td>output</td>
          <td>64</td>
          <td>Misalign缓冲区指令入队时间，表示指令加入执行队列的时间</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_debugInfo_selectTime</td>
          <td>output</td>
          <td>64</td>
          <td>Misalign缓冲区指令选择时间，表示指令被选中执行的时间</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_debugInfo_issueTime</td>
          <td>output</td>
          <td>64</td>
          <td>Misalign缓冲区指令发射时间，表示指令发射到执行单元的时间</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_debugInfo_writebackTime</td>
          <td>output</td>
          <td>64</td>
          <td>Misalign缓冲区指令回写时间，表示指令回写的时间</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_debugInfo_runahead_checkpoint_id</td>
          <td>output</td>
          <td>64</td>
          <td>Misalign缓冲区预执行检查点ID，标记指令的预执行阶段</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_debugInfo_tlbFirstReqTime</td>
          <td>output</td>
          <td>64</td>
          <td>Misalign缓冲区指令TLB首次请求时间，表示该指令发起TLB请求的时间</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_debugInfo_tlbRespTime</td>
          <td>output</td>
          <td>64</td>
          <td>Misalign缓冲区指令TLB响应时间，表示该指令收到TLB响应的时间</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_lqIdx_flag</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区Load Queue索引标志，指示是否使用Load Queue</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_lqIdx_value</td>
          <td>output</td>
          <td>7</td>
          <td>Misalign缓冲区Load Queue索引值，标识该指令在Load Queue中的位置</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_sqIdx_flag</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区Store Queue索引标志，指示是否使用Store Queue</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_uop_sqIdx_value</td>
          <td>output</td>
          <td>6</td>
          <td>Misalign缓冲区Store Queue索引值，标识该指令在Store Queue中的位置</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_vaddr</td>
          <td>output</td>
          <td>50</td>
          <td>Misalign缓冲区虚拟地址，表示存储请求的虚拟地址</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_vaNeedExt</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区虚拟地址是否需要扩展，指示是否需要扩展虚拟地址</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_paddr</td>
          <td>output</td>
          <td>48</td>
          <td>Misalign缓冲区物理地址，表示该操作的目标物理地址</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_gpaddr</td>
          <td>output</td>
          <td>64</td>
          <td>Misalign缓冲区通用物理地址，表示该操作的目标物理地址</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_mask</td>
          <td>output</td>
          <td>16</td>
          <td>Misalign缓冲区掩码，表示存储操作涉及的字节</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_hasException</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区是否包含异常，表示是否发生异常</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_isForVSnonLeafPTE</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区是否为非叶PTE操作，表示是否为非叶页面表项操作</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_isvec</td>
          <td>output</td>
          <td>1</td>
          <td>Misalign缓冲区是否为向量操作，表示是否为向量Store指令</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_elemIdx</td>
          <td>output</td>
          <td>8</td>
          <td>Misalign缓冲区元素索引，表示该向量操作的元素索引</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_alignedType</td>
          <td>output</td>
          <td>3</td>
          <td>Misalign缓冲区对齐类型，表示向量操作的对齐类型</td>
      </tr>
      <tr>
          <td>io_misalign_buf_bits_mbIndex</td>
          <td>output</td>
          <td>4</td>
          <td>Misalign缓冲区块索引，表示该向量操作的块索引</td>
      </tr>
      <tr>
          <td>io_s0_s1_valid</td>
          <td>output</td>
          <td>1</td>
          <td>S0/S1有效信号，指示S0/S1阶段是否有效</td>
      </tr>
  </tbody>
</table>
<h2 id="接口时序">接口时序</h2>
<h3 id="接口时序实例">接口时序实例</h3>
<p><img src="../LSU-StoreUnit-Timing.svg" alt="StoreUnit接口时序"></p>
<h2 id="测试点总表">测试点总表</h2>
<mrs-testpoints>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>功能名称</th>
          <th>测试点名称</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1.1</td>
          <td>SU_DISPATCH</td>
          <td>SCALAR_DISPATCH</td>
          <td>验证标量Store指令派发时分配一个StoreQueue条目。</td>
      </tr>
      <tr>
          <td>1.2</td>
          <td>SU_DISPATCH</td>
          <td>VECTOR_DISPATCH</td>
          <td>验证向量Store指令的一个uop分配多个LSQ条目（根据元素数量）。</td>
      </tr>
      <tr>
          <td>2.1</td>
          <td>SU_STORE</td>
          <td>S0_ADDRESS_CALC</td>
          <td>验证s0阶段地址计算和仲裁是否按三类指令优先级排序。</td>
      </tr>
      <tr>
          <td>2.2</td>
          <td>SU_STORE</td>
          <td>S1_RAW_CHECK</td>
          <td>验证s1阶段RAW冒险检测发生。</td>
      </tr>
      <tr>
          <td>2.3</td>
          <td>SU_STORE</td>
          <td>S2_SQ_MARK_READY</td>
          <td>验证s2阶段StoreQueue地址就绪标记。</td>
      </tr>
      <tr>
          <td>3.1</td>
          <td>SU_VECTOR</td>
          <td>SPLIT</td>
          <td>验证向量指令拆分正确性。</td>
      </tr>
      <tr>
          <td>3.2</td>
          <td>SU_VECTOR</td>
          <td>OFFSET</td>
          <td>验证向量元素偏移地址计算。</td>
      </tr>
      <tr>
          <td>4</td>
          <td>SU_REPLAY</td>
          <td>TLB_MISS</td>
          <td>验证TLB缺失时Store指令重发。</td>
      </tr>
      <tr>
          <td>5.1</td>
          <td>SU_RAW</td>
          <td>VIOLATION</td>
          <td>验证RAW违例检测。</td>
      </tr>
      <tr>
          <td>5.2</td>
          <td>SU_RAW</td>
          <td>RECOVERY_MECH</td>
          <td>验证检测到RAW违例后的恢复（流水线清空）。</td>
      </tr>
      <tr>
          <td>6.1</td>
          <td>SU_SBUFFER</td>
          <td>WRITE_MERGE</td>
          <td>验证同一缓存块的多个Store在SBuffer中合并。</td>
      </tr>
      <tr>
          <td>6.2</td>
          <td>SU_SBUFFER</td>
          <td>PLRU_REPLACE</td>
          <td>验证SBuffer满时按PLRU策略替换。</td>
      </tr>
      <tr>
          <td>7.1</td>
          <td>SU_MMIO</td>
          <td>ORDER</td>
          <td>验证MMIO指令强顺序执行（成为ROB头）。</td>
      </tr>
      <tr>
          <td>7.2</td>
          <td>SU_MMIO</td>
          <td>EXCEPTION</td>
          <td>验证原子/向量指令访问MMIO触发异常。</td>
      </tr>
      <tr>
          <td>8.1</td>
          <td>SU_NC</td>
          <td>EXEC</td>
          <td>验证NC访问允许乱序执行。</td>
      </tr>
      <tr>
          <td>8.2</td>
          <td>SU_NC</td>
          <td>FORWARD</td>
          <td>验证Uncache模块的Store到Load转发。</td>
      </tr>
      <tr>
          <td>9.1</td>
          <td>SU_MISALIGN</td>
          <td>SCALAR_SPLIT</td>
          <td>验证标量非对齐访问跨越16B边界时拆分为两个对齐访问。</td>
      </tr>
      <tr>
          <td>9.2</td>
          <td>SU_MISALIGN</td>
          <td>SEG_HANDLE</td>
          <td>验证向量Segment指令的非对齐处理（独立路径）。</td>
      </tr>
      <tr>
          <td>9.3</td>
          <td>SU_MISALIGN</td>
          <td>EXCEPTION</td>
          <td>验证原子指令、MMIO、NC空间非对齐访问触发异常。</td>
      </tr>
      <tr>
          <td>10.1</td>
          <td>SU_ATOMIC</td>
          <td>PRELOAD</td>
          <td>验证原子指令先将缓存块读入DCache。</td>
      </tr>
      <tr>
          <td>10.2</td>
          <td>SU_ATOMIC</td>
          <td>OPS</td>
          <td>验证原子操作（如AMO）执行正确性。</td>
      </tr>
  </tbody>
</table>
</mrs-testpoints>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ee675f9c192f352a52e83ce5a137f604">12.4.2.2 - 微报告模板</h1>
    
	<p><em><strong>SCALAR_DISPATCH 测试点</strong></em></p>
<h3 id="功能描述">功能描述</h3>
<p>本测试点验证标量Store指令（如sb、sh、sw、sd）从发射队列派发到StoreUnit时，是否正确分配一个StoreQueue（SQ）条目。测试确保指令派发机制正常工作，包括SQ索引分配、状态标记和信号交互。这是StoreUnit最基本的功能，涉及指令派发流水线的初始阶段。</p>
<h3 id="输入参数">输入参数</h3>
<ul>
<li>虚拟地址（vaddr）​​：0x1000</li>
<li>存储数据（data）​​：0x12345678</li>
<li>存储大小（size）​​：1、2、4、8字节</li>
<li>首次派发标志（is_first_issue）​​：true或false</li>
<li>指令类型​：通过fuOpType设置</li>
</ul>
<h3 id="输出验证">输出验证</h3>
<ul>
<li>派发成功信号​：io_stin_ready和io_stin_valid同时为高，表示指令被接收。</li>
<li>SQ条目分配​：io_lsq_valid为高，且io_lsq_bits_updateAddrValid为高，表示SQ地址更新有效。</li>
<li>SQ索引范围​：io_lsq_bits_uop_sqIdx_value在0到SQ_SIZE-1之间（如0-63）。</li>
<li>状态标记​：SQ条目中的valid位被设置为1，robIdx正确记录。</li>
<li>后续准备​：io_stin_ready保持为高，表示可接收新指令。</li>
</ul>
<h3 id="边界条件分析">边界条件分析</h3>
<ol>
<li>不同存储大小​：测试了1字节（sb）、2字节（sh）、4字节（sw）和8字节（sd）指令，确保所有大小都能正确分配SQ条目。</li>
<li>地址对齐​：测试对齐地址（如0x1000）和不对齐地址（如0x1001），验证地址计算不影响派发。</li>
<li>首次派发与重发​：设置is_first_issue为true和false，模拟首次派发和重发场景，确保重发机制不干扰SQ分配。</li>
<li>​SQ容量边界​：通过多次派发指令，测试SQ接近满时的行为，确保索引不溢出。</li>
<li>信号时序​：验证在时钟上升沿信号稳定，避免时序问题导致派发失败。</li>
</ol>
<h3 id="结果总结">结果总结</h3>
<p>测试通过，所有验证点均符合预期。标量Store指令派发功能正常，SQ条目分配正确，边界条件处理稳健。覆盖了标量存储的所有大小类型和常见地址场景，为后续流水线阶段提供了可靠基础。无异常或错误发生，测试完整性高。</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e87cd3c3ae2d38ec14b6cb12f832a155">12.4.3 - Shield-XS:基于Bitmap的安全隔离机制</h1>
    
	

<div class="pageinfo pageinfo-primary">
<p>在香山中，什么是香山bitmap 隔离模块，如何验证？</p>
<p>Location: MMU-L2TLB-Bitmap</p>

</div>


</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-d94efa552f365634197e1fbc8c58ee6c">12.4.3.1 - Shield-XS Bitmap 基础知识</h1>
    <div class="lead">本文档介绍了bitmap 安全隔离的基础设计思想，通过阅读本文档，你可以知道为什么需要bitmap， 以及其应用场景</div>
	<p>本节将介绍 bitmap 的一些基础知识，有助于理解为什么我们需要 bitmap，本节包含：</p>
<ul>
<li><strong>背景描述</strong></li>
<li><strong>威胁模型</strong></li>
<li><strong>防御原理</strong></li>
<li><strong>工作流程</strong></li>
<li><strong>应用场景</strong></li>
</ul>
<h4 id="术语描述">术语描述</h4>
<table>
  <thead>
      <tr>
          <th>缩写</th>
          <th>全名</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>TCB</td>
          <td>Trusted Computing Base</td>
          <td>可信计算基，负责底层硬件的安全可信操作</td>
      </tr>
      <tr>
          <td>TEE</td>
          <td>Trusted Execution Environment</td>
          <td>可信执行环境</td>
      </tr>
      <tr>
          <td>MMU</td>
          <td>Memory Management Unit</td>
          <td>内存管理单元</td>
      </tr>
      <tr>
          <td>RDSM</td>
          <td>Root Domain Security Mananger</td>
          <td>根域权限管理器</td>
      </tr>
      <tr>
          <td>C-SDSM</td>
          <td>Confidencial Supervisor Domain Security Manager</td>
          <td>可信监督域 权限管理器</td>
      </tr>
      <tr>
          <td>APLIC</td>
          <td>advanced platform level interrupt controller</td>
          <td>平台级中断控制器</td>
      </tr>
      <tr>
          <td>LLC</td>
          <td>Last Lavel Cache</td>
          <td>末级缓存</td>
      </tr>
      <tr>
          <td>DMA</td>
          <td>Direct Memory Access</td>
          <td>直接内存访问</td>
      </tr>
      <tr>
          <td>CVM</td>
          <td>Confidencial Virtual Machine</td>
          <td>可信虚拟机</td>
      </tr>
      <tr>
          <td>TLB</td>
          <td>Translation Lookaside Buffer</td>
          <td>页表缓存</td>
      </tr>
      <tr>
          <td>MBMC</td>
          <td>machine level bitmap check</td>
          <td>bitmap CSR 特殊状态寄存器</td>
      </tr>
      <tr>
          <td>BMA</td>
          <td>Bitmap Adress</td>
          <td>Shield Bitmap 专属内存区域基地址</td>
      </tr>
      <tr>
          <td>CMODE</td>
          <td>Confidencial Mode</td>
          <td>开启bitmap后当前模式是否是可信</td>
      </tr>
      <tr>
          <td>BME</td>
          <td>Bitmap Enable</td>
          <td>是否开启 Bitmap</td>
      </tr>
      <tr>
          <td>PTW</td>
          <td>Page Table Walker</td>
          <td>页表遍历器</td>
      </tr>
      <tr>
          <td>HPTW</td>
          <td>Hypervisor PTW</td>
          <td>监督域页表遍历器</td>
      </tr>
      <tr>
          <td>LLPTW</td>
          <td>Last Level PTW</td>
          <td>末级页表遍历器</td>
      </tr>
  </tbody>
</table>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-dd1286eb042d33c71170880919743180">12.4.3.1.1 - 背景描述</h1>
    <div class="lead">解释下为什么需要bitmap 进行隔离</div>
	<h2 id="背景描述">背景描述</h2>
<p>自计算机问世以来，数据安全始终是至关重要的议题。在个人计算机时代，数据安全主要集中在单机硬盘等存储设备的安全性上。随着互联网时代的到来，数据安全的范畴扩展到了计算机之间数据传输的安全性，促使了安全传输协议的设计与发展。如今，在云计算时代，用户的大量数据被存储和处理在云端。在云环境中存储、共享和计算的数据面临着多重安全威胁。在云计算环境下，不同类型的负载面临各自的威胁模型包括但不限于：</p>
<p>计算型负载：恶意软件可能侵入操作系统或固件，攻击 CPU 和内存资源，导致数据泄露或系统性能下降。</p>
<p>内存型负载：恶意软件或进程可能试图访问内存型负载使用的内存区域，导致数据泄露或篡改。</p>
<p>存储型负载：存储设备及其 DMA 功能可能被攻击者利用，直接访问或篡改存储设备内存，绕过传统安全检查。</p>
<p>网络型负载：网络攻击可能利用网络接口控制器（NIC）等网络设备漏洞入侵系统，通过 DMA 功能访问或篡改内存中的敏感数据。</p>
<h4 id="不同工作负载面临的安全威胁">不同工作负载面临的安全威胁</h4>
<p><img src="../../basic00_1.png" alt="不同工作负载面临的安全威胁"></p>
<h2 id="威胁模型">威胁模型</h2>
<hr>
<table>
  <thead>
      <tr>
          <th style="text-align: left"><strong>类别</strong></th>
          <th style="text-align: left"><strong>安全准则</strong></th>
          <th style="text-align: left"><strong>描述</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>内存分配</strong></td>
          <td style="text-align: left">动态分配安全/非安全内存的能力</td>
          <td style="text-align: left">安全内存应根据需求动态分配或释放。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>内存机密性</strong></td>
          <td style="text-align: left">内存隔离</td>
          <td style="text-align: left">防止非可信计算基（non-TCB）组件读取可信执行环境（TEE）的内存。</td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left">抵御软件攻击的内存完整性</td>
          <td style="text-align: left">防止软件攻击（如内存重映射、别名攻击、重放攻击、数据破坏等）。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>共享内存</strong></td>
          <td style="text-align: left">TEE控制与非TCB组件的数据共享</td>
          <td style="text-align: left">防止非TCB代码在未经TEE同意的情况下泄露信息。</td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left">TEE控制与其他TEE的数据共DUT 享</td>
          <td style="text-align: left">支持TEE之间安全共享内存的能力。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>I/O保护</strong></td>
          <td style="text-align: left">防止非TCB设备通过DMA访问TEE内存</td>
          <td style="text-align: left">禁止未被TCB接纳的外设设备访问TEE内存。</td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left">来自TCB内设备的可信I/O</td>
          <td style="text-align: left">通过准入控制将设备绑定到TEE。</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-750b311a404f64437ad197e254e70ed8">12.4.3.1.2 - 香山 bitmap 防御原理</h1>
    <div class="lead">本节介绍了bitmap 的基础思想和工作原理</div>
	<h2 id="防御原理">防御原理</h2>
<p>针对日益复杂的负载的安全威胁，香山轻量动态隔离模型为经典负载机密虚拟机和容器设计了一种动态隔离机制，用来保护正在使用中的数据的机密性和完整性。依据不同的应用场景，将负载从安全的维度进行划分，分为安全敏感型负载和非安全敏感型负载。</p>
<p>安全敏感型负载需要运行在可信执行环境下，用来保护正在使用中数据和代码的机密性和完整性。非安全敏感型负载对数据没有安全性保护需求，执行在开放的执行环境下，保证执行的效率。</p>
<p>基于bitmap的安全隔离的防御机制，其核心原理是通过可信根在软件层面的标记（Shield-bit）来隔离和保护敏感工作负载（Sensitive Workloads）与普通工作负载（Normal Workloads），从而增强系统的安全性。以下是其防御原理的详细描述：</p>
<h3 id="1-分类与标记">1. 分类与标记</h3>
<p><strong>工作负载分类</strong>：系统将工作负载分为两类：</p>
<ul>
<li>
<p><strong>敏感工作负载（Sensitive Workloads）</strong>：需要高安全级别的任务，如机密虚拟机、安全容器的任务（隐私数据的访问、处理）等。</p>
</li>
<li>
<p><strong>普通工作负载（Normal Workloads）</strong>：常规任务，代表系统中普通的应用程序或进程，安全要求较低。</p>
</li>
</ul>
<p><strong>Shield-bit 标记</strong>：通过 “Shield-bit”（<strong>每比特代表 4KB</strong>）对敏感工作负载使用的资源进行标记，依据需此标记动态调整资源访问权限：</p>
<ul>
<li>
<p><code>Shield-bit = 1</code> 表示<strong>安全敏感资源</strong></p>
</li>
<li>
<p><code>Shield-bit = 0</code> 表示<strong>非安全敏感资源</strong></p>
</li>
</ul>
<h3 id="2-资源隔离">2. 资源隔离</h3>
<p><strong>资源池划分</strong>：<a href="/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/basic/01_bm_principle/#light_model_img">图中</a>显示资源池中包含混合的敏感和普通工作负载，但通过 Shield-bit 实现逻辑隔离。</p>
<p><strong>资源类型保护</strong>：敏感工作负载访问特定资源（如内存、IO设备、中断等）时，Shield-bit 会触发保护机制，防止普通工作负载或恶意程序越权访问。例如：</p>
<ol>
<li>
<p><strong>内存隔离</strong>：敏感数据的内存区域仅对标记为敏感的工作负载可访问。</p>
</li>
<li>
<p><strong>设备与中断保护</strong>：关键外设或中断仅允许敏感工作负载调用。</p>
</li>
</ol>
<h3 id="3-bypass-机制">3. Bypass 机制</h3>
<p><strong>Bypass Shield-bit</strong>：在单向隔离的情况下（仅对普通负载的资源访问作限制），安全敏感负载可绕过 Shield-bit 的机制直接访问资源提升性能。</p>
<h3 id="4-防御目标">4. 防御目标</h3>
<p><strong>防止横向渗透</strong>：攻击者通过普通工作负载漏洞无法访问敏感资源。</p>
<p><strong>最小权限原则</strong>：每个工作负载仅能访问其必需的资源，降低攻击面。</p>
<p><strong>动态安全调整</strong>：根据工作负载的敏感程度动态切换保护状态。</p>
<h3 id="5-技术实现">5. 技术实现</h3>
<p><strong>硬件支持</strong>：依赖内存管理单元（MMU）的扩展功能。</p>
<p><strong>软件协同</strong>：由可信计算基负责标记管理和资源调度。</p>
<span id="light_model_img"/>
<h4 id="香山shield-xs-轻量隔离模型">香山Shield-XS 轻量隔离模型</h4>
<p><img src="../../basic01_1.png" alt="香山Shield-XS 轻量隔离模型"></p>
<h3 id="6-核心工作流程">6. 核心工作流程</h3>
<h4 id="shield-xs-隔离模型工作流程">Shield-XS 隔离模型工作流程</h4>
<p><img src="../../basic01_2.png" alt="Shield-XS 隔离模型工作流程"></p>
<p><strong>A. 启动</strong></p>
<p>系统初始化，加载固件（Firmware TCB）和可信执行环境（TEE TCB）。</p>
<p>开启Bitmap安全检测功能。</p>
<p><strong>B. 配置</strong></p>
<p>设定安全策略，例如定义受保护资源（内存、IO、中断等）访问权限。</p>
<p>TEE-TCB 依据应用需求配置不同资源的安全/非安全属性。</p>
<p><strong>C. 检测</strong></p>
<p>硬件监控访问行为，识别异常或非法访问请求。</p>
<p>通过 <strong>Bitmap</strong> 或其他机制标记不信任的访问行为。</p>
<p><strong>D. 故障处理</strong></p>
<p>当检测到违规操作（如未授权的内存访问）时，触发安全机制。</p>
<h3 id="7-关键安全机制">7. 关键安全机制</h3>
<p>支持对所有地址映射类资源（内存、I/O、中断）的动态隔离。</p>
<p>资源隔离支持按需分配的，而非静态划分（区别于PMP）。</p>
<p>使用位图（Bitmap）标记资源的信任状态，快速过滤不信任的访问请求。</p>
<h3 id="8-技术特点">8. 技术特点</h3>
<p><strong>灵活性</strong><br>
动态隔离允许根据运行时需求调整安全策略，适应不同场景。</p>
<p><strong>细粒度控制</strong><br>
支持多种资源类型（内存、I/O、中断）的精细化权限管理。</p>
<p><strong>轻量级检测</strong><br>
通过Bitmap等高效数据结构实现低开销的安全监控。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b732fa4bed6f7770e375f277d3134d11">12.4.3.1.3 - bitmap的工作流程</h1>
    <div class="lead">bitmap的工作流程是怎样的？</div>
	<h2 id="bitmap的工作流程是怎样的">bitmap的工作流程是怎样的？</h2>
<p><img src="../../basic02_1.png" alt=""></p>
<h3 id="1-识别负载类型">1. 识别负载类型</h3>
<p>根据应用场景和安全需求，将负载分为安全敏感型负载和非安全敏感型负载：</p>
<ul>
<li>
<p><strong>安全敏感型负载</strong>：需要在可信执行环境中运行，以保护数据和代码的机密性和完整性。</p>
</li>
<li>
<p><strong>非安全敏感型负载</strong>：可以在开放的执行环境中运行，主要关注执行效率。</p>
</li>
</ul>
<h3 id="2-设置隔离属性">2. 设置隔离属性</h3>
<p><strong>定义隔离属性</strong>：为不同类型负载设置隔离属性，包括单向隔离和双向隔离。</p>
<ul>
<li>
<p><strong>单向隔离</strong>：允许安全敏感型负载访问非安全敏感型负载的资源，但不允许反向访问。</p>
</li>
<li>
<p><strong>双向隔离</strong>：安全敏感型负载和非安全敏感型负载之间互相不能访问对方的资源。</p>
</li>
</ul>
<h3 id="3-划分资源池">3. 划分资源池</h3>
<p><strong>划分物理内存资源</strong>：将物理内存划分为不同的资源池以支持不同负载的隔离需求。</p>
<ul>
<li>
<p><strong>安全资源池</strong>：分配给安全敏感型负载。</p>
</li>
<li>
<p><strong>非安全资源池</strong>：分配给非安全敏感型负载。</p>
</li>
</ul>
<h3 id="4-配置安全属性">4. 配置安全属性</h3>
<p><strong>设置内存页安全状态</strong>：使用Bitmap数据结构标记每个物理内存页的安全状态。</p>
<ul>
<li>
<p><strong>安全页</strong>：标记为1，表示该页属于安全资源池。</p>
</li>
<li>
<p><strong>非安全页</strong>：标记为0，表示该页属于非安全资源池。</p>
</li>
</ul>
<h3 id="5-动态分配资源">5. 动态分配资源</h3>
<p><strong>按需分配内存</strong>：根据负载的启动和运行时需求，动态分配相应的内存资源。</p>
<ul>
<li>
<p><strong>安全敏感型负载</strong>：从安全资源池分配内存，并确保其访问受限于安全页。</p>
</li>
<li>
<p><strong>非安全敏感型负载</strong>：从非安全资源池分配内存，允许其访问非安全页。</p>
</li>
</ul>
<h3 id="6-隔离检测判断">6. 隔离检测判断</h3>
<p><strong>判断隔离类型</strong>：判断当前负载是否需要单向隔离或者双向隔离。</p>
<ul>
<li>
<p><strong>单向隔离</strong>：仅对非安全敏感型负载进行安全性检测，确保其不访问安全资源。</p>
</li>
<li>
<p><strong>双向隔离</strong>：对所有负载类型进行隔离检测，确保不同负载之间互不干扰。</p>
</li>
</ul>
<h3 id="7-安全性检测">7. 安全性检测</h3>
<p><strong>执行访问控制检查</strong>：</p>
<ul>
<li>
<p>对于单向隔离情况，检查非安全敏感型负载是否试图访问安全资源。</p>
</li>
<li>
<p>对于双向隔离情况，检查所有负载类型是否试图越界访问其他类型的资源。</p>
</li>
</ul>
<h3 id="8-动态回收资源">8. 动态回收资源</h3>
<p><strong>释放不再使用的资源</strong>：负载执行完毕后，其占用的内存资源被回收并返回到相应的资源池中，以便后续其他负载的使用。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-769d220f5cb16bbfee3403c98ead0181">12.4.3.1.4 - 香山bitmap 应用场景</h1>
    <div class="lead">香山bitmap 应用场景</div>
	<h2 id="应用场景">应用场景</h2>
<h3 id="1-机密虚拟机">1. 机密虚拟机</h3>
<p><img src="../../basic03_1.png" alt="应用场景-机密虚拟机"></p>
<p>Shield-XS用于普通虚拟机和机密虚拟机的隔离。在机密虚拟机（Confidential VM， CVM）环境中，bitmap 用于标记和隔离安全内存区域。</p>
<p>普通虚拟机在访问内存时，硬件通过 bitmap 检查机制确保其只能访问被授权的内存区域，从而实现虚拟机之间的内存隔离。</p>
<p>注：机密虚拟机之间的隔离通过MMU 完成，不需要经过Bitmap 的检查机制。</p>
<p>CVM Bitmap 的资源的标记和分配由C-SDSM (Confidential Supervisor Domain Security Manager) 完成，Hypervisor 和 CVM 通过TEECall 和 TEEResume 进行安全世界的交互。</p>
<p><img src="../../basic03_2.png" alt="安全世界接口"></p>
<p><strong>TEECall</strong></p>
<ul>
<li>从普通世界（Normal World）切换到安全世界（TEE），进入敏感工作负载执行流程。</li>
</ul>
<p><strong>TEEResume</strong></p>
<ul>
<li>从 TEE 返回普通世界，恢复 Normal Workloads 的执行。</li>
</ul>
<h3 id="2-安全增强容器">2. 安全增强容器</h3>
<p><img src="../../basic03_3.png" alt="应用场景-容器"></p>
<p>上图显示了bitmap在容器中的应用场景。安全容器和普通容器都位于可信计算基的保护范围内。在安全容器中运行的应用程序可能包含敏感数据或关键业务逻辑。为了防止这些数据被普通容器或恶意软件访问，采用通过 <strong>bitmap 机制</strong>进行隔离。</p>
<p>Bitmap 数据结构用于标记哪些物理页属于安全容器的存储空间，通过将对应该容器内存区域的位图数据写为1，确保普通容器无法访问这些存储空间。只有安全容器内的应用程可以访问这些被标记为安全的内存页。</p>
<p>普通容器中的应用程序可能来自不可信的来源。通过 bitmap 机制，普通容器的内存访问被限制在非安全内存区域。任何试图访问安全内存的请求都会被硬件拦截，并触发Access Fault。</p>
<p>在上述场景的具体的实施细节中，<strong><font style="color:#ee0000;">软件模块负责Bitmap管理和配置 ， 硬件机制负责Bitmap检查和同步。<font></strong></p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-72e5ff01bbf5ddaaf23ddb325bbb52a1">12.4.3.2 - Shield-XS Bitmap总体设计</h1>
    <div class="lead">本节将更近一步介绍Shield-XS Bitmap的技术细节</div>
	<p>本节介绍bitmap的总体设计，不包括具体的硬件实现，只解释概念，包含：</p>
<ul>
<li><strong>机器模式 Bitmap控制状态寄存器</strong></li>
<li><strong>Shield-Bitmap Cache 加速查表</strong></li>
<li><strong>虚拟化两阶段内存地址翻译转换原理</strong></li>
<li><strong>加入了Shield-XS安全检查后的内存地址转换流程</strong></li>
</ul>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a454fbac0661cacfe3738f76653fb9ed">12.4.3.2.1 - 机器模式Bitmap控制状态寄存器</h1>
    
	<h2 id="机器模式-bitmap控制状态寄存器">机器模式 Bitmap控制状态寄存器</h2>
<h3 id="基本信息">基本信息</h3>
<table>
  <thead>
      <tr>
          <th>寄存器名称</th>
          <th>MBMC（Machine BitMap Control）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>特权模式</td>
          <td>机器模式</td>
      </tr>
      <tr>
          <td>寄存器编号</td>
          <td>0xBC2</td>
      </tr>
      <tr>
          <td>读写权限</td>
          <td>可读可写</td>
      </tr>
      <tr>
          <td>功能描述</td>
          <td>用来控制Shield-bitmap 的使能、同步、Shield-XS Bitmap 基地址等</td>
      </tr>
  </tbody>
</table>
<h3 id="字段描述">字段描述</h3>
<table>
  <thead>
      <tr>
          <th>地址</th>
          <th>字段</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>[61:3]</strong></td>
          <td><strong>BMA (Bitmap Address)</strong></td>
          <td>Shield-XS Bitmap 基地址指定 Bitmap 数据结构在物理内存中的起始地址。</td>
      </tr>
      <tr>
          <td>2</td>
          <td>CMODE (Current Mode)</td>
          <td>表明当前执行模式CMODE = 1，表示安全模式CMODE = 0, 表示非安全模式。</td>
      </tr>
      <tr>
          <td>1</td>
          <td>BCLEAR (Bitmap Clear)</td>
          <td>Shield-XS Bitmap 同步位BCLEAR = 1，表示刷新所有Shield-bit 副本。<br/><strong>注：实际使用过程，可结合HFence 指令</strong></td>
      </tr>
      <tr>
          <td>0</td>
          <td>BME (Bitmap Enable)</td>
          <td>Shield-XS 使能位当 BME 置为 1 时，启用 Bitmap 功能。一旦启用，无法关闭，也无法修改 Bitmap 的基地址。</td>
      </tr>
  </tbody>
</table>
<h2 id="数据结构">数据结构</h2>
<p><img src="../../feature00_1.png" alt="Shield-XS Bitmap数据结构"></p>
<h4 id="shield-xs-bitmap数据结构">Shield-XS Bitmap数据结构</h4>
<p>上图为Shield-XS Bitmap的数据结构，所有的Shield-XS Bitmap权限数据都被存放在一块连续的物理内存区域中。其中基地址是存放Shield-XS Bitmap 数据结构的内存区域的起始物理地址。这个地址可以通过MBMC寄存器中的 BMA字段进行配置。</p>
<p>Shield-XS Bitmap 数据结构的大小取决于系统内存的大小。每个4k物理页对应一个比特位。一个4k页对应的权限根据其物理地址存放在Shield-XS Bitmap 数据结构中，其位置可以通过基地址加上该4k页物理地址的偏移量计算得出。</p>
<p><strong>当BME =1 （开启bitmap） 且CMODE= 0 （当前模式处于 非安全模式）时，会进行bitmap检查。当bitmap 检查 当前4k页 bitmap属性 为1（ 安全页面）时，会触发访问错误（access fault）。</strong></p>
<p><strong>当BME =1 （开启bitmap） 且CMODE= 1 （当前模式处于 安全模式）。无论安全还是非安全页面，当前状态都允许访问，因此无需进行bitmap检查。</strong></p>
<p><strong>当BME =0 （关闭bitmap）无需进行bitmap检查。</strong></p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8b0eada6be406a3b39784ffd6e146a6c">12.4.3.2.2 - Shield-Bitmap Cache</h1>
    
	<h2 id="shield-bitmap-cache-性能加速">Shield-Bitmap Cache 性能加速</h2>
<p>当访问一个物理地址 (PA) 时，硬件通过查找 Shield-XS Bitmap 数据结构中对应的位置来确定该页是否具有安全属性。</p>
<p>查找安全属性的物理地址计算公式如下：</p>
<p>即 <strong>Shield-Bitmap 访问地址 = MBMC.BMA + PA[ XLEN-1 : 12 + log<sub>2</sub>(XLEN/8) ]</strong></p>
<p>随后用选出对应该 4KB 页的权限。如果对应比特位为 1 ，则表示该页具有安全属性，只能被安全敏感型负载访问；如果为 0 ，则表示该页不具有安全属性，可以被非安全敏感型负载访问。</p>
<h5 id="shield-xs-直接从内存中读取安全属性">Shield-XS 直接从内存中读取安全属性</h5>
<p><img src="../../feature01_1.png" alt=""></p>
<p>开启Shield-XS 隔离之后，CPU 内部发起的任何一笔访存操作，都需要对标记安全属性的存储空间发起访问，从内存中获取安全属性的延迟过长，使得系统的性能变差。</p>
<p>为了Shield-XS 隔离带来的性能损失，利用了程序的局部性，增加了Shield-Bitmap Cache,
当任何一笔访存需要获取安全属性时，优先从Shield-Bitmap Cache 中读取，只有Shield-Bitmap Cache Miss时，才会发起访存请求。</p>
<h5 id="shield-xs优先从shield-bitmap-cache中读取安全属性">Shield-XS优先从Shield-BitMap Cache中读取安全属性</h5>
<p><img src="../../feature01_2.png" alt=""></p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-50afc8cbee1484cfa9fbda0874aefbd2">12.4.3.2.3 - Shield-Bitmap 地址翻译</h1>
    
	<h1 id="虚拟化两阶段地址翻译流程">虚拟化两阶段地址翻译流程</h1>
<p>bitmap和MMU-L2TLB耦合，会在虚拟化两阶段地址走表翻译完成后才进行隔离检查。如果bitmap检查没有通过，就向MMU-L1TLB 发送af。因此对L1TLB以及其上面的模块来说，bitmap是透明的。所以，在进一步介绍前，需要先了解MMU处理虚拟化两阶段地址的流程。</p>
<h2 id="基本概念">基本概念</h2>
<ul>
<li><strong>两阶段翻译</strong>：Guest Virtual Address (GVA) → Guest Physical Address (GPA) → Host Physical Address (HPA)</li>
<li><strong>关键寄存器</strong> ：
<ul>
<li><strong>hgatp</strong> ：控制G-stage（客户机阶段）页表根地址</li>
<li><strong>vsatp</strong> ：控制VS-stage（虚拟化监督模式阶段）页表根地址</li>
</ul>
</li>
</ul>
<p><strong>1. VAPT (Virtual Address Protection and Translation)</strong></p>
<p><strong>作用</strong> ：管理客户机虚拟地址（GVA）到客户机物理地址（GPA）的第一阶段翻译（VS-stage）。</p>
<table>
  <thead>
      <tr>
          <th><strong>字段名</strong></th>
          <th><strong>位宽</strong></th>
          <th><strong>描述</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>MODE</strong></td>
          <td>4</td>
          <td>页表模式：<br/> <ul><li><code>0</code>: 关闭翻译</li> <li><code>1</code>: Sv32</li> <li><code>8</code>: Sv39</li> <li><code>9</code>: Sv48</li> <li><code>10</code>: Sv57</li></ul></td>
      </tr>
      <tr>
          <td><strong>ASID</strong></td>
          <td>16</td>
          <td>地址空间标识符（Address Space ID），隔离不同客户机的地址空间</td>
      </tr>
      <tr>
          <td><strong>PPN</strong></td>
          <td>44</td>
          <td>物理页号（Physical Page Number），指向VS-stage页表的根页表地址</td>
      </tr>
      <tr>
          <td><strong>RESERVED</strong></td>
          <td>8</td>
          <td>保留位，必须写0</td>
      </tr>
      <tr>
          <td><strong>G</strong></td>
          <td>1</td>
          <td>全局映射标志（Global bit），若为1则忽略ASID匹配</td>
      </tr>
  </tbody>
</table>
<hr>
<p><strong>2. SVAPT (Supervisor Virtual Address Protection and Translation)</strong></p>
<p><strong>作用</strong> ：在Hypervisor模式下管理宿主机虚拟地址（HVA）到宿主机物理地址（HPA）的翻译（HS-stage）。</p>
<table>
  <thead>
      <tr>
          <th><strong>字段名</strong></th>
          <th><strong>位宽</strong></th>
          <th><strong>描述</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>MODE</strong></td>
          <td>4</td>
          <td>页表模式：<br/> <ul><li><code>0</code>: 关闭翻译</li> <li><code>1</code>: Sv32</li> <li><code>8</code>: Sv39</li> <li><code>9</code>: Sv48</li></ul></td>
      </tr>
      <tr>
          <td><strong>ASID</strong></td>
          <td>16</td>
          <td>宿主机地址空间标识符</td>
      </tr>
      <tr>
          <td><strong>PPN</strong></td>
          <td>44</td>
          <td>指向HS-stage页表的根页表地址</td>
      </tr>
      <tr>
          <td><strong>V</strong></td>
          <td>1</td>
          <td>虚拟化启用标志： <br/> <ul><li><code>1</code>: 启用两阶段翻译（需配合H-extension）</li></ul></td>
      </tr>
      <tr>
          <td><strong>RESERVED</strong></td>
          <td>7</td>
          <td>保留位</td>
      </tr>
  </tbody>
</table>
<hr>
<p><strong>3. HGAPT (Hypervisor Guest Address Protection and Translation)</strong></p>
<p><strong>作用</strong> ：控制客户机物理地址（GPA）到宿主机物理地址（HPA）的第二阶段翻译（G-stage）。</p>
<table>
  <thead>
      <tr>
          <th><strong>字段名</strong></th>
          <th><strong>位宽</strong></th>
          <th><strong>描述</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>MODE</strong></td>
          <td>4</td>
          <td>G-stage页表模式：<br/> <ul><li><code>0</code>: 关闭翻译</li> <li><code>3</code>: Sv32x4</li> <li><code>4</code>: Sv48x4</li></ul></td>
      </tr>
      <tr>
          <td><strong>VMID</strong></td>
          <td>14</td>
          <td>虚拟机标识符（Virtual Machine ID），隔离不同虚拟机的G-stage页表</td>
      </tr>
      <tr>
          <td><strong>PPN</strong></td>
          <td>44</td>
          <td>指向G-stage页表的根页表地址</td>
      </tr>
      <tr>
          <td><strong>GST</strong></td>
          <td>1</td>
          <td>客户机软件TLB失效指令使能： <br/> <ul><li><code>1</code>: <strong>允许客户机执行 sfence.vma</strong></li></ul></td>
      </tr>
      <tr>
          <td><strong>RESERVED</strong></td>
          <td>5</td>
          <td>保留位</td>
      </tr>
  </tbody>
</table>
<hr>
<p><strong>关键差异总结</strong></p>
<table>
  <thead>
      <tr>
          <th><strong>寄存器</strong></th>
          <th><strong>控制阶段</strong></th>
          <th><strong>核心功能</strong></th>
          <th><strong>特权级</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>VAPT</td>
          <td>VS-stage</td>
          <td>GVA→GPA翻译（客户机视角）</td>
          <td>VS-mode</td>
      </tr>
      <tr>
          <td>SVAPT</td>
          <td>HS-stage</td>
          <td>HVA→HPA翻译（宿主机视角）</td>
          <td>HS-mode</td>
      </tr>
      <tr>
          <td>HGAPT</td>
          <td>G-stage</td>
          <td>GPA→HPA翻译（硬件辅助虚拟化）</td>
          <td>M-mode/HS-mode</td>
      </tr>
  </tbody>
</table>
<ul>
<li><strong>特权级</strong> ：
<ul>
<li><strong>VS-stage</strong> ：由Hypervisor管理，处理客户机虚拟地址</li>
<li><strong>G-stage</strong> ：由客户机OS管理，处理客户机物理地址</li>
</ul>
</li>
</ul>
<h2 id="翻译过程"><strong>翻译过程</strong></h2>
<p><strong>第一阶段：VS-stage (GVA → GPA)</strong></p>
<table>
  <thead>
      <tr>
          <th><strong>VPN部分</strong></th>
          <th><strong>VS-stage页表</strong></th>
          <th><strong>依赖的G-stage页表</strong></th>
          <th><strong>说明</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>VPN[3]</td>
          <td>VS-L3</td>
          <td>通过<strong>hgatp</strong>访问G-L3</td>
          <td>最高级页表，需G-stage辅助查询</td>
      </tr>
      <tr>
          <td>VPN[2]</td>
          <td>VS-L2</td>
          <td>通过<strong>hgatp</strong>访问G-L2/G-L1/G-L0</td>
          <td>中间级页表，需G-stage多级支持</td>
      </tr>
      <tr>
          <td>VPN[1]</td>
          <td>VS-L1</td>
          <td>通过<strong>hgatp</strong>访问G-L1/G-L0</td>
          <td>次末级页表</td>
      </tr>
      <tr>
          <td>VPN[0]</td>
          <td>VS-L0</td>
          <td>通过<strong>hgatp</strong>访问G-L0</td>
          <td>最后级页表，直接指向GPA</td>
      </tr>
  </tbody>
</table>
<hr>
<p><strong>第二阶段：G-stage (GPA → HPA)</strong></p>
<table>
  <thead>
      <tr>
          <th><strong>页表层级</strong></th>
          <th><strong>作用</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>G-L3</td>
          <td>顶级页表，由<strong>hgatp</strong>寄存器指向</td>
      </tr>
      <tr>
          <td>G-L2</td>
          <td>中间级页表</td>
      </tr>
      <tr>
          <td>G-L1</td>
          <td>次末级页表</td>
      </tr>
      <tr>
          <td>G-L0</td>
          <td>最后级页表，与offset拼接生成HPA</td>
      </tr>
  </tbody>
</table>
<ul>
<li>任一阶段页表访问失败会触发异常：
<ul>
<li>VS-stage异常 → Hypervisor处理</li>
<li>G-stage异常 → 客户机Page Fault</li>
</ul>
</li>
</ul>
<p><img src="../../feature02_1.svg" alt=""></p>
<h4 id="l2tlb-table-walker-查表流程说明">L2TLB table walker 查表流程说明：</h4>
<ol>
<li>请求首先进入PageCache查询第一阶段页表</li>
<li>若第一阶段命中：
<ul>
<li>直接由PageTableWalker处理第二阶段</li>
</ul>
</li>
<li>若第一阶段未命中：
<ul>
<li>根据命中级别选择PageTableWalker或LastLevelPageTableWalker</li>
</ul>
</li>
<li>第二阶段处理：
<ul>
<li>先在PageCache中查询</li>
<li>未命中时转交HypervisorPageTableWalker</li>
<li>翻译结果返回PageCache后完成流程</li>
</ul>
</li>
</ol>
<h4 id="关键路径">关键路径：</h4>
<ul>
<li>快路径：PageCache(阶段1)→PageTableWalker→PageCache(阶段2)</li>
<li>慢路径：PageCache(阶段1)→LastLevelPTW/PTW→PageCache(阶段2)→HypervisorPTW</li>
</ul>
<h2 id="mmu-l2tlb-地址翻译流程">MMU-L2TLB 地址翻译流程</h2>
<p><img src="../../feature02_2.svg" alt=""></p>
<p><strong>1. L1TLB向L2TLB发送请求</strong></p>
<ul>
<li>
<p><strong>非两阶段翻译请求</strong>：</p>
<ul>
<li>首先访问PageCache。</li>
<li>若命中叶子节点，直接返回结果给L1TLB。</li>
<li>若未命中叶子节点：
<ul>
<li>根据PageCache命中的页表等级，结合PageTableWalker (PTW) 和 LastLevelPageTableWalker (LLPTW) 的空闲情况：
<ul>
<li>进入PTW、LLPTW 或 Miss Queue。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>两阶段地址翻译请求</strong>：</p>
<ul>
<li>PageCache每次只能处理一个查询请求。</li>
<li>首先查询第一阶段的页表：
<ul>
<li>若第一阶段命中，请求发送给PTW进行第二阶段的翻译。</li>
<li>若第一阶段未命中：
<ul>
<li>根据命中的页表级别，发送给PTW或LLPTW，在这两个模块中完成第二阶段的翻译。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>page Cache 访问流程：</strong></p>
</li>
</ul>
<p><img src="../../feature02_3.svg" alt=""></p>
<p><strong>2. PTW和LLPTW的第二阶段翻译</strong></p>
<ul>
<li>
<p>PTW和LLPTW发送的第二阶段翻译请求会先发送到PageCache查询：</p>
<ul>
<li>若命中，PageCache直接返回结果给对应模块（PTW或LLPTW）。</li>
<li>若未命中，发送给HypervisorPageTableWalker (HPTW) 进行翻译，结果直接返回给PTW或LLPTW</li>
</ul>
<p><strong>3. PageTableWalker (PTW) 处理</strong></p>
</li>
<li>
<p>PTW同时只能处理一个请求，进行HardwarePageTableWalk：</p>
<ul>
<li>访问内存中前两级页表（不访问4KB页表）。</li>
<li>可能的结果：
<ul>
<li>访问到2MB或1GB的叶子节点。</li>
<li>发生Pagefault或Access fault。</li>
<li>以上情况直接返回给L1TLB。</li>
<li>否则，请求送往LLPTW访问最后一级（4KB）页表。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>PTW 处理流程</p>
<p><img src="../../feature02_4.svg" alt=""></p>
<p><strong>4. HypervisorPageTableWalker (HPTW) 处理</strong></p>
<ul>
<li>HPTW每次只能处理一个请求：
<ul>
<li>LLPTW中第二阶段翻译的请求串行发送给HPTW。</li>
<li>HPTW访问可能触发Pagefault或Access fault，返回给PTW或LLPTW，最终返回给L1TLB。</li>
</ul>
</li>
</ul>
<p><img src="../../feature02_5.svg" alt=""></p>
<p><strong>5. 内存访问流程</strong></p>
<ul>
<li>PTW、LLPTW、HPTW均可向内存发送请求访问页表内容。</li>
<li>物理地址访问内存前需通过PMP和PMA模块检查：
<ul>
<li>若发生Access fault，不向内存发送请求。</li>
</ul>
</li>
<li>请求经过仲裁后，通过TileLink总线向L2Cache发送：
<ul>
<li>L2Cache访存宽度为512bits，每次返回8项页表。</li>
</ul>
</li>
</ul>
<p><img src="../../feature02_6.svg" alt=""></p>
<p><strong>6. 页表压缩机制</strong></p>
<ul>
<li><strong>L2TLB</strong>：
<ul>
<li>命中4KB页时，返回至多8项连续的页表项（虚拟页号高位相同且物理页号高位和属性相同）。</li>
<li>在H拓展中，与虚拟化相关的页表仍采用压缩机制。</li>
</ul>
</li>
<li><strong>L1TLB</strong>：
<ul>
<li>在H拓展中，与虚拟化相关的页表压缩机制无效，视为单个页表。</li>
</ul>
</li>
</ul>
<p><strong>7.异常处理</strong></p>
<ul>
<li>各级Walker（PTW、LLPTW、HPTW）访问中可能触发：
<ul>
<li>Pagefault或Access fault，逐级返回至L1TLB。</li>
</ul>
</li>
</ul>
<p><strong>8. 关键限制</strong></p>
<ul>
<li>PTW和HPTW均单请求处理，串行化。</li>
<li>PageCache单查询请求处理，两阶段翻译需分步完成。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8dd0a9f224170387a7af921f320750fe">12.4.3.2.4 - Shield-Bitmap 地址翻译2</h1>
    
	<h1 id="加入了shield-xs安全检查后的内存地址转换流程">加入了Shield-XS安全检查后的内存地址转换流程</h1>
<p>如前文所述， bitmap和MMU耦合。现在将介绍增加了bitmap后的MMU地址翻译流程。</p>
<p><img src="../../feature03_1.jpeg" alt=" "></p>
<p>从 <strong>客户虚拟地址</strong> 到 <strong>主机物理地址</strong> 的转换过程，同时涉及 <strong>安全属性检查</strong> 和 Shield-Bitmap<strong>高速缓存访问</strong>。以下是详细步骤：</p>
<ol>
<li>
<p><strong>客户虚拟地址（Guest Virtual Address）</strong>: 流程开始于计算单元（如CPU）使用客户虚拟地址发出内存访问请求。</p>
</li>
<li>
<p><strong>访问一级快表（L1TLB Lookup）</strong>: 首先查询一级快表（<strong>L1TLB</strong>），检查是否已缓存该地址的映射。只有经历过bitmap检查才会出现在L1TLB Cache中。因此和L2TLB Cache不同，L1TLB Cache 不会存储bitmap检查位。</p>
</li>
<li>
<p><strong>一级快表缓存命中？</strong></p>
<ul>
<li>
<p><strong>是</strong> → 直接从L1TLB Cache获取主机物理地址（Host Physical Address）。</p>
</li>
<li>
<p><strong>否</strong> → 进入下一级查询（访问二级快表）。</p>
</li>
</ul>
</li>
<li>
<p><strong>访问二级快表（L2TLB Lookup）</strong>: 如果一级快表未命中，继续查询二级快表（L2TLB），检查二级快表是否有对应的映射。L2TLB Cache 存储安全允许位（cf）表示 是否经过bitmap 检查。</p>
<ul>
<li>
<p><strong>二级快表缓存命中？</strong></p>
<ul>
<li>
<p><strong>cf 和 L2TLB 页表项均命中</strong> → 获取主机物理地址，并回填一级快表（更新L1TLB）。</p>
</li>
<li>
<p><strong>L2TLB 页表项命中，bitmap cf 未设</strong>→ 发送请求至bitmap，进行权限检查。</p>
</li>
<li>
<p><strong>否</strong> → 触发 <strong>页表遍历（Page Table Walker）</strong>，从内存中加载页表映射关系，随后进行bitmap检查。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>进行页表遍历</strong>：从内存中加载页表映射关系</p>
</li>
<li>
<p><strong>主机虚拟地址 → 主机物理地址转换</strong>：通过页表遍历获取主机物理地址（Host Physical Address）。</p>
</li>
<li>
<p><strong>安全性检查允许访问（Security Check）</strong>： 对物理地址进行 <strong>安全属性检查</strong>。如果检查失败，可能触发访问错误（Access Fault）。</p>
</li>
<li>
<p><strong>访问（安全属性高速缓存）Shield-Bitmap Cache</strong>：查询<strong>Shield-Bitmap</strong> Cache是否已缓存目标数据。</p>
<ul>
<li>
<p><strong>Shield-Bitmap Cache 命中？</strong></p>
<ul>
<li>
<p><strong>是</strong> → 返回数据。</p>
</li>
<li>
<p><strong>否</strong> → 继续访问主存<strong>Shield-Bitmap 专属内存区域</strong>，读取权限。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>访存请求合并（Shield-Bitmap Memory Request Merging）</strong>：如果多个请求访问同一地址，可能合并访存请求以提高效率。</p>
</li>
<li>
<p><strong>访问错误</strong>：如果访问不被允许，触发访问错误。</p>
</li>
</ol>
<h2 id="异常处理描述">异常处理描述</h2>
<p>RISC-V 特权手册规定的同步异常处理优先级</p>
<p><img src="../../feature03_2.png" alt=""></p>
<p>优先级处理如下：</p>
<table>
  <thead>
      <tr>
          <th>序号</th>
          <th>描述</th>
          <th>触发异常</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>PTE.V == Invalid</td>
          <td>Page fault</td>
      </tr>
      <tr>
          <td>2</td>
          <td>PTE.V == Invalid &amp;&amp;<br/>Page Table Walker (PMP || Bitmap) Check Fail</td>
          <td>Access Fault</td>
      </tr>
      <tr>
          <td>3</td>
          <td>PTE.V valid &amp;&amp; PTE.Permission (R/W/X) Check Fail</td>
          <td>Page fault</td>
      </tr>
      <tr>
          <td>4</td>
          <td>PTE.V valid &amp;&amp; PMP Check Fail</td>
          <td>Access Fault</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d051174c05fff6ce5497d8fbdb061286">12.4.3.3 - Shield-XS Bitmap 硬件设计</h1>
    <div class="lead">本部分文档将会详细介绍香山 bitmap 硬件设计</div>
	<h2 id="shield-xs-bitmap-硬件设计">Shield-XS Bitmap 硬件设计</h2>
<p>在硬件实现层面，Bitmap 机制由两个关键组件构成，即 Bitmap Checker 和 Bitmap Cache。其中，Checker 的职责是读取内存中的权限信息，以确保内存访问的安全性；而 Cache 则旨在加速查找过程，提升整体性能。需要指出的是，当前实现仅支持单向隔离功能。
这意味着在实际应用场景中，它能够有效地防止非安全敏感型负载对安全内存区域的非法访问，但尚未支持更高阶的双向隔离功能，即安全与非安全负载之间的互相访问限制。</p>
<h4 id="shield-xs-bitmap-硬件示意图">Shield-XS Bitmap 硬件示意图</h4>
<p><img src="../mod00.png" alt=""></p>
<p>上图展示了一次虚拟地址到物理地址转换过程中如何结合<strong>Shield-Bitmap安全机制</strong>进行访问权限检查。
以及bitmap cache hit 和miss的不同处理。在L1TLB hit时，无需进行bitmap检查，因为L1TLB只会存储bitmap 检查为 allow的项。
如果miss，在L2TLB的page cache中查找，如果页表项和对应的bitmap 均未命中，则先进行查表，后进行bitmap检查并返回结果。如果页表项命中但未进行过bitmap 检查，则只进行bitmap检查。 如果都命中，则直接返回。</p>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6bd34d855a03cd0a22829234e9921d00">12.4.3.3.1 - Bitmap Checker</h1>
    
	<h1 id="bitmap-checker硬件模块">Bitmap Checker硬件模块</h1>
<h2 id="bitmap-checker简介">Bitmap checker简介</h2>
<p>Bitmap checker 的作用是将来自外部（ptw/lptw/hptw）的请求发送至cache，并根据是否命中进行内存访问查权限。最后将cache返回的或者内存访问得到的权限发送回请求源。</p>
<p>此外，bitmap（walker）支持non blocking 特性，每一个请求来源都有FSM负责录入请求进行处理。但是一次只能有一个fsm进行cache访问。</p>
<h2 id="状态机描述">状态机描述</h2>
<p>为了保持non blocking，有8个独立的状态机（entries）并行运行。每个 entry 维护独立的状态和数据处理。当有请求进入时，从下到上依次将fsm填满，由于总共就8个请求来源，因此不会出现无空闲fsm可用的情况。</p>
<p>当entry的PA重复时，仅有一个fsm会进行一次查cache 或者访问memory，其余重复fsm项的状态会被部分跳过。重复表示PA的tag位[47:18] 一致。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">PA</th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">段</td>
          <td style="text-align: center">tag</td>
          <td style="text-align: center">Bitmap offset</td>
          <td style="text-align: center">Page offset</td>
      </tr>
      <tr>
          <td style="text-align: center">位</td>
          <td style="text-align: center">[47:18]</td>
          <td style="text-align: center">[17:12]</td>
          <td style="text-align: center">[11:0]</td>
      </tr>
  </tbody>
</table>
<h4 id="bitmap-checker-模块状态机">Bitmap checker 模块状态机</h4>
<p><img src="../../modul00_1.png" alt=""></p>
<h4 id="状态机状态">状态机状态</h4>
<table>
  <thead>
      <tr>
          <th>状态</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>state_idle</td>
          <td>标明该fsm状态为空，可以录入新请求<br/>当io.req.fire时，切换到新状态<br/>转换条件：<br/><ul><li>io.req.fire → state_addr_check (无重复请求)</li><li>io.req.fire &amp;&amp; to_wait → state_mem_waiting (检测到重复请求在等待) 同时写入重复项的id到fsm</li><li>io.req.fire &amp;&amp; to_mem_out → state_mem_out (重复请求已完成) 同时写入重复项的id到fsm</li></ul></td>
      </tr>
      <tr>
          <td>state_addr_check</td>
          <td>进行pmp检查<br/>转换条件：<br/><ul><li>accessFault=true → state_mem_out (检查失败)</li><li>accessFault=false → state_cache_req (检查通过)</li></ul></td>
      </tr>
      <tr>
          <td>state_cache_req</td>
          <td>将cachereq拉高，fire后→ state_cache_resp</td>
      </tr>
      <tr>
          <td>state_cache_resp</td>
          <td>Cache resp fire后更新：<ul><li>hit=true → state_mem_out (缓存命中)</li><li>hit=false &amp;&amp; cm_to_mem_out → state_mem_out (重复请求已完成) 同时写入重复项的id到fsm</li><li>hit=false &amp;&amp; cm_to_wait → state_mem_waiting (检测到重复请求) 同时写入重复项的id到fsm</li><li>hit=false → state_mem_req (无重复请求) </li></ul></td>
      </tr>
      <tr>
          <td>state_mem_req</td>
          <td>拉高valid 并等待，mem req fire时，将所有重复项目的id跟新为本fsm id，并将所有重复和本机 state 设置为mem wait</td>
      </tr>
      <tr>
          <td>state_mem_waiting</td>
          <td>Fire时→state_mem_out，并将所有的符合id项目内值全部跟新为mem返回值</td>
      </tr>
      <tr>
          <td>state_mem_out</td>
          <td>拉高 resp valid ，fire时→ state_idle</td>
      </tr>
  </tbody>
</table>
<h2 id="接口信号">接口信号</h2>
<table>
  <thead>
      <tr>
          <th>信号</th>
          <th>位宽</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Io.mem</td>
          <td></td>
          <td>内存访问相关信号</td>
      </tr>
      <tr>
          <td>io.mem.resp.bits.id</td>
          <td>4</td>
          <td>memory 响应返回的 ID(需为bitmap编号)</td>
      </tr>
      <tr>
          <td>io.mem.resp.bits.value</td>
          <td>512</td>
          <td>memory 返回的 bitmap 数据块</td>
      </tr>
      <tr>
          <td>io.mem.req_mask</td>
          <td>20</td>
          <td>Memory 请求屏蔽位</td>
      </tr>
      <tr>
          <td>io.mem.req.bits.addr</td>
          <td>56</td>
          <td>memory 请求的 bitmap 数据地址</td>
      </tr>
      <tr>
          <td>io.mem.req.bits.id</td>
          <td>4</td>
          <td>memory 请求的编号(恒定为bitmap编号)</td>
      </tr>
      <tr>
          <td>io.mem.req.bits.hptw_bypassed</td>
          <td>1</td>
          <td>（和</font>bitmap </font>模块内部无关）</td>
      </tr>
      <tr>
          <td>Io.Req</td>
          <td></td>
          <td>请求信号</td>
      </tr>
      <tr>
          <td>io.req.bits.bmppn</td>
          <td>27</td>
          <td>被检查的物理页号 PPN</td>
      </tr>
      <tr>
          <td>io.req.bits.id</td>
          <td>4</td>
          <td>请求编号，用于标识请求来源（和</font>bitmap </font>模块内部无关）</td>
      </tr>
      <tr>
          <td>io.req.bits.vpn</td>
          <td>27</td>
          <td>对应虚拟页号VPN</font>，用于唤醒</font>pagecache</font>（和</font>bitmap </font>模块内部无关）</td>
      </tr>
      <tr>
          <td>io.req.bits.level</td>
          <td>2</td>
          <td>所查询页表的级别信息（</font>0/1/2</font>），用于唤醒</font>pagecache</font>（和</font>bitmap </font>模块内部无关）</td>
      </tr>
      <tr>
          <td>io.req.bits.way_info</td>
          <td>8</td>
          <td>TLB way </font>编号用于唤醒</font>pagecache</font>（和</font>bitmap </font>模块内部无关）</td>
      </tr>
      <tr>
          <td>io.req.bits.hptw_bypassed</td>
          <td>1</td>
          <td>用于唤醒</font>pagecache</font>（和</font>bitmap </font>模块内部无关）</td>
      </tr>
      <tr>
          <td>Io.resp</td>
          <td></td>
          <td>返回结果</td>
      </tr>
      <tr>
          <td>io.resp.bits.cf</td>
          <td>1</td>
          <td>检查权限是否允许访问</td>
      </tr>
      <tr>
          <td>io.resp.bits.cfs</td>
          <td>8</td>
          <td>相邻8个（3bit地址空间）的权限</td>
      </tr>
      <tr>
          <td>io.resp.bits.id</td>
          <td>4</td>
          <td>响应对应的请求id</font>（和</font>bitmap </font>模块内部无关）</td>
      </tr>
      <tr>
          <td>Io.pmp</td>
          <td></td>
          <td>Pmp</font>查</td>
      </tr>
      <tr>
          <td>io.pmp.req.bits.addr</td>
          <td>56</td>
          <td>进行PMP检查的物理地址</td>
      </tr>
      <tr>
          <td>io.pmp.req.bits.cmd</td>
          <td>2</td>
          <td>读/写权限请求类型（恒定为读）</td>
      </tr>
      <tr>
          <td>io.pmp.req.bits.size</td>
          <td>3</td>
          <td>请求访问大小（恒定）</td>
      </tr>
      <tr>
          <td>io.pmp.resp.ld</td>
          <td>1</td>
          <td>PMP Load 权限检查结果</td>
      </tr>
      <tr>
          <td>io.pmp.resp.mmio</td>
          <td>1</td>
          <td>PMP MMIO 检查结果</td>
      </tr>
      <tr>
          <td>Io.wakeup</td>
          <td></td>
          <td>Resp</font>时且非</font>hptw bypassed </font>进行重填pagecache</td>
      </tr>
      <tr>
          <td>io.wakeup.bits.setIndex</td>
          <td>4</td>
          <td>唤醒用的setIndex</font>（和</font>bitmap </font>模块内部无关）</td>
      </tr>
      <tr>
          <td>io.wakeup.bits.tag</td>
          <td>4</td>
          <td>唤醒tag</font>（</font>VPN</font>高位）（和</font>bitmap </font>模块内部无关）</td>
      </tr>
      <tr>
          <td>io.wakeup.bits.isSp</td>
          <td>1</td>
          <td>是否为</font>superpage</font>（和</font>bitmap </font>模块内部无关）</td>
      </tr>
      <tr>
          <td>io.wakeup.bits.way_info</td>
          <td>8</td>
          <td>TLB</font>对应的way </font>信息（和</font>bitmap </font>模块内部无关）</td>
      </tr>
      <tr>
          <td>io.wakeup.bits.pte_index</td>
          <td>6</td>
          <td>PTE </font>在段页表中的索引位置（和</font>bitmap </font>模块内部无关）</td>
      </tr>
      <tr>
          <td>io.wakeup.bits.check_success</td>
          <td>1</td>
          <td>是否 bitmap 检查通过</td>
      </tr>
      <tr>
          <td>Refill</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>io.refill.bits.data</td>
          <td>64</td>
          <td>要写入cache </font>的bitmap </font>数据</td>
      </tr>
      <tr>
          <td>CSR</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>io_sfence_valid</td>
          <td>1</td>
          <td>SFENCE </font>操作有效信号（为高刷新</font>fsm</font>）</td>
      </tr>
      <tr>
          <td>io_csr_satp_changed</td>
          <td>1</td>
          <td>SATP </font>寄存器变更标志（为高刷新</font>fsm</font>）</td>
      </tr>
      <tr>
          <td>io_csr_vsatp_changed</td>
          <td>1</td>
          <td>VSATP </font>寄存器变更标志（为高刷新</font>fsm</font>）</td>
      </tr>
      <tr>
          <td>io_csr_hgatp_changed</td>
          <td>1</td>
          <td>HGATP </font>寄存器变更标志（为高刷新</font>fsm</font>）</td>
      </tr>
      <tr>
          <td>io_csr_mbmc_BMA</td>
          <td>58</td>
          <td>Bitmap </font>基址寄存器值</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-32bdcacdae91419ec8cfff490d7c275a">12.4.3.3.2 - Bitmap Cache</h1>
    
	<h3 id="bitmap-cache硬件模块">Bitmap Cache硬件模块</h3>
<h4 id="bitmap-cache简介">Bitmap cache简介</h4>
<p>Bitmap cache用于缓存 bitmap 数据块以减少 memory 访问延迟，存储最近访问的 bitmap 数据，<strong>共16个entry。每个 entry 存储一个 64-bit 数据段</strong>。使用plru替换策略。</p>
<h4 id="bitmap模块结构">Bitmap模块结构</h4>
<p>Cache 一回合出结果，不需要pipeline。此外，refill也只需要一回合。Refill使用plru进行充填。</p>
<h4 id="bitmap-cache接口">Bitmap cache接口</h4>
<table>
  <thead>
      <tr>
          <th>io_req</th>
          <th>位宽</th>
          <th>Bm 发起请求</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>io_req_bits_tag</td>
          <td>36</td>
          <td>Tag for cache lookup ([35:6] = tag)</td>
      </tr>
      <tr>
          <td>io_req_bits_order</td>
          <td>8</td>
          <td>发起请求的Fsm编号</td>
      </tr>
      <tr>
          <td>Io resp</td>
          <td></td>
          <td>返回bm请求</td>
      </tr>
      <tr>
          <td>io_resp_bits_hit</td>
          <td>1</td>
          <td>是否hit cache</td>
      </tr>
      <tr>
          <td>io_resp_bits_order</td>
          <td>8</td>
          <td>发起请求的Fsm编号</td>
      </tr>
      <tr>
          <td>io_resp_bits_cfs</td>
          <td>8</td>
          <td>相邻8个的权限</td>
      </tr>
      <tr>
          <td>Io refill</td>
          <td></td>
          <td>Refill接口，来自bm，bm resp valid时发起重填</td>
      </tr>
      <tr>
          <td>io_refill_bits_tag</td>
          <td>36</td>
          <td>Tag for cache refill ([35:6] = tag)</td>
      </tr>
      <tr>
          <td>io_refill_bits_data</td>
          <td>64</td>
          <td>Data to refill into cache</td>
      </tr>
      <tr>
          <td>io_resp_bits_hit</td>
          <td>1</td>
          <td>是否hit cache</td>
      </tr>
      <tr>
          <td>CSR</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>io_sfence_valid</td>
          <td>1</td>
          <td>同步刷新请求有效（触发缓存刷新）</td>
      </tr>
      <tr>
          <td>io_csr_satp_changed</td>
          <td>1</td>
          <td>SATP CSR 变更标志（触发缓存刷新）</td>
      </tr>
      <tr>
          <td>io_csr_vsatp_changed</td>
          <td>1</td>
          <td>VSATP CSR 变更标志（触发缓存刷新）</td>
      </tr>
      <tr>
          <td>io_csr_hgatp_changed</td>
          <td>1</td>
          <td>HGATP CSR 变更标志（触发缓存刷新）</td>
      </tr>
      <tr>
          <td>io_csr_mbmc_BCLEAR</td>
          <td>1</td>
          <td>缓存清除信号（触发缓存刷新）</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9cbbfef57ed1a52990970341b25766a2">12.4.3.3.3 - Bitmap 与L2TLB交互</h1>
    
	<h3 id="bitmap-与l2tlb内的交互">Bitmap 与L2TLB内的交互</h3>
<p><img src="../../module02_1.png" alt=""></p>
<h4 id="page-cache-与-bitmap-检测机制的交互">Page Cache 与 Bitmap 检测机制的交互</h4>
<h5 id="新增信号">新增信号</h5>
<p>发向 PTW 的 bitmap check 信号：用于触发 PTW 进行 bitmap 检测。</p>
<p>发向 HPTW 的 bitmap check 信号：用于触发 HPTW 进行 bitmap 检测。</p>
<p>接收来自 bitmap 的重填信号（bitmap wakeup）：用于接收 bitmap 检测结果并更新缓存。</p>
<h5 id="bitmap-wakeup接口-refill-bitmap">Bitmap Wakeup接口: refill bitmap</h5>
<p>功能描述：当接收到 wake up valid 信号时，将 check_success 结果写入对应的 sp 或 l0 的 cache bitmap reg 中。</p>
<p>工作原理：cache bitmap reg 用于标识缓存项是否通过 bitmap 检测。值为 1 表示已通过检测；值为 0 表示检测未通过或尚未检测。如果发现 PtwCache 命中的表项未通过检测，则触发 Bitmap 检测流程，并通过 bitmap wakeup 更新缓存项。此外，在走表过程中所有bitmap返回的项都会回填page cache。</p>
<center><img src=../../module02_2.jpeg width=30% /></center>
<h5 id="ptwllptw接口refill-data-后第一次伪hit发起bitmap请求">Ptw/llptw接口:refill data 后第一次伪hit发起bitmap请求</h5>
<p>功能描述：当缓存命中且 bitmap valid = 0 时，首次命中不直接返回 L1TLB，而是返回响应请求源并发起 bitmap 请求。</p>
<p>工作原理：使用 is_hptw 判断请求源。请求源在获取 bitmap 权限后，将结果重新填充到 Page Cache 中。</p>
<h4 id="page-table-walker-交互">Page Table walker 交互</h4>
<h5 id="状态机更新">状态机更新</h5>
<p>新增状态：PTW、LLPTW 和 HPTW 的状态机中新增了 state_bitmap_check。</p>
<p>工作流程：在 PTW、LLPTW 和 HPTW 的状态机中，于 state_mem_resp 阶段进行 bitmap 检测，并将 bitmap 检测的使能信号传递给这些部件。如果满足 bitmap 检测条件，则进入 state_bitmap_check 并获取检测结果。如果检测失败，则触发访问故障（Access Fault）并将结果返回。</p>
<h5 id="触发条件">触发条件</h5>
<p>PTW：仅在未开启虚拟化且检测到巨页（hugepage）时进行 bitmap 检测。</p>
<p>LLPTW：仅在请求未开启虚拟化（即进行 VA 到 PA 的地址转换时）进行 bitmap 检测。如果请求通过 HPTW，则 HPTW 已在工作过程中进行了 bitmap 检测。</p>
<p>HPTW：在遍历到最后一级页表时，于 mem_resp 阶段进行 bitmap 检测。</p>
<h5 id="新接口">新接口</h5>
<p>Req_bitmapcheck 接口：用于在 Page Cache 首次命中时发起 bitmap 检测。仅在 PTW 和 LLPTW 上实现。如果有效，则直接接收一个 PTE 并检查权限。状态机直接跳转到 state_bitmap_check，获取权限后直接返回 pagecache。</p>
<p>Bitmap 接口：用于在 state_bitmap_check 阶段发送 bitmap 请求，并检查权限是否通过。如果检测失败，则触发访问故障。HPTW 和 LLPTW 均具备此接口。</p>
<h5 id="刷新">刷新</h5>
<p>bitmap 依赖软件辅助刷新，硬件刷新不完整。在刷新前，需依次sfence 和 hfence L1 和L2TLB内所有项目，然后才可以拉高 CSR_MBMC_BCLEAR 进行bitmap cache刷新。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3c50cf87a79affd2dbf46b97a5ca0cdb">12.4.3.3.4 - Bitmap接口时序图</h1>
    
	<h2 id="bitmap接口时序图">Bitmap接口时序图</h2>
<p><img src="../../module03_1.png" alt=""></p>
<table>
  <thead>
      <tr>
          <th>信号</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>io_req_ready</td>
          <td>8个fsm中有至少一个idle时为高，可以视为常态高</td>
      </tr>
      <tr>
          <td>io_req_valid</td>
          <td>新请求进入时高，平时为低</td>
      </tr>
      <tr>
          <td>io_resp_ready</td>
          <td>当请求源（ptw hptw llptw）发送请求，等待返回时会拉高，平时无请求时为低</td>
      </tr>
      <tr>
          <td>io_resp_valid</td>
          <td>当返回查询结果时拉高，平时为低</td>
      </tr>
      <tr>
          <td>io_mem_req_ready</td>
          <td>有其它mem请求时（ptw llptw hptw）为低，平时为高</td>
      </tr>
      <tr>
          <td>io_mem_req_valid</td>
          <td>cache miss时发起mem请求拉高，平时为低</td>
      </tr>
      <tr>
          <td>io_mem_resp_valid</td>
          <td>mem 返回结果拉高，平时为低</td>
      </tr>
      <tr>
          <td>io_cache_req_valid</td>
          <td>bimap fsm 发起 cache 请求拉高，平时为低</td>
      </tr>
      <tr>
          <td>io_cache_req_ready</td>
          <td>常态高</td>
      </tr>
      <tr>
          <td>io_cache_resp_valid</td>
          <td>io_cache_req_valid下一clk 拉高平时低</td>
      </tr>
      <tr>
          <td>io_cache_resp_ready</td>
          <td>io_cache_req_valid 下一clk 拉高平时低</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a389bb1cb5d66249a6bc82fcc214610f">12.4.3.3.5 - 开销评估</h1>
    
	<h2 id="开销评估">开销评估</h2>
<p><strong>1. 基本配置</strong></p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"><strong>类别</strong></th>
          <th style="text-align: left"><strong>配置项</strong></th>
          <th style="text-align: left"><strong>参数**</strong>/*<strong>*设置</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>Shield-Bit 配置</strong></td>
          <td style="text-align: left">有效 Shield-XS 隔离模型</td>
          <td style="text-align: left">-</td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left">设置 Shield-Bitmap</td>
          <td style="text-align: left">_</td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left">Shield-Bitmap缓存大小</td>
          <td style="text-align: left">128 × 8 Bytes</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>KunminghuV2 配置</strong></td>
          <td style="text-align: left">TileLink Prototype</td>
          <td style="text-align: left">-</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>缓存层级配置</strong></td>
          <td style="text-align: left">L1 指令/数据缓存大小</td>
          <td style="text-align: left">64KB</td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left">L1 指令/数据 TLB</td>
          <td style="text-align: left">48-全关联（Full Association）</td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left">L2 缓存大小</td>
          <td style="text-align: left">1MB</td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left">L3 缓存大小</td>
          <td style="text-align: left">16MB</td>
      </tr>
  </tbody>
</table>
<p><strong>2. SPEC2006 性能数据</strong></p>
<p>SPECInt2006 Simpoint est.@<strong>3GHz</strong> <strong>GEOMEAN 44.62 <strong>-&gt;</strong> 44.29 (0.72% )</strong></p>
<p><img src="../../module04_1.png" alt=""></p>
<p>图 9.1 SPEC2006 性能开销</p>
<p>性能开销与DTLB Miss-rate 呈正比。有效的减少 DTLB 和 Shield-bitmap Cache 的miss-rate, 可以进一步提升性能。例如将缓存从 16 项扩展到 128 项，可使 GemsFDTD 的性能开销从 6.51% 降低至 2.36%。</p>
<p><strong>3. 硬件开销</strong></p>
<p>采用7纳米工艺制程，硬件面积开销仅为0.2%。</p>
<!-- | **模块** | **Cell ****面积****（平方微米）** |
| --- | --- |
| Shield-Bitmap Cache | 5,075 |
| Shield-Bitmap Checker | 1,088 |
| MMU Area | 50,843 |
| KMH V2 Core Area | 2,000,000 |
| Area Percentage | **<font style="color:#c00000;"><font style="color:#c00000;">0.3%** | -->
<table>
  <thead>
      <tr>
          <th>工艺</th>
          <th>子模块前 (单位: μm2)</th>
          <th>子模块后 (单位: μm2)</th>
          <th>百分比</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>T7</td>
          <td>Memblock.withoutBitmap:462415.887238</td>
          <td>Memblock.withBitmap:471410.993566</td>
          <td>+1.94524%</td>
      </tr>
      <tr>
          <td>T7</td>
          <td>L2TLB.withoutBitmap: 41538.554989</td>
          <td>L2TLB.withBitmap : 50843.978450</td>
          <td>+22.4%</td>
      </tr>
  </tbody>
</table>
<h2 id="时序违例">时序违例</h2>
<table>
  <thead>
      <tr>
          <th>模块路径</th>
          <th>clock period</th>
          <th>clock uncertainty</th>
          <th>data arrival time</th>
          <th>setup time</th>
          <th>slack</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>bitmap FSM -&gt; bitmap Cache Data Reg</td>
          <td>0.333 ns</td>
          <td>0.1 ns</td>
          <td>0.2724 ns</td>
          <td>0.0107 ns</td>
          <td>-0.0501 ns</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-787663ae6e6572d44662342c140b5dcc">12.4.3.4 - Shield-XS_Bitmap 单元验证</h1>
    <div class="lead">本文档将会对需要验证的点进行说明</div>
	<p>本文档将会对需要验证的点进行说明</p>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-3be48c9a62a64a4bc3986d27082ba76c">12.4.3.4.1 - 单元验证</h1>
    <div class="lead">验证需求</div>
	<h2 id="单元验证">单元验证</h2>
<h3 id="tlb-相关功能验证">TLB 相关功能验证</h3>
<table>
  <thead>
      <tr>
          <th>验证功能编号</th>
          <th>验证描述</th>
          <th>覆盖方法</th>
          <th>排列组合示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>TLB_001</td>
          <td>ITLB hit/miss 场景验证</td>
          <td>设计测试用例覆盖 ITLB 命中和未命中</td>
          <td>4K/2M/1G/512G 页大小</td>
      </tr>
      <tr>
          <td>TLB_002</td>
          <td>DTLB hit/miss 场景验证</td>
          <td>设计测试用例覆盖 DTLB 命中和未命中</td>
          <td>4K/2M/1G/512G 页大小</td>
      </tr>
      <tr>
          <td>TLB_003</td>
          <td>L2TLB hit/miss 场景验证</td>
          <td>设计测试用例覆盖 L2TLB 命中和替换</td>
          <td>4K/2M/1G/512G 页大小</td>
      </tr>
      <tr>
          <td>TLB_004</td>
          <td>L2TLB 压缩功能验证<br/>注：仅支持一阶段地址转换压缩，最多压缩8项</td>
          <td>测试TLB 压缩场景下，Bitmap 查询结果是否正确</td>
          <td>TLB 压缩启用 + 4K 页大小<br/></td>
      </tr>
  </tbody>
</table>
<h3 id="bitmap-cache-相关功能验证">Bitmap Cache 相关功能验证</h3>
<table>
  <thead>
      <tr>
          <th>验证功能编号</th>
          <th>验证描述</th>
          <th>覆盖方法</th>
          <th>排列组合示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>BITMAP_001</td>
          <td>Bitmap Cache hit/miss 场景验证</td>
          <td>设计测试用例覆盖命中和未命中</td>
          <td>Bitmap Y/N + 跨bitmap cache line</td>
      </tr>
      <tr>
          <td>BITMAP_002</td>
          <td>Bitmap check 功能验证</td>
          <td>验证 bitmap check 的正确性</td>
          <td>Bitmap check 启用 + 4K 页大小</td>
      </tr>
      <tr>
          <td>BITMAP_003</td>
          <td>跨bitmap cache line 场景验证</td>
          <td>测试跨 cache line 的访问行为</td>
          <td>跨bitmap cache line + 2M 页大小</td>
      </tr>
      <tr>
          <td>BITMAP_004</td>
          <td>NAPOT 拓展开启，验证Bitmap 的行为</td>
          <td>开启NAPOT，设置PTE.n 位，验证Bitmap 检测流程</td>
          <td>跨bitmap cache line + 64K 页大小切换PTE.n 位</td>
      </tr>
  </tbody>
</table>
<h3 id="bitmap-cache-和-tlb-组合相关功能验证">Bitmap Cache 和 TLB 组合相关功能验证</h3>
<table>
  <thead>
      <tr>
          <th>验证功能编号</th>
          <th>验证描述</th>
          <th>覆盖方法</th>
          <th>排列组合示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>TLB_BITMAP_001</strong></td>
          <td>Bitmap与TLB混合命中场景验证</td>
          <td>组合Bitmap命中与各级TLB命中，验证多级缓存协同</td>
          <td>Bitmap hit + ITLB/DTLB/L2TLB全命中<br/><br/></td>
      </tr>
      <tr>
          <td><strong>TLB_BITMAP_002</strong></td>
          <td>全未命中极端场景验证</td>
          <td>设计冷启动或冲刷缓存后首次访问的全未命中用例</td>
          <td>Bitmap miss + ITLB/DTLB/L2TLB全miss + 触发页表遍历</td>
      </tr>
      <tr>
          <td><strong>TLB_BITMAP_003</strong></td>
          <td>Bitmap跨行与TLB替换场景验证</td>
          <td>强制Bitmap跨cache line访问并触发TLB替换（如duplicate access或页表更新）</td>
          <td>Bitmap跨行 + DTLB miss + L2TLB替换</td>
      </tr>
      <tr>
          <td><strong>TLB_BITMAP_004</strong></td>
          <td>重复访问与Cache/TLB交互验证</td>
          <td>通过相同地址重复访问验证Bitmap/TLB的重复访问优化</td>
          <td>Bitmap重复命中 + ITLB重复命中 + 无替换<br/>Bitmap重复Miss + ITLB重复Miss + 替换</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="页表遍历ptw相关功能验证">页表遍历（PTW）相关功能验证</h3>
<table>
  <thead>
      <tr>
          <th>验证功能编号</th>
          <th>验证描述</th>
          <th>覆盖方法</th>
          <th>排列组合示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>PTW_001</td>
          <td>PTW/HPTW/LLPTW 优先级验证</td>
          <td>测试多级页表遍历的优先级</td>
          <td>PTW + HPTW 并发</td>
      </tr>
      <tr>
          <td>PTW_002</td>
          <td>PTW 返回异常（access fault）验证</td>
          <td>模拟 PTW 返回异常的场景</td>
          <td>PTW return af + 跨Page</td>
      </tr>
      <tr>
          <td>PTW_003</td>
          <td>PTE 合法性验证</td>
          <td>测试非法 PTE 的处理</td>
          <td>非法 PTE + PMP check</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="异常与重放replay功能验证">异常与重放（Replay）功能验证</h3>
<table>
  <thead>
      <tr>
          <th>验证功能编号</th>
          <th>验证描述</th>
          <th>覆盖方法</th>
          <th>排列组合示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>REPLAY_001</td>
          <td>标量 replay 场景验证</td>
          <td>测试标量指令重放行为</td>
          <td>标量 replay + access fault</td>
      </tr>
      <tr>
          <td>REPLAY_002</td>
          <td>向量访存 replay 场景验证</td>
          <td>测试向量指令重放行为</td>
          <td>向量 replay + 跨MMO</td>
      </tr>
      <tr>
          <td>EXCEPT_001</td>
          <td>异常优先级验证（access/page fault/guest page fault）</td>
          <td>验证异常触发的优先级</td>
          <td>page fault/guest page fault<br/>page table walker 过程中的PMP/bitmap 检测失败<br/>转换之后的物理地址PMP 检测失败</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="特权级与扩展功能验证">特权级与扩展功能验证</h3>
<table>
  <thead>
      <tr>
          <th>验证功能编号</th>
          <th>验证描述</th>
          <th>覆盖方法</th>
          <th>排列组合示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>PRIV_001</td>
          <td>U/S/M 特权级切换验证</td>
          <td>测试不同特权级下的访问权限</td>
          <td>U/S/M + 4K/2M 页大小</td>
      </tr>
      <tr>
          <td>EXT_001</td>
          <td>H-extension 功能验证</td>
          <td>测试 H-extension 启用和禁用场景</td>
          <td>H-extension + 跨tlb entry</td>
      </tr>
      <tr>
          <td>PMP_001</td>
          <td>PMP check 功能验证</td>
          <td>测试bitmap 内PMP 权限检查</td>
          <td>PMP Y/N + 跨Page</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="fense验证">Fense验证</h3>
<table>
  <thead>
      <tr>
          <th>验证功能编号</th>
          <th>验证描述</th>
          <th>覆盖方法</th>
          <th>排列组合示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>MISC_001</td>
          <td>Fence 操作验证</td>
          <td>测试 fence 指令的同步效果</td>
          <td>Fence + 切换Cmode</td>
      </tr>
  </tbody>
</table>
<h3 id="验证方法说明">验证方法说明</h3>
<p><strong>覆盖方法</strong>：通过随机测试、定向测试和边界值测试覆盖功能点。</p>
<p><strong>排列组合</strong>：优先覆盖高频场景，再逐步覆盖低频组合（如 512G 页）。</p>
<h3 id="备注">备注</h3>
<ul>
<li>
<p>需根据实际硬件行为调整测试用例的输入和预期输出。</p>
</li>
<li>
<p>动态检查（如 PMP check）需结合具体权限配置。</p>
</li>
</ul>

</div>



    
	
  

    
	
  

    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8dbadf515bd82346f64914c420b7494c">12.5 - Misc</h1>
    
	<p>其他模块验证文档</p>

</div>



    
      
  
  
  
  

  
  

  

    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3acd98556bb6e01bccfdb9fe2c4cfdc0">13 - 维护者</h1>
    
	<p>在提交 issue、pull request、discussion 时，如果指定对应模块的 maintainer 能更及时的得到响应。目前已有的维护人员如下（首字母排名）：</p>
<p><strong>验证工具：</strong></p>
<ul>
<li>picker：<a href="https://github.com/Makiras">Makiras</a>, <a href="https://github.com/SFangYy">SFangYy</a>, <a href="https://github.com/yaozhicheng">yaozhicheng</a></li>
<li>toffee/toffe-test：<a href="https://github.com/Miical">Miical</a>, <a href="https://github.com/yaozhicheng">yaozhicheng</a></li>
</ul>
<!-- <script src="../../js/echarts.min.js"></script> -->
<script>
function update_maintainers(data_url){
    updateMaintainers(data_url)
}
</script>
<div style="text-align: center; width: 100%;">

<label>当前版本：</label>
<select id="maintainersurlSelect" onchange="updateLink()" style="border: 0px">
    
    
    
    
    
    <option value="20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty" data-url="../../data/reports//UnityChipForXiangShan/20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty"  selected>20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty</option>
    
</select>
<a id="maintainersgoLink" href="#" target=“_blank“></a>

<script>
function updateLink() {
    var select = document.getElementById("maintainersurlSelect");
    var goLink = document.getElementById("maintainersgoLink");
    var opt = select.options[select.selectedIndex];
    if(!opt){
        return
    }
    var url = opt.getAttribute("data-url").replaceAll("/UnityChipForXiangShan/", "");
    goLink.href = url;
    
    window["update_maintainers"](url + "/ut_data_progress.json");
    
}
document.addEventListener('DOMContentLoaded', function() {
    updateLink()
});
</script>

</div>
<br>

<style>
#father-maintainers{
    font-size: 18px;
}

#son-maintainers{
    font-size: 16px;
}

#father-maintainers p, #son-maintainers .dynamic {
    margin-left: 20px;  
    text-indent: -20px;  
    padding-left: 20px;  
    position: relative;
}

#father-maintainers p::before, #son-maintainers .dynamic::before {
    content: "•";  
    font-size: 18px;  
    color: black;  
    position: absolute;
    left: 0;
    top: 0;
}
    
</style>
    
    
<div id="div-maintainers">
    <div id="father-maintainers">
        <p style="font-weight: bold;">主UT模块</p>
    </div>

    <div id="son-maintainers">
        <p style="font-weight: bold;">子UT模块</p>
    </div>
</div>
    
<script>

function updateMaintainers(data_url){
    $.getJSON(data_url, function (data) {
        var index = 1;
        $("#father-maintainers").html(`<p style="font-weight: bold;">主UT模块</p>`);
        $("#son-maintainers").html(`<p style="font-weight: bold;">子UT模块</p>`);
        const prefixes = []
        const fathers = []
        const sons = []
        
        function traverse(node, level = 1) {
            const name = node.name || "Unnamed";
            var maintainer = "TBD";
            if (node.maintainers){
                maintainers = []
                for (let i = 0; i < node.maintainers.length; i++){
                    let cur = node.maintainers[i]
                    let tmp_maintainer = cur.name || "TBD";
                    if (cur.page){
                        tmp_maintainer = "<a href=\"" + cur.page + "\">" + tmp_maintainer + "</a>"
                    } else {
                        tmp_maintainer = "<a>" + tmp_maintainer + "</a>"
                    }
                    maintainers.push(tmp_maintainer)
                }
                maintainer = maintainers.join(' ')
            }
            
            var has_son =  node.children && (node.children.length > 0)
            
            if (level > 1){
                prefixes.push(name);
                if (level == 2){

                    fathers.push("<p class=\"dynamic\">" + prefixes.join('.') + ": " + maintainer + "</p>")

                } else {
                    push_son = (!has_son) || (has_son && maintainer !== "TBD")
                    if (push_son){
                        sons.push("<p class=\"dynamic\">" + prefixes.join('.') + ": " + maintainer + "</p>")

                    }
                }
            }

            if (node.children && node.children.length > 0) {
                $.each(node.children, function (index, child) {
                    traverse(child, level + 1);
                });
            }

            if (level > 1){
                prefixes.pop()
            }
        }
        
        traverse(data.tree);
        

        
        $("#father-maintainers").html($("#father-maintainers").html() + fathers.join(''));
        $("#son-maintainers").html($("#son-maintainers").html() + sons.join(''));
    });
}
</script>

<p>*其他维护者陆续更新中</p>
<p>如果您对本项目感兴趣，欢迎申请成为本项目中的维护者。</p>

</div>



    
	
  



          </main>
        </div>
      </div>
      <footer class="td-footer row d-print-none">
  <div class="container-fluid">
    <div class="row mx-md-2">
      <div class="td-footer__left col-6 col-sm-4 order-sm-1">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="User mailing list" aria-label="User mailing list">
    <a target="_blank" rel="noopener" href="https://example.org/mail" aria-label="User mailing list">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__right col-6 col-sm-4 order-sm-3">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="GitHub" aria-label="GitHub">
    <a target="_blank" rel="noopener" href="https://github.com/google/docsy" aria-label="GitHub">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2">
        <span class="td-footer__copyright">&copy;
    2025
    <span class="td-footer__authors">BOSC</span></span><span class="td-footer__all_rights_reserved">保留所有权利</span><span class="ms-2"><a href="https://policies.google.com/privacy" target="_blank" rel="noopener">隐私政策</a></span>
      </div>
    </div>
  </div>
</footer>

    </div>
    <script src="/UnityChipForXiangShan/js/main.min.8bdc707530d61dee3a6fd659f8a422c05d2e2319377a8710175451ca21fa83b0.js" integrity="sha256-i9xwdTDWHe46b9ZZ&#43;KQiwF0uIxk3eocQF1RRyiH6g7A=" crossorigin="anonymous"></script>
<script src='/UnityChipForXiangShan/js/prism.js'></script>
<script src='/UnityChipForXiangShan/js/tabpane-persist.js'></script>

  </body>
</html>
