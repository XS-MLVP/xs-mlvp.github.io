<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LSQ on 万众一芯之香山处理器</title>
    <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/</link>
    <description>Recent content in LSQ on 万众一芯之香山处理器</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LoadQueueRAR</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/01_loadqueuerar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/01_loadqueuerar/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文档参考&lt;a href=&#34;https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ&#34;&gt;香山LSQ设计文档&lt;/a&gt;写成&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文档撰写的内容截至[ca892e73]&lt;/p&gt;&#xA;&lt;p&gt;请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！&lt;/p&gt;&#xA;&lt;h1 id=&#34;loadqueuerar-简介&#34;&gt;LoadQueueRAR 简介&lt;/h1&gt;&#xA;&lt;p&gt;LoadQueueRAR用于保存已经完成的load指令的用于load to load违例检测的信息。&lt;/p&gt;&#xA;&lt;p&gt;多核环境下会出现load to load违例。单核环境下相同地址的load乱序执行本来是不关心的，但是如果两个load之间有另外一个核做了相同地址的store，并且本身这个核的两个load做了乱序调度，就有可能导致新的load没有看到store更新的结果，但是旧的load看到了，出现了顺序错误。&lt;/p&gt;&#xA;&lt;p&gt;多核环境下的load-load违例有一个特征，当前DCache一定会收到L2 cache发来的Probe请求，使得DCache主动释放掉这个数据副本，这时DCache会通知load queue，将相同地址的load queue中已经完成访存的项做一个release标记。后续发往流水线的load指令会查询load queue中在它之后相同地址的load指令，如果存在release标记，就发生了load-load违例。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;L2Cache&lt;/td&gt;&#xA;          &lt;td&gt;二级高速缓存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;DCache&lt;/td&gt;&#xA;          &lt;td&gt;数据缓存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ROB&lt;/td&gt;&#xA;          &lt;td&gt;重排序缓冲区&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CAM&lt;/td&gt;&#xA;          &lt;td&gt;内容可寻址存储器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;FTQ&lt;/td&gt;&#xA;          &lt;td&gt;取指目标队列&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;ld-ld违例&#34;&gt;ld-ld违例&lt;/h2&gt;&#xA;&lt;p&gt;多核环境下，可能会出现load to load违例：在单核环境中，相同地址的load乱序执行通常不被关注，因为它们在同一核内执行，不会影响其他核的状态，也不会被其他核的操作影响。但是，当两个load操作之间有另一个核对相同地址进行了store操作，情况就变得复杂。&lt;/p&gt;&#xA;&lt;p&gt;考虑以下指令序列：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;load1（core1）&#xA;store（core2） &#xA;load2（core1）&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;指令的实际执行顺序为：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;load2（core1）&#xA;store（core2） &#xA;load1（core1）&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于指令的乱序执行，可能导致以下情况：旧的 load1 指令在执行时读取到了 store 修改后的新数据，而新的 load2 指令却读取到了未被修改的旧数据。这种执行顺序的变化会导致数据的不一致性，进而引发访存错误。&lt;/p&gt;&#xA;&lt;p&gt;因此，在多核环境中，正确处理指令的执行顺序和内存一致性是至关重要的，以确保所有核都能看到一致的内存状态。&lt;/p&gt;&#xA;&lt;h2 id=&#34;整体框图&#34;&gt;整体框图&lt;/h2&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../LoadQueueRAR_structure.svg&#34;&#xA;         alt=&#34;LoadQueueRAR结构示意图&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#xA;    图1：LoadQueueRAR结构示意图&lt;br&gt;&lt;br&gt;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;LoadQueueRAR最多能够存储72条指令（为了同VirtualLoadQueue的大小保持一致），每条指令占用一个条目。每个条目包含指令的物理地址（paddr）、与指令相关的信息（uop）、以及标记为已释放（released）和已分配（allocated）的状态寄存器。&lt;/p&gt;&#xA;&lt;p&gt;该模块通过 FreeList 子模块管理 entry 资源，FreeList 中存储的是 entry 的编号。当一条指令满足入队条件时，FreeList 会为其分配一个 entry 编号，并将该指令存放在相应的 entry 中。指令出队时，需要释放所占用的 entry 资源，并将条目编号重新放回 FreeList 中，以供后续指令使用。&lt;/p&gt;&#xA;&lt;p&gt;PaddrModule 的实现基于内容可寻址存储器（CAM），其深度为 72，数据宽度为 48。CAM 为每条流水线提供一个写端口，其中物理地址（paddr）作为写数据（wdata），条目编号作为写地址（waddr）。此外，CAM 还为每条流水线提供了一个地址查询端口（releaseViolationMdata），并为数据缓存（DCache）提供另一个地址查询端口（releaseMdata）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LoadQueueRAW</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/02_loadqueueraw/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/02_loadqueueraw/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文档参考&lt;a href=&#34;https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ&#34;&gt;香山LSQ设计文档&lt;/a&gt;写成&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文档撰写的内容截至[ca892e73]&lt;/p&gt;&#xA;&lt;p&gt;请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！&lt;/p&gt;&#xA;&lt;h1 id=&#34;loadqueueraw-简介&#34;&gt;LoadQueueRAW 简介&lt;/h1&gt;&#xA;&lt;p&gt;LoadQueueRAW是用于处理store-load违例的。由于load和store在流水线中都是乱序执行，会经常出现load越过了更老的相同地址的store，即这条load本应该前递store的数据，但是由于store地址或者数据没有准备好，导致这条load没有前递到store的数据就已经提交，后续使用这条load结果的指令也都发生了错误，于是产生store to load forwarding违例。&lt;/p&gt;&#xA;&lt;p&gt;当store address通过STA保留站发射出来进入store流水线时，会去查询LQRAW中在这条store后面的所有已经完成访存的相同地址的load，以及load流水线中正在进行的在该条store之后的相同地址的load，一旦发现有，就发生了store to load forwarding违例，可能有多个load发生了违例，需要找到离store最近的load，也就是最老的违例的load，然后给RedirectGenerator部件发送重定向请求，冲刷最老的违例的load及之后的所有指令。&lt;/p&gt;&#xA;&lt;p&gt;当store流水线执行cbo zero指令时，也需要进行store-load违例检查。&lt;/p&gt;&#xA;&lt;h2 id=&#34;st-ld违例&#34;&gt;st-ld违例&lt;/h2&gt;&#xA;&lt;p&gt;在现代处理器中，Load 和 Store 指令通常采用乱序执行的方式进行处理。这种执行策略旨在提高处理器的并行性和整体性能。然而，由于 Load 和 Store 指令在流水线中的乱序执行，常常会出现 Load 指令越过更早的相同地址的 Store 指令的情况。这意味着，Load 指令本应通过前递（forwarding）机制从 Store 指令获取数据，但由于 Store 指令的地址或数据尚未准备好，导致 Load 指令未能成功前递到 Store 的数据，而 Store 指令已被提交。由此，后续依赖于该 Load 指令结果的指令可能会出现错误，这就是 st-ld 违例。&lt;/p&gt;&#xA;&lt;p&gt;考虑以下伪代码示例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ST R1, 0(R2)  ; 将 R1 的值存储到 R2 指向的内存地址&#xA;LD R3, 0(R2)  ; 从 R2 指向的内存地址加载值到 R3&#xA;ADD R4, R3, R5 ; 使用 R3 的值进行计算&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设在这个过程中，Store 指令由于某种原因（如缓存未命中）未能及时完成，而 Load 指令已经执行并读取了旧的数据（例如，从内存中读取到的值为 &lt;code&gt;0&lt;/code&gt;）。此时，Load 指令并未获得 Store 指令更新后的值，导致后续计算的数据错误。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LoadQueueReplay</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/03_loadqueuereplay/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/03_loadqueuereplay/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文档参考&lt;a href=&#34;https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ&#34;&gt;香山LSQ设计文档&lt;/a&gt;写成&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文档撰写的内容截至[ca892e73]&lt;/p&gt;&#xA;&lt;p&gt;请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！&lt;/p&gt;&#xA;&lt;h1 id=&#34;loadqueuereplay-简介&#34;&gt;LoadQueueReplay 简介&lt;/h1&gt;&#xA;&lt;p&gt;LoadQueueReplay 模块是现代处理器架构中用于处理 Load 指令重发的重要组成部分。它负责管理因各种原因而需要重发的 Load 指令，确保指令执行的正确性和高效性。&lt;/p&gt;&#xA;&lt;h2 id=&#34;整体框图&#34;&gt;整体框图&lt;/h2&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../LoadQueueReplay_structure.png&#34;&#xA;         alt=&#34;LoadQueueReplay结构示意图&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#xA;    图1：LoadQueueReplay结构示意图&lt;br&gt;&lt;br&gt;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;LoadQueueReplay 最多存放72条指令，涉及多个状态和存储的信息。其关键组成部分如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Allocated&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;表示某个 Load 重发队列项是否已经被分配，反映该项的有效性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Scheduled&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指示某个 Load 重发队列项是否已被调度，意味着该项已经被选出，并将被发送至 Load Unit 进行重发。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Uop&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;该队列项对应的 Load 指令执行信息，包括微操作（uop）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Cause&lt;/strong&gt;：指示该 Load 指令重发的原因，主要包括以下几种情况：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_MA&lt;/strong&gt;：存储-加载（st-ld）违反重新执行。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_TM&lt;/strong&gt;：TLB（翻译后备页表）缺失。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_FF&lt;/strong&gt;：存储-加载转发。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_DR&lt;/strong&gt;：数据缓存（dcache）需要重发。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_DM&lt;/strong&gt;：数据缓存缺失。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_WF&lt;/strong&gt;：路径预测失败。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_BC&lt;/strong&gt;：数据缓存路径冲突。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_RAR&lt;/strong&gt;：读取-读取（RAR）队列无法接收。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_RAW&lt;/strong&gt;：读取-写入（RAW）队列无法接收。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_NK&lt;/strong&gt;：存储-加载违反。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Blocking&lt;/strong&gt;：指示该 Load 指令因等待条件而被阻塞，不能被调度重发。阻塞的原因和解除阻塞的条件包括：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_MA&lt;/strong&gt;：存储指令的地址就绪。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_TM&lt;/strong&gt;：TLB 回填完毕，并发送 Hint 信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_FF&lt;/strong&gt;：存储指令的数据就绪。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_DM&lt;/strong&gt;：数据缓存回填完毕。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_RAR&lt;/strong&gt;：RAR 队列未满，且 Load 指令比 Load Queue 的写回项更老。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_RAW&lt;/strong&gt;：RAW 队列未满，且 Load 指令比 Store Queue 中所有地址准备好的项都更老。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;LoadReplayQueue 通过 FreeList 管理队列的空闲状态。FreeList 的大小等于 LoadReplayQueue 的项数，分配宽度为3（Load Unit 的数量），释放宽度为 4。同时，Free List 可以反馈 Load Replay Queue 的空余项数量以及是否已满的信息。除了FreeList，LoadQueueReplay还包含两个子模块：AgeDetector 和 LqVAddrModule，其中 AgeDetector 用于寻找一系列load replay queue项中最早入队的一项。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LoadQueueUncache</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/04_loadqueueuncache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/04_loadqueueuncache/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文档参考&lt;a href=&#34;https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ&#34;&gt;香山LSQ设计文档&lt;/a&gt;写成&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文档撰写的内容截至[66e9b546]&lt;/p&gt;&#xA;&lt;p&gt;请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！&lt;/p&gt;&#xA;&lt;h1 id=&#34;loadqueueuncache-简介&#34;&gt;LoadQueueUncache 简介&lt;/h1&gt;&#xA;&lt;p&gt;LoadQueueUncache 和 Uncache 模块，对于 uncache load 访问请求来说，起到一个从 LoadUnit 流水线到总线访问的中间站作用。其中 Uncache 模块，作为靠近总线的一方，主要用于处理 uncache 访问到总线的请求和响应。LoadQueueUncache 作为靠近流水线的一方，需要承担以下责任：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;接收 LoadUnit 流水线传过来的 uncache load 请求。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;选择已准备好 uncache 访问的 uncache load 请求 发送到 Uncache Buffer。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;接收来自 Uncache Buffer 的处理完的 uncache load 请求。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;将处理完的 uncache load 请求 返回给 LoadUnit。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;LoadQueueUncache 结构上，目前有 4 项（项数可配）UncacheEntry，每一项独立负责一个请求并利用一组状态寄存器控制其具体处理流程；有一个 FreeList，管理各项分配和回收的情况。而 LoadQueueUncache 主要是协同 4 项的新项分配、请求选择、响应分派、出队等统筹逻辑。&lt;/p&gt;&#xA;&lt;h2 id=&#34;整体框图&#34;&gt;整体框图&lt;/h2&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../LoadQueueUncache_structure.svg&#34;&#xA;         alt=&#34;LoadQueueUncache结构示意图&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#xA;    图1：LoadQueueUncache结构示意图&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;UnCacheBuffer 最多存放4条指令，除了 FreeList 之外，另一个重要的子模块是 UncacheEntry，管理每个Uncahce请求，负责发起Uncache，写回Uncache数据。每个Entry内维护一个用于发起Uncache请求的状态机，状态机的状态转换图如下：&lt;/p&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../UncacheEntry.png&#34;&#xA;         alt=&#34;UncacheEntry结构示意图&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#xA;    图2：UncacheEntry状态转换图&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;s_idl:该项还未发起一个MMIO请求。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;s_req:向uncache模块发起MMIO请求，等待请求被接收。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;s_resp:等待uncache模块的MMIO响应。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;s_wait:等待将MMIO结果写回流水线。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;功能简介&#34;&gt;功能简介&lt;/h1&gt;&#xA;&lt;mrs-functions&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;功能1uncache指令请求入队&#34;&gt;功能1：Uncache指令请求入队&lt;/h3&gt;&#xA;&lt;p&gt;LoadQueueUncache 负责接收来自 LoadUnit 0、1、2 三个模块的请求，这些请求可以是 MMIO 请求，也可以是 NC 请求。&lt;/p&gt;</description>
    </item>
    <item>
      <title>StoreQueue</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/06_storequeue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/06_storequeue/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文档参考&lt;a href=&#34;https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ&#34;&gt;香山LSQ设计文档&lt;/a&gt;写成&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文档撰写的内容截至[ca892e73]&lt;/p&gt;&#xA;&lt;p&gt;请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！&lt;/p&gt;&#xA;&lt;h1 id=&#34;storequeue-简介&#34;&gt;StoreQueue 简介&lt;/h1&gt;&#xA;&lt;p&gt;StoreQueue是一个队列，用来装所有的 store 指令，功能如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在跟踪 store 指令的执行状态&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;存储 store 的数据，跟踪数据的状态（是否到达）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;为load提供查询接口，让load可以forward相同地址的store&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;负责 MMIO store和NonCacheable store的执行&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;将被 ROB 提交的 store 写到 sbuffer 中&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;维护地址和数据就绪指针，用于LoadQueueRAW的释放和LoadQueueReplay的唤醒&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;store进行了地址与数据分离发射的优化，即 StoreUnit 是 store 的地址发射出来走的流水线，StdExeUnit 是 store 的数据发射出来走的流水线，是两个不同的保留站，store 的数据就绪了就可以发射到 StdExeUnit，store 的地址就绪了就可以发射到 StoreUnit。&lt;/p&gt;&#xA;&lt;h2 id=&#34;整体框图&#34;&gt;整体框图&lt;/h2&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../StoreQueue_structure.svg&#34;&#xA;         alt=&#34;StoreQueue结构示意图&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#xA;    图1：StoreQueue结构示意图&lt;br&gt;&lt;br&gt;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;StoreQueue最多可以存放64条指令，&lt;strong&gt;store queue 中重要的状态位有：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;allocated：RS在storeQueue队列有空闲时，会设置这个entry的allocated状态，开始记录这条store 的生命周期。同时发射到StoreUnit/ StdExeUnit 2条流水。当这条store指令被提交到Sbuffer时，allocated状态被清除。&lt;/li&gt;&#xA;&lt;li&gt;addrvalid：在StoreUnit的S1更新，表示是否已经经过了地址转换得到物理地址，用于 load forward 检查时的 cam 比较。&lt;/li&gt;&#xA;&lt;li&gt;datavalid：在StdExeUnit 的S1更新，表示store 的数据是否已经被发射出来，是否已经可用&lt;/li&gt;&#xA;&lt;li&gt;committed：在store 是否已经被 ROB commit 了&lt;/li&gt;&#xA;&lt;li&gt;pending：在StoreUnit的S2更新，在这条 store 是否是 MMIO 空间的 store，主要是用于控制 MMIO 的状态机&lt;/li&gt;&#xA;&lt;li&gt;mmio：在StoreUnit的S2更新，这条 store 是否是 MMIO 空间的 store，主要是用于控制对 sbuffer 的写&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;非对齐store指令&#34;&gt;非对齐store指令&lt;/h2&gt;&#xA;&lt;p&gt;StoreQueue支持处理非对齐的Store指令，每一个非对齐的Store指令占用一项，并在写入dataBuffer对地址和数据对齐后写入。&lt;/p&gt;</description>
    </item>
    <item>
      <title>VirtualLoadQueue</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/05_virtualloadqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/05_virtualloadqueue/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文档参考&lt;a href=&#34;https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ&#34;&gt;香山LSQ设计文档&lt;/a&gt;写成&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文档撰写的内容截至[ca892e73]&lt;/p&gt;&#xA;&lt;p&gt;请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！&lt;/p&gt;&#xA;&lt;h1 id=&#34;virtualloadqueue-简介&#34;&gt;VirtualLoadQueue 简介&lt;/h1&gt;&#xA;&lt;p&gt;Virtualloadqueue是一个队列，用于存储所有load指令的微操作(MicroOp)，并维护这些load指令之间的顺序，它的功能类似于重排序缓冲区（Reorder Buffer, ROB），但专注于load指令的管理。其主要功能是跟踪Load指令执行状态，以确保在并发执行的环境中，加载操作能够正确、有序地完成。&lt;/p&gt;&#xA;&lt;h2 id=&#34;整体框图&#34;&gt;整体框图&lt;/h2&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../VirtualLoadQueue_structure.png&#34;&#xA;         alt=&#34;VirtualLoadQueue结构示意图&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#xA;    图1：VirtualLoadQueue结构示意图&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;Virtualloadqueue最多可以存放72条指令，dispatch阶段最多支持6条指令同时入队，最多支持8条指令出队。Virtualloadqueue对于每一个 entry 中的 load 指令都有若干状态位来标识这个 load 处于什么状态：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;allocated&lt;/strong&gt;：该项是否分配了load，用于确定load指令的生命周期。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;isvec&lt;/strong&gt;：该指令是否是向量load指令。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;committed&lt;/strong&gt;: 该项是否提交。&lt;/p&gt;&#xA;&lt;h1 id=&#34;功能简介&#34;&gt;功能简介&lt;/h1&gt;&#xA;&lt;mrs-functions&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;功能1load指令请求入队&#34;&gt;功能1：load指令请求入队&lt;/h3&gt;&#xA;&lt;p&gt;在调度阶段，保留站通过入队（enq）总线向VirtualLoadQueue发起入队请求，最多支持六组并发请求。成功入队的条件包括以下几点：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;StoreQueue 和 LoadQueue 有预留空间：确保LoadQueue有足够的容量来接收新的加载指令，以避免队列溢出。确保StoreQueu有预留空间则是基于数据一致性和避免指令阻塞的考虑，因为store指令入队阻塞可能会导致load指令无法正确读取或forward到数据。&lt;/li&gt;&#xA;&lt;li&gt;入队请求有效：入队请求必须是合法的，确保指令在调度过程中可以被正确处理。&lt;/li&gt;&#xA;&lt;li&gt;指令未被冲刷：确保指令在入队时没有被系统标记为无效或被撤销。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;成功入队之后，系统会执行以下操作：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;将指令的lqidx作为索引，将对应的allocated寄存器置1，bits信息写入uop寄存器。&lt;/li&gt;&#xA;&lt;li&gt;计算新的lqidx值，作为enq_resp传送给保留站。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;功能2接收load流水线写回的数据&#34;&gt;功能2：接收load流水线写回的数据&lt;/h3&gt;&#xA;&lt;p&gt;在 load 流水线的s3阶段，load unit会将指令执行的信息通过总线 ldin 写回到 VirtualLoadQueue。具体写回信息包括：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;是否发生了异常以及异常类型&lt;/li&gt;&#xA;&lt;li&gt;dcache是否命中&lt;/li&gt;&#xA;&lt;li&gt;tlb是否命中&lt;/li&gt;&#xA;&lt;li&gt;是否为mmio指令&lt;/li&gt;&#xA;&lt;li&gt;是否为软件预取或者硬件预取&lt;/li&gt;&#xA;&lt;li&gt;是否需要重发以及重发的原因&lt;/li&gt;&#xA;&lt;li&gt;写uop的使能信号&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;写回需要满足的条件如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;ldin 总线的 valid 信号需要拉高，表明当前正在进行有效的数据传输。&lt;/li&gt;&#xA;&lt;li&gt;指令不应需要重发（即 &lt;code&gt;need_rep&lt;/code&gt; 信号为 0），否则将影响写回的正常进行。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;在满足写回条件后，系统将生成相应的写回响应，具体包括以下几个方面：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果在执行过程中发生了异常、TLB命中或软件预取操作，&lt;code&gt;addrvalid&lt;/code&gt; 信号将被置为 1，表示地址信息有效。&lt;/li&gt;&#xA;&lt;li&gt;如果在执行过程中发生了异常、MMIO操作、DCACHE命中并且不需要重发，或是软件预取操作，&lt;code&gt;datavalid&lt;/code&gt; 信号将被置为 1，表示数据有效。&lt;/li&gt;&#xA;&lt;li&gt;指令在流水线的 S3 阶段有效（注意：不能是硬件预取指令）。当 &lt;code&gt;ldin&lt;/code&gt; 总线的写使能信号 &lt;code&gt;data_wen_dup&lt;/code&gt; 拉高时，将更新队列中的uop信息，以确保指令的状态及时反映。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;系统将&lt;code&gt;addrvalid&lt;/code&gt;和&lt;code&gt;datavalid&lt;/code&gt;分开进行处理是考虑到在一些情况下，地址可以被重用，而数据可能需要重新请求（如dcache miss/mmio/软件预取等）。分开标识可以减少流水线停顿，允许处理器在地址有效时继续执行其他指令，而不必等待数据有效性确认，从而优化整体性能。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
