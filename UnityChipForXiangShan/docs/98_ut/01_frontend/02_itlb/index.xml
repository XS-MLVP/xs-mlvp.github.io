<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ITLB on 万众一芯之香山处理器</title>
    <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/</link>
    <description>Recent content in ITLB on 万众一芯之香山处理器</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>IO接口说明</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/04_io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/04_io/</guid>
      <description>香山实例化 TLB.sv 接口说明（ITLB） 基本控制信号 clock: 时钟信号，驱动 TLB 的时序逻辑。 reset: 复位信号，用于重置 TLB 的状态。 刷新（SFENCE）接口信号 io_sfence_valid: SFENCE 操作的有效性标志。 io_sfence_bits_rs1: SFENCE 操作是否使用寄存器 rs1 的值。 io_sfence_bits_rs2: SFENCE 操作是否使用寄存器 rs2 的值。 io_sfence_bits_addr: SFENCE 操作指定的地址，用于选择性刷新特定地址的 TLB 条目。 io_sfence_bits_id: 刷新操作指定的 asid/vmid，用于选择性刷新特定地址空间的 TLB 条目。 io_sfence_bits_flushPipe: 刷新整个管道。 io_sfence_bits_hv: 指示指令是否为 HFENCE.VVMA，即是否刷新虚拟化下由 vsatp 寄存器控制的条目。 io_sfence_bits_hg: 指示指令是否为 HFENCE.GVMA，即是否刷新由 hgatp 寄存器控制的条目。 控制与状态寄存器（CSR）接口信号 io_csr_satp_mode: SATP 寄存器的模式字段（如裸模式、Sv32、Sv39 等）。 io_csr_satp_asid: 当前 SATP 寄存器的 ASID（地址空间标识符）。 io_csr_satp_changed: 指示 SATP 寄存器的值是否已更改。 io_csr_vsatp_mode: VSATP 寄存器的模式字段。 io_csr_vsatp_asid: VSATP 寄存器的 ASID。 io_csr_vsatp_changed: 指示 VSATP 寄存器的值是否已更改。 io_csr_hgatp_mode: HGATP 寄存器的模式字段。 io_csr_hgatp_vmid: HGATP 寄存器的 VMID（虚拟机标识符）。 io_csr_hgatp_changed: 指示 HGATP 寄存器的值是否已更改。 io_csr_priv_virt: 指示是否在虚拟模式下运行。 io_csr_priv_imode: 指令模式的特权级（如用户态、内核态等）。 请求者（Requestor）接口信号 Requestor 0 信号 io_requestor_0_req_valid: requestor0 的请求有效信号。 io_requestor_0_req_bits_vaddr: requestor0 的请求虚拟地址。 io_requestor_0_resp_bits_paddr_0: requestor0 的物理地址响应信号。 io_requestor_0_resp_bits_gpaddr_0: requestor0 的物理地址转换为 GPA（Guest Physical Address）的响应信号。 io_requestor_0_resp_bits_miss: requestor0 请求的地址未命中的信号。 io_requestor_0_resp_bits_excp_0_gpf_instr: requestor0 出现 General Protection Fault (GPF) 异常的信号。 io_requestor_0_resp_bits_excp_0_pf_instr: requestor0 出现 Page Fault (PF) 异常的信号。 io_requestor_0_resp_bits_excp_0_af_instr: requestor0 出现 Access Fault (AF) 异常的信号。 Requestor 1 信号 io_requestor_1_req_valid: requestor1 的请求有效信号。 io_requestor_1_req_bits_vaddr: requestor1 的请求虚拟地址。 io_requestor_1_resp_bits_paddr_0: requestor1 的物理地址响应信号。 io_requestor_1_resp_bits_gpaddr_0: requestor1 的 GPA 响应信号。 io_requestor_1_resp_bits_miss: requestor1 的未命中信号。 io_requestor_1_resp_bits_excp_0_gpf_instr: requestor1 出现 GPF 异常的信号。 io_requestor_1_resp_bits_excp_0_pf_instr: requestor1 出现 PF 异常的信号。 io_requestor_1_resp_bits_excp_0_af_instr: requestor1 出现 AF 异常的信号。 Requestor 2 信号 io_requestor_2_req_ready: requestor2 的请求就绪信号。 io_requestor_2_req_valid: requestor2 的请求有效信号。 io_requestor_2_req_bits_vaddr: requestor2 的请求虚拟地址。 io_requestor_2_resp_ready: requestor2 的响应就绪信号。 io_requestor_2_resp_valid: requestor2 的响应有效信号。 io_requestor_2_resp_bits_paddr_0: requestor2 的物理地址响应信号。 io_requestor_2_resp_bits_gpaddr_0: requestor2 的 GPA 响应信号。 io_requestor_2_resp_bits_excp_0_gpf_instr: requestor2 出现 GPF 异常的信号。 io_requestor_2_resp_bits_excp_0_pf_instr: requestor2 出现 PF 异常的信号。 io_requestor_2_resp_bits_excp_0_af_instr: requestor2 出现 AF 异常的信号。 刷新管道（Flush Pipe）信号 io_flushPipe_0: 刷新管道 0 的信号。 io_flushPipe_1: 刷新管道 1 的信号。 io_flushPipe_2: 刷新管道 2 的信号。 页表遍历（Page Table Walker, PTW）接口信号 PTW 请求信号 io_ptw_req_0_valid: PTW req0 有效信号。 io_ptw_req_0_bits_vpn: PTW req0 的虚拟页号（VPN）。 io_ptw_req_0_bits_s2xlate: 指示 PTW req0 的转换模式。 io_ptw_req_0_bits_getGpa: PTW req0 的获取 GPA 信号。 io_ptw_req_1_valid: PTW req1 有效信号。 io_ptw_req_1_bits_vpn: PTW req1 的虚拟页号。 io_ptw_req_1_bits_s2xlate: 指示 PTW req1 的转换模式。 io_ptw_req_1_bits_getGpa: PTW req1 的获取 GPA 信号。 io_ptw_req_2_ready: PTW req2 就绪信号。 io_ptw_req_2_valid: PTW req2 有效信号。 io_ptw_req_2_bits_vpn: PTW req2 的虚拟页号。 io_ptw_req_2_bits_s2xlate: 指示 PTW req2 的转换模式。 io_ptw_req_2_bits_getGpa: PTW req2 的获取 GPA 信号。 PTW 响应信号 io_ptw_resp_valid: PTW resp 有效信号。 io_ptw_resp_bits_s2xlate: 指示 PTW resp 的地址转换类型。 io_ptw_resp_bits_s1_entry_tag: PTW resp 的第一阶段页表条目标签。 io_ptw_resp_bits_s1_entry_asid: PTW resp 的第一阶段页表条目 ASID。 io_ptw_resp_bits_s1_entry_vmid: PTW resp 的第一阶段页表条目 VMID。 io_ptw_resp_bits_s1_entry_perm_d: PTW resp 的第一阶段页表条目可写位。 io_ptw_resp_bits_s1_entry_perm_a: PTW resp 的第一阶段页表条目已访问位。 io_ptw_resp_bits_s1_entry_perm_g: PTW resp 的第一阶段页表条目全局位。 io_ptw_resp_bits_s1_entry_perm_u: PTW resp 的第一阶段页表条目用户模式位。 io_ptw_resp_bits_s1_entry_perm_x: PTW resp 的第一阶段页表条目可执行位。 io_ptw_resp_bits_s1_entry_perm_w: PTW resp 的第一阶段页表条目可写位。 io_ptw_resp_bits_s1_entry_perm_r: PTW resp 的第一阶段页表条目可读位。 io_ptw_resp_bits_s1_entry_level: PTW resp 的第一阶段页表条目级别。 io_ptw_resp_bits_s1_entry_ppn: PTW resp 的第一阶段页表条目物理页号（PPN）。 io_ptw_resp_bits_s1_addr_low: PTW resp 的第一阶段页表条目地址低位。 io_ptw_resp_bits_s1_ppn_low_*: PTW resp 的第一阶段页表条目 PPN 低位。 io_ptw_resp_bits_s1_valididx_*: PTW resp 的第一阶段页表条目有效索引。 io_ptw_resp_bits_s1_pteidx_*: PTW resp 的第一阶段页表条目 PTE 索引。 io_ptw_resp_bits_s1_pf: PTW resp 的第一阶段页表条目出现 PF。 io_ptw_resp_bits_s1_af: PTW resp 的第一阶段页表条目出现 AF。 io_ptw_resp_bits_s2_entry_tag: PTW resp 的第二阶段页表条目标签。 io_ptw_resp_bits_s2_entry_vmid: PTW resp 的第二阶段页表条目 VMID。 io_ptw_resp_bits_s2_entry_ppn: PTW resp 的第二阶段页表条目 PPN。 io_ptw_resp_bits_s2_entry_perm_*: PTW resp 的第二阶段页表条目的权限位。 io_ptw_resp_bits_s2_entry_level: PTW resp 的第二阶段页表条目级别。 io_ptw_resp_bits_s2_gpf: PTW resp 的第二阶段页表条目 GPF 信号。 io_ptw_resp_bits_s2_gaf: PTW resp 的第二阶段页表条目 GAF 信号。 io_ptw_resp_bits_getGpa: PTW resp 的获取 GPA 信号。 </description>
    </item>
    <item>
      <title>功能详述</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_func/</guid>
      <description>支持 SV48 分页机制 SV48 （Supervisor-mode Virtual Memory）是一种基于 RISC-V 的页表虚拟内存寻址模式，指定了 48 位虚拟地址空间的结构，支持 256TB 的虚拟内存地址空间。使用四级页表结构：&#xA;在 SV48 的一个 PTE 中包含了如下字段：&#xA;N:&#xA;指示是否为 NAPOT PTE。供 Svnapot 扩展使用，如果未实现 Svnapot 则该位必须由软件置 0，否则应当出现 Page Fault。目前香山昆明湖架构尚未支持此扩展。 PBMT:&#xA;Page-Based Memory Types，即基于页面的内存类型，供 Svpbmt 扩展使用，允许操作系统为每个页面指定不同的内存访问属性。 0: None，没有特定的内存属性。 1: NC，非缓存、幂等、弱序（RVWMO），适用于主存。 2: IO，非缓存、非幂等、强序（I/O 排序），适用于 I/O 设备。 3: Reserved，保留供将来标准使用。 同样的，如果未实现 Svpbmt 则这两位必须由软件置 0，否则应当出现 Page Fault。&#xA;Reserved:&#xA;保留位，供未来的标准使用。如果有任意一位不是 0 则会触发 PF 异常。 PPN:&#xA;表示物理页框号，指向实际的物理内存页。PPN 与页面内偏移结合形成完整的物理地址，用于地址转换。 RSW:&#xA;保留供软件使用的位，通常用于特定的标志或操作，以便在软件实现中提供灵活性。 D:&#xA;脏位，指示该页面是否被写入。如果该位为 1，表示该页的数据已被修改，需在换出时写回到存储设备。 A:&#xA;访问位，指示该页是否被访问过。如果该位为 1，表示该页已被读取或写入，用于页面替换算法。 G:</description>
    </item>
    <item>
      <title>关键信号说明</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/03_keysignal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/03_keysignal/</guid>
      <description>相关 CSR 寄存器 val csr = Input(new TlbCsrBundle) csr：包含 satp、vsatp、hgatp 三个寄存器的信息以及一些权限信息。&#xA;class TlbCsrBundle(implicit p: Parameters) extends XSBundle { val satp = new TlbSatpBundle() val vsatp = new TlbSatpBundle() val hgatp = new TlbHgatpBundle() val priv = new Bundle { val mxr = Bool() val sum = Bool() val vmxr = Bool() val vsum = Bool() val virt = Bool() val spvp = UInt(1.W) val imode = UInt(2.W) val dmode = UInt(2.</description>
    </item>
    <item>
      <title>环境配置</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_env/</guid>
      <description>推荐使用WSL2+Ubuntu22.04+GTKWave 我们推荐Windows10/11用户通过WSL2进行开发，在此给出通过此方法进行环境配置的教程集锦，仅供参考。如环境安装过程中出现任何问题，欢迎在QQ群（群号：976081653）中提出，我们将尽力帮助解决。此页面将收集大家提出的所有环境配置相关问题并提供解决方案，欢迎随时向我们提问！&#xA;1、在Windows下安装WSL2（Ubuntu22.04） 参考资源：&#xA;&amp;mdash; 微软官方教程：如何使用 WSL 在 Windows 上安装 Linux&#xA;&amp;mdash; 其它资源：安装WSL2和Ubuntu22.04版本&#xA;2、打开WSL，换源 推荐使用清华源：清华大学开源软件镜像站-Ubuntu软件仓库&#xA;3、配置验证环境 请参照开放验证平台学习资源-快速开始-搭建验证环境配置picker环境。&#xA;4、使用 GTKWave 使用重庆大学硬件综合设计实验文档-Windows原生GTKWave给出的方法，可以通过在WSL中输入 gtkwave.exe wave.fst 打开在Windows下安装的GTKWave。请注意，gtkwave在使用中需要进入fst文件所在文件夹，否则会出现无法 initialize的情况。&#xA;cd out gtkwave.exe {test_name}.fst cd .. 5、使用VSCode插件Live Server查看验证报告 成功安装插件Live Server后，打开文件列表，定位到 /out/report/2025*-itlb-doc-*/index.html 右键并选择 Open With Live Server，之后在浏览器中打开提示的端口（默认为//localhost:5500）即可。</description>
    </item>
  </channel>
</rss>
