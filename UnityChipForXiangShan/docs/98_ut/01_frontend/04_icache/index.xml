<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ICache on 万众一芯之香山处理器</title>
    <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/</link>
    <description>Recent content in ICache on 万众一芯之香山处理器</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CtrlUnit</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/05_ctrlunit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/05_ctrlunit/</guid>
      <description>&lt;div class=&#34;icache-ctx&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;ctrlunit&#34;&gt;CtrlUnit&lt;/h2&gt;&#xA;&lt;p&gt;目前 CtrlUnit 主要负责 ECC 校验使能/错误注入等功能。&#xA;RegField 案例类和伴生对象的作用，RegReadFn 和 RegWriteFn 案例类和伴生对象的作用。&lt;/p&gt;&#xA;&lt;p&gt;通过两个控制寄存器 CSR：eccctrl 和 ecciaddr，来实现错误注入。&#xA;在 eccctrlBundle 中，定义 eccctrl 的 ierror、istatus、itarget、inject、enable 域的初始值。&#xA;在 ecciaddrBundle 中，定义 ecciaddr 的 paddr 域的初始值。&lt;/p&gt;&#xA;&lt;h3 id=&#34;mmio-mapped-csr&#34;&gt;mmio-mapped CSR&lt;/h3&gt;&#xA;&lt;p&gt;CtrlUnit 内实现了一组 mmio-mapped CSR，连接在 tilelink 总线上，地址可由参数 &lt;code&gt;cacheCtrlAddressOpt&lt;/code&gt; 配置，默认地址为&lt;code&gt;0x38022080&lt;/code&gt;。总大小为 128B。&lt;/p&gt;&#xA;&lt;p&gt;当参数 &lt;code&gt;cacheCtrlAddressOpt&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; 时，CtrlUnit &lt;strong&gt;不会实例化&lt;/strong&gt;。此时 ECC 校验使能&lt;strong&gt;默认开启&lt;/strong&gt;，软件不可控制关闭；软件不可控制错误注入。&lt;/p&gt;&#xA;&lt;p&gt;目前实现的 CSR 如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              64     10        7         4         2        1        0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x00 eccctrl   | WARL | ierror | istatus | itarget | inject | enable |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              64 PAddrBits-1               0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x08 ecciaddr  | WARL |       paddr        |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;CSR&lt;/th&gt;&#xA;          &lt;th&gt;field&lt;/th&gt;&#xA;          &lt;th&gt;desp&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;eccctrl&lt;/td&gt;&#xA;          &lt;td&gt;enable&lt;/td&gt;&#xA;          &lt;td&gt;ECC 错误校验使能，原 sfetchctl(0) 。 &lt;br&gt;注：即使不使能，在 icache 重填时仍会计算 parity，可能会有额外功耗；但如果不计算，则在未使能转换成使能时需要冲刷 icache（否则读出的 parity 有 50%概率是错的）。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;eccctrl&lt;/td&gt;&#xA;          &lt;td&gt;inject&lt;/td&gt;&#xA;          &lt;td&gt;ECC 错误注入使能，写 1 即使能，读恒 0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;eccctrl&lt;/td&gt;&#xA;          &lt;td&gt;itarget&lt;/td&gt;&#xA;          &lt;td&gt;ECC 错误注入目标 &lt;br&gt;0: metaArray&lt;br&gt;1: rsvd&lt;br&gt;2: dataArray&lt;br&gt;3: rsvd&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;eccctrl&lt;/td&gt;&#xA;          &lt;td&gt;istatus&lt;/td&gt;&#xA;          &lt;td&gt;ECC 错误注入状态（read-only）&lt;br&gt;0: idle：注入控制器闲置&lt;br&gt;1: working：收到注入请求，注入中&lt;br&gt;2: injected：注入完成，等待触发&lt;br&gt;3: rsvd&lt;br&gt;4: rsvd&lt;br&gt;5: rsvd&lt;br&gt;6: rsvd&lt;br&gt;7: error：注入出错&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;eccctrl&lt;/td&gt;&#xA;          &lt;td&gt;ierror&lt;/td&gt;&#xA;          &lt;td&gt;ECC 错误原因（read-only）&lt;br&gt;0: ECC 未使能 (i.e. !eccctrl.enable) &lt;br&gt;1: inject 目标 SRAM 无效 (i.e. eccctrl.itarget==rsvd) &lt;br&gt;2: inject 目标地址 (i.e. ecciaddr.paddr) 不在 ICache 中&lt;br&gt;3: rsvd &lt;br&gt;4: rsvd &lt;br&gt;5: rsvd &lt;br&gt;6: rsvd &lt;br&gt;7: rsvd&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ecciaddr&lt;/td&gt;&#xA;          &lt;td&gt;paddr&lt;/td&gt;&#xA;          &lt;td&gt;ECC 错误注入物理地址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;RERI standard&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;RERI 手册还要求了错误计数等寄存器，用于软件获取 RAS controller 状态，参考手册，可能需要与 dcache、L2cache 统一在后端实现，icache 像现在给 BEU 送 error 一样送给后端。&lt;br&gt;即：暂时不需要在 icache 实现，但要把错误计数等机制所需的接口准备出来&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;错误校验使能&#34;&gt;错误校验使能&lt;/h3&gt;&#xA;&lt;p&gt;CtrlUnit 的 &lt;code&gt;eccctrl.enable&lt;/code&gt; 位直接连接到 MainPipe，控制 ECC 校验使能。当该位为 0 时，ICache 不会进行 ECC 校验。但仍会在重填时计算校验码并存储，这可能会有少量的额外功耗；如果不计算，则在未使能转换成使能时需要冲刷 ICache（否则读出的 parity code 可能是错的）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ICache</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/06_icache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/06_icache/</guid>
      <description>&lt;div class=&#34;icache-ctx&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;icache&#34;&gt;ICache&lt;/h2&gt;&#xA;&lt;p&gt;各种组合数据的宽度以 system verilog/verilog 中的为准。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IPrefetchPipe 接收来自 FTQ 的预取请求，然后向 MetaArray 和 ITLB 发送请求，再从 ITLB 的响应得到 paddr，之后与 MetaArray 返回的 tag 进行比较得到命中信息，把命中信息、MetaArray ECC 校验信息和 ITLB 信息一并写入 WayLookup，同时进行 PMP 检查。未命中就将信息发送给 MissUnit 处理，MissUnit 通过 TileLink 总线向 L2Cache 发起请求，获取数据后返回给 MetaArray 和 IPrefetchPipe。之后会判断是否 Miss，如果 Miss 则把预取请求发送到 MissUnit，它会通过 TileLink 向 L2 做预取指。&lt;/li&gt;&#xA;&lt;li&gt;MainPipe 接收来自 FTQ 的取指请求，然后从 WayLookup 获取路命中信息和 ITLB 查询结果，再访问 DataArray。命中后向 replacer 发送 touch 请求，replacer 采用 PLRU 替换策略,接收到 MainPipe 的命中更新，向 MissUnit 提供写入的 waymask。同时进行 PMP 检查，接收 DataArry 返回的数据。对 DataArray 做 ECC 校验，根据 DataArry 和 MetaArry 的校验结果（MetaArray 的校验结果来自 Waylookup）判断是否将错误报告给总线（beu）。之后，如果 DataArry 没有命中，将信息发往 MissUnit 处理。MissUnit 通过 TileLink 总线向 L2Cache 发起请求，获取数据后返回给 DataArray 和 MainPipe。之后就可以将数据返回给 IFU。&lt;/li&gt;&#xA;&lt;li&gt;MetaArray 存储缓存行的标签（Tag）和 ECC 校验码&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用双 Bank SRAM 结构，支持双线访问（Double-Line），每个 Bank 存储部分元数据。&lt;/li&gt;&#xA;&lt;li&gt;标签包含物理地址的高位，用于地址匹配。&lt;/li&gt;&#xA;&lt;li&gt;支持标签 ECC 校验，检测和纠正存储错误。&lt;/li&gt;&#xA;&lt;li&gt;valid_array 记录每个 Way 的有效状态，Flush 操作会清零&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;DataArray 存储实际的指令数据块。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据按 Bank 划分为八个，每个 Bank 宽度为 64 位，支持多 Bank 并行访问。&lt;/li&gt;&#xA;&lt;li&gt;数据 ECC 校验，分段生成校验码，增强错误检测能力。&lt;/li&gt;&#xA;&lt;li&gt;支持双线访问，根据地址偏移选择 Bank，单周期可读取 32 字节数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;冲刷信号有三种：ftqPrefetch.flushFromBpu，itlbFlushPipe，模块外部的 fencei 和 flush 信号。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftqPrefetch.flushFromBpu：通过 FTQ 来自的 BPU 刷新信号，用于控制预取请求的冲刷。&lt;/li&gt;&#xA;&lt;li&gt;itlbFlushPipe：ITLB 的冲刷信号，itlb 在收到该信号时会冲刷 gpf 缓存。&lt;/li&gt;&#xA;&lt;li&gt;fencei:刷新 MetaArray，清除所有路的 valid_array 清零；missUnit 中所有 MSHR 置无效。&lt;/li&gt;&#xA;&lt;li&gt;flush:mainPipe 和 prefetchPipe 所有流水级直接置无效，wayLookup 读写指针复位，gpf_entry 直接置无效,missUnit 中所有 MSHR 置无效。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;replacer&#34;&gt;Replacer&lt;/h3&gt;&#xA;&lt;p&gt;采用 PLRU 更新算法，考虑到每次取指可能访问连续的 doubleline，对于奇地址和偶地址设置两个 replacer，在进行 touch 和 victim 时根据地址的奇偶分别更新 replacer。&lt;/p&gt;</description>
    </item>
    <item>
      <title>IPrefetchPipe</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/01_iprefetchpipe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/01_iprefetchpipe/</guid>
      <description>&lt;div class=&#34;icache-ctx&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;iprefetchpipe&#34;&gt;IPrefetchPipe&lt;/h2&gt;&#xA;&lt;p&gt;IPrefetchPipe 为预取的流水线，三级流水设计，负责预取请求的过滤。&lt;/p&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../iprefetchpipe_structure.png&#34;&#xA;         alt=&#34;IPrefetchPipe模块结构示意图&#34;&#xA;         style=&#34;zoom:40%&#34;/&gt;&#xA;    &lt;br&gt;&#x9;&#x9;&#xA;    IPrefetchPipe结构示意图&#x9;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;br&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;接收预取请求（s0 阶段）：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从 FTQ 或后端接收预取请求。&lt;/li&gt;&#xA;&lt;li&gt;发送读请求到 ITLB 和 MetaArray 缓存元数据模块。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;地址转换和缓存检查（s1 阶段）：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接收 ITLB 的地址转换结果，处理可能的缺失和重发。&lt;/li&gt;&#xA;&lt;li&gt;从缓存元数据中读取标签和有效位，检查是否命中。&lt;/li&gt;&#xA;&lt;li&gt;进行 PMP 权限检查，合并异常信息。&lt;/li&gt;&#xA;&lt;li&gt;根据情况决定是否发送请求到 WayLookup 模块。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;未命中请求处理（s2 阶段）：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;检查与 missUnit 的交互，更新命中状态。&lt;/li&gt;&#xA;&lt;li&gt;对于无异常的未命中请求，向 missUnit 发送请求以获取数据。&lt;/li&gt;&#xA;&lt;li&gt;控制流水线的推进和刷新，处理可能的阻塞和异常。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;s0-流水级&#34;&gt;S0 流水级&lt;/h3&gt;&#xA;&lt;p&gt;在 S0 流水级，接收来自 FTQ 的预取请求，向 MetaArray 和 ITLB 发送请求。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接收预取请求：从 FTQ 或后端接收预取请求，提取预取请求的虚拟地址、FTQ 索引、是否为软件预取、是否跨缓存行信、虚拟组索引（s0_req_vSetIdx）和后端的异常信息。&lt;/li&gt;&#xA;&lt;li&gt;发送请求到 ITLB：将虚拟地址发送到 ITLB 进行地址转换。&lt;/li&gt;&#xA;&lt;li&gt;发送请求到缓存元数据（Meta SRAM）：将请求发送到缓存的元数据存储器，以便在后续阶段读取缓存标签和有效位。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;s1-流水级&#34;&gt;S1 流水级&lt;/h3&gt;&#xA;&lt;p&gt;软件预取 enqway 持续一拍&amp;hellip;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接收 ITLB 的响应：从 ITLB 接收地址转换的结果，包括物理地址 paddr、异常类型(&lt;code&gt;af&lt;/code&gt;/&lt;code&gt;pf&lt;/code&gt;)和特殊情况(&lt;code&gt;pbmt.nc&lt;/code&gt;/&lt;code&gt;pbmt.io&lt;/code&gt;)。&lt;/li&gt;&#xA;&lt;li&gt;接收缓存元数据的响应并检查缓存命中：从缓存元数据存储器 MetaArray 读取缓存标签 &lt;code&gt;tag&lt;/code&gt; 和有效位，检查预取地址是否在缓存中已存在，命中结果存入 &lt;code&gt;waymask&lt;/code&gt; 中。&lt;/li&gt;&#xA;&lt;li&gt;权限检查：使用 PMP 对物理地址进行权限检查，确保预取操作的合法性。&lt;/li&gt;&#xA;&lt;li&gt;异常处理和合并：合并来自后端、ITLB、PMP 的异常信息，准备在后续阶段处理。&lt;/li&gt;&#xA;&lt;li&gt;发送请求到 WayLookup 模块：当条件满足时，将元数据（命中信息 &lt;code&gt;waymask&lt;/code&gt;、ITLB 信息 &lt;code&gt;paddr&lt;/code&gt;/&lt;code&gt;af&lt;/code&gt;/&lt;code&gt;pf&lt;/code&gt;）发送到 WayLookup 模块，以便进行后续的缓存访问。&lt;/li&gt;&#xA;&lt;li&gt;状态机转换：根据当前状态和条件，更新下一个状态。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;状态机初始状态为 &lt;code&gt;idle&lt;/code&gt;，当 S1 流水级进入新的请求时，首先判断 ITLB 是否缺失，如果缺失，就进入 &lt;code&gt;itlbResend&lt;/code&gt;；如果 ITLB 命中但命中信息未入队 WayLookup，就进入 &lt;code&gt;enqWay&lt;/code&gt;；如果 ITLB 命中且 WayLookup 入队但 S2 请求未处理完，就进入 &lt;code&gt;enterS2&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;在 &lt;code&gt;itlbResend&lt;/code&gt; 状态，重发 ITLB 请求，此时占用 ITLB 端口，直至请求回填完成，在回填完成的当拍向 MetaArray 再次发送读请求，回填期间可能发生新的写入，如果 MetaArray 繁忙（正在被写入），就进入&lt;code&gt;metaResend&lt;/code&gt;，否则进入 &lt;code&gt;enqWay&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;在 &lt;code&gt;metaResend&lt;/code&gt; 状态，重发 MetaArray 读请求，发送成功后进入 &lt;code&gt;enqWay&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;在 &lt;code&gt;enqWay&lt;/code&gt; 状态，尝试将元数据入队 WayLookup，如果 WayLookup 队列已满，就阻塞至 WayLookup 入队成功，另外在 MSHR 发生新的写入时禁止入队，主要是为了防止写入的信息与命中信息所冲突，需要对命中信息进行更新。当成功入队 WayLookup 或者是软件预取时，如果 S2 空闲，就直接进入 &lt;code&gt;idle&lt;/code&gt;，否则进入 &lt;code&gt;enterS2&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;在 &lt;code&gt;enterS2&lt;/code&gt; 状态，尝试将请求流入下一流水级，流入后进入 &lt;code&gt;idle&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&lt;!--块级封装--&gt;&#xA;    &lt;center&gt;&#x9;&lt;!--将图片和文字居中--&gt;&#xA;    &lt;img src=&#34;../iprefetchpipe_fsm.png&#34;&#xA;         alt=&#34;IPrefetchPipe状态机&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#x9;&#x9;&lt;!--换行--&gt;&#xA;    IPrefetchPipe S1状态机&#x9;&lt;!--标题--&gt;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;s2-流水级&#34;&gt;S2 流水级&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;监控 missUnit 的请求：更新 MSHR 的匹配状态。综合该请求的命中结果、ITLB 异常、PMP 异常、meta 损坏，判断是否需要预取，只有不存在异常时才进行预取。&lt;/li&gt;&#xA;&lt;li&gt;发送请求到 missUnit：因为同一个预测块可能对应两个 cacheline，所以通过 Arbiter 依次将请求发送至 MissUnit。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;命中信息的更新&#34;&gt;命中信息的更新&lt;/h3&gt;&#xA;&lt;p&gt;在 S1 流水级中得到命中信息后，距离命中信息真正在 MainPipe 中被使用要经过两个阶段，分别是在 IPrefetchPipe 中等待入队 WayLookup 阶段和在 WayLookup 中等待出队阶段，在等待期间可能会发生 MSHR 对 Meta/DataArray 的更新，因此需要对 MSHR 的响应进行监听，分为两种情况：&lt;/p&gt;</description>
    </item>
    <item>
      <title>MainPipe</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/02_mainpipe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/02_mainpipe/</guid>
      <description>&lt;div class=&#34;icache-ctx&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;mainpipe&#34;&gt;MainPipe&lt;/h2&gt;&#xA;&lt;p&gt;MainPipe 为 ICache 的主流水，为三级流水设计，负责从 DataArray 中读取数据，pmp 检查，缺失处理，并且将结果返回给 IFU。&lt;/p&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../mainpipe_structure.png&#34;&#xA;         alt=&#34;MainPipe结构示意图&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#x9;&#x9;&#xA;    MainPipe结构示意图&#x9;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;br&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从 WayLookup 获取信息，访问 DataArray 单路（S0 阶段）&#xA;在 S0 流水级，从 WayLookup 获取元数据，包括路命中信息和 ITLB 查询结果，访问 DataArray 的单路，如果 DataArray 正在被写或 WayLookup 中没有有效表项，流水线就会阻塞。每次重定向后，FTQ 中同一个请求被同时发送到 MainPipe 和 IPrefetchPipe 中，MainPipe 始终需要等待 IPrefetchPipe 将请求的查询信息写入 WayLookup 后才能向下走，导致了 1 拍重定向延迟，当预取超过取指时，该延迟就会被覆盖。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接收并解析来自 FTQ 的取指请求，提取必要的请求信息，如虚拟地址、缓存组索引、块内偏移、是否为双行读、后端的异常信息。&lt;/li&gt;&#xA;&lt;li&gt;从 WayLookup 模块获取缓存命中信息和 TLB 信息，包括 waymask、物理标签、虚拟机物理地址、是否为叶节点、 ITLB 异常、ITLB 的 PBMT 信息、缓存元数据的校验码。&lt;/li&gt;&#xA;&lt;li&gt;访问 DataArray 的单路，如果 DataArray 正在被写或 WayLookup 中没有有效表项，流水线就会阻塞。&lt;/li&gt;&#xA;&lt;li&gt;每次重定向后，FTQ 中同一个请求被同时发送到 MainPipe 和 IPrefetchPipe 中，MainPipe 始终需要等待 IPrefetchPipe 将请求的查询信息写入 WayLookup 后才能向下走，导致了 1 拍重定向延迟，当预取超过取指时，该延迟就会被覆盖。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;接收上一个阶段的信息并进行数据暂存、PMP 检查、从 DataArray 获取读响应异常合并、替换策略更新以及监控 MissUnit（S1 阶段）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;寄存并延迟 S0 阶段信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从 S0 获取的地址、tag、命中方式（waymask）、TLB 异常标志、下一拍要用的数据等，都会在 S1 寄存一拍，保证在流水线停顿时也能维持正确值。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Meta ECC 检查&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对 S0 读出的 meta 和其校验码（ECC/Parity）进行比对，判断是否发生错误。如果关闭 parity 功能，则跳过该检查。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;更新 replacer&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对确定命中的访问请求，进行“touch”更新，标记最近使用过的 way，以便后续替换算法正确运行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;PMP 检查&#xA;&lt;ul&gt;&#xA;&lt;li&gt;根据 S0 得到的物理地址（paddr），在 S1 对其进行 PMP 检查，判断是否拥有执行权限、是否为 MMIO 等。在当拍收到响应，将结果寄存到下一流水级进行处理。&lt;/li&gt;&#xA;&lt;li&gt;需要指出，IPrefetchPipe s1 流水级也会进行 PMP 检查，和此处的检查实际上是完全一样的，分别检查只是为了优化时序（避免 &lt;code&gt;ITLB(reg) -&amp;gt; ITLB.resp -&amp;gt; PMP.req -&amp;gt; PMP.resp -&amp;gt; WayLookup.write -&amp;gt; bypass -&amp;gt; WayLookup.read -&amp;gt; MainPipe s1(reg)&lt;/code&gt; 的超长组合逻辑路径）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;异常合并&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将 ITLB 与 PMP 异常进行优先级合并，产生最终的异常标记。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;选择数据来源：MSHR 或 SRAM&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接收 DataArray 返回的 data 和 code 并寄存，同时监听 MSHR 的响应，当 DataArray 和 MSHR 的响应同时有效时，后者的优先级更高。当 MSHR 已在填充一些数据，如果当前请求与 MSHR 命中，可以在 S1 阶段直接选用 MSHR 的数据，而不必依赖 SRAM 读出的结果。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;监控 MissUnit，在 ECC 校验、异常处理和缺失处理之后，将最终的数据、异常信息传递给 IFU，完成取指流程（S2 阶段）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECC 校验&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DataArray ECC 校验，对 S1 流水级寄存的 code 进行校验，生成 data 是否损坏信号 s2_data_corrupt。如果校验出错，就将错误报告给 BEU。&lt;/li&gt;&#xA;&lt;li&gt;MetaArray ECC 校验，IPrefetchPipe 读出 MetaArray 的数据后会直接进行校验，并将校验结果随命中信息一起入队 WayLookup 并随 MainPipe 流水到达 S2 级（meta_corrupt 信号），在此处随 DataArray 的 ECC 校验结果一起报告给 BEU。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;监控 MissUnit 响应端口&#xA;&lt;ul&gt;&#xA;&lt;li&gt;检查当前 S2 阶段的请求是否与 MSHR 中的条目匹配，命中时寄存 MSHR 响应的数据，为了时序在下一拍才将数据发送到 IFU。&lt;/li&gt;&#xA;&lt;li&gt;更新 Data 和其是否来自 MSHR 的信息。&lt;/li&gt;&#xA;&lt;li&gt;更新 s2_hits 和处理异常。&lt;/li&gt;&#xA;&lt;li&gt;处理 L2 Cache 的 Corrupt 标志。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;缺失处理，发送 Miss 请求到 MSHR&#xA;&lt;ul&gt;&#xA;&lt;li&gt;计算是否需要重新获取（Refetch）。&lt;/li&gt;&#xA;&lt;li&gt;通过是否命中、ECC 错误、正确跨行、是否异常和是否属于 MMIO 区域来发送 Miss 请求。&lt;/li&gt;&#xA;&lt;li&gt;设置 Arbiter 合并多个端口的 Miss 请求，确保一次只处理一个请求，同时有避免重复请求的设置。&lt;/li&gt;&#xA;&lt;li&gt;判断 Fetch 是否完成。&lt;/li&gt;&#xA;&lt;li&gt;生成 L2 Cache 的异常标记，再将当前 S2 阶段的异常（包括 ITLB、PMP）与 L2 Cache 的异常进行合并。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;响应 IFU&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将最终的数据、异常信息传递给 IFU，完成取指流程。&lt;/li&gt;&#xA;&lt;li&gt;根据请求是否为跨行，决定如何处理双行数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;报告 TileLink 的 Corrupt 错误&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于每个端口，如果在当前周期 s2_fire 时检测到来自 L2 Cache 的数据 corrupt 错误，就将错误报告给 BEU。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;mainpipe-的功能点和测试点&#34;&gt;MainPipe 的功能点和测试点&lt;/h2&gt;&#xA;&lt;h3 id=&#34;访问-dataarray-的单路&#34;&gt;访问 DataArray 的单路&lt;/h3&gt;&#xA;&lt;p&gt;根据从 WayLookup 获取信息，包括路命中信息和 ITLB 查询结果还有 DataArray 当前的情况，决定是否需要从 DataArray 中读取数据。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MissUnit</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/04_missunit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/04_missunit/</guid>
      <description>&lt;div class=&#34;icache-ctx&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;子模块fifo&#34;&gt;子模块：FIFO&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个先入先出的循环队列，目前仅在 MissUnit 中有使用，作为优先队列 priorityFIFO。&lt;/li&gt;&#xA;&lt;li&gt;按照在 MissUnit 中的实例化，pipe 是默认值 false，hasflush 是 true。&lt;/li&gt;&#xA;&lt;li&gt;队列的指针都是环形的，分为入队指针（写指针，ent_ptr）和出队指针（读指针，deq_ptr），记录读和写的位置。&lt;/li&gt;&#xA;&lt;li&gt;两个指针都有对应的 flag 位，当指针超过队列大小时，flag 位会翻转，用以判断是否已经循环。&lt;/li&gt;&#xA;&lt;li&gt;在入队、出队对应的 fire（valid &amp;amp;&amp;amp; ready） 信号有效时，移动对应的指针。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;fifo-的功能点和测试点&#34;&gt;FIFO 的功能点和测试点&lt;/h2&gt;&#xA;&lt;h3 id=&#34;入队操作&#34;&gt;入队操作&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;队未满，正常入队&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当队列未满，且空位不小于一时，可以正常入队，如果从零号位开始入队到最大容量，入队指针的 flag 不会翻转。&lt;/li&gt;&#xA;&lt;li&gt;io.enq.fire 为高有效，regFiles(enq_ptr.value) = io.enq.bits，enq_ptr.value+1 入队指针移动，入队指针标记位不翻转。&lt;/li&gt;&#xA;&lt;li&gt;重复以上操作至队满。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;队未满，入队后标记位翻转&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当队未满，但是空位却是靠近队尾时，入队一位后就到达了队头，入队指针的 flag 会翻转。&lt;/li&gt;&#xA;&lt;li&gt;队列的容量为 10，入队指针指向 9，队未满。此时如果 io.enq.fire 为高，则 regFiles(9) = io.enq.bits，enq_ptr.value+1（循环队列，加完后 enq_ptr.value=0）入队指针移动，入队指针标记位翻转。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;队满，入队就绪信号为低，无法入队&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当队满时，(enq_ptr.value === deq_ptr.value) &amp;amp;&amp;amp; (enq_ptr.flag ^ deq_ptr.flag) 为高，io.enq.ready 为低，io.enq.fire 为低无效。&lt;/li&gt;&#xA;&lt;li&gt;此时入队，入队指针的 value 和 flag 不变。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;出队操作&#34;&gt;出队操作&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;队非空，正常出队&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当队列非空时，可以正常出队，如果出队指针不经过最大容量位置，出队指针的 flag 不会翻转。&lt;/li&gt;&#xA;&lt;li&gt;io.deq.fire 为高有效，io.deq.bits = regFiles(deq_ptr.value)，deq_ptr.value+1 出队指针移动，出队指针标记位不翻转。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;队非空，出队后标记位翻转&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当队非空，但是出队指针是靠近队尾时，出队一位后就到达了队头，出队指针的 flag 会翻转。&lt;/li&gt;&#xA;&lt;li&gt;队列的容量为 10，出队指针指向 9，队非空。此时如果 io.deq.fire 为高，则 io.deq.bits = regFiles(9)，deq_ptr.value+1（循环队列，加完后 deq_ptr.value=0）出队指针移动，出队指针标记位翻转。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;队空，出队有效信号为低，无法出队&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当队空时，enq_ptr === deq_ptr 为高，io.deq.valid 为低，io.deq.fire 为低无效。&lt;/li&gt;&#xA;&lt;li&gt;此时出队，出队指针的 value 和 flag 不变。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;刷新清空操作&#34;&gt;刷新清空操作&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;flush 清空&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当刷新信号有效时，重置出队和入队的指针和标记位，清空队列。&lt;/li&gt;&#xA;&lt;li&gt;当 flush 为高时，deq_ptr.value=0，enq_ptr.value=0，deq_ptr.flag=false，enq_ptr.flag=false，empty=true,full=false。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;missunit&#34;&gt;MissUnit&lt;/h2&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../missunit_structure.png&#34;&#xA;         alt=&#34;MissUnit 结构&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#x9;&#x9;&#xA;    MissUnit 结构&#x9;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;br&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接收并管理多个 Miss 请求&#xA;&lt;ul&gt;&#xA;&lt;li&gt;处理来自 Fetch 和 Prefetch 的 Miss 请求。&lt;/li&gt;&#xA;&lt;li&gt;将这些请求分派给适当数量的 MSHR 进行排队和状态管理。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;管理 MSHR&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ICacheMissUnit 使用多个 MSHR 来跟踪和管理未完成的缓存未命中请求。为了防止 flush 时取指 MSHR 不能完全释放，设置取指 MSHR 的数量为 4，预取 MSHR 的数量为 10。采用数据和地址分离的设计方法，所有的 MSHR 共用一组数据寄存器，在 MSHR 只存储请求的地址信息、状态等信息。&lt;/li&gt;&#xA;&lt;li&gt;接收来自 MainPipe 的取指请求和来自 IPrfetchPipe 的预取请求，取指请求只能被分配到 fetchMSHR，预取请求只能分配到 prefetchMSHR，入队时采用低 index 优先的分配方式。&lt;/li&gt;&#xA;&lt;li&gt;在入队的同时对 MSHR 进行查询，如果请求已经在 MSHR 中存在，就丢弃该请求，对外接口仍表现 fire，只是不入队到 MSHR 中。==在入队时向 Replacer 请求写入 waymask==。当请求完成后，MSHR 会被释放，以便处理新的请求。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通过 TileLink 协议与 L2 缓存进行通信，发送获取缓存块的请求（mem_acquire），并接收 L2 缓存的响应（mem_grant）。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当到 L2 的总线空闲时，选择 MSHR 表现进行处理，整体 fetchMSHR 的优先级高于 prefetchMSHR，只有没有需要处理的 fetchMSHR，才会处理 prefetchMSHR。&lt;/li&gt;&#xA;&lt;li&gt;对于 fetchMSHR，采用低 index 优先的优先级策略，因为同时最多只有两个请求需要处理，并且只有当两个请求都处理完成时才能向下走，所有 fetchMSHR 之间的优先级并不重要。&lt;/li&gt;&#xA;&lt;li&gt;对于 prefetchMSHR，考虑到预取请求之间具有时间顺序，采用先到先得的优先级策略，在入队时通过一个 FIFO 记录入队顺序，处理时按照入队顺序进行处理。&lt;/li&gt;&#xA;&lt;li&gt;通过状态机与 Tilelink 的 D 通道进行交互，到 L2 的带宽为 32byte，需要分 2 次传输，并且不同的请求不会发生交织，所以只需要一组寄存器来存储数据。&lt;/li&gt;&#xA;&lt;li&gt;当一次传输完成时，根据传输的 id 选出对应的 MSHR，从 MSHR 中读取地址、掩码等信息，将相关信息写入 SRAM，同时将 MSHR 释放。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;向 MetaArray 和 DataArray 发送写请求，向 MainPipe 发送响应&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当数据传回后，MissUnit 根据相应的替换策略信息（victim way），将新数据写回 ICache 的 SRAM(Meta/Data) 。&lt;/li&gt;&#xA;&lt;li&gt;同时向取指端（或预取端）返回“Miss 已完成”的响应，包括：写入了哪一路（way）、实际数据以及可能的校验信息（如 corrupt 标记等）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;处理特殊情况（如 flush、fencei、数据损坏等）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;遇到 Flush 或 fence.i 等指令时，MissUnit 可以终止或跳过某些 Miss 请求的写回，从而保证不在无效或过期的情况下写入缓存。&lt;/li&gt;&#xA;&lt;li&gt;数据若出现 corrupt（部分拍损坏），也会在写回或发给前端时进行特殊处理或标记。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;过程：&lt;/p&gt;</description>
    </item>
    <item>
      <title>WayLookup</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/03_waylookup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/03_waylookup/</guid>
      <description>&lt;div class=&#34;icache-ctx&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;waylookup&#34;&gt;WayLookup&lt;/h2&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../waylookup_structure_rw.png&#34;&#xA;         alt=&#34;WayLookup 读写结构&#34;&#xA;         style=&#34;zoom:40%&#34;/&gt;&#xA;    &lt;br&gt;&#x9;&#x9;&#xA;    WayLookup 读写结构&#x9;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;br&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../waylookup_structure_update.png&#34;&#xA;         alt=&#34;WayLookup 更新结构&#34;&#xA;         style=&#34;zoom:40%&#34;/&gt;&#xA;    &lt;br&gt;&#x9;&#x9;&#xA;    WayLookup 更新结构&#x9;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;br&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内部是 FIFO 环形队列结构。暂存 IPrefetchPipe 查询 MetaArray 和 ITLB 得到的元数据，以备 MainPipe 使用。同时监听 MSHR 写入 SRAM 的 cacheline，对命中信息进行更新。&lt;/li&gt;&#xA;&lt;li&gt;通过 readPtr 和 writePtr 来管理读写位置。当有 flush 信号时，读写指针都会被重置。当写入数据时，写指针递增；读取时，读指针递增。需要处理队列的空和满的情况，empty 是读指针等于写指针，而 full 则是两者的值相同且标志位不同。&lt;/li&gt;&#xA;&lt;li&gt;处理 GPF 的部分，有一个 gpf_entry 寄存器，存储 GPF 的相关信息。当写入的数据包含 GPF 异常时，需要将信息存入 gpf_entry，并记录当前的写指针位置到 gpfPtr。当读取的时候，如果当前读指针的位置与 gpfPtr 匹配，并且 gpf_entry 有效，那么就将 GPF 信息一并输出。&lt;/li&gt;&#xA;&lt;li&gt;IPrefetchPipe 向其写入 WayLookupInfo 信息（包括 vSetIdx，waymask，ptag，itlb_exception，itlb_pbmt，meta_codes，gpaddr，isForVSnonLeafPTE）。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;写入前，需要考虑队列是否已满，以及是否有 GPF 阻塞。如果有 GPF 信息待读取且未被处理，则写入需要等待，防止覆盖 GPF 信息。写入时，如果数据中包含 GPF 异常，就将信息存入 gpf_entry，并更新 gpfPtr。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;MainPipe 从其读出 WayLookupInfo 信息。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在读取上，有两种情况：当队列为空但有写请求时，可以直接将写的数据旁路（bypass）给读端口；否则就从 entries 数组中读取对应读指针的数据。同时，如果当前读的位置存在 GPF 信息，就将 GPF 信息一起输出，并在读取后清除有效位。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;允许 bypass（当队列为空但有写请求时，可以直接将写的数据旁路给读端口），为了不将更新逻辑的延迟引入到 DataArray 的访问路径上，在 MSHR 有新的写入时禁止出队，MainPipe 的 S0 流水级也需要访问 DataArray，当 MSHR 有新的写入时无法向下走，所以该措施并不会带来额外影响。&lt;/li&gt;&#xA;&lt;li&gt;MissUnit 向其写入命中信息。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若是命中则将 waymask 更新 ICacheMissResp 信息（包括 blkPaddr，vSetIdx，waymask，data，corrupt）且 meta_codes 也更新，否则 waymask 清零。更新逻辑与 IPrefetchPipe 中相同，见 &lt;a href=&#34;https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/01_iprefetchpipe/#%e5%91%bd%e4%b8%ad%e4%bf%a1%e6%81%af%e7%9a%84%e6%9b%b4%e6%96%b0&#34;&gt;IPrefetchPipe 子模块文档中的“命中信息的更新”&lt;/a&gt;一节。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;gpaddr-省面积机制&#34;&gt;GPaddr 省面积机制&lt;/h3&gt;&#xA;&lt;p&gt;由于 &lt;code&gt;gpaddr&lt;/code&gt; 仅在 guest page fault 发生时有用，并且每次发生 gpf 后前端实际上工作在错误路径上，后端保证会送一个 redirect（WayLookup flush）到前端（无论是发生 gpf 前就已经预测错误/发生异常中断导致的；还是 gpf 本身导致的），因此在 WayLookup 中只需存储 reset/flush 后第一个 gpf 有效时的 gpaddr。对双行请求，只需存储第一个有 gpf 的行的 &lt;code&gt;gpaddr。&lt;/code&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
