<!doctype html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-cn" class="no-js">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="canonical" type="text/html" href="https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/">
<link rel="alternate" type="application/rss&#43;xml" href="https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/index.xml">
<meta name="robots" content="noindex, nofollow">


<link rel="shortcut icon" href="/UnityChipForXiangShan/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/UnityChipForXiangShan/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/UnityChipForXiangShan/favicons/android-192x192.png" sizes="192x192">

<title>FTQ概述 | 万众一芯之香山处理器</title>
<meta name="description" content="下文（包括所有的FTQ文档）中会提到一些关于BPU和IFU的相关知识，详情需要去查看对应的文档:
BPU文档链接 IFU文档链接 hint：建议先从BPU基础设计中着重理解以下概念：
什么是分支预测？ 什么是分支预测块？一个有帮助的链接：预测块 (可选)什么是重定向，什么是预测结果重定向？ (可选)分支预测的流水级 简介 FTQ 是分支预测和取指单元之间的缓冲队列，它的主要职能是暂存 BPU 预测的取指目标，并根据这些取指目标给 IFU 发送取指请求。它的另一重要职能是暂存 BPU 各个预测器的预测信息，在指令提交后把这些信息送回 BPU 用作预测器的训练，因此它需要维护指令从预测到提交的完整的生命周期。另外，后端将存储来自FTQ的取指目标PC，便于自身读取。
![[Pasted image 20250222103931.png]]
模块之间的中转站 从上图，FTQ很大程度上相当于一个中转站，中间人的角色，一方面，它承担着BPU和IFU之间的交互，这通常是因为BPU预测的速度快于IFU取值执行，所以使用FTQ作为缓冲。另一方面，它承担着后端与前端的交互，比如把前端将要执行的pc交给后端去执行。
显然，FTQ的 中转远不止这么多，下面更具体地讨论一下FTQ怎么中转各个前端或后端模块的信息的。
BPU和FTQ BPUtoFTQ：BPU会将分支预测结果和meta数据发给FTQ。
从分支预测结果中，我们可以提取出分支预测块对应的取值目标，比如，一个不跨缓存行且所有指令均为RVC指令的分支预测块对应的取值目标，是从分支预测块起始地址开始的以2B为间隔的连续16条指令。 meta信息则存储了各个预测器相关的预测信息，由于BPU预测有三个流水级，每个流水级都有相应的预测器，所以只有到s3阶段才有可能收集到所有预测器的预测信息，直到此时FTQ才接受到完整的meta，这些信息会在该分支预测块的全部指令被后端提交时交给BPU进行训练 FTBEntry：严格来说，它其实也是meta的一部分，但是因为更新的时候ftb_entry需要在原来的基础上继续修改，为了不重新读一遍ftb，另外给它存储一个副本。 FTQtoBPU：FTQ会将带元数据的训练信息和重定向信息发回给BPU
请参照BPU文档链接 BPU 模块整体对外接口 (PredirectIO) FTQ和IFU FTQtoIFU：FTQ会将存储的取值目标发往IFU进行取值译码和把后端的重定向信息也移交给IFU
取值目标同时也发给： toICache：同样的取值目标会被发给指令缓存单元，看对应的指令是否在缓存单元内存在，如果有会被直接发送给IFU加速取值效率 toPrefetch: prefetch是ICache的一个组件，负责预取功能 转发后端重定向： 后端重定向不仅需要转发给BPU帮助其回到正确状态，也同时需要转发给IFU帮助其回到正确状态 IFUtoFTQ：IFU将预译码信息和重定向信息写回FTQ
预译码信息：包含分支预测块对应的预测宽度内所有指令的预译码信息 预测宽度：一个指令块预测块覆盖的指令范围，香山中是16条rvc指令 重定向信息其实也是根据预译码信息得到的：当预译码信息中指出预测块内某一条指令预测出错时，写回IFU重定向信息 后端和FTQ FTQ到后端：FTQ会将存储的取值目标发往后端，后端存储 PC后，在本地即可进行读取取指目标。
除了IFU，预测块的取值目标也会发给后端，但这里有一点区别：IFU空闲时才能从FTQ中获取取值目标，但是后端会一直取得最新的预测块的取指目标 后端到FTQ：后端重定向和指令commit
后端重定向与更新：后端是实际执行指令的单元，通过后端的执行结果，才能确认一条指令是否执行错误，产生重定向，同时，在发生重定向时，根据后端实际执行结果生成更新信息。 指令commit：当一个分支预测块内的所有指令都被执行，在后端提交，这标志着FTQ队列中这个分支预测块对应的FTQ项已经结束了它的生命周期，可以从队列中移除了，这时候，我们就可以把它的更新信息发给FTQ了。 FTQ指针 FTQ的全名叫取值目标队列，队列中的一个项叫做FTQ项，BPU写入预测结果时是写入队列中哪个位置，IFU又是从哪个队列取FTQ项？这时候，我们需要一个FTQ指针去索引FTQ项，而由于和不同模块的交互需要索引不同的FTQ项，因此，有以下类型的FTQ指针，下面，由指令生命周期为例，大致介绍这些指针：
指令在 FTQ 中的生存周期 指令以预测块为单位，从 BPU 预测后便送进 FTQ，直到指令所在的预测块中的所有指令全部在后端提交完成，FTQ 才会在存储结构中完全释放该预测块所对应的项。这个过程中发生的事如下：
预测块从 BPU 发出，进入 FTQ，bpuPtr 指针加一，初始化对应 FTQ 项的各种状态，把各种预测信息写入存储结构；如果预测块来自 BPU 覆盖预测逻辑，则恢复 bpuPtr 和 ifuPtr FTQ 向 IFU 发出取指请求，ifuPtr 指针加一，等待预译码信息写回 IFU 写回预译码信息，ifuWbPtr 指针加一，如果预译码检测出了预测错误，则给 BPU 发送相应的重定向请求，恢复 bpuPtr 和 ifuPtr 指令进入后端执行，如果后端检测出了误预测，则通知 FTQ，给 IFU 和 BPU 发送重定向请求，恢复 bpuPtr、ifuPtr 和 ifuWbPtr 指令在后端提交，通知 FTQ，等 FTQ 项中所有的有效指令都已提交，commPtr 指针加一，从存储结构中读出相应的信息，送给 BPU 进行训练 预测块 n 内指令的生存周期会涉及到 FTQ 中的 bpuPtr、ifuPtr、ifuWbPtr 和 commPtr 四个指针，当 bpuPtr 开始指向 n&#43;1 时，预测块内的指令进入生存周期，当 commPtr 指向 n&#43;1 后，预测块内的指令完成生存周期。">
<meta property="og:title" content="FTQ概述" />
<meta property="og:description" content="Powerful, extensible, and feature-packed frontend toolkit. Build and customize with Sass, utilize prebuilt grid system and components, and bring projects to life with powerful JavaScript plugins." />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/" />
<meta itemprop="name" content="FTQ概述">
<meta itemprop="description" content="Powerful, extensible, and feature-packed frontend toolkit. Build and customize with Sass, utilize prebuilt grid system and components, and bring projects to life with powerful JavaScript plugins."><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="FTQ概述"/>
<meta name="twitter:description" content="Powerful, extensible, and feature-packed frontend toolkit. Build and customize with Sass, utilize prebuilt grid system and components, and bring projects to life with powerful JavaScript plugins."/>
<link rel="preload" href="/UnityChipForXiangShan/scss/main.min.689b22b0041c8c7c7cf217802f908a4ce2122a5f8924320dd5431c6362fe39a7.css" as="style" integrity="sha256-aJsisAQcjHx88heAL5CKTOISKl&#43;JJDIN1UMcY2L&#43;Oac=" crossorigin="anonymous">
<link href="/UnityChipForXiangShan/scss/main.min.689b22b0041c8c7c7cf217802f908a4ce2122a5f8924320dd5431c6362fe39a7.css" rel="stylesheet" integrity="sha256-aJsisAQcjHx88heAL5CKTOISKl&#43;JJDIN1UMcY2L&#43;Oac=" crossorigin="anonymous">
<script
  src="https://code.jquery.com/jquery-3.7.1.min.js"
  integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g=="
  crossorigin="anonymous"></script>
<script defer
  src="https://unpkg.com/lunr@2.3.9/lunr.min.js"
  integrity="sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli"
  crossorigin="anonymous"></script>
<link rel="stylesheet" href="/UnityChipForXiangShan/css/prism.css"/>

    <script>
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?6aacb1c7ca0a3ef4e3aa84c1eaa237dd";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
    </script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z2ZY6ZE84"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-4Z2ZY6ZE84');
    </script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />

<script>
    $(document).ready(function() {
        $('a[name="multi-lang-toggle"]').on('click', function(event) {
            var language = $(this).attr('lang');
            var codeDiv = $(this).closest('.highlight');
            var preNodes = codeDiv.find('pre');
            preNodes.each(function(index, preNode) {
                if ($(preNode).attr("name").toLowerCase().indexOf(language.toLowerCase()) !== -1) {
                    preNode.style.display = 'block';
                } else {
                    preNode.style.display = 'none';
                }
            });
            var alist = codeDiv.find('a[name="multi-lang-toggle"]');
            alist.each(function(index, aNode) {
                if ($(aNode).attr('lang').toLowerCase() === language.toLowerCase()) {
                    aNode.style.fontWeight = 'bold';
                } else {
                    aNode.style.fontWeight = 'normal';
                }
            });
        })
        $(this).find('pre[name^="group-lang-code-"]').each(function(index, preNode) {
            if (preNode.style.display !== 'none') {
                var language = $(preNode).attr("name").replace('group-lang-code-', '');
                var alist = $(this).closest('.highlight').find('a[name="multi-lang-toggle"]');
                alist.each(function(index, aNode) {
                    if ($(aNode).attr('lang').toLowerCase() === language.toLowerCase()) {
                        aNode.style.fontWeight = 'bold';
                    } else {
                        aNode.style.fontWeight = 'normal';
                    }
                });
            }
        });
    });
</script>
    
  </head>
  <body class="td-section">
    <header>
      <nav class="td-navbar js-navbar-scroll" data-bs-theme="dark">
<div class="container-fluid flex-column flex-md-row">
  <a class="navbar-brand" href="/UnityChipForXiangShan/"><span class="navbar-brand__logo navbar-logo"><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" style="enable-background:new 0 0 500 500"><g><path style="fill:#fff" d="M116.8525 421.9722c-5.7041.0-10.3442-4.3127-10.3442-9.6129V88.183c0-5.3002 4.6401-9.6117 10.3442-9.6117H320.858c3.0347.0 9.3959.5498 11.7506 2.6302l.3545.3442 58.905 63.2912c2.3101 2.491 2.9202 8.4928 2.9202 11.3184v256.2039c0 5.3002-4.6407 9.6129-10.3436 9.6129H116.8525z"/><g><g><g><path style="fill:#767676" d="M384.4445 423.2066H116.852c-6.3839.0-11.5786-4.8658-11.5786-10.8474V88.1831c0-5.9804 5.1947-10.8461 11.5786-10.8461h204.0062c.377.0 9.2786.0329 12.568 2.9389l.3947.3833 58.9508 63.337c3.2135 3.4652 3.2514 11.7924 3.2514 12.1593v256.2036C396.0231 418.3408 390.8284 423.2066 384.4445 423.2066zM116.5079 411.9189c.0848.0278.1999.0531.3441.0531h267.5925c.1442.0.2581-.0253.3441-.0531V156.1556c-.0076-.9033-.3593-3.7347-.7034-5.0037l-57.6527-61.9416c-1.4651-.3176-4.4533-.6389-5.5742-.6389H116.852c-.143.0-.2594.024-.3441.0531V411.9189zm267.4533-261.149zM327.0321 89.371v.0013V89.371z"/></g></g></g><g><g><path style="fill:#5b7fc0" d="M189.0874 210.1754l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4473C177.5953 212.627 183.0601 210.1742 189.0874 210.1754zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 234.1722 197.0804 232.033z"/><path style="opacity:.3;fill:#fff" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/><g><defs><path id="SVGID_1_" d="M194.7376 237.6875c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 234.2399 196.1861 236.239 194.7376 237.6875z"/></defs><clipPath id="SVGID_2_"><use xlink:href="#SVGID_1_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_2_);fill:#fff" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/><path style="opacity:.13;clip-path:url(#SVGID_2_);fill:#020202" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/></g><g><defs><path id="SVGID_3_" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/></defs><clipPath id="SVGID_4_"><use xlink:href="#SVGID_3_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_4_);fill:#5b7fc0" d="M172.6595 215.6045c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8475-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 209.1953 176.6171 211.647 172.6595 215.6045z"/></g></g><rect x="198.8952" y="225.1043" style="fill:#5b7fc0" width="122.6266" height="13.8671"/></g><g><path style="fill:#d95140" d="M189.0874 155.7611l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.0249 2.454-11.4897 6.4116-15.4473C177.5953 158.2128 183.0601 155.7599 189.0874 155.7611zm7.993 21.8577c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.2508 181.7667 197.0816 179.758 197.0804 177.6188z"/><path style="opacity:.3;fill:#fff" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/><g><defs><path id="SVGID_5_" d="M194.7376 183.2733c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 179.8256 196.1861 181.8248 194.7376 183.2733z"/></defs><clipPath id="SVGID_6_"><use xlink:href="#SVGID_5_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_6_);fill:#fff" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/><path style="opacity:.13;clip-path:url(#SVGID_6_);fill:#020202" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/></g><g><defs><path id="SVGID_7_" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/></defs><clipPath id="SVGID_8_"><use xlink:href="#SVGID_7_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_8_);fill:#d95140" d="M172.6595 161.1903c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 154.7811 176.6171 157.2327 172.6595 161.1903z"/></g><rect x="198.8952" y="170.69" style="fill:#d95140" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#56a55c" d="M189.5379 264.6147l.0012-.0012c7.7751.0012 15.0294 4.1862 18.932 10.9235 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032-5.8394.0-11.3281-2.2733-15.458-6.4032-4.13-4.13-6.4032-9.6186-6.4056-15.4628.0012-6.0249 2.454-11.4897 6.4116-15.4472C178.0458 267.0663 183.5105 264.6135 189.5379 264.6147zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6538 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.7013 290.6202 197.5321 288.6115 197.5309 286.4723z"/><path style="opacity:.3;fill:#fff" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/><g><defs><path id="SVGID_9_" d="M195.1881 292.1268c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9941 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.5344 288.6792 196.6366 290.6783 195.1881 292.1268z"/></defs><clipPath id="SVGID_10_"><use xlink:href="#SVGID_9_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_10_);fill:#fff" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/><path style="opacity:.13;clip-path:url(#SVGID_10_);fill:#020202" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/></g><g><defs><path id="SVGID_11_" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/></defs><clipPath id="SVGID_12_"><use xlink:href="#SVGID_11_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_12_);fill:#56a55c" d="M173.11 270.0439c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7325-11.1497-10.9151-18.926-10.9151C182.5311 263.6346 177.0676 266.0863 173.11 270.0439z"/></g></g><rect x="199.3456" y="279.5436" style="fill:#56a55c" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#f1bc42" d="M189.0874 318.7208l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3305-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4472C177.5953 321.1724 183.0601 318.7196 189.0874 318.7208zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 342.7176 197.0804 340.5784z"/><path style="opacity:.3;fill:#fff" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/><g><defs><path id="SVGID_13_" d="M194.7376 346.2329c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 342.7853 196.1861 344.7844 194.7376 346.2329z"/></defs><clipPath id="SVGID_14_"><use xlink:href="#SVGID_13_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_14_);fill:#fff" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/><path style="opacity:.13;clip-path:url(#SVGID_14_);fill:#020202" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/></g><g><defs><path id="SVGID_15_" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/></defs><clipPath id="SVGID_16_"><use xlink:href="#SVGID_15_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_16_);fill:#f1bc42" d="M172.6595 324.15c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8474-1.0151-7.6327-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 317.7407 176.6171 320.1924 172.6595 324.15z"/></g></g><rect x="198.8952" y="333.6497" style="fill:#f1bc42" width="122.6266" height="13.8671"/></g></g></svg></span><span class="navbar-brand__name">万众一芯之香山处理器</span></a>
  <div class="td-navbar-nav-scroll ms-md-auto" id="main_navbar">
    <ul class="navbar-nav">
      <li class="nav-item dropdown d-none d-lg-block">
        <div class="dropdown">
  <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">中文</a>
  <ul class="dropdown-menu">
    <li><a class="dropdown-item" href="/UnityChipForXiangShan/en/">English</a></li>
    </ul>
</div></li>
      </ul>
  </div>
  <div class="d-none d-lg-block">
    <div class="td-search td-search--offline">
  <div class="td-search__icon"></div>
  <input
    type="search"
    class="td-search__input form-control"
    placeholder="站内搜索…"
    aria-label="站内搜索…"
    autocomplete="off"
    
    data-offline-search-index-json-src="/UnityChipForXiangShan/offline-search-index.58dbf9d634e9819a876c4135dddad1cd.json"
    data-offline-search-base-href="/"
    data-offline-search-max-results="10"
  >
</div>
  </div>
</div>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 ps-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">FTQ概述</h1>





    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-7ff52559ce920632c127396bd7ec9421">FTQ顶层</a></li>


    
  
    
    
	
<li>2: <a href="#pg-8b82b413ea6abfeab9ebac3ba72e7b9c">FTQ子队列</a></li>


    
  
    
    
	
<li>3: <a href="#pg-a08c000e80bb83d7987b168d3f0ac2f5">FTQ接收BPU分支预测结果</a></li>


    
  
    
    
	
<li>4: <a href="#pg-bbc889120c17b68caa4f605372b47a0e">FTQ向IFU发送取指目标</a></li>


    
  
    
    
	
<li>5: <a href="#pg-902c9098c896a3c8e9e6f1dff8bed38e">IFU向FTQ写回预译码信息</a></li>


    
  
    
    
	
<li>6: <a href="#pg-9c89ab197585abfab0c8084355d958c0">FTQ接收后端重定向</a></li>


    
  
    
    
	
<li>7: <a href="#pg-a21c8d5c61630fe55cf5e4227e97c8f6">FTQ接收IFU重定向</a></li>


    
  
    
    
	
<li>8: <a href="#pg-d5eaae05e615ad48e9d4009fee393d14">FTQ向后端发送取指目标</a></li>


    
  
    
    
	
<li>9: <a href="#pg-060cd9108a272839369f1158228bfaa9">执行单元修改FTQ状态队列</a></li>


    
  
    
    
	
<li>10: <a href="#pg-63ebff3aa1d2952064b973785cdcbf35">冲刷指针和状态队列</a></li>


    
  
    
    
	
<li>11: <a href="#pg-5a73ff17101ad6634015b300133e5fb2">FTQ向BPU发送更新与重定向信息</a></li>


    
  

    </ul>


<div class="content">
      <p>下文（包括所有的FTQ文档）中会提到一些关于BPU和IFU的相关知识，详情需要去查看对应的文档:</p>
<ul>
<li><a href="https://open-verify.cc/xs-bpu/docs/">BPU文档链接</a></li>
<li><a href="https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/">IFU文档链接</a></li>
</ul>
<p><em>hint：建议先从BPU基础设计中着重理解以下概念：</em></p>
<ol>
<li>什么是分支预测？</li>
<li>什么是分支预测块？一个有帮助的链接：<a href="https://docs.xiangshan.cc/zh-cn/latest/frontend/bp/#pred-block">预测块</a></li>
<li>(可选)什么是重定向，什么是预测结果重定向？</li>
<li>(可选)分支预测的流水级</li>
</ol>
<h1 id="简介">简介</h1>
<p>FTQ 是分支预测和取指单元之间的缓冲队列，它的主要职能是<strong>暂存 BPU 预测的取指目标</strong>，并根据这些取指目标<strong>给 IFU 发送取指请求</strong>。它的另一重要职能是<strong>暂存 BPU 各个预测器的预测信息</strong>，在指令提交后把这些信息送回 BPU 用作预测器的训练，因此它需要<strong>维护指令从预测到提交的完整的生命周期</strong>。另外，后端将存储来自FTQ的取指目标PC，便于自身读取。</p>
<p>![[Pasted image 20250222103931.png]]</p>
<h1 id="模块之间的中转站">模块之间的中转站</h1>
<p>从上图，FTQ很大程度上相当于一个中转站，中间人的角色，一方面，它承担着BPU和IFU之间的交互，这通常是因为BPU预测的速度快于IFU取值执行，所以使用FTQ作为缓冲。另一方面，它承担着后端与前端的交互，比如把前端将要执行的pc交给后端去执行。</p>
<p>显然，FTQ的 中转远不止这么多，下面更具体地讨论一下FTQ怎么中转各个前端或后端模块的信息的。</p>
<h2 id="bpu和ftq">BPU和FTQ</h2>
<p>BPUtoFTQ：BPU会将分支预测结果和meta数据发给FTQ。</p>
<ul>
<li>从分支预测结果中，我们可以提取出分支预测块对应的取值目标，比如，一个不跨缓存行且所有指令均为RVC指令的分支预测块对应的取值目标，是从分支预测块起始地址开始的以2B为间隔的连续16条指令。</li>
<li>meta信息则存储了各个预测器相关的预测信息，由于BPU预测有三个流水级，每个流水级都有相应的预测器，所以只有到s3阶段才有可能收集到所有预测器的预测信息，直到此时FTQ才接受到完整的meta，这些信息会在该分支预测块的全部指令被后端提交时交给BPU进行训练</li>
<li>FTBEntry：严格来说，它其实也是meta的一部分，但是因为更新的时候ftb_entry需要在原来的基础上继续修改，为了不重新读一遍ftb，另外给它存储一个副本。</li>
</ul>
<p>FTQtoBPU：FTQ会将带元数据的训练信息和重定向信息发回给BPU</p>
<ul>
<li><a href="https://open-verify.cc/xs-bpu/docs/ports/02_global_ports/">请参照BPU文档链接</a> <strong>BPU 模块整体对外接口 (PredirectIO)</strong></li>
</ul>
<h2 id="ftq和ifu">FTQ和IFU</h2>
<p>FTQtoIFU：FTQ会将存储的取值目标发往IFU进行取值译码和把后端的重定向信息也移交给IFU</p>
<ul>
<li>取值目标同时也发给：
<ul>
<li>toICache：同样的取值目标会被发给指令缓存单元，看对应的指令是否在缓存单元内存在，如果有会被直接发送给IFU加速取值效率</li>
<li>toPrefetch: prefetch是ICache的一个组件，负责预取功能</li>
</ul>
</li>
<li>转发后端重定向：
<ul>
<li>后端重定向不仅需要转发给BPU帮助其回到正确状态，也同时需要转发给IFU帮助其回到正确状态</li>
</ul>
</li>
</ul>
<p>IFUtoFTQ：IFU将预译码信息和重定向信息写回FTQ</p>
<ul>
<li>预译码信息：包含分支预测块对应的预测宽度内所有指令的预译码信息
<em><strong>预测宽度：一个指令块预测块覆盖的指令范围，香山中是16条rvc指令</strong></em></li>
<li>重定向信息其实也是根据预译码信息得到的：当预译码信息中指出预测块内某一条指令预测出错时，写回IFU重定向信息</li>
</ul>
<h2 id="后端和ftq">后端和FTQ</h2>
<p>FTQ到后端：FTQ会将存储的取值目标发往后端，后端存储 PC后，在本地即可进行读取取指目标。</p>
<ul>
<li>除了IFU，预测块的取值目标也会发给后端，但这里有一点区别：IFU空闲时才能从FTQ中获取取值目标，但是后端会一直取得最新的预测块的取指目标</li>
</ul>
<p>后端到FTQ：后端重定向和指令commit</p>
<ul>
<li>后端重定向与更新：后端是实际执行指令的单元，通过后端的执行结果，才能确认一条指令是否执行错误，产生重定向，同时，在发生重定向时，根据后端实际执行结果生成更新信息。</li>
<li>指令commit：当一个分支预测块内的所有指令都被执行，在后端提交，这标志着FTQ队列中这个分支预测块对应的FTQ项已经结束了它的生命周期，可以从队列中移除了，这时候，我们就可以把它的更新信息发给FTQ了。</li>
</ul>
<h1 id="ftq指针">FTQ指针</h1>
<p>FTQ的全名叫取值目标队列，队列中的一个项叫做FTQ项，BPU写入预测结果时是写入队列中哪个位置，IFU又是从哪个队列取FTQ项？这时候，我们需要一个FTQ指针去索引FTQ项，而由于和不同模块的交互需要索引不同的FTQ项，因此，有以下类型的FTQ指针，下面，由指令生命周期为例，大致介绍这些指针：</p>
<h2 id="指令在ftq中的生存周期">指令在 FTQ 中的生存周期</h2>
<p>指令以<a href="https://docs.xiangshan.cc/zh-cn/latest/frontend/bp/#pred-block">预测块</a>为单位，从 BPU 预测后便送进 FTQ，直到指令所在的<a href="https://docs.xiangshan.cc/zh-cn/latest/frontend/bp/#pred-block">预测块</a>中的所有指令全部在后端提交完成，FTQ 才会在存储结构中完全释放该<a href="https://docs.xiangshan.cc/zh-cn/latest/frontend/bp/#pred-block">预测块</a>所对应的项。这个过程中发生的事如下：</p>
<ol>
<li>预测块从 BPU 发出，进入 FTQ，<code>bpuPtr</code> 指针加一，初始化对应 FTQ 项的各种状态，把各种预测信息写入存储结构；如果预测块来自 BPU 覆盖预测逻辑，则恢复 <code>bpuPtr</code> 和 <code>ifuPtr</code></li>
<li>FTQ 向 IFU 发出取指请求，<code>ifuPtr</code> 指针加一，等待预译码信息写回</li>
<li>IFU 写回预译码信息，<code>ifuWbPtr</code> 指针加一，如果预译码检测出了预测错误，则给 BPU 发送相应的重定向请求，恢复 <code>bpuPtr</code> 和 <code>ifuPtr</code></li>
<li>指令进入后端执行，如果后端检测出了误预测，则通知 FTQ，给 IFU 和 BPU 发送重定向请求，恢复 <code>bpuPtr</code>、<code>ifuPtr</code> 和 <code>ifuWbPtr</code></li>
<li>指令在后端提交，通知 FTQ，等 FTQ 项中所有的有效指令都已提交，<code>commPtr</code> 指针加一，从存储结构中读出相应的信息，送给 BPU 进行训练</li>
</ol>
<p>预测块 <code>n</code> 内指令的生存周期会涉及到 FTQ 中的 <code>bpuPtr</code>、<code>ifuPtr</code>、<code>ifuWbPtr</code> 和 <code>commPtr</code> 四个指针，当 <code>bpuPtr</code> 开始指向 <code>n+1</code> 时，预测块内的指令进入生存周期，当 <code>commPtr</code> 指向 <code>n+1</code> 后，预测块内的指令完成生存周期。</p>
<h2 id="循环队列">循环队列</h2>
<p>FTQ队列实际上是一个循环队列，所有类型的FTQ指针都是同一类型，ftqPtr的value字段用来表示索引，flag字段则用来表示循环轮数，flag只有一位，进入新的循环时flag位翻转。
这样，我们就可以在一个有限的队列空间内不断更新新的项，以及正确进行比较，判断哪个项在队列中更靠前或者更靠后。</p>

</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7ff52559ce920632c127396bd7ec9421">1 - FTQ顶层</h1>
    
	<h1 id="简述">简述</h1>
<p>在FTQ概述中，我们已经知道了，FTQ的作用就是多个模块交互的中转站，大致了解了它接受其他模块的哪些信息，它如何接受并存储这些信息在FTQ中，并如何把这些存储信息传递给需要的模块。
下面我们来具体了解一下FTQ与其他模块的交互接口，我们会对这种交互有一个更具体的认识。</p>
<h1 id="io一览">IO一览</h1>
<h2 id="模块间io">模块间IO</h2>
<ul>
<li><strong>fromBpu：接受BPU预测结果的接口（BpuToFtqIO）</strong></li>
<li><strong>fromIfu：接受IFU预译码写回的接口（IfuToFtqIO）</strong></li>
<li><strong>fromBackend：接受后端执行结果和commit信号的接口（CtrlToFtqIO）</strong></li>
<li><strong>toBpu：向BPU发送训练信息和重定向信息的接口（FtqToBpuIO）</strong></li>
<li><strong>toIfu：向IFU发送取值目标和重定向信息的接口（FtqToIfuIO）</strong></li>
<li>toICache：向ICache发送取值目标的接口（FtqToICacheIO）</li>
<li><strong>toBackend：向后端发送取值目标的接口（FtqToCtrlIO）</strong></li>
<li>toPrefetch：向Prefetch发送取值目标的接口（FtqToPrefetchIO）</li>
<li>mmio</li>
</ul>
<h2 id="其他">其他</h2>
<p>上述是主要的IO接口，此外，还有一些用于性能统计的IO接口，比如对BPU预测正确和错误结果次数进行统计，并进行转发的IO, 还有转发BPU各预测器预测信息的IO。</p>
<h1 id="bputoftqiohttpsopen-verifyccxs-bpudocsports02_global_ports"><a href="https://open-verify.cc/xs-bpu/docs/ports/02_global_ports/">BpuToFtqIO</a></h1>
<h1 id="ifutoftqio">IfuToFtqIO</h1>
<p>我们知道从IFU，我们会得到预译码信息和重定向信息，而后者其实也是从预译码信息中生成。所以从IFU到FTQ的接口主要就是用来传递预译码信息的</p>
<ul>
<li>pdWb：IFU向FTQ写回某个FTQ项的预译码信息
<ul>
<li>接口类型：<strong>PredecodeWritebackBundle</strong></li>
<li>信号列表：
<ul>
<li>pc：一个分支预测块覆盖的预测范围内的所有pc
<ul>
<li>接口类型：Vec(PredictWidth, UInt(VAddrBits.W))</li>
</ul>
</li>
<li>pd：预测范围内所有指令的预译码信息
<ul>
<li>接口类型：Vec(PredictWidth, new PreDecodeInfo)</li>
<li>PreDecodeInfo：每条指令的预译码信息
<ul>
<li>接口类型：PreDecodeInfo</li>
<li>信号列表：
<ul>
<li>valid：预译码有效信号
<ul>
<li>接口类型：Bool</li>
</ul>
</li>
<li>isRVC：是RVC指令
<ul>
<li>接口类型：Bool</li>
</ul>
</li>
<li>brType：跳转指令类型
<ul>
<li>接口类型：UInt(2.W)</li>
<li>说明：根据brType的值判断跳转指令类型
<ul>
<li>b01：对应分支指令</li>
<li>b10：对应jal</li>
<li>b11：对应jalr</li>
<li>b00：对应非控制流指令</li>
</ul>
</li>
</ul>
</li>
<li>isCall：是Call指令
<ul>
<li>接口类型：Bool</li>
</ul>
</li>
<li>isRet：是Ret指令
<ul>
<li>接口类型：Bool</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ftqIdx：FTQ项的索引，标记写回到哪个FTQ项
<ul>
<li>接口类型：FtqPtr</li>
</ul>
</li>
<li>ftqOffset：由BPU预测结果得到的，在该指令块中指令控制流指令的位置（指令控制流指令就是实际发生跳转的指令）
<ul>
<li>接口类型：UInt(log2Ceil(PredictWidth).W)</li>
</ul>
</li>
<li>misOffset：预译码发现发生预测错误的指令在指令块中的位置
<ul>
<li>接口类型：ValidUndirectioned(UInt(log2Ceil(PredictWidth).W))</li>
<li>说明：它的valid信号拉高表示该信号有效，也就说明存在预测错误，会引发重定向</li>
</ul>
</li>
<li>cfiOffset：由预译码结果得到的，在该指令块中指令控制流指令的位置（指令控制流指令就是实际发生跳转的指令）
<ul>
<li>接口类型：ValidUndirectioned(UInt(log2Ceil(PredictWidth).W))</li>
</ul>
</li>
<li>target：该指令块的目标地址
<ul>
<li>接口类型：UInt(VAddrBits.W)</li>
<li>说明：所谓目标地址，即在指令块中有控制流指令时，控制流指令的地址，在没有控制流指令时，指令块顺序执行，该指令块最后一条指令的下一条指令</li>
</ul>
</li>
<li>jalTarget：jal指令的跳转地址
<ul>
<li>接口类型：UInt(VAddrBits.W)</li>
</ul>
</li>
<li>instrRange：有效指令范围
<ul>
<li>接口类型：Vec(PredictWidth, Bool())</li>
<li>说明：表示该条指令是不是在这个预测块的有效指令范围内（第一条有效跳转指令之前的指令）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="ctrltoftqio">CtrlToFtqIO</h1>
<p>后端控制块向FTQ发送指令提交信息，后端执行结果的接口。</p>
<ul>
<li>rob_commits：一个提交宽度内的RobCommitInfo信息。
<ul>
<li>接口类型：Vec(CommitWidth, Valid(new RobCommitInfo))</li>
<li>详情链接：RobCommitInfo</li>
</ul>
</li>
<li>redirect：后端提供重定向信息的接口。
<ul>
<li>接口类型：Valid(new Redirect)</li>
<li>详情链接：Redirect</li>
</ul>
</li>
<li>ftqIdxAhead：提前重定向的FTQ指针，将要重定向的FTQ项的指针提前发送
<ul>
<li>接口类型： Vec(BackendRedirectNum, Valid(new FtqPtr))</li>
<li>说明：虽然有三个接口，但实际上只用到了第一个接口，后面两个弃用了</li>
</ul>
</li>
<li>ftqIdxSelOH：独热码，本来是依靠该信号从提前重定向ftqIdxAhead中选择一个，但现在只有一个接口了，独热码也只有一位了。
<ul>
<li>接口类型：Valid(UInt((BackendRedirectNum).W))</li>
<li>说明：为了实现提前一拍读出在ftq中存储的重定向数据，减少redirect损失，后端会向ftq提前一拍（相对正式的后端redirect信号）传送ftqIdxAhead信号和ftqIdxSelOH信号。</li>
</ul>
</li>
</ul>
<h1 id="ftqtobpuiohttpsopen-verifyccxs-bpudocsports02_global_ports"><a href="https://open-verify.cc/xs-bpu/docs/ports/02_global_ports/">FtqToBpuIO</a></h1>
<h1 id="ftqtoicacheio">FtqToICacheIO</h1>
<p>FTQ向IFU发送取值目标，ICache是指令缓存，如果取值目标在ICache中命中，由ICache将指令发给IFU</p>
<ul>
<li>req：FTQ向ICache发送取值目标的请求
<ul>
<li>接口类型：Decoupled(new FtqToICacheRequestBundle)</li>
<li>信号列表：
<ul>
<li>pcMemRead：FTQ针对ICache发送的取值目标，ICache通过5个端口同时读取取指目标
<ul>
<li>接口类型：Vec(5, new FtqICacheInfo)</li>
<li>FtqICacheInfo: FTQ针对ICache发送的取值目标
<ul>
<li>信号列表：
<ul>
<li>ftqIdx：指令块在FTQ中的位置索引
<ul>
<li>接口类型：FtqPtr</li>
</ul>
</li>
<li>startAddr：预测块起始地址
<ul>
<li>接口类型：UInt(VAddrBits.W)</li>
</ul>
</li>
<li>nextlineStart：起始地址所在cacheline的下一个cacheline的开始地址
<ul>
<li>接口类型：UInt(VAddrBits.W)</li>
</ul>
</li>
<li>说明：通过startAddr(blockOffBits - 1)这一位（也就是块内偏移地址的最高位）可以判断该预读取pc地址是位于cacheline的前半块还是后半块，若是前半块，由于取值块大小为cacheline大小的一半，不会发生跨cacheline行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>readValid: 对应5个pcMemRead是否有效</li>
<li>backendException：是否有后端异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="ftqtoctrlio">FtqToCtrlIO</h1>
<p>FTQ向后端控制模块转发PC，后端将这些pc存储在本地，之后直接在本地读取这些pc
<strong>写入后端pc mem</strong></p>
<ul>
<li>pc_mem_wen：FTQ向后端pc存储单元pc_mem写使能信号
<ul>
<li>接口类型：Output(Bool())</li>
</ul>
</li>
<li>pc_mem_waddr：写入地址
<ul>
<li>接口类型：Output(UInt(log2Ceil(FtqSize).W))</li>
</ul>
</li>
<li>pc_mem_wdata：写入数据，是一个指令块的取值目标
<ul>
<li>接口类型：Output(new Ftq_RF_Components)，详见FTQ子队列相关介绍
<strong>写入最新目标</strong></li>
</ul>
</li>
<li>newest_entry_en：是否启用
<ul>
<li>接口类型：Output(Bool())</li>
</ul>
</li>
<li>newest_entry_target：最新指令块的跳转目标
<ul>
<li>接口类型：Output(UInt(VAddrBits.W))</li>
</ul>
</li>
<li>newest_entry_ptr：最新指令块的索引值
<ul>
<li>接口类型： Output(new FtqPtr)</li>
</ul>
</li>
</ul>
<h1 id="ftqtoprefetchio">FtqToPrefetchIO</h1>
<ul>
<li>req：FTQ向Prefetch发送取值目标的请求
<ul>
<li>接口类型：FtqICacheInfo</li>
</ul>
</li>
<li>flushFromBPU: 来自BPU的冲刷信息
<ul>
<li>接口类型：BpuFlushInfo</li>
<li>信号列表：
<ul>
<li>s2 ：BPU预测结果重定向（注意这种重定向是BPU自己产生的，与其他类型要做区分）发生在s2阶段时，此阶段的分支预测块的索引
<ul>
<li>接口类型：Valid(new FtqPtr)</li>
<li>说明：valid信号有效时，说明此时s2流水级分支预测结果与其s1阶段预测结果不一致，产生s2阶段重定向</li>
</ul>
</li>
<li>s3：BPU预测结果重定向（注意这种重定向是BPU自己产生的，与其他类型要做区分）发生在s3阶段时，此阶段的分支预测块的索引
<ul>
<li>接口类型：Valid(new FtqPtr)</li>
<li>说明：与s2类似</li>
</ul>
</li>
<li>说明：发生预测结果重定向的时候，预取单元和IFU都可能会被冲刷，比如，如果发生s2阶段重定向，FTQ会比较发给IFU req接口中的ftqIdx和s2阶段预测结果的ftqIdx，如果s2阶段的ftqIdx不在req的ftqIdx之后，这意味着，s2阶段产生的预测结果重定向之前的错误预测结果s1阶段预测结果被发给IFU进行取指了，为了消除这种错误，需要向IFU发送s2阶段flush信号。</li>
</ul>
</li>
</ul>
</li>
<li>backendException：后端执行发生的异常
<ul>
<li>接口类型：UInt(ExceptionType.width.W)</li>
<li>说明：表示后端执行时发生异常的类型，有这样几种类型的异常：</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">none</span><span style="color:#204a87;font-weight:bold">:</span>  <span style="color:#204a87;font-weight:bold">UInt</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;b00&#34;</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">U</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">width</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">pf</span><span style="color:#204a87;font-weight:bold">:</span>    <span style="color:#204a87;font-weight:bold">UInt</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;b01&#34;</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">U</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">width</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic">// instruction page fault
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">gpf</span><span style="color:#204a87;font-weight:bold">:</span>   <span style="color:#204a87;font-weight:bold">UInt</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;b10&#34;</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">U</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">width</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic">// instruction guest page fault
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">def</span> <span style="color:#000">af</span><span style="color:#204a87;font-weight:bold">:</span>    <span style="color:#204a87;font-weight:bold">UInt</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#4e9a06">&#34;b11&#34;</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">U</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">width</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">W</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#8f5902;font-style:italic">// instruction access fault
</span></span></span></code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8b82b413ea6abfeab9ebac3ba72e7b9c">2 - FTQ子队列</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p><em><strong>请注意：从本篇开始，就涉及待验证的功能点和测试点了</strong></em></p>
<p>在之前的介绍中，我们采用FTQ项这个术语描述描述FTQ队列中的每一个元素，实际上，这只是一种便于抽象的说法。</p>
<p>实际上的FTQ队列，是由好多个子队列共同构成的，一些子队列维护一类信息，另一些子队列维护另一类信息，相同ftqIdx索引的子队列信息共同构成一个完整的FTQ项。</p>
<p>为什么要把它们分开成多个子队列呢？因为某些模块只需要FTQ项中的某一些信息，比如IFU想要取值目标，它只需要专门存储取值目标的子队列提供的信息就行了。另外，在我们更改FTQ项的内容时，也只需要写入需要更新的子队列，比如IFU预译码写回时，只需要写回专门存储预译码信息的队列了。</p>
<p>下面来介绍一些FTQ的主要子队列，以及它们内部存储的数据结构。此外，FTQ还有一些存储中间状态的更小的队列</p>
<h2 id="术语说明">术语说明</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://open-verify.cc/xs-bpu/docs/ports/00_ftb/">FTB项</a></td>
<td>分支预测结果的基本组成项，包含对预测块中分支指令和跳转指令的预测</td>
</tr>
<tr>
<td>取指目标</td>
<td>一个预测块内包含的所有指令PC，当然，它不是直接发送所有PC，而是发送部分信号，接收方可由该信号推出所有PC</td>
</tr>
</tbody>
</table>
<h2 id="子模块列表">子模块列表</h2>
<table>
<thead>
<tr>
<th>子模块</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ftq_redirect_mem<br></td>
<td>重定向存储子队列，存储来自分支预测结果的重定向信息</td>
</tr>
<tr>
<td>ftq_pd_mem</td>
<td>预译码存储子队列，存储来自IFU的对指令块的预译码信息</td>
</tr>
<tr>
<td>ftb_entry_mem</td>
<td>FTB项存储子队列，存储自分支预测结果中的ftb项</td>
</tr>
<tr>
<td>ftq_pc_mem</td>
<td>取指目标子队列，存储来自分支预测结果的取指目标</td>
</tr>
</tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-ftq_redirect_mem存储重定向信息">1. ftq_redirect_mem存储重定向信息</h3>
<p>ftq_redirect_mem是香山ftq的一个子队列。它记录了重定向需要的一些信息，帮助重定向回正确状态，这些信息来自于BPU分支预测中的RAS预测器，以及顶层的分支历史指针，如果想要了解，可以参考BPU的RAS子文档了解如何通过这些信息回溯到之前的状态。</p>
<p>它是一个寄存器堆，由64（FtqSize）个表项（Ftq_Redirect_SRAMEntry）构成。支持同步读写操作。有3个读端口和1个写端口，每个读端口负责与不同的模块交互。</p>
<h4 id="11-ftq_redirect_mem读操作">1.1 ftq_redirect_mem读操作</h4>
<ul>
<li>读操作：
<ul>
<li>输入：
<ul>
<li>需要使能ren，这是一个向量，可指定任意读端口可读
<ul>
<li>对应接口：ren</li>
</ul>
</li>
<li>从任意读端口中输入要读取的元素在ftq_redirect_mem中的地址，这是一个从0到ftqsize-1的索引
<ul>
<li>对应接口：raddr</li>
</ul>
</li>
</ul>
</li>
<li>输出：
<ul>
<li>从发起输入的读端口对应的读出端口中读出Ftq_Redirect_SRAMEntry。
<ul>
<li>对应接口：rdata</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="12-ftq_redirect_mem写操作">1.2 ftq_redirect_mem写操作</h4>
<ul>
<li>写操作
<ul>
<li>输入：
<ul>
<li>需要使能wen，可指定写端口可写
<ul>
<li>对应接口：wen</li>
</ul>
</li>
<li>向写端口中输入要写入的元素在ftq_redirect_mem中的地址，这是一个从0到ftqsize-1的索引
<ul>
<li>对应接口：waddr</li>
</ul>
</li>
<li>向wdata中写入Ftq_Redirect_SRAMEntry
<ul>
<li>对应接口：wdata</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>多端口读：可以从多个读端口读取结果</li>
</ul>
<p><em>每个子队列的读写基本都是类似的，后面不再赘述</em></p>
<h3 id="ftq_redirect_sramentry">Ftq_Redirect_SRAMEntry</h3>
<p>ftq_redirect_mem存储的表项。继承自SpeculativeInfo，存储RAS预测器相关重定向信息，根据这些信息回溯到之前的状态</p>
<ul>
<li>sc_disagree：统计分支指令在sc预测器中预测是否发生错误
<ul>
<li>接口类型：Some(Vec(numBr, Bool()))</li>
<li>说明：Option 类型，表明这个值可能不存在，在非FPGA平台才有，否则为none</li>
<li>信号列表：
<ul>
<li>SpeculativeInfo：推测信息，帮助BPU在发生重定向的时候回归正常的状态
<ul>
<li>接口列表:
<ul>
<li>histPtr：重定向请求需要恢复的全局历史指针，可参见BPU顶层文档了解详情
<ul>
<li>接口类型：CGHPtr</li>
</ul>
</li>
</ul>
</li>
<li>说明：以下都属于RAS重定向信息,可参见BPU文档了解如何利用这些信息进行重定向
<ul>
<li>ssp：重定向请求指令对应的 RAS 推测栈栈顶在提交栈位置的指针
<ul>
<li>接口类型：UInt(log2Up(RasSize).W)</li>
</ul>
</li>
<li>sctr：重定向请求指令对应的 RAS 推测栈栈顶递归计数 Counter
<ul>
<li>接口类型：RasCtrSize.W</li>
</ul>
</li>
<li>TOSW：重定向请求指令对应的 RAS 推测栈（队列）写指针
<ul>
<li>接口类型：RASPtr</li>
</ul>
</li>
<li>TOSR：重定向请求指令对应的 RAS 推测栈（队列）读指针
<ul>
<li>接口类型：RASPtr</li>
</ul>
</li>
<li>NOS：重定向请求指令对应的 RAS 推测栈（队列）读指针
<ul>
<li>接口类型：RASPtr</li>
</ul>
</li>
<li>topAddr：
<ul>
<li>接口类型：UInt(VAddrBits.W)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>测试点名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.1</td>
<td>FTQ_REDIRECT_MEM</td>
<td>WRITE</td>
<td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
</tr>
<tr>
<td>1.2</td>
<td>FTQ_REDIRECT_MEM</td>
<td>READ</td>
<td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
</tr>
</tbody>
</table>
<h3 id="2-ftq_pd_mem存储预译码信息">2. ftq_pd_mem存储预译码信息</h3>
<p>由64（FtqSize）个表项（Ftq_pd_Entry）构成。支持同步读写操作。有2个读端口和1个写端口。具有读写使能信号。</p>
<p>存储来自IFU预译码的写回信息，它是一个寄存器堆，由64（FtqSize）个表项（Ftq_pd_Entry）构成。有2个读端口和1个写端口。</p>
<p>ftq_pd_mem直接接收来自IfuToFtqIO的信号，从中获取Ftq_pd_Entry，表示一个指令块对应的预译码信息表项。读取时获取预测块内某条指令的预测信息</p>
<h4 id="ftq_pd_entry">Ftq_pd_Entry</h4>
<ul>
<li>brMask：一个指令预测宽度内（16条rvc指令）的指令块中，哪些指令是分支指令
<ul>
<li>接口类型：Vec(PredictWidth, Bool())</li>
</ul>
</li>
<li>jmpInfo：jump信息，其值对应不同的jmp指令类型，表示指令块内jmp指令类型
<ul>
<li>接口类型：ValidUndirectioned(Vec(3, Bool()))</li>
<li>说明：  jumpinfo有效的时候，第0位是0，表示jal指令，第0位是1，表示jalr指令，第1位是1，表示call指令，第二位是1，表示ret指令。</li>
</ul>
</li>
<li>jmpOffset：jmp指令在指令预测块中的偏移地址
<ul>
<li>接口类型： UInt(log2Ceil(PredictWidth).W)</li>
</ul>
</li>
<li>rvcMask：一个预测块内的指令（16条rvc指令）哪些是rvc指令
<ul>
<li>接口类型：Vec(PredictWidth, Bool())</li>
</ul>
</li>
</ul>
<h3 id="21-ftq_pd_mem写操作">2.1 ftq_pd_mem写操作</h3>
<h4 id="predecodewritebackbundleifutoftqio如何写入ftq_pd_mem的一条ftq_pd_entry"><strong>PredecodeWritebackBundle（IfuToFtqIO）如何写入ftq_pd_mem的一条Ftq_pd_Entry</strong></h4>
<p>Ftq_pd_Entry项的写入是通过PredecodeWritebackBundle这个接口进行写入的（其实也就是IfuToFtqIO）
<em>从fromPdWb接口中接收信号生成表项</em>：</p>
<ul>
<li>brmask：PredecodeWritebackBundle有一个预测块内的所有指令的预译码信息，当一条指令的预译码信息有效(valid)且是分支指令（is_br）时, bool序列对应位置的指令被判定为分支指令</li>
<li>jumpInfo：
<ul>
<li>valid：预测块内存在一条指令，其预译码信息有效（valid），且是jmp指令（isJal或者isJalr）时，jumpInfo有效</li>
<li>bits：预测块内的第一条有效跳转指令的info，它是一个三位序列，从低到高（拉高）对应该指令被预译码为是isJalr，isCall，isRet</li>
</ul>
</li>
<li>jmpOffset：预测块内第一条有效jmp跳转指令的偏移</li>
<li>rvcMask：原封不动接受同名信号</li>
<li>jalTarget：原封不动接收同名信号</li>
</ul>
<h3 id="22-ftq_pd_mem写操作">2.2 ftq_pd_mem写操作</h3>
<h4 id="ftq_pd_mem的一条ftq_pd_entry如何以predecodeinfoto-pd的形式输出"><strong>ftq_pd_mem的一条Ftq_pd_Entry如何以PreDecodeInfo（to pd）的形式输出</strong></h4>
<p>PreDecodeInfo是一个Ftq_pd_Entry中的一条指令的预译码，需要输入offset，指定该预译码指令在预测块内的偏移</p>
<ul>
<li>
<p>valid：直接set为1</p>
</li>
<li>
<p>isRVC：设置为rvcMask bool序列中对应偏移的值</p>
</li>
<li>
<p>isBr：设置为brMask bool序列中对应偏移的值</p>
</li>
<li>
<p>isJalr：输入的偏移量等于jumpOffset，且jumpInfo有效并指明该指令type是isJalr（jmpInfo.valid &amp;&amp; jmpInfo.bits(0)）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>测试点名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>2.1</td>
<td>FTQ_PD_MEM</td>
<td>WRITE</td>
<td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
</tr>
<tr>
<td>2.2</td>
<td>FTQ_PD_MEM</td>
<td>READ</td>
<td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
</tr>
</tbody>
</table>
<h3 id="3-ftb_entry_mem存储ftb项">3. ftb_entry_mem存储FTB项</h3>
<p>有两个读端口，一个写端口，FtqSize个表项，存储的数据项为FTBEntry_FtqMem，FTBEntry_FtqMem与FTBEntry基本上是一致的。</p>
<h4 id="ftbentry_ftqmem">FTBEntry_FtqMem</h4>
<ul>
<li>brSlots：分支指令槽
<ul>
<li>接口类型：Vec(numBrSlot, new FtbSlot_FtqMem)</li>
<li>FtbSlot_FtqMem：
<ul>
<li>信号列表：
<ul>
<li>offset：给分支指令在相对于指令块起始地址的偏移
<ul>
<li>接口类型：UInt(log2Ceil(PredictWidth).W)</li>
</ul>
</li>
<li>sharing：对于tailSlot来说，启用sharing表示把这个slot让给分支指令来被预测
<ul>
<li>接口类型：Bool</li>
</ul>
</li>
<li>valid：预测槽有效
<ul>
<li>接口类型：Bool</li>
<li>说明：当slot有效时，我们才能说这条指令是br指令还是jmp指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>tailSlot：跳转指令槽
<ul>
<li>接口类型：FtbSlot_FtqMem</li>
</ul>
</li>
<li>FTBEntry_part：FTBEntry_FtqMem的父类，存储部分FTB信息，记录跳转指令的类型
<ul>
<li>信号列表：
<ul>
<li>isCall：接口类型：Bool</li>
<li>isRet：接口类型：Bool</li>
<li>isJalr：接口类型：Bool</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="31-ftb_entry_mem读操作">3.1 ftb_entry_mem读操作</h4>
<p>除了读出FTB项之外，顶层还可以从FTBEntry_FtqMem获取以下有效信息，在这里我们不需要验证以下内容，但是在验证顶层的时候我们会用到以下内容，在此处提一下，此外，以下内容并不会生成具体的信号接口，而是产生相应的判断逻辑：</p>
<ul>
<li>jmpValid：预测块中jmp指令有效
<ul>
<li>说明：当tailslot有效且不分享给分支指令时，jmp有效</li>
</ul>
</li>
<li>getBrRecordedVec：三维向量，对于三个slot
<ul>
<li>说明：接收一个offset偏移，如果命中有效分支slot（或者sharing拉高的tailslot），对应slot的向量元素拉高。</li>
</ul>
</li>
<li>brIsSaved：给定offset的指令是否是分支指令
<ul>
<li>说明：采用slot预测结果来说明是不是分支指令，前提需要信号有效</li>
</ul>
</li>
<li>getBrMaskByOffset：
<ul>
<li>说明：在给定offset范围内的三个slot中的指令是否是有效分支指令，用一个三位maks表示</li>
</ul>
</li>
<li>newBrCanNotInsert：能否插入新的brSlot
<ul>
<li>说明：给定offset超过有效tailSlot对应的offset时，不能插入新的brSlot</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>测试点名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.1</td>
<td>FTQ_ENTRY_MEM</td>
<td>WRITE</td>
<td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
</tr>
<tr>
<td>3.2</td>
<td>FTQ_ENTRY_MEM</td>
<td>READ</td>
<td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
</tr>
</tbody>
</table>
<h3 id="4-ftq_pc_mem存储取指目标">4. ftq_pc_mem存储取指目标</h3>
<p>pc存储子队列。存储项为Ftq_RF_Components，用来读取取指信息，取值信息交给IFU进行取指。</p>
<h4 id="ftq_rf_components">Ftq_RF_Components</h4>
<p><strong>信号含义</strong></p>
<ul>
<li>startAddr: 预测块的起始地址</li>
<li>nexLineAddr: 预测块下一个缓存行的起始地址
<ul>
<li>startAddr加上64个字节，一个缓存行的大小是64字节</li>
</ul>
</li>
<li>isNextMask: 一个预测宽度内的16条指令各自是否属于下一个预测块(在最新版本rtl中已被编译优化掉)
<ul>
<li>通过计算某条指令相对于预测块起始地址的偏移量（每条指令两个字节）得到偏移地址，该偏移地址的第4位（从0开始）为1，表示该指令属于下一个预测块。</li>
<li>进一步说，其实也就可以根据它判断该指令是否在预测块跨缓存行的时候判断该指令是否属于下一个cacheline了</li>
</ul>
</li>
<li>fallThruError ：预测出的下一个顺序取指地址是否存在错误</li>
</ul>
<h5 id="41-ftq_pc_mem写操作">4.1 ftq_pc_mem写操作</h5>
<p><strong>信息获取：上述信息都可以从一个单流水级分支预测结果 (BranchPredictionBundle)中获取</strong>。
获取方式：startAddr直接获取BranchPredictonBundle中的pc，fallThruError直接获取BranchPredictionBundle中的fallThruError。</p>
<h5 id="42-ftq_pc_mem读操作">4.2 ftq_pc_mem读操作</h5>
<p><strong>多端口读</strong>：ftq_pc_mem的每个读端口的读地址被直接连到各个FTQ指针的写入信号，这样做的目的，是可以及时的读取，从pc存储子队列读出的项一定是此时FTQ指针指向的项</p>
<h5 id="读写时机">读写时机</h5>
<p><strong>写入时机</strong>：BPU流水级的S1阶段，创建新的预测entry时写入
<strong>读出时机</strong>： 读数据每个时钟周期都会存进Reg。如果IFU不需要从bypass中读取数据，Reg数据直连给Icache和IFU，如果IFU不需要从bypass中读取数据，Reg数据直连给Icache和IFU</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>测试点名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>4.1</td>
<td>FTQ_PC_MEM</td>
<td>WRITE</td>
<td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
</tr>
<tr>
<td>4.2</td>
<td>FTQ_PC_MEM</td>
<td>READ</td>
<td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
</tr>
</tbody>
</table>
<h3 id="5-ftq_meta_1r_sram存储meta信息">5. ftq_meta_1r_sram存储meta信息</h3>
<p>存储的数据为Ftq_1R_SRAMEntry，同样有FtqSize项
Ftq_1R_SRAMEntry接口列表</p>
<ul>
<li>meta：分支预测的meta数据</li>
<li>ftb_entry：分支预测的FTB项
<strong>写入时机</strong>：在 BPU的s3阶段接收信息，因为对于一个指令预测块，只有在其s3阶段才能获取完整的mata信息，同样被接收的还有最后阶段ftqentry信息</li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>测试点名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>5.1</td>
<td>FTQ_META_1R_SRAM</td>
<td>WRITE</td>
<td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
</tr>
<tr>
<td>5.2</td>
<td>FTQ_META_1R_SRAM</td>
<td>READ</td>
<td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
</tr>
</tbody>
</table>
<h2 id="接口说明">接口说明</h2>
<h3 id="ftq_redirect_sramentry-1">Ftq_Redirect_SRAMEntry</h3>
<p>ftq_redirect_mem存储的表项。继承自SpeculativeInfo，存储RAS预测器相关重定向信息，根据这些信息回溯到之前的状态</p>
<ul>
<li>sc_disagree：统计分支指令在sc预测器中预测是否发生错误
<ul>
<li>接口类型：Some(Vec(numBr, Bool()))</li>
<li>说明：Option 类型，表明这个值可能不存在，在非FPGA平台才有，否则为none</li>
<li>信号列表：
<ul>
<li>SpeculativeInfo：推测信息，帮助BPU在发生重定向的时候回归正常的状态
<ul>
<li>接口列表:
<ul>
<li>histPtr：重定向请求需要恢复的全局历史指针，可参见BPU顶层文档了解详情
<ul>
<li>接口类型：CGHPtr</li>
</ul>
</li>
</ul>
</li>
<li>说明：以下都属于RAS重定向信息,可参见BPU文档了解如何利用这些信息进行重定向
<ul>
<li>ssp：重定向请求指令对应的 RAS 推测栈栈顶在提交栈位置的指针
<ul>
<li>接口类型：UInt(log2Up(RasSize).W)</li>
</ul>
</li>
<li>sctr：重定向请求指令对应的 RAS 推测栈栈顶递归计数 Counter
<ul>
<li>接口类型：RasCtrSize.W</li>
</ul>
</li>
<li>TOSW：重定向请求指令对应的 RAS 推测栈（队列）写指针
<ul>
<li>接口类型：RASPtr</li>
</ul>
</li>
<li>TOSR：重定向请求指令对应的 RAS 推测栈（队列）读指针
<ul>
<li>接口类型：RASPtr</li>
</ul>
</li>
<li>NOS：重定向请求指令对应的 RAS 推测栈（队列）读指针
<ul>
<li>接口类型：RASPtr</li>
</ul>
</li>
<li>topAddr：
<ul>
<li>接口类型：UInt(VAddrBits.W)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ftq_pd_entry-1">Ftq_pd_Entry</h3>
<ul>
<li>brMask：一个指令预测宽度内（16条rvc指令）的指令块中，哪些指令是分支指令
<ul>
<li>接口类型：Vec(PredictWidth, Bool())</li>
</ul>
</li>
<li>jmpInfo：jump信息，其值对应不同的jmp指令类型，表示指令块内jmp指令类型
<ul>
<li>接口类型：ValidUndirectioned(Vec(3, Bool()))</li>
<li>说明：  jumpinfo有效的时候，第0位是0，表示jal指令，第0位是1，表示jalr指令，第1位是1，表示call指令，第二位是1，表示ret指令。</li>
</ul>
</li>
<li>jmpOffset：jmp指令在指令预测块中的偏移地址
<ul>
<li>接口类型： UInt(log2Ceil(PredictWidth).W)</li>
</ul>
</li>
<li>rvcMask：一个预测块内的指令（16条rvc指令）哪些是rvc指令
<ul>
<li>接口类型：Vec(PredictWidth, Bool())</li>
</ul>
</li>
</ul>
<h2 id="测试点总表">测试点总表</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>测试点名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.1</td>
<td>FTQ_REDIRECT_MEM</td>
<td>WRITE</td>
<td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
</tr>
<tr>
<td>1.2</td>
<td>FTQ_REDIRECT_MEM</td>
<td>READ</td>
<td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
</tr>
<tr>
<td>2.1</td>
<td>FTQ_PD_MEM</td>
<td>WRITE</td>
<td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
</tr>
<tr>
<td>2.2</td>
<td>FTQ_PD_MEM</td>
<td>READ</td>
<td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
</tr>
<tr>
<td>3.1</td>
<td>FTQ_ENTRY_MEM</td>
<td>WRITE</td>
<td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
</tr>
<tr>
<td>3.2</td>
<td>FTQ_ENTRY_MEM</td>
<td>READ</td>
<td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
</tr>
<tr>
<td>4.1</td>
<td>FTQ_PC_MEM</td>
<td>WRITE</td>
<td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
</tr>
<tr>
<td>4.2</td>
<td>FTQ_PC_MEM</td>
<td>READ</td>
<td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
</tr>
<tr>
<td>5.1</td>
<td>FTQ_META_1R_SRAM</td>
<td>WRITE</td>
<td>向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata</td>
</tr>
<tr>
<td>5.2</td>
<td>FTQ_META_1R_SRAM</td>
<td>READ</td>
<td>向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取</td>
</tr>
</tbody>
</table>
<h2 id="附录">附录</h2>
<p><em><strong>虽然列在附录，但实际上这段内容依然十分重要，当你需要的时候请一定要查看。</strong></em></p>
<h3 id="其余状态子队列">其余状态子队列</h3>
<p>上述存储结构是FTQ中比较核心的存储结构，实际上，还有一些子队列用来存储一些状态信息，也同样都是存储ftqsize个（64）元素。主要有以下：</p>
<p>update_target：记录每个FTQ项的跳转目标，跳转目标有两种，一种是当该FTQ项对应的分支预测结果中指明的该分支预测块中执行跳转的分支指令将要跳转到的地址，另一种则是分支预测块中不发生跳转，跳转目标为分支预测块中指令顺序执行的下一条指令地址。</p>
<ul>
<li>此外，与之配套的还有newest_entry_target，newest_entry_ptr用来指示新写入的跳转目标地址，和它对应的指令预测块或者说FTQ项的在FTQ中的位置，同时，有辅助信号newest_entry_target_modified和newest_entry_ptr_modified用来标识该地址的FTQ项跳转地址是否被修改。</li>
</ul>
<p>写入时机：上一个周期的bpu_in_fire有效的时候，或者说相对于bpu_in_fire有效时延迟一个周期写入。</p>
<p>newest_entry_ptr，newest_entry_target：这几个内部信号，表明我们当前最新的有效FTQ项。BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，在相应的文档中，对其生成方式做具体的描述。</p>
<p>cfiIndex_vec：记录每个FTQ项的发生跳转的指令cfi（control flow instruction）指令在其分支预测块中的位置
写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</p>
<p>mispredict_vec：记录每个FTQ项的分支预测结果是否有误，初始化为false</p>
<p>pred_stage：记录每个FTQ项的分支预测结果是来自于哪个阶段
写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</p>
<p>pred_s1_cycle：记录每个FTQ项的分支预测结果对应的s1阶段的分支预测结果生成的时间（cycle数）
写入时机：相对于bpu_in_fire有效时延迟两个周期写入。</p>
<p>commitStateQueueReg：记录每个FTQ项中对应的分支预测块中每条指令（一般是16条rvc指令，对应一个预测宽度）的提交状态，提交状态有c_empty ，c_toCommit ，c_committed ，c_flushed，依次用从0开始的从小到大的枚举量表示，初始化为c_empty状态
写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</p>
<p>entry_fetch_status：记录每个FTQ项的分支预测结果是否被送到ifu中，该状态由两个枚举量f_to_send ， f_sent来表示, 初始化为f_sent状态。
写入时机：上一个周期的bpu_in_fire有效的时候，相对于bpu_in_fire有效时延迟一个周期写入。
写入数据：写入f_to_send</p>
<p>entry_hit_status：记录每个FTQ项拿到的分支预测结果是否是ftb entry hit的，即生成该分支预测结果的时候是否是从FTB ( <a href="https://open-verify.cc/xs-bpu/docs/modules/03_ftb/">预测结果生成：hit</a>)(非必须了解)中，读取到了对应的记录表项。初始化为not_hit状态。
写入时机：当来自BPU的全局分支预测信息中s2阶段的分支预测结果有效时，写入s2阶段分支预测结果中指名的hit状态，因为FTB预测器是分支预测s2阶段开始生效的，在此时判断预测项是否在FTB缓存中命中</p>
<p>newest_entry_ptr，newest_entry_target这几个内部信号，它们不是队列，但是它们很重要，表明我们当前应该关注的最新的FTQ项及对应的跳转目标。BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，在涉及到修改该信号的相应的文档中，对其生成方式做具体的描述。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a08c000e80bb83d7987b168d3f0ac2f5">3 - FTQ接收BPU分支预测结果</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>BPU会将分支预测结果和meta数据发给FTQ。</p>
<ul>
<li>从分支预测结果中，我们可以提取出分支预测块对应的取值目标，比如，一个不跨缓存行且所有指令均为RVC指令的分支预测块对应的取值目标，是从分支预测块起始地址开始的以2B为间隔的连续16条指令。</li>
<li>meta信息则存储了各个预测器相关的预测信息，由于BPU预测有三个流水级，每个流水级都有相应的预测器，所以只有到s3阶段才有可能收集到所有预测器的预测信息，直到此时FTQ才接受到完整的meta，这些信息会在该分支预测块的全部指令被后端提交时交给BPU进行训练</li>
<li>FTBEntry：严格来说，它其实也是meta的一部分，但是因为更新的时候ftb_entry需要在原来的基础上继续修改，为了不重新读一遍ftb，另外给它存储一个副本。</li>
</ul>
<h2 id="术语说明">术语说明</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>BPU (Branch Prediction Unit)</td>
<td>分支预测单元</td>
</tr>
<tr>
<td>FTQ (Fetch Target Queue)</td>
<td>采集目标队列</td>
</tr>
<tr>
<td>IFU (Instruction Fetch Unit)</td>
<td>指令采集单元</td>
</tr>
<tr>
<td>RAS (Return Address Stack)</td>
<td>返回地址堆</td>
</tr>
<tr>
<td>FTQ Entry</td>
<td>FTQ队列中的单个表项</td>
</tr>
</tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-新的预测块进队条件">1. 新的预测块进队条件</h3>
<h4 id="11-成功接收数据"><strong>1.1 成功接收数据</strong></h4>
<h5 id="111-ftq准备好接收信号">1.1.1 FTQ准备好接收信号</h5>
<ul>
<li>FTQ准备好接收信号：
     当FTQ队列中元素小于FtqSize或者可以提交指令块（canCommit拉高，说明可以提交指令块，在后面的文档: FTQ向BPU发送更新信息中介绍怎么判断是否可以提交指令块）的时候，来自BPU的新的指令预测块可以进入FTQ队列，队列准备好接收新的预测块，fromBpu的resp接口ready信号拉高。</li>
</ul>
<h5 id="112-bpu准备好要发送的信号">1.1.2 BPU准备好要发送的信号</h5>
<ul>
<li>BPU准备好要发送的信号：
     当BPU发往FTQ的接口vaid信号拉高，表示发送信号准备好</li>
</ul>
<p>满足以上两个条件时,fromBpu的resp接口fire，表示接口数据被成功发送到FTQ中。</p>
<h4 id="12-允许bpu入队allowbpuin"><strong>1.2 允许BPU入队allowBpuIn</strong></h4>
<ul>
<li>重定向发生时，会回滚到之前的状态，新发送的BPU预测信息自然就不需要了。<strong>允许BPU入队</strong>时不能发生重定向</li>
</ul>
<h5 id="121-后端重定向发生">1.2.1 后端重定向发生</h5>
<ol>
<li>后端重定向发生：
<ul>
<li>标志：接收后端写回信息的接口fromBackend的重定向接口redirect有效，则该周期不允许入队，如果没有发生真实提前重定向realAhdValid(参见FTQ接收后端重定向一文)，则下一个周期也不允许入队。</li>
</ul>
</li>
</ol>
<h5 id="122-ifu重定向发生">1.2.2 IFU重定向发生</h5>
<ol start="2">
<li>IFU重定向发生：
<ul>
<li>标志：IFU重定向信息生成的两个周期，均不许入队（参见FTQ接收IFU重定向一文了解IFU重定向信息的生成）</li>
</ul>
</li>
</ol>
<p>只要避免上述两种重定向出现的情况，就可以允许BPU入队,即可以把发送到FTQ的数据，写入FTQ项</p>
<h4 id="13-以bpu预测结果重定向的方式入队">1.3 以BPU预测结果重定向的方式入队</h4>
<p>上述的BPU入队方式是一个全新的预测块进队，即BPU分支预测的s1阶段结果入队，此时未发生预测结果重定向。</p>
<p>当BPU发生预测结果重定向时，只要<strong>允许BPU入队allowBpuIn</strong>，也可以看作预测结果入队，不过这种入队是覆写队列中已有的FTQ项，没有写入新的指令块。</p>
<ul>
<li>BPU预测结果发生重定向的具体标志：fromBpu的resp接口的s2（s2阶段的预测信息）有效，且s2的hasRedirect拉高，表示在s2阶段发生了重定向，s3阶段重定向是一样的。</li>
</ul>
<p><em><strong>综合两种形式的BPU入队，这里称之为广义BPU入队方便区分，记为bpu_in_fire，该信号拉高，表明发生广义BPU入队。</strong></em></p>
<h3 id="2-写入ftq项">2. 写入FTQ项</h3>
<p>之前已经说明过了，FTQ项只是一个抽象的概念，FTQ有很多个子队列组成，它们的项共同构成一个FTQ项，所以，向FTQ中写入FTQ项，实际上就是就是把BPU的预测信息写到对应的FTQ子队列中。</p>
<p>FTQ主要获取以下信息作为bpu_in_resp</p>
<ul>
<li>bpu_in_resp：BPU交给FTQ的resp详见BPU文档，resp中含有s1,s2,s3三个阶段的指令预测信息，bpu_in_resp将获取其中某一阶段预测信息selectedResp作为其值。未发生重定向时，使用s1作为预测结果，s2或者s3发生重定向信息时，优先s3的预测信息作为selectedResp。某阶段发生重定向的标志与上文讲述的一样一样。
从selectedResp（bpu_in_resp）中，我们还可以获取以下目标信息帮助我们写入子队列：ftq_idx，帮助我们索引写入子队列的地址</li>
</ul>
<h4 id="21-写入ftq子队列">2.1 写入FTQ子队列：</h4>
<h5 id="211-写入ftq_pc_mem">2.1.1 写入ftq_pc_mem</h5>
<ul>
<li>ftq_pc_mem: 来自BPU的selectedResp预测信息被写入ftq_pc_mem, 该存储结构有ftqsize个表项，对应队列中的所有ftq表项，每个存储元素可以推出对应的ftq表项中每条指令的pc地址
接收信号列表：
<ul>
<li>wen：接收bpu_in_fire作为写使能信号</li>
<li>waddr：接收selectedResp的ftq_idx</li>
<li>wdata：selectedResp的相应信号</li>
</ul>
</li>
</ul>
<h5 id="212-写入ftq_redirect_mem">2.1.2 写入ftq_redirect_mem</h5>
<ul>
<li>ftq_redirect_mem: 在BPU的s3（也就是最终阶段）接收信息，因为重定向信息只有在s3阶段才能得到。里面存储了RAS重定向相关的信息帮助BPU进行重定向。
接收信号列表：
<ul>
<li>wen：从BPU（fromBpu）回应（resp）的lastStage有效信号</li>
<li>waddr：从BPU回应的lastStage的ftq_idx.value</li>
<li>wdata：从BPU回应的last_stage_spec_info</li>
</ul>
</li>
</ul>
<h5 id="213-写入ftq_meta_1r_sram">2.1.3 写入ftq_meta_1r_sram</h5>
<ul>
<li>ftq_meta_1r_sram：在 BPU的s3阶段接收信息，同样是因为对于一个指令预测块，只有在其s3阶段才能获取完整的mata信息，同样被接收的还有最后阶段ftqentry信息
接收信号列表：
<ul>
<li>wen：从BPU（fromBpu）回应（resp）的lastStage有效信号</li>
<li>waddr：从BPU回应的lastStage的ftq_idx的value</li>
<li>wdata：
<ul>
<li>meta：从BPU回应的last_stage_meta</li>
<li>ftb_entry：从BPU回应的last_stage_ftb_entry</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="214-写入ftb_entry_mem">2.1.4 写入ftb_entry_mem</h5>
<ul>
<li>ftb_entry_mem：虽然ftq_meta_1r_sram中存储有最后阶段ftbentry，但此处出于更高效率读取专门把它存在ftb_entry_mem中。
接收信号列表：
<ul>
<li>wen：从BPU（fromBpu）回应（resp）的lastStage有效信号</li>
<li>waddr：从BPU回应的lastStage的ftq_idx的value字段</li>
<li>wdata：从BPU回应的last_stage_ftb_entry
从中可以看到，FTQ虽然名字上听起来是一个队列，<strong>实际上内部却是由数个队列组成</strong>，他们共同构成了FTQ这个大队列</li>
</ul>
</li>
</ul>
<h4 id="22-写入状态队列">2.2 写入状态队列</h4>
<p>上述存储结构是FTQ中比较核心的存储结构，实际上，还有一些子队列用来存储一些状态信息，也同样都是存储ftqsize个（64）元素，需要被写入，写入时机是在发生bpu_in_fire的下一个周期，或者再下一个周期 。主要有以下：</p>
<h5 id="221-写入update_target">2.2.1 写入update_target</h5>
<p>update_target：记录每个FTQ项的跳转目标，跳转目标有两种，一种是当该FTQ项对应的分支预测结果中指明的该分支预测块中执行跳转的分支指令将要跳转到的地址，另一种则是分支预测块中不发生跳转，跳转目标为分支预测块中指令顺序执行的下一条指令地址。</p>
<ul>
<li>此外，与之配套的还有newest_entry_target，newest_entry_ptr用来指示bpu_in_resp推出的跳转目标地址，表示下一次预测时开始的目标地址，和它对应的bpu_in_resp指令预测块在FTQ中的位置。
<ul>
<li>同时，有辅助信号newest_entry_target_modified和newest_entry_ptr_modified用来标识该这两个字段是否被修改。</li>
</ul>
</li>
<li>写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
<li>写入数据：bpu_in_resp.getTarget</li>
</ul>
<h5 id="222-写入cfiindex_vec">2.2.2 写入cfiIndex_vec</h5>
<p>cfiIndex_vec：记录每个FTQ项的发生跳转的指令cfi（control flow instruction）指令在其分支预测块中的位置</p>
<ul>
<li>写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
<li>写入数据：bpu_in_resp推断出的跳转目标</li>
</ul>
<h5 id="223-写入mispredict_vec">2.2.3 写入mispredict_vec</h5>
<p>mispredict_vec：记录每个FTQ项的所有指令的预测结果是否有误，初始化为false</p>
<ul>
<li>写入时机：相对于bpu_in_fire有效时延迟两个周期写入。</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
<li>写入数据：将该指令块的所有预测结果对应的值设置为false</li>
</ul>
<h5 id="224-写入pred_stage">2.2.4 写入pred_stage</h5>
<p>pred_stage：记录每个FTQ项的分支预测结果是来自于哪个阶段</p>
<ul>
<li>写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
</ul>
<h5 id="写入pred_s1_cycle不需要测试">写入pred_s1_cycle（不需要测试）</h5>
<p>pred_s1_cycle：记录每个FTQ项的分支预测结果对应的s1阶段的分支预测结果生成的时间（cycle数）</p>
<ul>
<li>写入时机：相对于bpu_in_fire有效时延迟两个周期写入。</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
</ul>
<h5 id="225-写入commitstatequeuereg">2.2.5 写入commitStateQueueReg</h5>
<p>commitStateQueueReg：记录每个FTQ项中对应的分支预测块中每条指令（一般是16条rvc指令，对应一个预测宽度）的提交状态，提交状态有c_empty ，c_toCommit ，c_committed ，c_flushed，依次用从小到大的枚举量表示，初始化为c_empty状态</p>
<ul>
<li>写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</li>
<li>写入数据：写入c_empty</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
</ul>
<h5 id="226-写入entry_fetch_status">2.2.6 写入entry_fetch_status</h5>
<p>entry_fetch_status：记录每个FTQ项的分支预测结果是否被送到ifu中，该状态由两个枚举量f_to_send ， f_sent来表示, 初始化为f_sent状态。</p>
<ul>
<li>写入时机：相对于bpu_in_fire有效时延迟一个周期写入。</li>
<li>写入数据：写入f_to_send</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
</ul>
<h5 id="227-写入entry_hit_status">2.2.7 写入entry_hit_status</h5>
<p>entry_hit_status：记录每个FTQ项拿到的分支预测结果是否是ftb entry hit的，即生成该分支预测结果的时候是否是从ftb中，读取到了对应的记录表项。初始化为not_hit状态。</p>
<ul>
<li>写入时机：当来自BPU的全局分支预测信息中s2阶段的分支预测结果有效时，写入s2阶段分支预测结果中指名的hit状态</li>
<li>写入地址：bpu_in_resp记录的要写入FTQ的地址</li>
<li>写入数据：f_to_send</li>
</ul>
<p>注：之所以延迟时钟周期写入，是为了缩短关键路径，以及帮助减少扇出</p>
<h3 id="3-转发分支预测重定向"><strong>3 转发分支预测重定向</strong>：</h3>
<h4 id="31-转发给ifu">3.1 转发给IFU</h4>
<ul>
<li>s2以及s3阶段的预测重定向信息通过FTQ与Ifu的接口toIfu的flushFromBpu发送给IFU，当完整分支预测结果中的s2阶段分支预测结果发生预测结果重定向时，flushFromBpu.s2.valid拉高，flushFromBpu.s2.bits接收s2阶段分支预测结果中指明的该分支预测结果在FTQ中的位置ftq_idx。</li>
</ul>
<h4 id="32-转发给预取">3.2 <strong>转发给预取</strong></h4>
<ul>
<li>该重定向信号同样会通过toPrefetch.flushFromBpu接口以相同的方式传递给Prefetch
s3阶段向IFU以及Prefetch的重定向传递与s2阶段的重定向信号传递一样。该阶段的重定向信号传递会覆盖可能的s2阶段重定向信号传递结果</li>
</ul>
<h3 id="4-修正ftq指针">4 修正FTQ指针</h3>
<p>此外，分支预测结果重定向也会影响ifuPtr与pfPtr两个指针信号的写入信号。</p>
<h4 id="41-正常修改">4.1 正常修改</h4>
<ul>
<li>正常情况下，allowToIfu（条件和allowToBpu一样），同时BPU向Ifu发送FTQ项的io接口toIfu.req发生fire的时候，ifuPtr寄存器中写入ifuPtr+1。同样发生修改的还有pfPtr，当allowToIfu，同时BPU向Prefetch发送FTQ项的io接口totoPrefetch.req发生fire的时候。</li>
</ul>
<h4 id="42-发生重定向时修改">4.2 发生重定向时修改</h4>
<ul>
<li>而如果是发生重定向的时候，比如s2阶段预测结果发生重定向，此时，若ifuPtr不在s2阶段预测结果中指明的ftq_idx之前，ifuPtr写入该ftq_idx，pfPtr_write同样如此</li>
</ul>
<p><strong>bpuptr</strong>：
由FTQ交给BPU用于指示新的指令预测块应该放到FTQ队列中的位置，上述存储结构，ftq_pc_mem，ftq_redirect_mem，ftq_meta_1r_sram，ftb_entry_mem基本上也是通过与该指针相关的信号得知信息应该存储的addr（bpuptr交给BPU，BPU基于此获知每个阶段预测结果的ftq_idx）。</p>
<p>bpuptr寄存器的输出值直接连到FTQ发往BPU的接口toBpu的enq_ptr字段中，当然，再次之前，bpuptr的值会根据实际情况修改。</p>
<p>在enq from bpu的过程中，正常情况下，发生enq的时候，也就是新的预测块进队时，bpuptr+1，BPU将要向FTQ中写入的位置前进一位</p>
<p>但是，如果发生重定向的时候，比如，如果s2阶段预测结果发生重定向，bpuptr被更新为s2阶段分支预测结果的ftq_idx+1，表示BPU将要向FTQ中写入的位置为s2阶段预测结果在FTQ中位置的后一位，因为此时新的全局预测结果会基于s2的预测结果展开下一轮预测（即以s2分支预测块的下一块展开预测，自然会被写入），该结果会覆盖enq_fire发生时的结果，此外s3阶段的分支预测重定向时，会覆盖可能的s2阶段重定向修改的bpuptr</p>
<p>其他的ftq指针也是类似的，用于指示写入FTQ的地址</p>
<h2 id="接口说明">接口说明</h2>
<p>FTQ接收BPU分支预测结果工程中涉及到的IO接口如下，在FTQ顶层IO一文中有详细说明</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>fromBackend</td>
<td>根据是否有重定向确认是否允许BPU预测结果入队</td>
</tr>
<tr>
<td>fromBPU</td>
<td>接收BPU预测结果</td>
</tr>
<tr>
<td>toIfu</td>
<td>发送更新的IFU指针，转发BPU预测结果重定向</td>
</tr>
<tr>
<td>toPrefetch</td>
<td>发送更新的Prefetch指针，转发BPU预测结果重定向</td>
</tr>
<tr>
<td>toBpu</td>
<td>发送更新的BPU指针</td>
</tr>
</tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>测试点名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.1.1</td>
<td>BPU_IN_RECEIVE</td>
<td>FTQ_READY</td>
<td>当FTQ队列中元素小于FtqSize或者可以提交指令块的时候，队列准备好接收新的预测块</td>
</tr>
<tr>
<td>1.1.2</td>
<td>BPU_IN_RECEIVE</td>
<td>BPU_VALID</td>
<td>BPU准备好要发送的信号</td>
</tr>
<tr>
<td>1.2.1</td>
<td>BPU_IN_ALLOW</td>
<td>BACKEND</td>
<td>接收后端写回信息的接口fromBackend的重定向接口redirect有效，则该周期不允许入队，如果没有发生真实提前重定向，则下一个周期也不允许入队</td>
</tr>
<tr>
<td>1.2.2</td>
<td>BPU_IN_ALLOW</td>
<td>IFU</td>
<td>IFU重定向信息生成的两个周期，均不许入队</td>
</tr>
<tr>
<td>1.3.1</td>
<td>BPU_IN_BY_REDIRECT</td>
<td>REDIRECT</td>
<td>当BPU发生预测结果重定向时，只要<strong>允许BPU入队allowBpuIn</strong>，也可以看作预测结果入队</td>
</tr>
<tr>
<td>2.1.1</td>
<td>WRITE_FTQ_SUBQUEUE</td>
<td>FTQ_PC</td>
<td>根据BPU预测结果写入ftq_pc_mem</td>
</tr>
<tr>
<td>2.1.2</td>
<td>WRITE_FTQ_SUBQUEUE</td>
<td>FTQ_REDIRECT</td>
<td>根据BPU预测结果写入ftq_redirect_mem</td>
</tr>
<tr>
<td>2.1.3</td>
<td>WRITE_FTQ_SUBQUEUE</td>
<td>FTQ_MATA</td>
<td>根据BPU预测结果写入ftq_meta_1r_sram</td>
</tr>
<tr>
<td>2.1.4</td>
<td>WRITE_FTQ_SUBQUEUE</td>
<td>FTQ_ENTRY</td>
<td>根据BPU预测结果写入ftb_entry_mem</td>
</tr>
<tr>
<td>2.2.1</td>
<td>WRITE_FTQ_STATEQUEUE</td>
<td>UPDATED_TARGET</td>
<td>根据BPU预测结果写入update_target</td>
</tr>
<tr>
<td>2.2.2</td>
<td>WRITE_FTQ_STATEQUEUE</td>
<td>CFIINDEX</td>
<td>根据BPU预测结果写入cfiIndex_vec</td>
</tr>
<tr>
<td>2.2.3</td>
<td>WRITE_FTQ_STATEQUEUE</td>
<td>MISPREDICT</td>
<td>根据BPU预测结果写入mispredict_vec</td>
</tr>
<tr>
<td>2.2.4</td>
<td>WRITE_FTQ_STATEQUEUE</td>
<td>PRED_STAGE</td>
<td>根据BPU预测结果写入pred_stage</td>
</tr>
<tr>
<td>2.2.5</td>
<td>WRITE_FTQ_STATEQUEUE</td>
<td>COMMITSTATE</td>
<td>根据BPU预测结果写入commitStateQueueReg</td>
</tr>
<tr>
<td>2.2.6</td>
<td>WRITE_FTQ_STATEQUEUE</td>
<td>ENTRY_FETCH_STATU</td>
<td>根据BPU预测结果写入entry_fetch_status</td>
</tr>
<tr>
<td>2.2.7</td>
<td>WRITE_FTQ_STATEQUEUE</td>
<td>ENTRY_HIT_STATU</td>
<td>根据BPU预测结果写入entry_hit_status</td>
</tr>
<tr>
<td>3.1</td>
<td>TRANSFER_BPU_REDIRECT</td>
<td>IFU</td>
<td>转发分支预测重定向给IFU</td>
</tr>
<tr>
<td>3.2</td>
<td>TRANSFER_BPU_REDIRECT</td>
<td>PREFETCH</td>
<td>转发分支预测重定向给PREFETCH</td>
</tr>
<tr>
<td>4.1</td>
<td>UPDATE_FTQ_PTR</td>
<td>NORMAL</td>
<td>正常情况下修改FTQ指针</td>
</tr>
<tr>
<td>4.2</td>
<td>UPDATE_FTQ_PTR</td>
<td>REDIRECT</td>
<td>发生重定向时修改FTQ指针</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bbc889120c17b68caa4f605372b47a0e">4 - FTQ向IFU发送取指目标</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>IFU需要取FTQ中的项进行取指令操作，同时也会简单地对指令进行解析，并写回错误的指令
FTQ发送给IFU的信号同时也需发送给ICache一份，ICache是指令缓存，帮助快速读取指令。</p>
<h2 id="术语说明">术语说明</h2>
<ul>
<li>ifuPtr：该寄存器信号指示了当前FTQ中需要读取的项的指针。直接发送给io.toIfu.req接口的ftqIdx。</li>
<li>entry_is_to_send：entry_fetch_status存储每个FTQ项的发送状态，初始化并默认为当前ifuptr指向的项对应的发送状态，后续可能因为旁路逻辑等改变</li>
<li>entry_ftq_offset: 从cfiIndex_vec中初始化并默认为当前ifuptr指向项的跳转指令在预测块中的偏移，后续可能因为旁路逻辑等改变</li>
<li>entry_next：本次取指结束后下一次取值的开始地址</li>
<li>pc_mem_ifu_ptr_rdata：获取ifuptr指向FTQ项的取指信息（从ftq_pc_mem的读取接口ifuPtr_rdata中获取）</li>
<li>pc_mem_ifu_plus1_rdata：获取ifuptr+1指向FTQ项的pc相关信息（从ftq_pc_mem的读取接口ifuPtrPlus1_rdata中）</li>
<li>copied_ifu_plus1_to_send：多个相同的复制信号，entry_fetch_status中指向ifuPtrPlus1的项是f_to_send状态或者上一周期bpu_in_fire,同时旁路bpu指针bpu_in_bypass_ptr等于ifuptr+1时，信号copied_ifu_plus1_to_send在一周期后拉高</li>
<li>copied_ifu_ptr_to_send：同理，只是把ifuptr+1改成了ifuptr</li>
</ul>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-获取取指目标信息">1. 获取取指目标信息</h3>
<p>获取取指目标有两个来源，一个是BPU写入信息时，直接将取指目标旁路出来，一种则是从存储取指目标的队列ftq_pc_mem中读取。使用前一种方式的前提，是刚好ifuPtr指向的读取项刚好就是旁路指针信号bpu_in_resp_ptr（BPU入队时写入项的ftqIdx）</p>
<ul>
<li>旁路逻辑：pc信号在被写入存储子队列时就被旁路一份，写入信号ftq_pc_mem.io.wdata在bpu_in_fire信号拉高时被旁路到旁路信号寄存器bpu_in_bypass_buf中。同时被旁路的还有指针信号bpu_in_resp_ptr，在同样的条件下被旁路到寄存器bpu_in_bypass_ptr中</li>
<li>读取ftq_pc_mem: 存储pc相关的取指目标，该存储队列有多个读接口，对所有ftqptr的写入信号（比如ifuPtr_write, ifuPtrPlus1_write等）被直接连接到存储队列的读取接口，这样，在ftqPtr寄存器正式被更新时，就可以同时直接从对应的读取接口中返回对应指针的读取结果，比如ftq_pc_mem.io.ifuPtr_rdata</li>
</ul>
<h4 id="11-准备发往icache的取指目标">1.1 准备发往ICache的取指目标</h4>
<p>有以下三种情况，分别对应<strong>测试点1.1.1，1.1.2，1.1.3</strong></p>
<ol>
<li>旁路生效，即旁路bpu指针等于ifuptr，且上一周期bpu输入有效结果（last_cycle_bpu_in表示上一周期bpu_in_fire）有效（也就相当于该旁路指针是有效的），此时，直接向toICache接口输入旁路pc信息bpu_in_bypass_buf</li>
<li>不满足情况1，但是上一周期发生ifu_fire（即FTQ发往IFU的接口发生fire），成功传输信号，此toICache中被写入pc存储子队列ftq_pc_mem中ifuptr+1对应项的结果，这是因为此时发生了ifu_fire，新的ifuptr还未来得及更新（即加1），所以直接从后一项中获取新的发送数据</li>
<li>前两种情况都不满足，此时toICache接口中被写入pc存储队列中ifuptr对应项的结果</li>
</ol>
<h4 id="12-提前一周期准备发往prefetch的取指目标">1.2 提前一周期准备发往Prefetch的取指目标</h4>
<p>有以下三种情况，分别对应<strong>测试点1.2.1，1.2.2，1.2.3</strong>
同样有三种情况：</p>
<ol>
<li>bpu有信号写入（bpu_in_fire），同时bpu_in_resp_ptr等于pfptr的写入信号pfptr_write, （此时pfptr_write还没有正式被写入pfptr中），读取bpu向pc存储队列的写入信号wdata，下一周期写入ToPrefetch
     <em>xxxptr_write：是相应FTQptr寄存器的write信号，连接到寄存器的写端口，寄存器在时钟上升沿成功写入write信号</em></li>
<li>不满足情况1，且由bpu到prefetch的接口发生fire，即bpu向预取单元成功发送信号，pc存储单元的pfPtrPlus1_rdata下一周期写入ToPrefetch接口，选择指针加1对应项的原因与toICache类似。</li>
<li>不满足以上两种情况：pc存储单元的pfPtr_rdata在下一周期被写入ToPrefetch接口</li>
</ol>
<h4 id="13-设置下一个发送的指令块的起始地址">1.3 设置下一个发送的指令块的起始地址</h4>
<p>有以下三种情况，分别对应<strong>测试点1.3.1，1.3.2，1.3.3</strong></p>
<p><strong>target（entry_next_addr）旁路逻辑：</strong>
有三种情况：</p>
<ol>
<li>上一周期bpu写入信号，且旁路指针等于ifuptr：
<ul>
<li>toIfu：写入旁路pc信息bpu_in_bypass_buf</li>
<li>entry_is_to_send ：拉高</li>
<li>entry_next_addr ：bpu预测结果中跳转地址last_cycle_bpu_target</li>
<li>entry_ftq_offset ：bpu预测结果中跳转指令在预测块中的偏移last_cycle_cfiIndex</li>
</ul>
</li>
<li>不满足情况1，bpu到ifu的接口发生fire，信号成功写入
<ul>
<li>toIfu：写入pc存储队列的读出信号ifuPtrPlus1_rdata，这同样是因为ifuptr还没来得及更改，所以直接使用ifuptr+1对应项的rdata</li>
<li>entry_is_to_send ：发送状态队列中ifuPtrPlus1对应项为f_to_send或者在上一周期bpu有写入时旁路bpu指针等于ifuptr加1，entry_is_to_send拉高。</li>
<li>entry_next_addr ：
<ul>
<li>如果上一周期bpu有写入且bpu旁路指针等于ifuptr+1，写入bpu旁路pc信号的startAddr字段，而这个项的pc信息还没有写入，正在pc旁路信号中，这是因为ifuptr+1对应下一个指令预测块，它的起始地址实际上就是ifuptr对应指令的预测块的跳转目标。</li>
<li>如果不满足该条件，
<ol>
<li>ifuptr等于newest_entry_ptr: 使用newest_entry_target作为entry_next_addr，newest_entry_ptr，newest_entry_target这几个内部信号，表明我们当前队列中最新的有效的FTQ项。如之前所说，BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，在相应的文档中，对其生成方式做具体的描述。</li>
<li>不满足条件1：使用pc存储队列的ifuPtrPlus2_rdata.startAddr</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>不满足情况1，2：</li>
</ol>
<ul>
<li>toIfu：写入pc存储队列的读出信号ifuPtr_rdata</li>
<li>entry_is_to_send ：发送状态队列中ifuPtr对应项为f_to_send或者在上一周期bpu有写入时旁路bpu指针等于ifuptr</li>
<li>entry_next_addr ：</li>
<li>如果上一周期bpu有写入且bpu旁路指针等于ifuptr+1，写入bpu旁路pc信号的startAddr字段。</li>
<li>如果不满足该条件，
         1. ifuptr等于newest_entry_ptr: 使用newest_entry_target作为entry_next_addr。
         2. 不满足上面的条件1：使用pc存储队列的ifuPtrPlus1_rdata.startAddr，为什么条件2和条件3，一个使用ifuPtrPlus2_rdata.startAddr作为entry_next_addr ，一个使用ifuPtrPlus1_rdata.startAddr作为，这也是出于时序的考虑：
因为要获得实际上的ifuptr+1对应项的start值作为结果，而因为第一处那里因为ifuptr还没来得及更新（加1）同步到当前实际的ifuptr，所以要加2来达到实际上的ifuptr+1对应的值，而第二处的ifuptr已经更新了，所以只用加1就行了。</li>
</ul>
<h3 id="2-发送取指信息">2. 发送取指信息</h3>
<h4 id="21-发送取指目标">2.1 发送取指目标</h4>
<h5 id="211-发送给ifu">2.1.1 发送给IFU</h5>
<p><strong>toIfu接口的req接口：</strong>
FTQ通过该接口向IFU发送取指信号：</p>
<ul>
<li>valid：要发送的FTQ项处于将发送状态entry_is_to_send且ifuptr不等于bpuptr</li>
<li>nextStartAddr：递交最终的entry_next_addr</li>
<li>ftqOffset：递交最终的entry_ftq_offset</li>
<li>toIfu：递交pc信息</li>
</ul>
<h5 id="212-发送给icache">2.1.2 发送给ICache</h5>
<p><strong>toICache的req接口：</strong>
FTQ通过该接口向ICache发送取指信号：</p>
<ul>
<li>valid：FTQ项处于将发送状态entry_is_to_send且ifuptr不等于bpuptr</li>
<li>readValid：ICache的有多个read接口，readVlid是一个向量，表示这几个read接口是否有效，readVlid中的每个元素的写入值与valid一样</li>
<li>pcMemRead：同样是一个向量，对应readVlid向量的ICache的多个pc信号read接口，从toIfu接口中将pc信息结果写入向量中各接口，接口的ftqIdx字段被写入ifuPtr</li>
<li>backendException：后端出现异常，同时后端pc错误指针等于ifuPtr</li>
</ul>
<h4 id="213-发送给prefetch">2.1.3 发送给Prefetch</h4>
<p><strong>toPrefetch的req接口：</strong></p>
<ul>
<li>valid：传给预取模块的项的状体toPrefetchEntryToSend为1，（toPrefetchEntryToSend会玩一个周期存储nextCycleToPrefetchEntryToSend的值），且pfptr不等于bpuptr，</li>
<li>toPrefetch：递交pc</li>
<li>ftqIdx字段被设置为pfptr寄存器的值</li>
<li>backendException：在后端pc错误指针等于pfptr的时候，传入后端异常信号，否则传入无异常信号</li>
</ul>
<h4 id="22-错误命中">2.2 错误命中</h4>
<p><strong>错误命中falsehit：</strong>
当发往Ifu的pc接口toIfu中发生fallThruError（预测块的fall through地址小于预测的起始地址时），且hit状态队列entry_hit_status中ifuPtr对应项显示命中的话，进行如下判断：</p>
<p>当发往ifu的接口toIfu的req接口发生fire，且bpu的预测结果不发生满足以下条件的重定向: s2或者s3的重定向的预测块对应的FTQ项索引号ftq_idx等于ifuptr, 此时，hit状态队列中ifuptr对应项被设置为false_hit。</p>
<h4 id="23-bpu冲刷">2.3 BPU冲刷</h4>
<p><strong>bpu向ifu的req请求的flush：</strong>
发往ifu的flushfrombpu(来自bpu的冲刷)接口中，记录有s2，s3阶段的指针，如果其中一条指针不大于发往ifu的req接口的ftqIdx的时候，表示应该被冲刷掉req信号，即冲刷掉新的发送给FTQ的预测信息。</p>
<h4 id="24-更新发送状态">2.4 更新发送状态</h4>
<p><strong>成功发送：</strong>
发往ifu的req接口发生fire，且req不被来自bpu的flush给冲刷掉时：
entry_fetch_status状态队列中ifuptr对应项的发送状态置为f_sent。表示该ftq项被成功发送 了</p>
<h2 id="接口说明">接口说明</h2>
<table>
<thead>
<tr>
<th>顶层IO</th>
<th>子接口</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>toIFU</td>
<td>req</td>
<td>发送取指目标</td>
</tr>
<tr>
<td>toIFU</td>
<td>flushfrombpu</td>
<td>冲刷掉发送给IFU的取指目标</td>
</tr>
<tr>
<td>toICache</td>
<td>req</td>
<td>发送取指目标</td>
</tr>
<tr>
<td>toPrefetch</td>
<td>req</td>
<td>发送取指目标</td>
</tr>
</tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>测试点名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.1.1</td>
<td>GET_PC_FOR_ICACHE</td>
<td>COND1</td>
<td>旁路生效，即旁路bpu指针等于ifuptr，且上一周期bpu输入有效结果有效，直接向toICache接口输入旁路pc信息bpu_in_bypass_buf</td>
</tr>
<tr>
<td>1.1.2</td>
<td>GET_PC_FOR_ICACHE</td>
<td>COND2</td>
<td>不满足情况1，但是上一周期发生ifu_fire，成功传输信号，此时toICache中被写入pc存储子队列ftq_pc_mem中ifuptr+1对应项的结果</td>
</tr>
<tr>
<td>1.1.3</td>
<td>GET_PC_FOR_ICACHE</td>
<td>COND3</td>
<td>前两种情况都不满足，此时toICache中被写入pc存储队列中ifuptr对应项的结果</td>
</tr>
<tr>
<td>1.2.1</td>
<td>GET_PC_FOR_PREFETCH</td>
<td>COND1</td>
<td>bpu有信号写入，同时bpu_in_resp_ptr等于pfptr的写入信号pfptr_write, 读取bpu向pc存储队列的写入信号wdata，下一周期写入ToPrefetch</td>
</tr>
<tr>
<td>1.2.2</td>
<td>GET_PC_FOR_PREFETCH</td>
<td>COND2</td>
<td>不满足情况1，且由bpu到prefetch的接口发生fire，即bpu向预取单元成功发送信号，pc存储单元的pfPtrPlus1_rdata下一周期写入ToPrefetch接口</td>
</tr>
<tr>
<td>1.2.3</td>
<td>GET_PC_FOR_PREFETCH</td>
<td>COND3</td>
<td>不满足以上两种情况：pc存储单元的pfPtr_rdata在下一周期被写入ToPrefetch接口</td>
</tr>
<tr>
<td>1.3.1</td>
<td>SET_NEXT_ADDR</td>
<td>COND1</td>
<td>上一周期bpu写入信号，且旁路指针等于ifuptr时设置下一个发送的指令块的起始地址</td>
</tr>
<tr>
<td>1.3.2</td>
<td>SET_NEXT_ADDR</td>
<td>COND2</td>
<td>不满足情况1，bpu到ifu的接口发生fire时设置下一个发送的指令块的起始地址</td>
</tr>
<tr>
<td>1.3.3</td>
<td>SET_NEXT_ADDR</td>
<td>COND3</td>
<td>不满足情况1，2时设置下一个发送的指令块的起始地址</td>
</tr>
<tr>
<td>2.1.1</td>
<td>SEND_PC</td>
<td>IFU</td>
<td>向IFU发送取指目标</td>
</tr>
<tr>
<td>2.1.2</td>
<td>SEND_PC</td>
<td>ICACHE</td>
<td>向ICache发送取指目标</td>
</tr>
<tr>
<td>2.1.3</td>
<td>SEND_PC</td>
<td>PREFETCH</td>
<td>向Prefetch发送取指目标</td>
</tr>
<tr>
<td>2.2</td>
<td>FALSE_HIT</td>
<td>FALSE_HIT</td>
<td>当发往Ifu的pc接口toIfu中发生fallThruError，且FTB项命中时判断是否是错误命中</td>
</tr>
<tr>
<td>2.3</td>
<td>FLUSH_FROM_BPU</td>
<td>FLUSH_FROM_BPU</td>
<td>发往ifu的flushfrombpu(来自bpu的冲刷)接口中的s2，s3阶段的指针其中一条指针不大于发往ifu的req接口的ftqIdx的时候，应该冲刷掉新的发送给FTQ的预测信息</td>
</tr>
<tr>
<td>2.4</td>
<td>UPDATE_SEND_STATU</td>
<td>UPDATE_SEND_STATU</td>
<td>发往ifu的req接口发生fire，且req不被来自bpu的flush给冲刷掉时：<br>entry_fetch_status状态队列中ifuptr对应项的发送状态置为f_sent</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-902c9098c896a3c8e9e6f1dff8bed38e">5 - IFU向FTQ写回预译码信息</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>IFU获取来自BPU的预测信息之后，会执行预译码，并将FTQ项写回FTQ中去。我们会比对FTQ中原BPU预测项和预译码的结果，判断是否有预测错误</p>
<h3 id="基本流程">基本流程</h3>
<p>预译码写回ftq_pd_mem：</p>
<ul>
<li>FTQ从pdWb接口中获取IFU的写回信息，FTQ首先将预译码写回信息写回到ftq_pd_mem,</li>
</ul>
<p>更新提交状态队列commitStateQueue：</p>
<ul>
<li>然后根据写回信息中指令的有效情况更新提交状态队列commitStateQueue。</li>
</ul>
<p>比对错误：</p>
<ul>
<li>同时，从ftb_entry_mem读出ifu_Wb_idx所指的FTB项，将该FTB项的预测结果与预译码写回结果进行对比，看两者对分支的预测结果是否有所不同。</li>
</ul>
<p>综合错误：</p>
<ul>
<li>之后就综合根据预译码信息可能得到的错误：有前面说的比对BPU的预测结果和预译码结果得到的错误，也有直接根据预译码得到的错误预测信息。根据错误预测结果更新命中状态队列。</li>
</ul>
<p>更新写回指针</p>
<ul>
<li>最后，如果IFU成功写回，ifu_Wb_idx更新加1。</li>
</ul>
<h2 id="术语说明">术语说明</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>预译码</td>
<td>IFU会对取指目标进预译码，之后写回FTQ</td>
</tr>
<tr>
<td>ifuWbPtr</td>
<td>IFU写回指针，知识IFU预译码要写入FTQ的位置</td>
</tr>
</tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-预译码写回ftq_pd_mem">1. 预译码写回ftq_pd_mem</h3>
<p>写回有效：预译码信息pdWb有效时，写有效
写回地址：pdWb的ftqIdx的value
写回值：解析整个pdWb的结果</p>
<h3 id="2-更新提交状态队列">2. 更新提交状态队列</h3>
<p>当预译码信息pdWb有效时，相当于写回有效，此时，根据预译码信息中每条指令的有效情况和该指令是否在有效范围内，判断指令的提交状态是否可以修改，若可以修改，则将提交状态队列，写回项中的指令状态修改</p>
<h4 id="详细信号表示">详细信号表示</h4>
<p>pdWb有效时，ifu_wb_valid拉高。
此时，对于预译码信息中每一条指令的预译码结果pd做判断：
如果预译码结果valid，且指令在有效范围内（根据insrtRange的bool数组指示），则提交状态队列commitStateQueue中，写回项中的指令状态修改为c_toCommit，表示可以提交，这是因为只有在FTQ项被预译码写回后，才能根据后端提交信息提交该FTQ项，之后会把预译码信息一并发往更新通道。</p>
<h3 id="3-比对预测结果与预译码结果">3. 比对预测结果与预译码结果</h3>
<p>从ftb存储队列ftb_entry_mem中的读取ifu写回指针ifuwbptr的对应项：</p>
<ul>
<li>pdWb有效的时候，读有效，读取地址为预译码信息中指示的ftqIdx。
当命中状态队列指示待比对项ftb命中，且回写有效时，读取出FTB存储队列中对应的项，与预译码信息进行比对，当BPU预测的FTB项指示指令是有效分支指令，而预译码信息中则指示不是有效分支指令时，发生分支预测错误，当BPU预测的FTB项指示指令是有效jmp指令，而预译码信息中则指示不是有效jmp指令时，发生跳转预测错误</li>
</ul>
<h4 id="详细信号表示-1">详细信号表示：</h4>
<p>ifu_wb_valid回写有效时，ftb_entry_mem回写指针对应读使能端口ren有效，读取地址为ifu_wb_idx预测译码信息中指示的ftqIdx的value值。
回写项命中且回写有效，hit_pd_valid信号有效，此时，读取ftb存储队列中的FTB项，读出brSlots与tailSlot，并进行比对：</p>
<h4 id="31-判断是否有分支预测错误br_false_hit">3.1 判断是否有分支预测错误br_false_hit</h4>
<h5 id="测试点311和312对应以下两种条件导致的br_false_hit">测试点3.1.1和3.1.2对应以下两种条件导致的br_false_hit</h5>
<ul>
<li>判断是否有分支预测错误br_false_hit：
<ol>
<li>brSlots的任意一项有效，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高表明是分支指令，</li>
<li>taiSlot有效且sharing字段拉高表明该slot为分支slot，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高表明是分支指令
满足任意条件可判断发生分支预测错误br_false_hit，该信号拉高</li>
</ol>
</li>
</ul>
<h4 id="32-判断是否发生jmp预测错误jal_false_hit">3.2 判断是否发生jmp预测错误jal_false_hit</h4>
<ul>
<li>判断是否发生jmp预测错误jal_false_hit：
<ul>
<li>预测结果中必须指明指令预测有效，且其中isJal拉高表面是jal指令或者指明是isjalr指令</li>
</ul>
</li>
</ul>
<h3 id="4-预译码错误">4. 预译码错误</h3>
<p>直接从预测结果中获取错误预测相关信息，如果回写项ftb命中且missoffset字段有效表明有错误预测的指令，hit_pd_mispred信号拉高，表示预译码结果中直接指明有预测错误的指令。</p>
<h3 id="5-综合错误">5. 综合错误</h3>
<p>综合比对预测结果与预译码结果得到的错误信息，与预译码错误直接获得的预测错误，任意一种发生时has_false_hit拉高表示有预测错误，此时，命中状态队列entry_hit_status中写回项的状态置为h_false_hit</p>
<h3 id="6-更新写回指针">6. 更新写回指针</h3>
<p>ifu_wb_valid拉高，表示写回有效，将ifuWbPtr更新为原值加1。</p>
<h2 id="接口说明">接口说明</h2>
<table>
<thead>
<tr>
<th>顶层IO</th>
<th>子接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>fromIfu</td>
<td>pdWb</td>
</tr>
</tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>测试点名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>WB_PD</td>
<td>WB_PD</td>
<td>向ftq_pd_mem中写回预译码信息</td>
</tr>
<tr>
<td>2</td>
<td>UPDATE_COMMITSTATE</td>
<td>UPDATE_COMMITSTATE</td>
<td>当预译码信息pdWb有效时，根据预译码信息中每条指令的有效情况和该指令是否在有效范围内，判断指令的提交状态是否可以修改，若可以修改，则将提交状态队列，写回项中的指令状态修改</td>
</tr>
<tr>
<td>3.1.1</td>
<td>BR_FALSE_HIT</td>
<td>COND1</td>
<td>brSlots的任意一项有效，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高</td>
</tr>
<tr>
<td>3.1.2</td>
<td>BR_FALSE_HIT</td>
<td>COND2</td>
<td>taiSlot有效且sharing字段拉高表明该slot为分支slot，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高</td>
</tr>
<tr>
<td>3.2</td>
<td>JAL_FALSE_HIT</td>
<td>JAL_FALSE_HIT</td>
<td>指令预测有效，且其中isJal拉高或者指明是isjalr指令</td>
</tr>
<tr>
<td>4</td>
<td>PD_MISS</td>
<td>PD_MISS</td>
<td>如果回写项ftb命中且missoffset字段有效表明有错误预测的指令，hit_pd_mispred信号拉高</td>
</tr>
<tr>
<td>5</td>
<td>FALSE_HIT</td>
<td>FALSE_HIT</td>
<td>综合比对预测结果与预译码结果得到的错误信息，与预译码错误直接获得的预测错误，任意一种发生时has_false_hit拉高表示有预测错误，此时，命中状态队列entry_hit_status中写回项的状态置为h_false_hit</td>
</tr>
<tr>
<td>6</td>
<td>UPDATE_IFU_WB_PTR</td>
<td>UPDATE_IFU_WB_PTR</td>
<td>ifu_wb_valid拉高，将ifuWbPtr更新为原值加1</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9c89ab197585abfab0c8084355d958c0">6 - FTQ接收后端重定向</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>FTQ重定向信息有两个来源，分别是IFU 和 后端。两者的 重定向接口大致相似，但重定向的过程有一定区别。</p>
<p>对于重定向，后端有提前重定向机制，为了实现提前一拍读出在ftq中存储的重定向数据，减少redirect损失，后端会向ftq提前一拍（相对正式的后端redirect信号）传送ftqIdxAhead信号和ftqIdxSelOH信号。ftqIdxSelOH信号出现的原因，是早期版本要读多个ftqIdxAhead信号，以独热码的形式选其中一路作为最终确认的提前索引值，但现在只需要从一个端口获取ftqIdx信号了，ftqIdxAhead只能确认这一个端口了。</p>
<h2 id="术语说明">术语说明</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sc_disagree</td>
<td>统计SC预测错误用的性能计数器中需要用到的值，SC预测器是BPU子预测器TAGE-SC预测器的一个部分</td>
</tr>
</tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-接收后端重定向信号">1. 接收后端重定向信号</h3>
<h3 id="时序">时序</h3>
<h4 id="11-提前重定向">1.1 提前重定向</h4>
<p>第一个周期：</p>
<ul>
<li>后端重定向写回时，首先会从后端到FTQ的IO接口（CtrltoFtqIO）中，看ftqIdx是不是有效信号，且此时后端正式重定向信号redirect无效(因为提前重定向会比正式重定向提前一拍，所以此时正式重定向无效)，这时，提前重定向信号aheadValid有效, 将使用提前获取的重定向ftqIdx，</li>
</ul>
<h4 id="12-真实提前重定向">1.2 真实提前重定向</h4>
<p>第二个周期：</p>
<ul>
<li>如果此时后端正式重定向信号有效了，且ftqIdxSelOH拉高，说明在正式重定向阶段成功对ftqIdxAhead信号进行选中，同时上一周期重定向信号aheadValid是有效的，则真实提前重定向信号realAhdValid拉高，在此时读取</li>
</ul>
<h4 id="13-存储后端重定向信号">1.3 存储后端重定向信号</h4>
<p>第三个周期：</p>
<ul>
<li>该周期会把来自后端的重定向信息的存储一份在寄存器backendRedirectReg中，具体的来说，当上一个周期后端重定向有效时，将后端重定向bits字段（存储实际内容）被写入寄存器的bits字段。</li>
<li>而实际决定信号是否有效的valid字段（决定该信号是否有效）则在上一周期真实提前重定向信号有效（表示确实使用了提前重定向的ftqIdx进行重定向）的情况下，被写入false，因为提前重定向发生时，我们直接使用当前的后端重定向信号交给FTQ就可以了。而不需要多保存一个周期。</li>
<li>真实提前重定向信号无效时，则由上一周期后端正式重定向的有效值决定，只有信号有效时，我们才需要把它存下来，之后交给FTQ。</li>
</ul>
<h3 id="2-选择重定向信号">2. 选择重定向信号</h3>
<p><strong>信号抉择</strong>：
是提前获取后端重定向信息还是延迟一个周期从寄存器内读取？
真实重定向有效时，直接将后端重定向信息传递给FTQ，否则，取重定向寄存器内的信号作为重定向信息传递给FTQ，相当于晚一个周期发送重定向信息。最后被选择的重定向信息作为<strong>后端重定向结果fromBackendRedirect</strong>发送给FTQ</p>
<p>接下来讲讲后端重定向在这三个周期到底通过ftqIdx到底读了哪些FTQ子队列中的信息，以及怎么使用它们。</p>
<h3 id="3-整合子队列信号">3. 整合子队列信号</h3>
<h4 id="31-读取子队列">3.1 读取子队列</h4>
<p>接下来讲讲后端重定向在这三个周期到底通过ftqIdx到底读了哪些FTQ子队列中的信息，以及怎么使用它们。</p>
<p><strong>后端重定向读取的子队列：</strong></p>
<ul>
<li>ftq_redirect_mem：FTQ会根据后端重定向提供的ftqIdx读出ftq_Redirect_SRAMEntry，借助它提供的信息重定向到之前的状态。</li>
<li>ftq_entry_mem：读出重定向指令块对应的FTB项</li>
<li>ftq_pd_mem：读出重定向指令块的预译码信息</li>
</ul>
<h4 id="311-发生提前重定向时读取子队列需要两个周期">3.1.1 发生提前重定向时，读取子队列需要两个周期</h4>
<h4 id="312-未发生提前重定向时读取子队列需要三个周期">3.1.2 未发生提前重定向时，读取子队列需要三个周期</h4>
<p><strong>读子队列时序：</strong>
第一个周期：</p>
<ul>
<li>提前重定向信号有效时，将子队列的读端口，读有效信号拉高，输入ftqIdxAhead的value字段作为读地址，发起读取请求。</li>
</ul>
<p>第二个周期：</p>
<ul>
<li>case1. 如果第一周期的提前重定向无效，而现在正式重定向有效，则在此时才拉高读有效信号，使用正式重定向接口的ftqIdx作为读取地址，发起读取请求。</li>
<li>case2. 真实提前重定向有效了，此时因为前一个周期已经发起读取请求，此时可以直接从子队列的读端口读出了</li>
</ul>
<p>第三个周期</p>
<ul>
<li>真实提前重定向无效，但至少前一个周期正式重定向发起的读取请求能保证在当前周期从子队列中读出。</li>
</ul>
<h4 id="32-将子队列信息整合到后端重定向信号">3.2 将子队列信息整合到后端重定向信号</h4>
<p><strong>处理读取信息</strong>
<em>FTQ会将从子队列中读出的信息整合到fromBackendRedirect中。</em>
具体来说：</p>
<ul>
<li>重定向redirect接口的CfiUpdateInfo接口直接接收ftq_Redirect_SRAMEntry中的同名信号。</li>
<li>利用fromBackendRedirect中指示的ftqOffset读取指令块预译码信息中实际跳转指令的预译码信息，该ftqOffset为后端执行过后确定的控制流指令在指令块内的偏移。
<ul>
<li>得到的预译码信息被直接连接到CfiUpdateInfo接口的pd接口中</li>
</ul>
</li>
<li>对于读出的指令块对应的FTB项，我们可以从中得知实际执行时得到的跳转指令，是否在FTB项被预测为跳转指令，或者是被预测为jmp指令，如果是，则cfiUpdateInfo的br_hit接口或者jr_hit接口被拉高，表示对应的分支预测结果正确了。
<ul>
<li>具体来说：通过发送ftqOffset，ftb项以brIsSaved的方式判断是否br_hit，判断是否jr_hit的方式也是类似的（r_ftb_entry.isJalr &amp;&amp; r_ftb_entry.tailSlot.offset === r_ftqOffset）。</li>
<li>在CfiUpdateInfo接口设置为br_hit的时候，还会根据这条发生跳转的分支指令是哪个槽从ftq_Redirect_SRAMEntry重定向接口的sc_disagree统计SC预测错误用的性能计数器中，获取对应值，最后整合到后端重定向接口中（如果没有br_hit，对应计数器的两个值都为0）。</li>
</ul>
</li>
</ul>
<h2 id="接口说明">接口说明</h2>
<table>
<thead>
<tr>
<th>顶层IO</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>fromBackend</td>
<td>接收后端重定向信息</td>
</tr>
</tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>测试点名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.1</td>
<td>RECERIVE_BACKEND_REDIRECT</td>
<td>REDIRECT_AHEAD</td>
<td>后端重定向写回时，首先会从后端到FTQ的IO接口（CtrltoFtqIO）中，看ftqIdx是不是有效信号，且此时后端正式重定向信号redirect无效，这时，提前重定向信号aheadValid有效</td>
</tr>
<tr>
<td>1.2</td>
<td>RECERIVE_BACKEND_REDIRECT</td>
<td>REAL_REDIRECT_AHEAD</td>
<td>如果此时后端正式重定向信号有效了，且ftqIdxSelOH拉高，同时上一周期重定向信号aheadValid是有效的，则真实提前重定向信号realAhdValid拉高</td>
</tr>
<tr>
<td>1.3</td>
<td>RECERIVE_BACKEND_REDIRECT</td>
<td>STORE_REDIRECT</td>
<td>后端真实重定向无效时写入寄存器</td>
</tr>
<tr>
<td>2</td>
<td>CHOOSE_AHEAD</td>
<td>CHOOSE_AHEAD</td>
<td>真实重定向有效时，直接将后端重定向信息传递给FTQ，否则，取重定向寄存器内的信号作为重定向信息传递给FTQ</td>
</tr>
<tr>
<td>3.1.1</td>
<td>READ_FTQ_SUBQUEUE</td>
<td>READ_AHEAD</td>
<td>发生提前重定向时，读取子队列需要两个周期</td>
</tr>
<tr>
<td>3.1.2</td>
<td>READ_FTQ_SUBQUEUE</td>
<td>READ_NO_AHEAD</td>
<td>未发生提前重定向时，读取子队列需要三个周期</td>
</tr>
<tr>
<td>3.2</td>
<td>ADD_SUBQUEUE_INFO</td>
<td>ADD_SUBQUEUE_INFO</td>
<td>将子队列信息整合到后端重定向信号</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a21c8d5c61630fe55cf5e4227e97c8f6">7 - FTQ接收IFU重定向</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>除了后端，IFU也会发送重定向相关消息，和后端不同，IFU的重定向信息来自于预译码写回信息。相同的是，它们都是通过BranchPredictionRedirect的接口传递重定向信息。</p>
<h2 id="术语说明">术语说明</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>RedirectLevel</td>
<td>重定向等级，重定向请求是否包括本位置，低表示在本位置后重定向，高表示在本位置重定向。它在之后决定了由重定向导致的冲刷信号是否会影响到发生重定向的指令</td>
</tr>
</tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-ifu重定向信号生成">1. IFU重定向信号生成</h3>
<h4 id="流程">流程</h4>
<p>IFU重定向是通过这个BranchPredictionRedirect接口传递的，下面来讲述IFU重定向怎么生成IFU的BranchPredictionRedirect内相应信号的，这个过程需要两个周期
信号列表：
<strong>第一个周期</strong></p>
<h4 id="11-ifu-重定向触发条件">1.1 IFU 重定向触发条件</h4>
<ul>
<li>valid：当预译码写回pdWb有效，且pdWb的missOffset字段有效表明存在预测错误的指令，同时后端冲刷信号backendFlush无效时，valid信号有效。</li>
</ul>
<h4 id="12-ifu生成重定向信号">1.2 IFU生成重定向信号</h4>
<ul>
<li>ftqIdx：接收pdWb指定的ftqIdx</li>
<li>ftqOffset：接收pdWb的missOffset的bits字段</li>
<li>level：RedirectLevel.flushAfter，将重定向等级设置为flushAfter</li>
<li>BTBMissBubble：true</li>
<li>debugIsMemVio：false</li>
<li>debugIsCtrl：false</li>
<li>cfiUpdate：
信号列表:
<ul>
<li>pc：pdWb中记录的指令块中所有指令pc中，missOffset对应的pc</li>
<li>pd：pdWb中记录的指令块中所有指令的pd中，missOffset对应的pd</li>
<li>predTaken：从cfiIndex_vec子队列中读取pdWb中ftqIdx索引的项是否valid，有效说明指令块内被预测为有控制流指令。</li>
<li>target：pdWb中的target</li>
<li>taken：pdWb中cfiOffset的valid字段，有效时表明预译码认为指令块中存在指令控制流指令</li>
<li>isMisPred：pdWb中missOffset的valid字段，有效时表明预译码认为指令块中存在预测错误的指令</li>
</ul>
</li>
</ul>
<p><strong>第二个周期：</strong>
该周期进行的信号生成是在第一周期valid字段有效的情况下才继续的</p>
<ul>
<li>cifUpdate：
信号列表：
<ul>
<li>重定向RAS相关信号：通过ftqIdx索引从 ftq_redirect_mem读出ftq_Redirect_SRAMEntry，把其中的所有信号直接传递给cfiUpdate的同名信号中。</li>
<li>target：已在第一周期写入cfiUpdate的pd有效，且isRet字段拉高，指明发生预测错误的指令本是一条Ret指令，此时，将target设置为cfiUpdate的topAddr，帮助回到发生错误之前的状态。</li>
</ul>
</li>
</ul>
<h3 id="2-重定向结果生效">2. 重定向结果生效</h3>
<p>两个周期生成完整的重定向信息后，IFU重定向信息才有效，有可能被FTQ采取，完整的<strong>IFU重定向结果记为ifuRedirectToBpu</strong></p>
<h3 id="3-ifu-冲刷信号-ifuflush">3. IFU 冲刷信号 (<code>ifuFlush</code>)</h3>
<p><strong>指令流控制信号</strong>：
ifuFlush：来自IFU的冲刷信号，主要是由IFU重定向造成的，生成IFU重定向信息的两个周期内，该信号都拉高</p>
<ul>
<li>标志：IFU重定向信息产生接口BranchPredictionRedirect中valid有效，表示开始生成重定向信息，该周期以及下一个周期，ifuFlush拉高</li>
</ul>
<h2 id="接口说明">接口说明</h2>
<table>
<thead>
<tr>
<th>顶层IO</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>fromIFU</td>
<td>接收来自IFU的预译码信息</td>
</tr>
</tbody>
</table>
<h2 id="接口时序">接口时序</h2>
<h2 id="测试点总表">测试点总表</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>测试点名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.1</td>
<td>IFU_REDIRECT</td>
<td>IFU_REDIRECT_GRN_VALID</td>
<td>当预译码写回pdWb有效，且pdWb的missOffset字段有效表明存在预测错误的指令，同时后端冲刷信号backendFlush无效时，valid信号有效</td>
</tr>
<tr>
<td>1.2</td>
<td>IFU_REDIRECT</td>
<td>IFU_REDIRECT_GEN</td>
<td>允许生成IFU重定向时，在两周期内生成具体信号</td>
</tr>
<tr>
<td>2</td>
<td>IFU_REDIRECT_TO_BPU</td>
<td>IFU_REDIRECT_TO_BPU</td>
<td>IFU重定向生成后，IFU重定向结果生效</td>
</tr>
<tr>
<td>3</td>
<td>IFU_FLUSH</td>
<td>IFU_FLUSH</td>
<td>生成IFU重定向信息的两个周期内，ifuFlush信号都拉高</td>
</tr>
</tbody>
</table>
</mrs-testpoints>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d5eaae05e615ad48e9d4009fee393d14">8 - FTQ向后端发送取指目标</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>pc取值目标会发给后端pc mem让他自己进行存储，之后从自己的pc mem取指，此外，最新的FTQ项和对应的跳转目标也会发给后端。</p>
<p>怎样算是一个最新的FTQ项，BPU最新发送的预测块可以是最新的FTQ项，其次，重定向发生时，需要回滚到发生错误预测之前的状态，从指定的FTQ项开始重新开始预测，预译码等等，这也可以是被更新的最新的FTQ项。</p>
<h2 id="术语说明">术语说明</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>暂无</td>
<td>暂无</td>
</tr>
</tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h4 id="流程">流程</h4>
<h4 id="1发送取值目标到pc-mem">1.发送取值目标到pc mem</h4>
<ul>
<li>发送时机：bpu_in_fire，即BPU向前端发送有效预测信息，或者重定向信息的时候。以此为基础之后的第二个周期，进行发送，通过将toBackend接口的pc_mem_wen设置为true的方式指明开始发送</li>
<li>接口信号列表：
<ul>
<li>pc_mem_wen：设置为true</li>
<li>pc_mem_waddr：接收bpu_in_fire那个周期BPU发送的ftqIdx</li>
<li>pc_mem_wdata：接收bpu_in_fire那个周期，FTQ读取的ftq_pc_mem中的取指目标</li>
</ul>
</li>
</ul>
<h4 id="2更新最新的ftq项">2.更新最新的FTQ项</h4>
<ul>
<li>发送时机：
<ul>
<li>最新的FTQ项可能是由BPU写入最新预测信息造成的，<strong>发送取值目标到pc mem</strong>也是因为BPU写入最新预测信息才写入的，如果是这种情况造成的，更新FTQ项和写入pc mem的时机是一致的。</li>
<li>此外发生重定向时，也会进行状态回滚更新FTQ项，标志是后端接口fromBackend的重定向redirect信号有效，或者写入BPU的接口toBPU的redirctFromIFU拉高说明当前有来自IFU的重定向
<ul>
<li><em>（注释（可忽略）IFU重定向信号生成有两个周期，可以认为第一个周期预译码信息中missoffset有效说明IFU重定向发生，也可以认为第二个周期redirctFromIFU拉高说明重定向发生，此处取后者）。</em></li>
</ul>
</li>
<li>同样是向toBackend中写入</li>
</ul>
</li>
<li>接口信号列表：
<ul>
<li>newest_entry_en：前面说的发送时机到来时，再延迟一个周期达到真正的写入时机，这时才拉高信号</li>
<li>newest_entry_ptr：发送时机到来时的newest_entry_ptr，在真正的写入时机写入</li>
<li>newest_entry_target：发送时机到来时的newest_entry_target
newest_entry_ptr，newest_entry_target这几个都是同名的内部信号，如之前所说，BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，在相应的文档中，对其生成方式做具体的描述。</li>
</ul>
</li>
</ul>
<h2 id="接口说明">接口说明</h2>
<table>
<thead>
<tr>
<th>顶层IO</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>toBackend</td>
<td>发送取指令目标，让后端进行储存</td>
</tr>
</tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>测试点名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SEND_PC_TO_BACKEND</td>
<td>SEND_PC</td>
<td>发送取值目标到pc mem</td>
</tr>
<tr>
<td>2</td>
<td>SEND_PC_TO_BACKEND</td>
<td>UPDATE_NEWEST</td>
<td>更新最新的FTQ项</td>
</tr>
</tbody>
</table>
</mrs-testpoints>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-060cd9108a272839369f1158228bfaa9">9 - 执行单元修改FTQ状态队列</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>后端的写回信息，包括重定向信息和更新信息，实际上都是执行之后，由实际执行单元根据结果发回的</p>
<h2 id="术语说明">术语说明</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>cfiIndex_vec</td>
<td>控制流指令索引队列，记录每个指令块中控制流指令的索引</td>
</tr>
<tr>
<td>update_target</td>
<td>更新目标队列，记录每个指令块的跳转目标</td>
</tr>
<tr>
<td>FTQ最新项</td>
<td>BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，表明我们当前关注的最新FTQ项。</td>
</tr>
</tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-由后端的写回信号修改ftq状态">1. 由后端的写回信号修改FTQ状态</h3>
<h4 id="11-修改ftq状态队列">1.1 修改FTQ状态队列</h4>
<p>从后端写回FTQ接口fromBackend中的redirect接口中，我们可以读出valid，ftqPtr，ftqOffset（后端实际执行时确认的控制流指令的偏移），taken，mispred字段，依靠它们来判断，如何修改FTQ的状态队列和相关的变量</p>
<p><strong>后端执行单元写回时被修改的队列</strong>：</p>
<h4 id="111-修改cfiindex_vec">1.1.1 修改cfiIndex_vec</h4>
<ul>
<li>cfiIndex_vec：
修改方式：执行写回修改队列中ftqPtr那一项
<ul>
<li>valid：fromBackend中的redirect接口中，valid有效，taken有效，且ftqOffset小于或者等于cfiIndex_vec中ftqPtr那一项指定的偏移：这说明重定向发生，实际执行结果判断ftqPtr索引的指令块确实会发生跳转，且实际执行跳转的指令在被预测为发生跳转的指令之前或等于它。所以这时指令块是会发生跳转的，控制流索引队列的ftqPtr项valid</li>
<li>bits：fromBackend中的redirect接口中，valid有效，taken有效，且ftqOffset小于cfiIndex_vec中ftqPtr那一项指定的偏移，偏移量被更新为更小值ftqOffset。</li>
</ul>
</li>
</ul>
<h4 id="112-修改update_target">1.1.2 修改update_target</h4>
<ul>
<li>update_target：
<ul>
<li>ftqPtr索引项的跳转目标修改为fromBackend的redirect接口中的cifUpdate中指定的target</li>
</ul>
</li>
</ul>
<h4 id="113-修改mispredict_vec">1.1.3 修改mispredict_vec</h4>
<ul>
<li>mispredict_vec：
<ul>
<li>如果该重定向指令是来自后端的重定向指令， ftqPtr索引项的ftqOffset偏移指令被设置为fromBackend的redirect接口中的cifUpdate中指定的isMisPred</li>
</ul>
</li>
</ul>
<h4 id="12-修改ftq最新项">1.2 修改FTQ最新项</h4>
<ul>
<li>newest_entry_target：
<ul>
<li>被修改为重定向接口中cfiUpdate指定的target</li>
<li>辅助信号newest_entry_target_modified被指定为true</li>
</ul>
</li>
<li>newest_entry_ptr：
<ul>
<li>修改为重定向接口指定的ftqIdx</li>
<li>辅助信号newest_entry_ptr_modified被指定为true</li>
</ul>
</li>
</ul>
<h3 id="2-由ifu的写回信号修改ftq状态">2. 由IFU的写回信号修改FTQ状态</h3>
<p>IFU既然也能和后端一样生成重定向信息，那么他也能在产生重定向信息的时候修改这些状态队列和FTQ最新项，区别：</p>
<ul>
<li>但是，由于IFU没有真的执行，所以它的预译码结果并不能作为决定指令块是不是真的被错误预测了，所以它不能修改mispredict_vec的状态</li>
<li>其次，后端重定向优先级永远高于IFU重定向，两者同时发生时只采用后端重定向。</li>
</ul>
<p>所以这个部分也有以下测试点：</p>
<h4 id="211-修改cfiindex_vec">2.1.1 修改cfiIndex_vec</h4>
<h4 id="212-修改update_target">2.1.2 修改update_target</h4>
<h4 id="22-修改ftq最新项">2.2 修改FTQ最新项</h4>
<h2 id="常量说明">常量说明</h2>
<table>
<thead>
<tr>
<th>常量名</th>
<th>常量值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>常量1</td>
<td>64</td>
<td>常量1解释</td>
</tr>
<tr>
<td>常量2</td>
<td>8</td>
<td>常量2解释</td>
</tr>
<tr>
<td>常量3</td>
<td>16</td>
<td>常量3解释</td>
</tr>
</tbody>
</table>
<h2 id="接口说明">接口说明</h2>
<table>
<thead>
<tr>
<th>顶层IO</th>
<th>子接口</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>fromBackend</td>
<td>redirect</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<p>实际使用下面的表格时，请用有意义的英文大写的功能名称和测试点名称替换下面表格中的名称</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>测试点名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.1.1</td>
<td>BACKEDN_REDIRECT_UPDATE_STATE</td>
<td>UPDATE_CFIINDEXVEC</td>
<td>后端重定向修改cfiinedex状态队列</td>
</tr>
<tr>
<td>1.1.2</td>
<td>BACKEDN_REDIRECT_UPDATE_STATE</td>
<td>UPDATE_UPDATE_TARGET</td>
<td>后端重定向修改update_target状态队列</td>
</tr>
<tr>
<td>1.1.3</td>
<td>BACKEDN_REDIRECT_UPDATE_STATE</td>
<td>UPDATE_MISPREDICTVEC</td>
<td>后端重定向修改mispredict状态队列</td>
</tr>
<tr>
<td>1.2</td>
<td>BACKEDN_REDIRECT_UPDATE_NEWEST</td>
<td>BACKEDN_REDIRECT_UPDATE_NEWEST</td>
<td>后端重定向修改FTQ最新项</td>
</tr>
<tr>
<td>2.1.1</td>
<td>IFU_REDIRECT_UPDATE_STATE</td>
<td>UPDATE_CFIINDEXVEC</td>
<td>IFU重定向修改cfiinedex状态队列</td>
</tr>
<tr>
<td>2.1.2</td>
<td>IFU_REDIRECT_UPDATE_STATE</td>
<td>UPDATE_UPDATE_TARGET</td>
<td>IFU重定向修改update_target状态队列</td>
</tr>
<tr>
<td>2.2</td>
<td>IFU_REDIRECT_UPDATE_NEWEST</td>
<td>IFU_REDIRECT_UPDATE_NEWEST</td>
<td>IFU重定向修改FTQ最新项</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-63ebff3aa1d2952064b973785cdcbf35">10 - 冲刷指针和状态队列</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>之前讲了，后端和IFU重定向写回会修改一些状态队列。此外，FtqPtr也是一种比较重要的维护信息。由后端或者IFU引起的重定向，需要恢复各种类型用来索引FTQ项的FtqPtr。而当重定向是由后端发起的时候，还要修改提交状态队列，说明指令已经被执行。</p>
<h2 id="术语说明">术语说明</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>FTQ指针</td>
<td>用来索引FTQ项，有不同类型的FTQ指针，比如bpuPtr，ifuPtr</td>
</tr>
<tr>
<td>flush</td>
<td>冲刷，发生时需要重置FTQ指针，以及重置其他状态</td>
</tr>
<tr>
<td>融合指令</td>
<td>一条指令可以和其他指令融合，形成融合指令</td>
</tr>
</tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-冲刷ftq指针及提交状态队列">1. 冲刷FTQ指针及提交状态队列</h3>
<h4 id="流程">流程</h4>
<p>后端和IFU的重定向信号都会冲刷指针，更具体的来说：</p>
<h4 id="11-冲刷条件">1.1 冲刷条件</h4>
<ul>
<li>后端写回接口fromBackend有效，或者IFU重定向有效：（当预译码写回pdWb有效，且pdWb的missOffset字段有效表明存在预测错误的指令，同时后端冲刷信号backendFlush无效）。（参考：从IFU重定向的第一个周期，重定向valid值有效条件）</li>
</ul>
<h4 id="12-冲刷指针">1.2 冲刷指针</h4>
<p>第一个周期：</p>
<ul>
<li>冲刷指针：确认后端和IFU的重定向信号可能冲刷指针时，从两个重定向来源的redirect接口读出重定向信息，包括ftqIdx，ftqOffset，重定向等级RedirectLevel。有两个来源时，优先后端的重定向信息。
冲刷指针列表：
<ul>
<li>bpuPtr：ftqIdx+1</li>
<li>ifuPtr：ftqIdx+1</li>
<li>ifuWbPtr：ftqIdx+1</li>
<li>pfPtr：ftqIdx+1
<em>注：只是在当前周期向指针寄存器写入更新信息，实际生效是在下一个周期。</em>
这样一来，所有类型指针当前指向的都是发生重定向的指令块的下一项了，我们从这一项开始重新进行分支预测，预译码，等等。</li>
</ul>
</li>
</ul>
<h4 id="13-冲刷提交状态队列">1.3 冲刷提交状态队列</h4>
<p>第二个周期：
如果上一个周期的重定向来源是后端，FTQ会进一步更改提交状态队列</p>
<ul>
<li>提交状态队列中，对于重定向的指令块（通过ftqIdx索引），位于ftqOffset后面的指令的状态被设置为c_empty</li>
<li>对于正好处于ftqOffset的指令，判断RedirectLevel，低表示在本位置后flush，高表示在本位置flush，所以level为高时，对于的指令提交状态被设置为flush。</li>
</ul>
<h3 id="2-转发到顶层io">2 转发到顶层IO</h3>
<p>实际上，在发生重定向的时候，还涉及一些将重定向信息通过FTQ顶层IO接口转发给其他模块的操作，比如ICache需要flush信号取进行冲刷，IFU也需要后端的重定向信号对它进行重定向，具体来说：
在<strong>流程</strong>的第一个周期：</p>
<h4 id="21-flush转发到icacheflush">2.1 flush转发到icacheFlush</h4>
<ul>
<li>flush信号顶层IO转发（icacheFlush）：
<ul>
<li>确认后端和IFU的重定向信号可能冲刷指针时，拉高FTQ顶层IO接口中的icacheFlush信号，把重定向产生的flush信号转发给ICache</li>
</ul>
</li>
</ul>
<h4 id="22-重定向信号转发到ifu">2.2 重定向信号转发到IFU</h4>
<ul>
<li>重定向信号顶层IO转发（toIFU）：
<ul>
<li>redirect：
<ul>
<li>bits：接收来自后端的重定向信号</li>
<li>valid：后端的重定向信号有效时有效，保持有效，直到下个周期依然有效</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-重排序缓冲区提交">3 重排序缓冲区提交</h3>
<p>其实，除了后端重定向会更新提交状态队列，最直接的更新提交状态队列的方式是通过FTQ顶层IO中frombackend里提供的提交信息，rob_commits告知我们哪些指令需要被提交。</p>
<p>rob_commits的valid字段有效，可以根据其中信息对指令进行提交，修改状态队列。对于被执行的指令，是如何提交的，如何对应地修改提交状态队列，有两种情况：</p>
<h4 id="31-提交普通指令">3.1 提交普通指令</h4>
<ul>
<li>对于普通指令，根据rob_commits的ftqIdx和ftqOffset索引提交状态队列中的某条指令，将对应的提交状态设置为c_commited</li>
</ul>
<h3 id="32-提交融合指令">3.2 提交融合指令</h3>
<ul>
<li>对于融合指令，根据提交类型commitType对被索引的指令和另一与之融合的指令进行提交，将对应的提交状态设置为c_commited
<ol>
<li>commitType = 4：同时把被索引指令的下一条指令设为c_commited</li>
<li>commitType = 5：同时把被索引指令的之后的第二条指令设为c_commited</li>
<li>commitType = 6：同时把被指令块的下一个指令块的第0条指令设为c_commited</li>
<li>commitType = 7：同时把被指令块的下一个指令块的第1条指令设为c_commited</li>
</ol>
</li>
</ul>
<h2 id="接口说明">接口说明</h2>
<table>
<thead>
<tr>
<th>顶层IO</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>fromBackend</td>
<td>接收后端重定向和指令提交</td>
</tr>
<tr>
<td>fromIfu</td>
<td>接收IFU重定向</td>
</tr>
<tr>
<td>icacheFlush</td>
<td>将flush信号转发到icache</td>
</tr>
<tr>
<td>toIFU</td>
<td>将后端重定向转发到IFU</td>
</tr>
</tbody>
</table>
<h2 id="测试点总表">测试点总表</h2>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>测试点名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.1</td>
<td>FLUSH_FTQPTR_AND_COMMITSTATE</td>
<td>FLUSH_COND</td>
<td>后端写回接口fromBackend有效，或者IFU重定向有效时，进行冲刷</td>
</tr>
<tr>
<td>1.2</td>
<td>FLUSH_FTQPTR_AND_COMMITSTATE</td>
<td>FLUSH_FTQ_PTR</td>
<td>优先采用后端重定向信息冲刷FTQ指针</td>
</tr>
<tr>
<td>1.3</td>
<td>FLUSH_FTQPTR_AND_COMMITSTATE</td>
<td>FLUSH_COMMIT_STATE</td>
<td>发生后端重定向时，进一步修改提交状态队列</td>
</tr>
<tr>
<td>2.1</td>
<td>TRANSFER_TO_TOP</td>
<td>FLUSH</td>
<td>后端和IFU的重定向信号可能冲刷指针，拉高FTQ顶层IO接口中的icacheFlush信号</td>
</tr>
<tr>
<td>2.2</td>
<td>TRANSFER_TO_TOP</td>
<td>IFU</td>
<td>将重定向信号转发到IFU</td>
</tr>
<tr>
<td>3.1</td>
<td>COMMIT_BY_ROB</td>
<td>NORMAL</td>
<td>对于普通指令，根据rob_commits的ftqIdx和ftqOffset索引提交状态队列中的某条指令，将对应的提交状态设置为c_commited</td>
</tr>
<tr>
<td>3.2</td>
<td>COMMIT_BY_ROB</td>
<td>FUSION</td>
<td>对于融合指令，根据提交类型commitType对被索引的指令和另一与之融合的指令进行提交，将对应的提交状态设置为c_commited</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5a73ff17101ad6634015b300133e5fb2">11 - FTQ向BPU发送更新与重定向信息</h1>
    
	<h2 id="文档概述">文档概述</h2>
<p>FTQ将已提交指令的更新信息发往BPU进行训练，同时转发重定向信息。</p>
<h2 id="术语说明">术语说明</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>暂无</td>
<td>暂无</td>
</tr>
</tbody>
</table>
<h2 id="模块功能说明">模块功能说明</h2>
<h3 id="1-转发重定向">1. 转发重定向</h3>
<p>向toBPU接口进行转发：</p>
<h4 id="11-ifu重定向结果有效">1.1 IFU重定向结果有效</h4>
<ul>
<li>redirctFromIFU：IFU重定向结果有效时，拉高该信号（注意：IFU重定向有效的时机有两种说法，因为IFU重定向结果生成需要两个周期，此处取后者，即，IFU重定向生成过程的第二个周期有效，也是IFU生成完整重定向结果的周期）</li>
</ul>
<h4 id="12-选择后端重定向或者ifu重定向">1.2 选择后端重定向或者IFU重定向</h4>
<ul>
<li>redirect：如果后端重定向结果fromBackendRedirect有效，选用fromBackendRedirect，否则选用IFU重定向结果ifuRedirectToBpu</li>
</ul>
<h3 id="2-bpu更新暂停">2 BPU更新暂停</h3>
<p>BPU的更新需要两个周期，故需要三种状态去表明我们当前的更新状态：更新的第一个周期，第二个周期，更新完成。
当发生更新的时候，会暂停FTQ对指令块的提交以及发送更新信息。</p>
<h3 id="3-提交指令块">3 提交指令块</h3>
<p>FTQ需要对当前comPtr指向的当前提交指令块，进行判断是否能够提交。
这个过程比较复杂。
由于 香山V2版本 的后端会在 ROB 中重新压缩 FTQ entry，因此并不能保证提交一个 entry 中的每条指令，甚至不能保证每一个 entry 都有指令提交。</p>
<p><strong>判断一个 entry 是否被提交有如下几种可能</strong>：</p>
<ul>
<li>robCommPtr 在 commPtr 之后（ptr更大）。也就是说，后端已经开始提交之后 entry 的指令，在 robCommPtr 指向的 entry 之前的 entry 一定都已经提交完成</li>
<li>commitStateQueue 中的某个指令块内最后一条有效范围内指令被提交。FTQ项中该指令被提交意味着这FTQ项内的指令已经全部被提交</li>
</ul>
<p>在此以外，还必须要考虑到，后端存在 flush itself 的 redirect 请求，这意味着这条指令自身也需要重新执行，这包括异常、load replay 等情况。在这种情况下，这一FTQ项不应当被提交以更新 BPU，否则会导致 BPU 准确率显著下降。</p>
<h4 id="31-cancommit">3.1 canCommit</h4>
<p>具体来看，判断commPtr指向的指令块能否提交，如果可以提交记为canCommit。</p>
<p>canCommit的设置条件如下：</p>
<h4 id="311-cond1">3.1.1 COND1</h4>
<ul>
<li>当commPtr不等于ifuWbPtr，且没有因为BPU更新而暂停，同时robCommPtr在commPtr之后。之所以要求commPtr不等于ifuWbPtr是因为，前面说过了必须先预译码写回FTQ项才能提交</li>
</ul>
<h4 id="312-cond2">3.1.2 COND2</h4>
<ul>
<li>commitStateQueue 中commPtr对应指令块有指令处于c_toCommit 或c_committed状态。且指令块中最后一条处于c_toCommit 或c_committed状态的指令是c_committed的。</li>
</ul>
<p>这两种情况下，canCommit拉高，说明可以提交该指令块</p>
<h3 id="32-canmovecommptr">3.2 canMoveCommPtr</h3>
<h4 id="321-提交指令块更新提交指针">3.2.1 提交指令块更新提交指针</h4>
<p>在commPtr指向的指令块如果能提交，那么我们自然可以移动CommPtr指向下一个FTQ项了。</p>
<h4 id="322-指令冲刷更新提交指针">3.2.2 指令冲刷更新提交指针</h4>
<p>但除此之外，commitStateQueue 中commPtr对应指令块的第一条指令被后端重定向冲刷掉了时，这表明该指令需要重新执行，这一FTQ项不应被提交，但是却可以更新CommPtr指针，因为该指令块内已经没有可以提交的指令了。</p>
<ul>
<li>CanMoveCommPtr时，commPtr指针更新加1（一周期后成功写入）。</li>
</ul>
<h3 id="33-robcommptr更新">3.3 robCommPtr更新</h3>
<p>有几种情况</p>
<h4 id="331-cond1">3.3.1 COND1</h4>
<ul>
<li>当来自后端接口fromBackend的rob_commits信息中，有信息有效时，取最后一条有效交割信息的ftqIdx作为robCommPtr</li>
</ul>
<h4 id="332-cond2">3.3.2 COND2</h4>
<ul>
<li>不满足情况1，选取commPtr, robCommPtr中较大的那个</li>
</ul>
<h3 id="34-mmio提交">3.4 mmio提交</h3>
<p>发往mmioCommitRead接口</p>
<ul>
<li>mmioLastCommit：</li>
</ul>
<h4 id="341-cond1">3.4.1 COND1</h4>
<ul>
<li>当commPtr比来自mmioCommitRead接口的mmioFtqPtr大时，</li>
</ul>
<h4 id="342-cond2">3.4.2 COND2</h4>
<ul>
<li>或者两者正好相等，且commPtr指向的指令块中有c_toCommit 或c_committed状态的指令，最后一条处于c_toCommit 或c_committed状态的指令是c_committed的</li>
</ul>
<p>在这两种情况下，mmioLastCommit信号在下一个周期被拉高</p>
<h3 id="4-发送bpu更新信息">4 发送BPU更新信息</h3>
<p>FTQ需要从FTQ子队列中，读取提交项的预测信息，重定向信息，meta信息，用这些信息来对BPU发送更新信息。</p>
<p>当canCommit时，可以提交commPtr指向的指令块时，从ftq_pd_mem，ftq_redirect_mem,ftq_meta_1r_sram_mem这些子队列，以及一些小的状态队列中读出对应指令块的相应信息，这些信息需要专门花一个周期才能读取到。具体来说：</p>
<ul>
<li>从预译码信息子队列ftq_pd_mem中读取提交提交指令块（commptr所指）的预译码信息</li>
<li>从取指目标子队列ftq_pc_mem中读取取指信息</li>
<li>从分支预测重定向信息子队列ftq_redirect_mem中读取提交指令块的重定向信息。</li>
<li>从预测阶段状态队列中读取提交块来自BPU的哪个预测阶段</li>
<li>从meta信息子队列ftq_meta_1r_sram中读取提交指令块的meta，和相应的ftb_entry。</li>
<li>从提交状态队列commitStateQueueReg中读取提交状态，并确认指令块中哪些指令为c_committed,用bool数组表示</li>
<li>从控制流索引状态队列cfiIndex_vec中读取指令控制流指令在块中索引</li>
<li>结合错误预测状态队列mispredict_vec，和提交状态队列信息确认指令块中的提交错误指令。(即提交状态指示为c_commited 同时错误预测指示为预测错误)</li>
<li>从表项命中状态队列entry_hit_status中读取提交指令块是否命中</li>
</ul>
<p>根据相关信息进行判断：</p>
<ul>
<li>获取提交块的目标，如果commPtr等于newest_entry_ptr，则取newest_entry_target_modified拉高时记录下的newest_entry_target，否则取ftq_pc_mem.io.commPtrPlus1_rdata.startAddr，获取到的提交块目标将会被用来辅助新FTB项的生成</li>
</ul>
<h4 id="41-将子队列读取信息发向更新通道">4.1 将子队列读取信息发向更新通道</h4>
<p>整合完上述信息后，FTQ会向toBpu的update接口发送更新请求，具体如下：</p>
<ul>
<li>valid：canCommit 且 指令块满足命中或者存在cfi指令，valid接口有效，表明可以发送更新请求</li>
<li>bits：
<ul>
<li>false_hit：提交块命中状态指示为h_false_hit时，该信号拉高</li>
<li>pc：提交块的取指信息中的startAddr</li>
<li>meta：提交块的meta</li>
<li>cfi_idx：提交块中cfi指令的index</li>
<li>full_target：提交块的目标</li>
<li>from_stage：提交块来自哪个预测阶段</li>
<li>spec_info：提交块的meta</li>
<li>pred_hit：提交块的命中状态为hit或者false_hit</li>
</ul>
</li>
</ul>
<p>另外，被更新的FTB表项也会<strong>同时</strong>被转发到更新接口，但是新的FTB表项生成方式相对复杂，下一节专门展开叙述</p>
<h4 id="42-修正ftb项">4.2 修正FTB项</h4>
<p>更新结果会基于旧的FTB项进行更新，然后直接转发给更新接口。你可能需要先阅读<a href="https://open-verify.cc/xs-bpu/docs/ports/00_ftb/">FTB项相关文档</a>了解FTB项的结构和相关信号生成方式</p>
<p>commit表项的相关信息会被发送给一个名为FTBEntryGen的接口，经过一系列组合电路处理，输出更新后的FTB表项信息。</p>
<p>为了更新FTB项，提交项如下信息会被读取：</p>
<ul>
<li>取值目标中的起始地址 startAddr</li>
<li>meta中旧FTB项 old_entry</li>
<li>包含FTQ项内32Byte内所有分支指令的预译码信息 pd</li>
<li>此FTQ项内有效指令的真实跳转结果 cfiIndex，包括是否跳转，以及跳转指令相对startAddr的偏移</li>
<li>此FTQ项内分支指令（如跳转）的跳转地址（执行结果）</li>
<li>预测时FTB是否真正命中（旧FTB项是否有效）</li>
<li>对应FTQ项内所有可能指令的误预测 mask</li>
</ul>
<p>接下来介绍如何通过这些信息更新FTB。
FTB项生成逻辑：</p>
<h5 id="421-情况1ftb未命中则创建一个新的ftb项">4.2.1 <strong>情况1：FTB未命中，则创建一个新的FTB项</strong></h5>
<p><em>我们会根据预译码信息进行判断，预译码会告诉我们，指令块中cfi指令是否是br指令，jmp指令信息（以及是哪种类型的jmp指令）</em></p>
<ol>
<li>无条件跳转指令处理：
<ul>
<li>不论是否被执行，都一定会被写入新FTB项的tailSlot</li>
<li>如果最终FTQ项内跳转的指令是条件分支指令，写入新FTB项的第一个brSlot（目前也只有这一个），对应的strongbias被设置为1作为初始化</li>
</ul>
</li>
<li>pftAddr设置：
<ul>
<li>存在无条件跳转指令时：以无条件跳转指令的结束地址设置</li>
<li>无无条件跳转指令时：以startAddr+取指宽度（32B）设置</li>
<li>特殊情况：当4Byte宽度的无条件跳转指令起始地址位于startAddr+30时，虽然结束地址超出取指宽度范围，仍按startAddr+32设置</li>
</ul>
</li>
<li>carry位根据pftAddr的条件同时设置</li>
<li>设置分支类型标志：
<ul>
<li>isJalr、isCall、isRet按照无条件跳转指令的类型设置</li>
<li>特殊标志：当且仅当4Byte宽度的无条件跳转指令起始地址位于startAddr+30时，置last_may_be_rvi_call位</li>
</ul>
</li>
</ol>
<p><em>详细信号说明</em>：</p>
<ul>
<li>
<p>cfiIndex有效（说明指令块存在跳转指令），且pd的brmask指明该指令是br指令。则判断控制流指令是br指令</p>
</li>
<li>
<p>pd的jmpinfo有效，且cifIndx有效。则进一步根据jmpinfo判断是那种类型的jmp指令</p>
<ol>
<li>第零位为0：jal</li>
<li>第零位为1：jalr</li>
<li>第一位为1：call</li>
<li>第二位为1：ret</li>
</ol>
</li>
<li>
<p>判断最后一条指令是否是rvi（4byte）的jmp指令：jmpinfo有效，pd中jmpOffset等于15，且pd的rvcMask指明最后一条指令不是rvc指令</p>
</li>
<li>
<p>判断cfi指令是否是jal指令：cfiindx = jmpOffset，且根据之前的判断确认jmp指令是jal指令</p>
</li>
<li>
<p>判断cfi指令是jalr指令也是同理的。</p>
</li>
<li>
<p>FTB生成：valid被初始化为true</p>
<ul>
<li>brslot：在判断控制流指令是br指令时，进行填充
<ul>
<li>valid：初始化为true</li>
<li>offset：cfiindx</li>
<li>lower和stat：根据startaddr和提交块指定的target计算</li>
<li>对应的strongbias：被初始化为true</li>
</ul>
</li>
<li>tailslot：pd的jmpinfo有效时，进行填充
<ul>
<li>valid：根据之前的判断确认jmp指令是jal指令或者是jalr指令时，valid有效</li>
<li>offset：pd的jmpoffset</li>
<li>lower和stat：根据startaddr和target计算，如果cfi指令是jalr指令，使用提交块指定的target，否则用pd预测的jalTarget</li>
<li>对应的strongbias：根据之前的判断确认jmp指令是jalr指令时，拉高。strongbias是针对于BPU的ittage预测器的，该预测器基于一些统计信息工作，strongbias用来指向指令跳转偏好的强弱，其中jal指令不需要记录strongbias。</li>
</ul>
</li>
<li>pftAddr：上方介绍已经够详细了</li>
<li>carry：上方介绍已经足够</li>
<li>isJalr/isCall/isRet</li>
<li>last_may_be_rvi_call</li>
</ul>
</li>
</ul>
<h4 id="422-情况2ftb命中修改旧的ftb项">4.2.2 情况2：FTB命中，修改旧的FTB项</h4>
<h5 id="4221-插入brslot的ftb项">4.2.2.1 插入brslot的FTB项</h5>
<p><em>在原来的基础上改动即可，比如插入新的slot，注意，只针对新的brslot</em></p>
<ol>
<li><strong>修改条件</strong>：首先根据oldftbentry判断在旧entry中，cfi指令是否被记录为br指令，如果不是，<strong>则说明这是一个新的br指令</strong>。</li>
<li>接着从旧FTB中判断哪些slot可以被插入slot：
<ul>
<li>brslot：如果旧FTB的brslot无效，表示该slot空闲，此时可以在此位置插入新的brslot，此外，如果新slot在旧slot之前（新的br指令在旧slotbr指令之前执行，或者说在指令块之前的位置），即使不空也能插入</li>
<li>tailslot：当不能在brslot插入时，才考虑tailslot，同样，在该slot空闲或者新slot在旧slot之前，可以插入此位置</li>
</ul>
</li>
<li>插入slot：
<ol>
<li>brslot：能插入时则在这里插入，不能的时候，把对应的strongbias拉低，因为这说明新slot一定在旧slot之后（如果不想要详细了解ittage的原理可以不用理解原因）。</li>
<li>tailslot：能插入时则在这里插入，不能的时候，如果新slot在旧slot之后，把对应的strongbias拉低，如果不在之后，当原brslot有效（即不空闲），则用插入前的brslot代替该tailslot。对应的strongbias维持不变。</li>
</ol>
</li>
</ol>
<p><em>注：tailslot不能插入且新slot在其之前，其实就已经说明brslot一定是可以插入的，所以才有后面的替代</em></p>
<p><em><strong>pftaddr</strong></em>
出现新的br指令，同时旧的FTB项内没有空闲的slot，这说明确实发生了在FTB项内确实发生了FTB项的替换，pftaddr也需要做相应的调整。</p>
<ul>
<li>如果没有能插入的位置，使用新的br指令的偏移作为pftaddr对应的偏移，因为此时，新br指令一定在两个slot之后。否则，使用旧FTB项的最后一个slot的offset。将ptfoffset结合startAddr得到最后的pftAddr，carry也进行相应的设置。</li>
<li>last_may_be_rvi_call，isCall，isRet ，isJalr全部置false。</li>
</ul>
<h5 id="4222-修改jmp-target的ftb项">4.2.2.2 修改jmp target的FTB项</h5>
<p><strong>修改条件</strong>：<strong>当cfi指令是一个jalr指令</strong>，且旧的tailslot对应的是一个jump的指令，但tailslot指示的target与提交项指示的target不同时，说明需要对跳转目标进行修改。</p>
<ul>
<li>根据正确的跳转目标对lower和stat进行修改</li>
<li>两位strongbias设置成0</li>
</ul>
<h5 id="4223-修改bias的ftb项">4.2.2.3 修改bias的FTB项</h5>
<p><strong>当cfi指令就是原FTB项的条件跳转指令</strong>，只需要根据跳转情况设置跳转的强弱</p>
<ul>
<li>brslot：旧的brslot有发生跳转时，bias在原bias拉高，发生跳转的cfiindex等于该slot的offset，brslot有效时，保持拉高，其余情况拉低。</li>
<li>tailslot：旧的brslot没有跳转，而tailslot有分支指令且发生跳转，把brslot的bias置为false，tailslot保持bias的方式与上面的brslot一致。</li>
</ul>
<p><strong>修改条件</strong>：当旧的bias拉高且对应的旧的FTB项中的slot中有分支指令，同时修改后的bias拉低。任何一个slot出现这种情况都需要进行修改。</p>
<p>最后，需要抉择出一个修改的FTB项</p>
<ul>
<li>如果cfi是一个新的分支指令，我们采用插入新的slot的FTB项。</li>
<li>如果是cfi是一个jalr指令，且跳转目标发生修改，我们采用修改jmp跳转目标的FTB项</li>
<li>如cfi指令就是原FTB项的条件跳转指令，采用修改bias的FTB项</li>
</ul>
<h4 id="43-发送新ftb项及相关信号">4.3 发送新FTB项及相关信号</h4>
<p>此时，根据是否hit，我们已经得到更新后的FTB项了，在这个基础上我们继续更新一些相关信号以发送到FTQ更新接口。</p>
<ul>
<li>new_br_insert_pos：使用之前我们判断的FTB项中可插入位置的bool数组</li>
<li>taken_mask：根据cfi指令在更新后FTB项的位置判断，只有分支指令才做此计算，若是jmp指令置为0。</li>
<li>jump_taken: cfi指令在更新后FTB项的taislot，且jmpValid。</li>
<li>mispred_mask的最后一项：更新后的FTB项jumpValid，且预译码推断的jmp指令在提交项的错误预测信息中指示错误。
<ul>
<li><strong>mispred_mask</strong> 预测块内预测错误的掩码。第一、二位分别代表两个条件分支指令是否预测错误，第三位指示无条件跳转指令是否预测错误。
<ul>
<li>接口类型：<code>Vec(numBr+1, Bool())</code></li>
</ul>
</li>
</ul>
</li>
<li>old_entry：如果hit，且FTB项不做任何修改，即不满足上述三种修改FTB项的条件，拉高该信号，说明更新后的FTB项是旧的FTB项。</li>
</ul>
<h5 id="发送处理后的更新信息">发送处理后的更新信息</h5>
<p>此时，我们就可以向BPU发送处理好的更新信息了，下面是update的接口接收的信号</p>
<ul>
<li>ftb_entry：更新后的FTB项</li>
<li>new_br_insert_pos：上一小节已述</li>
<li>mispred_mask：上一小节已述</li>
<li>old_entry：上一小节已述</li>
<li>br_taken_mask: 上一小节已述</li>
<li>br_committed：根据提交项的提交状态信息判断新FTB项中的有效分支指令是否已经提交</li>
<li>jmp_taken：上一小节已述</li>
</ul>
<h2 id="接口说明">接口说明</h2>
<table>
<thead>
<tr>
<th>顶层IO</th>
<th></th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>toBpu</td>
<td></td>
<td>向BPU发送重定向信息与更新信息</td>
</tr>
<tr>
<td>fromBackend</td>
<td></td>
<td>获取指令交割信息，判断指令块是否被提交</td>
</tr>
<tr>
<td>mmioCommiRead</td>
<td></td>
<td>发送mmio指令的提交信息</td>
</tr>
</tbody>
</table>
<h2 id="测试点总表-必填项针对细分的测试点列出表格">测试点总表 (【必填项】针对细分的测试点，列出表格)</h2>
<p>实际使用下面的表格时，请用有意义的英文大写的功能名称和测试点名称替换下面表格中的名称</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>功能名称</th>
<th>测试点名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.1</td>
<td>TRANSFER_REDIRECT</td>
<td>REDIRECT_FROM_FLUSH</td>
<td>IFU重定向结果有效时，拉高该信号</td>
</tr>
<tr>
<td>1.2</td>
<td>TRANSFER_REDIRECT</td>
<td>CHOOSE_REDIRECT</td>
<td>如果后端重定向结果fromBackendRedirect有效，选用fromBackendRedirect，否则选用IFU重定向结果ifuRedirectToBpu</td>
</tr>
<tr>
<td>2</td>
<td>UPDATE_STALL</td>
<td>UPDATE_STALL</td>
<td>当发生BPU的更新时候，会暂停FTQ对指令块的提交以及发送更新信息</td>
</tr>
<tr>
<td>3.1.1</td>
<td>CAN_COMMIT_ENTRY</td>
<td>COND1</td>
<td>当commPtr不等于ifuWbPtr，且没有因为BPU更新而暂停，同时robCommPtr在commPtr之后,canCommit拉高</td>
</tr>
<tr>
<td>3.1.2</td>
<td>CAN_COMMIT_ENTRY</td>
<td>COND2</td>
<td>commitStateQueue 中commPtr对应指令块有指令处于c_toCommit 或c_committed状态。且指令块中最后一条处于c_toCommit 或c_committed状态的指令是c_committed的,canCommit拉高</td>
</tr>
<tr>
<td>3.2.1</td>
<td>MOVECOMMPTR</td>
<td>BY_ROB_COMMIT</td>
<td>在commPtr指向的指令块如果能提交,可以移动CommPtr</td>
</tr>
<tr>
<td>3.2.2</td>
<td>MOVECOMMPTR</td>
<td>BY_FLUSH</td>
<td>commitStateQueue 中commPtr对应指令块的第一条指令被后端重定向冲刷掉,可以移动CommPtr</td>
</tr>
<tr>
<td>3.3.1</td>
<td>UPDATE_ROB_COMM_PTR</td>
<td>COND1</td>
<td>当来自后端接口fromBackend的rob_commits信息中，有信息有效时，取最后一条有效交割信息的ftqIdx作为robCommPtr</td>
</tr>
<tr>
<td>3.3.2</td>
<td>UPDATE_ROB_COMM_PTR</td>
<td>COND2</td>
<td>不满足情况1，选取commPtr, robCommPtr中较大的那个</td>
</tr>
<tr>
<td>3.4.1</td>
<td>MMIO_LAST_COMMIT</td>
<td>COND1</td>
<td>当commPtr比来自mmioCommitRead接口的mmioFtqPtr大时,mmioLastCommit信号在下一个周期被拉高</td>
</tr>
<tr>
<td>3.4.2</td>
<td>MMIO_LAST_COMMIT</td>
<td>COND2</td>
<td>两者正好相等，且commPtr指向的指令块中有c_toCommit 或c_committed状态的指令，最后一条处于c_toCommit 或c_committed状态的指令是c_committed的,mmioLastCommit信号在下一个周期被拉高</td>
</tr>
<tr>
<td>4.1</td>
<td>SEND_UPDATE_TO_BPU</td>
<td>SEND_SUBQUEUE_INFO_TO_UPDATE</td>
<td>将提交项的子队列读取信息发向更新通道</td>
</tr>
<tr>
<td>4.2.1</td>
<td>UPDATE_FTB_ENTRY</td>
<td>CREATE_NEW</td>
<td>FTB未命中，创建一个新的FTB项</td>
</tr>
<tr>
<td>4.2.2.1</td>
<td>CREATE_NEW_FTB_ENTRY</td>
<td>INSERT</td>
<td>FTB未命中，创建一个新的FTB项,在原来的基础上改动即可，插入新的slot</td>
</tr>
<tr>
<td>4.2.2.2</td>
<td>CREATE_NEW_FTB_ENTRY</td>
<td>jmp target</td>
<td>FTB未命中，创建一个新的FTB项,在原来的基础上改动即可，<strong>当cfi指令是一个jalr指令</strong>，且旧的tailslot对应的是一个jump的指令，但tailslot指示的target与提交项指示的target不同时，说明需要对跳转目标进行修改</td>
</tr>
<tr>
<td>4.2.2.3</td>
<td>CREATE_NEW_FTB_ENTRY</td>
<td>bias</td>
<td>FTB未命中，创建一个新的FTB项,在原来的基础上改动即可，<strong>当cfi指令就是原FTB项的条件跳转指令</strong>，只需要根据跳转情况设置跳转的强弱</td>
</tr>
<tr>
<td>4.3</td>
<td>SEND_UPDATE_TO_BPU</td>
<td>SEND_NEW_FTB_RELATED</td>
<td>根据是否hit，我们已经得到更新后的FTB项了，在这个基础上我们继续更新一些相关信号以发送到FTQ更新接口。</td>
</tr>
</tbody>
</table>

</div>



    
	
  



          </main>
        </div>
      </div>
      <footer class="td-footer row d-print-none">
  <div class="container-fluid">
    <div class="row mx-md-2">
      <div class="td-footer__left col-6 col-sm-4 order-sm-1">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="User mailing list" aria-label="User mailing list">
    <a target="_blank" rel="noopener" href="https://example.org/mail" aria-label="User mailing list">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__right col-6 col-sm-4 order-sm-3">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="GitHub" aria-label="GitHub">
    <a target="_blank" rel="noopener" href="https://github.com/google/docsy" aria-label="GitHub">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2">
        <span class="td-footer__copyright">&copy;
    2025
    <span class="td-footer__authors">BOSC</span></span><span class="td-footer__all_rights_reserved">保留所有权利</span><span class="ms-2"><a href="https://policies.google.com/privacy" target="_blank" rel="noopener">隐私政策</a></span>
      </div>
    </div>
  </div>
</footer>

    </div>
    <script src="/UnityChipForXiangShan/js/main.min.37d14e870feb76f0f7a2a2422bae231efb0186c477999a4ab9ca7e9924ced592.js" integrity="sha256-N9FOhw/rdvD3oqJCK64jHvsBhsR3mZpKucp&#43;mSTO1ZI=" crossorigin="anonymous"></script>
<script src='/UnityChipForXiangShan/js/prism.js'></script>
<script src='/UnityChipForXiangShan/js/tabpane-persist.js'></script>

  </body>
</html>
