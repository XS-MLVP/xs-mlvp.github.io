<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FTQ概述 on 万众一芯之香山处理器</title>
    <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/</link>
    <description>Recent content in FTQ概述 on 万众一芯之香山处理器</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>FTQ顶层</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/01_topio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/01_topio/</guid>
      <description>&lt;h1 id=&#34;简述&#34;&gt;简述&lt;/h1&gt;&#xA;&lt;p&gt;在FTQ概述中，我们已经知道了，FTQ的作用就是多个模块交互的中转站，大致了解了它接受其他模块的哪些信息，它如何接受并存储这些信息在FTQ中，并如何把这些存储信息传递给需要的模块。&#xA;下面我们来具体了解一下FTQ与其他模块的交互接口，我们会对这种交互有一个更具体的认识。&lt;/p&gt;&#xA;&lt;h1 id=&#34;io一览&#34;&gt;IO一览&lt;/h1&gt;&#xA;&lt;h2 id=&#34;模块间io&#34;&gt;模块间IO&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;fromBpu：接受BPU预测结果的接口（BpuToFtqIO）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;fromIfu：接受IFU预译码写回的接口（IfuToFtqIO）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;fromBackend：接受后端执行结果和commit信号的接口（CtrlToFtqIO）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;toBpu：向BPU发送训练信息和重定向信息的接口（FtqToBpuIO）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;toIfu：向IFU发送取值目标和重定向信息的接口（FtqToIfuIO）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;toICache：向ICache发送取值目标的接口（FtqToICacheIO）&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;toBackend：向后端发送取值目标的接口（FtqToCtrlIO）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;toPrefetch：向Prefetch发送取值目标的接口（FtqToPrefetchIO）&lt;/li&gt;&#xA;&lt;li&gt;mmio&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;&#xA;&lt;p&gt;上述是主要的IO接口，此外，还有一些用于性能统计的IO接口，比如对BPU预测正确和错误结果次数进行统计，并进行转发的IO, 还有转发BPU各预测器预测信息的IO。&lt;/p&gt;&#xA;&lt;h1 id=&#34;bputoftqio&#34;&gt;&lt;a href=&#34;https://open-verify.cc/xs-bpu/docs/ports/02_global_ports/&#34;&gt;BpuToFtqIO&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;ifutoftqio&#34;&gt;IfuToFtqIO&lt;/h1&gt;&#xA;&lt;p&gt;我们知道从IFU，我们会得到预译码信息和重定向信息，而后者其实也是从预译码信息中生成。所以从IFU到FTQ的接口主要就是用来传递预译码信息的&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pdWb：IFU向FTQ写回某个FTQ项的预译码信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;strong&gt;PredecodeWritebackBundle&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pc：一个分支预测块覆盖的预测范围内的所有pc&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Vec(PredictWidth, UInt(VAddrBits.W))&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;pd：预测范围内所有指令的预译码信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Vec(PredictWidth, new PreDecodeInfo)&lt;/li&gt;&#xA;&lt;li&gt;PreDecodeInfo：每条指令的预译码信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：PreDecodeInfo&lt;/li&gt;&#xA;&lt;li&gt;信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;valid：预译码有效信号&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Bool&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;isRVC：是RVC指令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Bool&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;brType：跳转指令类型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：UInt(2.W)&lt;/li&gt;&#xA;&lt;li&gt;说明：根据brType的值判断跳转指令类型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;b01：对应分支指令&lt;/li&gt;&#xA;&lt;li&gt;b10：对应jal&lt;/li&gt;&#xA;&lt;li&gt;b11：对应jalr&lt;/li&gt;&#xA;&lt;li&gt;b00：对应非控制流指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;isCall：是Call指令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Bool&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;isRet：是Ret指令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Bool&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ftqIdx：FTQ项的索引，标记写回到哪个FTQ项&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：FtqPtr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ftqOffset：由BPU预测结果得到的，在该指令块中指令控制流指令的位置（指令控制流指令就是实际发生跳转的指令）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：UInt(log2Ceil(PredictWidth).W)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;misOffset：预译码发现发生预测错误的指令在指令块中的位置&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：ValidUndirectioned(UInt(log2Ceil(PredictWidth).W))&lt;/li&gt;&#xA;&lt;li&gt;说明：它的valid信号拉高表示该信号有效，也就说明存在预测错误，会引发重定向&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;cfiOffset：由预译码结果得到的，在该指令块中指令控制流指令的位置（指令控制流指令就是实际发生跳转的指令）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：ValidUndirectioned(UInt(log2Ceil(PredictWidth).W))&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;target：该指令块的目标地址&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：UInt(VAddrBits.W)&lt;/li&gt;&#xA;&lt;li&gt;说明：所谓目标地址，即在指令块中有控制流指令时，控制流指令的地址，在没有控制流指令时，指令块顺序执行，该指令块最后一条指令的下一条指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;jalTarget：jal指令的跳转地址&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：UInt(VAddrBits.W)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;instrRange：有效指令范围&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Vec(PredictWidth, Bool())&lt;/li&gt;&#xA;&lt;li&gt;说明：表示该条指令是不是在这个预测块的有效指令范围内（第一条有效跳转指令之前的指令）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;ctrltoftqio&#34;&gt;CtrlToFtqIO&lt;/h1&gt;&#xA;&lt;p&gt;后端控制块向FTQ发送指令提交信息，后端执行结果的接口。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;rob_commits：一个提交宽度内的RobCommitInfo信息。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Vec(CommitWidth, Valid(new RobCommitInfo))&lt;/li&gt;&#xA;&lt;li&gt;详情链接：RobCommitInfo&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;redirect：后端提供重定向信息的接口。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Valid(new Redirect)&lt;/li&gt;&#xA;&lt;li&gt;详情链接：Redirect&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ftqIdxAhead：提前重定向的FTQ指针，将要重定向的FTQ项的指针提前发送&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型： Vec(BackendRedirectNum, Valid(new FtqPtr))&lt;/li&gt;&#xA;&lt;li&gt;说明：虽然有三个接口，但实际上只用到了第一个接口，后面两个弃用了&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ftqIdxSelOH：独热码，本来是依靠该信号从提前重定向ftqIdxAhead中选择一个，但现在只有一个接口了，独热码也只有一位了。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Valid(UInt((BackendRedirectNum).W))&lt;/li&gt;&#xA;&lt;li&gt;说明：为了实现提前一拍读出在ftq中存储的重定向数据，减少redirect损失，后端会向ftq提前一拍（相对正式的后端redirect信号）传送ftqIdxAhead信号和ftqIdxSelOH信号。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;ftqtobpuio&#34;&gt;&lt;a href=&#34;https://open-verify.cc/xs-bpu/docs/ports/02_global_ports/&#34;&gt;FtqToBpuIO&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;ftqtoicacheio&#34;&gt;FtqToICacheIO&lt;/h1&gt;&#xA;&lt;p&gt;FTQ向IFU发送取值目标，ICache是指令缓存，如果取值目标在ICache中命中，由ICache将指令发给IFU&lt;/p&gt;</description>
    </item>
    <item>
      <title>FTQ子队列</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/02_subqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/02_subqueue/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;请注意：从本篇开始，就涉及待验证的功能点和测试点了&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;在之前的介绍中，我们采用FTQ项这个术语描述描述FTQ队列中的每一个元素，实际上，这只是一种便于抽象的说法。&lt;/p&gt;&#xA;&lt;p&gt;实际上的FTQ队列，是由好多个子队列共同构成的，一些子队列维护一类信息，另一些子队列维护另一类信息，相同ftqIdx索引的子队列信息共同构成一个完整的FTQ项。&lt;/p&gt;&#xA;&lt;p&gt;为什么要把它们分开成多个子队列呢？因为某些模块只需要FTQ项中的某一些信息，比如IFU想要取值目标，它只需要专门存储取值目标的子队列提供的信息就行了。另外，在我们更改FTQ项的内容时，也只需要写入需要更新的子队列，比如IFU预译码写回时，只需要写回专门存储预译码信息的队列了。&lt;/p&gt;&#xA;&lt;p&gt;下面来介绍一些FTQ的主要子队列，以及它们内部存储的数据结构。此外，FTQ还有一些存储中间状态的更小的队列&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;a href=&#34;https://open-verify.cc/xs-bpu/docs/ports/00_ftb/&#34;&gt;FTB项&lt;/a&gt;&lt;/td&gt;&#xA;          &lt;td&gt;分支预测结果的基本组成项，包含对预测块中分支指令和跳转指令的预测&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;取指目标&lt;/td&gt;&#xA;          &lt;td&gt;一个预测块内包含的所有指令PC，当然，它不是直接发送所有PC，而是发送部分信号，接收方可由该信号推出所有PC&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;子模块列表&#34;&gt;子模块列表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;子模块&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ftq_redirect_mem&lt;br&gt;&lt;/td&gt;&#xA;          &lt;td&gt;重定向存储子队列，存储来自分支预测结果的重定向信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ftq_pd_mem&lt;/td&gt;&#xA;          &lt;td&gt;预译码存储子队列，存储来自IFU的对指令块的预译码信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ftb_entry_mem&lt;/td&gt;&#xA;          &lt;td&gt;FTB项存储子队列，存储自分支预测结果中的ftb项&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ftq_pc_mem&lt;/td&gt;&#xA;          &lt;td&gt;取指目标子队列，存储来自分支预测结果的取指目标&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-ftq_redirect_mem存储重定向信息&#34;&gt;1. ftq_redirect_mem存储重定向信息&lt;/h3&gt;&#xA;&lt;p&gt;ftq_redirect_mem是香山ftq的一个子队列。它记录了重定向需要的一些信息，帮助重定向回正确状态，这些信息来自于BPU分支预测中的RAS预测器，以及顶层的分支历史指针，如果想要了解，可以参考BPU的RAS子文档了解如何通过这些信息回溯到之前的状态。&lt;/p&gt;&#xA;&lt;p&gt;它是一个寄存器堆，由64（FtqSize）个表项（Ftq_Redirect_SRAMEntry）构成。支持同步读写操作。有3个读端口和1个写端口，每个读端口负责与不同的模块交互。&lt;/p&gt;&#xA;&lt;h4 id=&#34;11-ftq_redirect_mem读操作&#34;&gt;1.1 ftq_redirect_mem读操作&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读操作：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;输入：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要使能ren，这是一个向量，可指定任意读端口可读&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对应接口：ren&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;从任意读端口中输入要读取的元素在ftq_redirect_mem中的地址，这是一个从0到ftqsize-1的索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对应接口：raddr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;输出：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从发起输入的读端口对应的读出端口中读出Ftq_Redirect_SRAMEntry。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对应接口：rdata&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;12-ftq_redirect_mem写操作&#34;&gt;1.2 ftq_redirect_mem写操作&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;写操作&#xA;&lt;ul&gt;&#xA;&lt;li&gt;输入：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要使能wen，可指定写端口可写&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对应接口：wen&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;向写端口中输入要写入的元素在ftq_redirect_mem中的地址，这是一个从0到ftqsize-1的索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对应接口：waddr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;向wdata中写入Ftq_Redirect_SRAMEntry&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对应接口：wdata&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;多端口读：可以从多个读端口读取结果&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;em&gt;每个子队列的读写基本都是类似的，后面不再赘述&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;ftq_redirect_sramentry&#34;&gt;Ftq_Redirect_SRAMEntry&lt;/h3&gt;&#xA;&lt;p&gt;ftq_redirect_mem存储的表项。继承自SpeculativeInfo，存储RAS预测器相关重定向信息，根据这些信息回溯到之前的状态&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;sc_disagree：统计分支指令在sc预测器中预测是否发生错误&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Some(Vec(numBr, Bool()))&lt;/li&gt;&#xA;&lt;li&gt;说明：Option 类型，表明这个值可能不存在，在非FPGA平台才有，否则为none&lt;/li&gt;&#xA;&lt;li&gt;信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SpeculativeInfo：推测信息，帮助BPU在发生重定向的时候回归正常的状态&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口列表:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;histPtr：重定向请求需要恢复的全局历史指针，可参见BPU顶层文档了解详情&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：CGHPtr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;说明：以下都属于RAS重定向信息,可参见BPU文档了解如何利用这些信息进行重定向&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ssp：重定向请求指令对应的 RAS 推测栈栈顶在提交栈位置的指针&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：UInt(log2Up(RasSize).W)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;sctr：重定向请求指令对应的 RAS 推测栈栈顶递归计数 Counter&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：RasCtrSize.W&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;TOSW：重定向请求指令对应的 RAS 推测栈（队列）写指针&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：RASPtr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;TOSR：重定向请求指令对应的 RAS 推测栈（队列）读指针&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：RASPtr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;NOS：重定向请求指令对应的 RAS 推测栈（队列）读指针&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：RASPtr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;topAddr：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：UInt(VAddrBits.W)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;功能名称&lt;/th&gt;&#xA;          &lt;th&gt;测试点名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;          &lt;td&gt;FTQ_REDIRECT_MEM&lt;/td&gt;&#xA;          &lt;td&gt;WRITE&lt;/td&gt;&#xA;          &lt;td&gt;向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.2&lt;/td&gt;&#xA;          &lt;td&gt;FTQ_REDIRECT_MEM&lt;/td&gt;&#xA;          &lt;td&gt;READ&lt;/td&gt;&#xA;          &lt;td&gt;向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;2-ftq_pd_mem存储预译码信息&#34;&gt;2. ftq_pd_mem存储预译码信息&lt;/h3&gt;&#xA;&lt;p&gt;由64（FtqSize）个表项（Ftq_pd_Entry）构成。支持同步读写操作。有2个读端口和1个写端口。具有读写使能信号。&lt;/p&gt;</description>
    </item>
    <item>
      <title>FTQ接收BPU分支预测结果</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/03_enqfrombpu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/03_enqfrombpu/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;BPU会将分支预测结果和meta数据发给FTQ。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从分支预测结果中，我们可以提取出分支预测块对应的取值目标，比如，一个不跨缓存行且所有指令均为RVC指令的分支预测块对应的取值目标，是从分支预测块起始地址开始的以2B为间隔的连续16条指令。&lt;/li&gt;&#xA;&lt;li&gt;meta信息则存储了各个预测器相关的预测信息，由于BPU预测有三个流水级，每个流水级都有相应的预测器，所以只有到s3阶段才有可能收集到所有预测器的预测信息，直到此时FTQ才接受到完整的meta，这些信息会在该分支预测块的全部指令被后端提交时交给BPU进行训练&lt;/li&gt;&#xA;&lt;li&gt;FTBEntry：严格来说，它其实也是meta的一部分，但是因为更新的时候ftb_entry需要在原来的基础上继续修改，为了不重新读一遍ftb，另外给它存储一个副本。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BPU (Branch Prediction Unit)&lt;/td&gt;&#xA;          &lt;td&gt;分支预测单元&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;FTQ (Fetch Target Queue)&lt;/td&gt;&#xA;          &lt;td&gt;采集目标队列&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;IFU (Instruction Fetch Unit)&lt;/td&gt;&#xA;          &lt;td&gt;指令采集单元&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;RAS (Return Address Stack)&lt;/td&gt;&#xA;          &lt;td&gt;返回地址堆&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;FTQ Entry&lt;/td&gt;&#xA;          &lt;td&gt;FTQ队列中的单个表项&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-新的预测块进队条件&#34;&gt;1. 新的预测块进队条件&lt;/h3&gt;&#xA;&lt;h4 id=&#34;11-成功接收数据&#34;&gt;&lt;strong&gt;1.1 成功接收数据&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;h5 id=&#34;111-ftq准备好接收信号&#34;&gt;1.1.1 FTQ准备好接收信号&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FTQ准备好接收信号：&#xA;     当FTQ队列中元素小于FtqSize或者可以提交指令块（canCommit拉高，说明可以提交指令块，在后面的文档: FTQ向BPU发送更新信息中介绍怎么判断是否可以提交指令块）的时候，来自BPU的新的指令预测块可以进入FTQ队列，队列准备好接收新的预测块，fromBpu的resp接口ready信号拉高。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;112-bpu准备好要发送的信号&#34;&gt;1.1.2 BPU准备好要发送的信号&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;BPU准备好要发送的信号：&#xA;     当BPU发往FTQ的接口vaid信号拉高，表示发送信号准备好&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;满足以上两个条件时,fromBpu的resp接口fire，表示接口数据被成功发送到FTQ中。&lt;/p&gt;&#xA;&lt;h4 id=&#34;12-允许bpu入队allowbpuin&#34;&gt;&lt;strong&gt;1.2 允许BPU入队allowBpuIn&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重定向发生时，会回滚到之前的状态，新发送的BPU预测信息自然就不需要了。&lt;strong&gt;允许BPU入队&lt;/strong&gt;时不能发生重定向&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;121-后端重定向发生&#34;&gt;1.2.1 后端重定向发生&lt;/h5&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;后端重定向发生：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标志：接收后端写回信息的接口fromBackend的重定向接口redirect有效，则该周期不允许入队，如果没有发生真实提前重定向realAhdValid(参见FTQ接收后端重定向一文)，则下一个周期也不允许入队。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h5 id=&#34;122-ifu重定向发生&#34;&gt;1.2.2 IFU重定向发生&lt;/h5&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;IFU重定向发生：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标志：IFU重定向信息生成的两个周期，均不许入队（参见FTQ接收IFU重定向一文了解IFU重定向信息的生成）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;只要避免上述两种重定向出现的情况，就可以允许BPU入队,即可以把发送到FTQ的数据，写入FTQ项&lt;/p&gt;&#xA;&lt;h4 id=&#34;13-以bpu预测结果重定向的方式入队&#34;&gt;1.3 以BPU预测结果重定向的方式入队&lt;/h4&gt;&#xA;&lt;p&gt;上述的BPU入队方式是一个全新的预测块进队，即BPU分支预测的s1阶段结果入队，此时未发生预测结果重定向。&lt;/p&gt;&#xA;&lt;p&gt;当BPU发生预测结果重定向时，只要&lt;strong&gt;允许BPU入队allowBpuIn&lt;/strong&gt;，也可以看作预测结果入队，不过这种入队是覆写队列中已有的FTQ项，没有写入新的指令块。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;BPU预测结果发生重定向的具体标志：fromBpu的resp接口的s2（s2阶段的预测信息）有效，且s2的hasRedirect拉高，表示在s2阶段发生了重定向，s3阶段重定向是一样的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;综合两种形式的BPU入队，这里称之为广义BPU入队方便区分，记为bpu_in_fire，该信号拉高，表明发生广义BPU入队。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-写入ftq项&#34;&gt;2. 写入FTQ项&lt;/h3&gt;&#xA;&lt;p&gt;之前已经说明过了，FTQ项只是一个抽象的概念，FTQ有很多个子队列组成，它们的项共同构成一个FTQ项，所以，向FTQ中写入FTQ项，实际上就是就是把BPU的预测信息写到对应的FTQ子队列中。&lt;/p&gt;&#xA;&lt;p&gt;FTQ主要获取以下信息作为bpu_in_resp&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;bpu_in_resp：BPU交给FTQ的resp详见BPU文档，resp中含有s1,s2,s3三个阶段的指令预测信息，bpu_in_resp将获取其中某一阶段预测信息selectedResp作为其值。未发生重定向时，使用s1作为预测结果，s2或者s3发生重定向信息时，优先s3的预测信息作为selectedResp。某阶段发生重定向的标志与上文讲述的一样一样。&#xA;从selectedResp（bpu_in_resp）中，我们还可以获取以下目标信息帮助我们写入子队列：ftq_idx，帮助我们索引写入子队列的地址&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;21-写入ftq子队列&#34;&gt;2.1 写入FTQ子队列：&lt;/h4&gt;&#xA;&lt;h5 id=&#34;211-写入ftq_pc_mem&#34;&gt;2.1.1 写入ftq_pc_mem&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftq_pc_mem: 来自BPU的selectedResp预测信息被写入ftq_pc_mem, 该存储结构有ftqsize个表项，对应队列中的所有ftq表项，每个存储元素可以推出对应的ftq表项中每条指令的pc地址&#xA;接收信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;wen：接收bpu_in_fire作为写使能信号&lt;/li&gt;&#xA;&lt;li&gt;waddr：接收selectedResp的ftq_idx&lt;/li&gt;&#xA;&lt;li&gt;wdata：selectedResp的相应信号&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;212-写入ftq_redirect_mem&#34;&gt;2.1.2 写入ftq_redirect_mem&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftq_redirect_mem: 在BPU的s3（也就是最终阶段）接收信息，因为重定向信息只有在s3阶段才能得到。里面存储了RAS重定向相关的信息帮助BPU进行重定向。&#xA;接收信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;wen：从BPU（fromBpu）回应（resp）的lastStage有效信号&lt;/li&gt;&#xA;&lt;li&gt;waddr：从BPU回应的lastStage的ftq_idx.value&lt;/li&gt;&#xA;&lt;li&gt;wdata：从BPU回应的last_stage_spec_info&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;213-写入ftq_meta_1r_sram&#34;&gt;2.1.3 写入ftq_meta_1r_sram&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftq_meta_1r_sram：在 BPU的s3阶段接收信息，同样是因为对于一个指令预测块，只有在其s3阶段才能获取完整的mata信息，同样被接收的还有最后阶段ftqentry信息&#xA;接收信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;wen：从BPU（fromBpu）回应（resp）的lastStage有效信号&lt;/li&gt;&#xA;&lt;li&gt;waddr：从BPU回应的lastStage的ftq_idx的value&lt;/li&gt;&#xA;&lt;li&gt;wdata：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;meta：从BPU回应的last_stage_meta&lt;/li&gt;&#xA;&lt;li&gt;ftb_entry：从BPU回应的last_stage_ftb_entry&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;214-写入ftb_entry_mem&#34;&gt;2.1.4 写入ftb_entry_mem&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftb_entry_mem：虽然ftq_meta_1r_sram中存储有最后阶段ftbentry，但此处出于更高效率读取专门把它存在ftb_entry_mem中。&#xA;接收信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;wen：从BPU（fromBpu）回应（resp）的lastStage有效信号&lt;/li&gt;&#xA;&lt;li&gt;waddr：从BPU回应的lastStage的ftq_idx的value字段&lt;/li&gt;&#xA;&lt;li&gt;wdata：从BPU回应的last_stage_ftb_entry&#xA;从中可以看到，FTQ虽然名字上听起来是一个队列，&lt;strong&gt;实际上内部却是由数个队列组成&lt;/strong&gt;，他们共同构成了FTQ这个大队列&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;22-写入状态队列&#34;&gt;2.2 写入状态队列&lt;/h4&gt;&#xA;&lt;p&gt;上述存储结构是FTQ中比较核心的存储结构，实际上，还有一些子队列用来存储一些状态信息，也同样都是存储ftqsize个（64）元素，需要被写入，写入时机是在发生bpu_in_fire的下一个周期，或者再下一个周期 。主要有以下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>FTQ向IFU发送取指目标</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/04_toifu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/04_toifu/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;IFU需要取FTQ中的项进行取指令操作，同时也会简单地对指令进行解析，并写回错误的指令&#xA;FTQ发送给IFU的信号同时也需发送给ICache一份，ICache是指令缓存，帮助快速读取指令。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ifuPtr：该寄存器信号指示了当前FTQ中需要读取的项的指针。直接发送给io.toIfu.req接口的ftqIdx。&lt;/li&gt;&#xA;&lt;li&gt;entry_is_to_send：entry_fetch_status存储每个FTQ项的发送状态，初始化并默认为当前ifuptr指向的项对应的发送状态，后续可能因为旁路逻辑等改变&lt;/li&gt;&#xA;&lt;li&gt;entry_ftq_offset: 从cfiIndex_vec中初始化并默认为当前ifuptr指向项的跳转指令在预测块中的偏移，后续可能因为旁路逻辑等改变&lt;/li&gt;&#xA;&lt;li&gt;entry_next：本次取指结束后下一次取值的开始地址&lt;/li&gt;&#xA;&lt;li&gt;pc_mem_ifu_ptr_rdata：获取ifuptr指向FTQ项的取指信息（从ftq_pc_mem的读取接口ifuPtr_rdata中获取）&lt;/li&gt;&#xA;&lt;li&gt;pc_mem_ifu_plus1_rdata：获取ifuptr+1指向FTQ项的pc相关信息（从ftq_pc_mem的读取接口ifuPtrPlus1_rdata中）&lt;/li&gt;&#xA;&lt;li&gt;copied_ifu_plus1_to_send：多个相同的复制信号，entry_fetch_status中指向ifuPtrPlus1的项是f_to_send状态或者上一周期bpu_in_fire,同时旁路bpu指针bpu_in_bypass_ptr等于ifuptr+1时，信号copied_ifu_plus1_to_send在一周期后拉高&lt;/li&gt;&#xA;&lt;li&gt;copied_ifu_ptr_to_send：同理，只是把ifuptr+1改成了ifuptr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-获取取指目标信息&#34;&gt;1. 获取取指目标信息&lt;/h3&gt;&#xA;&lt;p&gt;获取取指目标有两个来源，一个是BPU写入信息时，直接将取指目标旁路出来，一种则是从存储取指目标的队列ftq_pc_mem中读取。使用前一种方式的前提，是刚好ifuPtr指向的读取项刚好就是旁路指针信号bpu_in_resp_ptr（BPU入队时写入项的ftqIdx）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;旁路逻辑：pc信号在被写入存储子队列时就被旁路一份，写入信号ftq_pc_mem.io.wdata在bpu_in_fire信号拉高时被旁路到旁路信号寄存器bpu_in_bypass_buf中。同时被旁路的还有指针信号bpu_in_resp_ptr，在同样的条件下被旁路到寄存器bpu_in_bypass_ptr中&lt;/li&gt;&#xA;&lt;li&gt;读取ftq_pc_mem: 存储pc相关的取指目标，该存储队列有多个读接口，对所有ftqptr的写入信号（比如ifuPtr_write, ifuPtrPlus1_write等）被直接连接到存储队列的读取接口，这样，在ftqPtr寄存器正式被更新时，就可以同时直接从对应的读取接口中返回对应指针的读取结果，比如ftq_pc_mem.io.ifuPtr_rdata&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;11-准备发往icache的取指目标&#34;&gt;1.1 准备发往ICache的取指目标&lt;/h4&gt;&#xA;&lt;p&gt;有以下三种情况，分别对应&lt;strong&gt;测试点1.1.1，1.1.2，1.1.3&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;旁路生效，即旁路bpu指针等于ifuptr，且上一周期bpu输入有效结果（last_cycle_bpu_in表示上一周期bpu_in_fire）有效（也就相当于该旁路指针是有效的），此时，直接向toICache接口输入旁路pc信息bpu_in_bypass_buf&lt;/li&gt;&#xA;&lt;li&gt;不满足情况1，但是上一周期发生ifu_fire（即FTQ发往IFU的接口发生fire），成功传输信号，此toICache中被写入pc存储子队列ftq_pc_mem中ifuptr+1对应项的结果，这是因为此时发生了ifu_fire，新的ifuptr还未来得及更新（即加1），所以直接从后一项中获取新的发送数据&lt;/li&gt;&#xA;&lt;li&gt;前两种情况都不满足，此时toICache接口中被写入pc存储队列中ifuptr对应项的结果&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;12-提前一周期准备发往prefetch的取指目标&#34;&gt;1.2 提前一周期准备发往Prefetch的取指目标&lt;/h4&gt;&#xA;&lt;p&gt;有以下三种情况，分别对应&lt;strong&gt;测试点1.2.1，1.2.2，1.2.3&lt;/strong&gt;&#xA;同样有三种情况：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;bpu有信号写入（bpu_in_fire），同时bpu_in_resp_ptr等于pfptr的写入信号pfptr_write, （此时pfptr_write还没有正式被写入pfptr中），读取bpu向pc存储队列的写入信号wdata，下一周期写入ToPrefetch&#xA;     &lt;em&gt;xxxptr_write：是相应FTQptr寄存器的write信号，连接到寄存器的写端口，寄存器在时钟上升沿成功写入write信号&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;不满足情况1，且由bpu到prefetch的接口发生fire，即bpu向预取单元成功发送信号，pc存储单元的pfPtrPlus1_rdata下一周期写入ToPrefetch接口，选择指针加1对应项的原因与toICache类似。&lt;/li&gt;&#xA;&lt;li&gt;不满足以上两种情况：pc存储单元的pfPtr_rdata在下一周期被写入ToPrefetch接口&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;13-设置下一个发送的指令块的起始地址&#34;&gt;1.3 设置下一个发送的指令块的起始地址&lt;/h4&gt;&#xA;&lt;p&gt;有以下三种情况，分别对应&lt;strong&gt;测试点1.3.1，1.3.2，1.3.3&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;target（entry_next_addr）旁路逻辑：&lt;/strong&gt;&#xA;有三种情况：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;上一周期bpu写入信号，且旁路指针等于ifuptr：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;toIfu：写入旁路pc信息bpu_in_bypass_buf&lt;/li&gt;&#xA;&lt;li&gt;entry_is_to_send ：拉高&lt;/li&gt;&#xA;&lt;li&gt;entry_next_addr ：bpu预测结果中跳转地址last_cycle_bpu_target&lt;/li&gt;&#xA;&lt;li&gt;entry_ftq_offset ：bpu预测结果中跳转指令在预测块中的偏移last_cycle_cfiIndex&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;不满足情况1，bpu到ifu的接口发生fire，信号成功写入&#xA;&lt;ul&gt;&#xA;&lt;li&gt;toIfu：写入pc存储队列的读出信号ifuPtrPlus1_rdata，这同样是因为ifuptr还没来得及更改，所以直接使用ifuptr+1对应项的rdata&lt;/li&gt;&#xA;&lt;li&gt;entry_is_to_send ：发送状态队列中ifuPtrPlus1对应项为f_to_send或者在上一周期bpu有写入时旁路bpu指针等于ifuptr加1，entry_is_to_send拉高。&lt;/li&gt;&#xA;&lt;li&gt;entry_next_addr ：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果上一周期bpu有写入且bpu旁路指针等于ifuptr+1，写入bpu旁路pc信号的startAddr字段，而这个项的pc信息还没有写入，正在pc旁路信号中，这是因为ifuptr+1对应下一个指令预测块，它的起始地址实际上就是ifuptr对应指令的预测块的跳转目标。&lt;/li&gt;&#xA;&lt;li&gt;如果不满足该条件，&#xA;&lt;ol&gt;&#xA;&lt;li&gt;ifuptr等于newest_entry_ptr: 使用newest_entry_target作为entry_next_addr，newest_entry_ptr，newest_entry_target这几个内部信号，表明我们当前队列中最新的有效的FTQ项。如之前所说，BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，在相应的文档中，对其生成方式做具体的描述。&lt;/li&gt;&#xA;&lt;li&gt;不满足条件1：使用pc存储队列的ifuPtrPlus2_rdata.startAddr&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;不满足情况1，2：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;toIfu：写入pc存储队列的读出信号ifuPtr_rdata&lt;/li&gt;&#xA;&lt;li&gt;entry_is_to_send ：发送状态队列中ifuPtr对应项为f_to_send或者在上一周期bpu有写入时旁路bpu指针等于ifuptr&lt;/li&gt;&#xA;&lt;li&gt;entry_next_addr ：&lt;/li&gt;&#xA;&lt;li&gt;如果上一周期bpu有写入且bpu旁路指针等于ifuptr+1，写入bpu旁路pc信号的startAddr字段。&lt;/li&gt;&#xA;&lt;li&gt;如果不满足该条件，&#xA;         1. ifuptr等于newest_entry_ptr: 使用newest_entry_target作为entry_next_addr。&#xA;         2. 不满足上面的条件1：使用pc存储队列的ifuPtrPlus1_rdata.startAddr，为什么条件2和条件3，一个使用ifuPtrPlus2_rdata.startAddr作为entry_next_addr ，一个使用ifuPtrPlus1_rdata.startAddr作为，这也是出于时序的考虑：&#xA;因为要获得实际上的ifuptr+1对应项的start值作为结果，而因为第一处那里因为ifuptr还没来得及更新（加1）同步到当前实际的ifuptr，所以要加2来达到实际上的ifuptr+1对应的值，而第二处的ifuptr已经更新了，所以只用加1就行了。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-发送取指信息&#34;&gt;2. 发送取指信息&lt;/h3&gt;&#xA;&lt;h4 id=&#34;21-发送取指目标&#34;&gt;2.1 发送取指目标&lt;/h4&gt;&#xA;&lt;h5 id=&#34;211-发送给ifu&#34;&gt;2.1.1 发送给IFU&lt;/h5&gt;&#xA;&lt;p&gt;&lt;strong&gt;toIfu接口的req接口：&lt;/strong&gt;&#xA;FTQ通过该接口向IFU发送取指信号：&lt;/p&gt;</description>
    </item>
    <item>
      <title>IFU向FTQ写回预译码信息</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/05_wbfromifu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/05_wbfromifu/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;IFU获取来自BPU的预测信息之后，会执行预译码，并将FTQ项写回FTQ中去。我们会比对FTQ中原BPU预测项和预译码的结果，判断是否有预测错误&lt;/p&gt;&#xA;&lt;h3 id=&#34;基本流程&#34;&gt;基本流程&lt;/h3&gt;&#xA;&lt;p&gt;预译码写回ftq_pd_mem：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FTQ从pdWb接口中获取IFU的写回信息，FTQ首先将预译码写回信息写回到ftq_pd_mem,&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;更新提交状态队列commitStateQueue：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;然后根据写回信息中指令的有效情况更新提交状态队列commitStateQueue。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;比对错误：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同时，从ftb_entry_mem读出ifu_Wb_idx所指的FTB项，将该FTB项的预测结果与预译码写回结果进行对比，看两者对分支的预测结果是否有所不同。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;综合错误：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;之后就综合根据预译码信息可能得到的错误：有前面说的比对BPU的预测结果和预译码结果得到的错误，也有直接根据预译码得到的错误预测信息。根据错误预测结果更新命中状态队列。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;更新写回指针&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最后，如果IFU成功写回，ifu_Wb_idx更新加1。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;预译码&lt;/td&gt;&#xA;          &lt;td&gt;IFU会对取指目标进预译码，之后写回FTQ&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ifuWbPtr&lt;/td&gt;&#xA;          &lt;td&gt;IFU写回指针，知识IFU预译码要写入FTQ的位置&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-预译码写回ftq_pd_mem&#34;&gt;1. 预译码写回ftq_pd_mem&lt;/h3&gt;&#xA;&lt;p&gt;写回有效：预译码信息pdWb有效时，写有效&#xA;写回地址：pdWb的ftqIdx的value&#xA;写回值：解析整个pdWb的结果&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-更新提交状态队列&#34;&gt;2. 更新提交状态队列&lt;/h3&gt;&#xA;&lt;p&gt;当预译码信息pdWb有效时，相当于写回有效，此时，根据预译码信息中每条指令的有效情况和该指令是否在有效范围内，判断指令的提交状态是否可以修改，若可以修改，则将提交状态队列，写回项中的指令状态修改&lt;/p&gt;&#xA;&lt;h4 id=&#34;详细信号表示&#34;&gt;详细信号表示&lt;/h4&gt;&#xA;&lt;p&gt;pdWb有效时，ifu_wb_valid拉高。&#xA;此时，对于预译码信息中每一条指令的预译码结果pd做判断：&#xA;如果预译码结果valid，且指令在有效范围内（根据insrtRange的bool数组指示），则提交状态队列commitStateQueue中，写回项中的指令状态修改为c_toCommit，表示可以提交，这是因为只有在FTQ项被预译码写回后，才能根据后端提交信息提交该FTQ项，之后会把预译码信息一并发往更新通道。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-比对预测结果与预译码结果&#34;&gt;3. 比对预测结果与预译码结果&lt;/h3&gt;&#xA;&lt;p&gt;从ftb存储队列ftb_entry_mem中的读取ifu写回指针ifuwbptr的对应项：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pdWb有效的时候，读有效，读取地址为预译码信息中指示的ftqIdx。&#xA;当命中状态队列指示待比对项ftb命中，且回写有效时，读取出FTB存储队列中对应的项，与预译码信息进行比对，当BPU预测的FTB项指示指令是有效分支指令，而预译码信息中则指示不是有效分支指令时，发生分支预测错误，当BPU预测的FTB项指示指令是有效jmp指令，而预译码信息中则指示不是有效jmp指令时，发生跳转预测错误&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;详细信号表示-1&#34;&gt;详细信号表示：&lt;/h4&gt;&#xA;&lt;p&gt;ifu_wb_valid回写有效时，ftb_entry_mem回写指针对应读使能端口ren有效，读取地址为ifu_wb_idx预测译码信息中指示的ftqIdx的value值。&#xA;回写项命中且回写有效，hit_pd_valid信号有效，此时，读取ftb存储队列中的FTB项，读出brSlots与tailSlot，并进行比对：&lt;/p&gt;&#xA;&lt;h4 id=&#34;31-判断是否有分支预测错误br_false_hit&#34;&gt;3.1 判断是否有分支预测错误br_false_hit&lt;/h4&gt;&#xA;&lt;h5 id=&#34;测试点311和312对应以下两种条件导致的br_false_hit&#34;&gt;测试点3.1.1和3.1.2对应以下两种条件导致的br_false_hit&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;判断是否有分支预测错误br_false_hit：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;brSlots的任意一项有效，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高表明是分支指令，&lt;/li&gt;&#xA;&lt;li&gt;taiSlot有效且sharing字段拉高表明该slot为分支slot，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高表明是分支指令&#xA;满足任意条件可判断发生分支预测错误br_false_hit，该信号拉高&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;32-判断是否发生jmp预测错误jal_false_hit&#34;&gt;3.2 判断是否发生jmp预测错误jal_false_hit&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;判断是否发生jmp预测错误jal_false_hit：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;预测结果中必须指明指令预测有效，且其中isJal拉高表面是jal指令或者指明是isjalr指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;4-预译码错误&#34;&gt;4. 预译码错误&lt;/h3&gt;&#xA;&lt;p&gt;直接从预测结果中获取错误预测相关信息，如果回写项ftb命中且missoffset字段有效表明有错误预测的指令，hit_pd_mispred信号拉高，表示预译码结果中直接指明有预测错误的指令。&lt;/p&gt;&#xA;&lt;h3 id=&#34;5-综合错误&#34;&gt;5. 综合错误&lt;/h3&gt;&#xA;&lt;p&gt;综合比对预测结果与预译码结果得到的错误信息，与预译码错误直接获得的预测错误，任意一种发生时has_false_hit拉高表示有预测错误，此时，命中状态队列entry_hit_status中写回项的状态置为h_false_hit&lt;/p&gt;&#xA;&lt;h3 id=&#34;6-更新写回指针&#34;&gt;6. 更新写回指针&lt;/h3&gt;&#xA;&lt;p&gt;ifu_wb_valid拉高，表示写回有效，将ifuWbPtr更新为原值加1。&lt;/p&gt;&#xA;&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;顶层IO&lt;/th&gt;&#xA;          &lt;th&gt;子接口&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;fromIfu&lt;/td&gt;&#xA;          &lt;td&gt;pdWb&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;测试点总表&#34;&gt;测试点总表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;功能名称&lt;/th&gt;&#xA;          &lt;th&gt;测试点名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;WB_PD&lt;/td&gt;&#xA;          &lt;td&gt;WB_PD&lt;/td&gt;&#xA;          &lt;td&gt;向ftq_pd_mem中写回预译码信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;UPDATE_COMMITSTATE&lt;/td&gt;&#xA;          &lt;td&gt;UPDATE_COMMITSTATE&lt;/td&gt;&#xA;          &lt;td&gt;当预译码信息pdWb有效时，根据预译码信息中每条指令的有效情况和该指令是否在有效范围内，判断指令的提交状态是否可以修改，若可以修改，则将提交状态队列，写回项中的指令状态修改&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.1.1&lt;/td&gt;&#xA;          &lt;td&gt;BR_FALSE_HIT&lt;/td&gt;&#xA;          &lt;td&gt;COND1&lt;/td&gt;&#xA;          &lt;td&gt;brSlots的任意一项有效，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.1.2&lt;/td&gt;&#xA;          &lt;td&gt;BR_FALSE_HIT&lt;/td&gt;&#xA;          &lt;td&gt;COND2&lt;/td&gt;&#xA;          &lt;td&gt;taiSlot有效且sharing字段拉高表明该slot为分支slot，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.2&lt;/td&gt;&#xA;          &lt;td&gt;JAL_FALSE_HIT&lt;/td&gt;&#xA;          &lt;td&gt;JAL_FALSE_HIT&lt;/td&gt;&#xA;          &lt;td&gt;指令预测有效，且其中isJal拉高或者指明是isjalr指令&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;PD_MISS&lt;/td&gt;&#xA;          &lt;td&gt;PD_MISS&lt;/td&gt;&#xA;          &lt;td&gt;如果回写项ftb命中且missoffset字段有效表明有错误预测的指令，hit_pd_mispred信号拉高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;5&lt;/td&gt;&#xA;          &lt;td&gt;FALSE_HIT&lt;/td&gt;&#xA;          &lt;td&gt;FALSE_HIT&lt;/td&gt;&#xA;          &lt;td&gt;综合比对预测结果与预译码结果得到的错误信息，与预译码错误直接获得的预测错误，任意一种发生时has_false_hit拉高表示有预测错误，此时，命中状态队列entry_hit_status中写回项的状态置为h_false_hit&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;6&lt;/td&gt;&#xA;          &lt;td&gt;UPDATE_IFU_WB_PTR&lt;/td&gt;&#xA;          &lt;td&gt;UPDATE_IFU_WB_PTR&lt;/td&gt;&#xA;          &lt;td&gt;ifu_wb_valid拉高，将ifuWbPtr更新为原值加1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>FTQ接收后端重定向</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/06_-redirectfrombackend/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/06_-redirectfrombackend/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;FTQ重定向信息有两个来源，分别是IFU 和 后端。两者的 重定向接口大致相似，但重定向的过程有一定区别。&lt;/p&gt;&#xA;&lt;p&gt;对于重定向，后端有提前重定向机制，为了实现提前一拍读出在ftq中存储的重定向数据，减少redirect损失，后端会向ftq提前一拍（相对正式的后端redirect信号）传送ftqIdxAhead信号和ftqIdxSelOH信号。ftqIdxSelOH信号出现的原因，是早期版本要读多个ftqIdxAhead信号，以独热码的形式选其中一路作为最终确认的提前索引值，但现在只需要从一个端口获取ftqIdx信号了，ftqIdxAhead只能确认这一个端口了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;sc_disagree&lt;/td&gt;&#xA;          &lt;td&gt;统计SC预测错误用的性能计数器中需要用到的值，SC预测器是BPU子预测器TAGE-SC预测器的一个部分&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-接收后端重定向信号&#34;&gt;1. 接收后端重定向信号&lt;/h3&gt;&#xA;&lt;h3 id=&#34;时序&#34;&gt;时序&lt;/h3&gt;&#xA;&lt;h4 id=&#34;11-提前重定向&#34;&gt;1.1 提前重定向&lt;/h4&gt;&#xA;&lt;p&gt;第一个周期：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;后端重定向写回时，首先会从后端到FTQ的IO接口（CtrltoFtqIO）中，看ftqIdx是不是有效信号，且此时后端正式重定向信号redirect无效(因为提前重定向会比正式重定向提前一拍，所以此时正式重定向无效)，这时，提前重定向信号aheadValid有效, 将使用提前获取的重定向ftqIdx，&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;12-真实提前重定向&#34;&gt;1.2 真实提前重定向&lt;/h4&gt;&#xA;&lt;p&gt;第二个周期：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果此时后端正式重定向信号有效了，且ftqIdxSelOH拉高，说明在正式重定向阶段成功对ftqIdxAhead信号进行选中，同时上一周期重定向信号aheadValid是有效的，则真实提前重定向信号realAhdValid拉高，在此时读取&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;13-存储后端重定向信号&#34;&gt;1.3 存储后端重定向信号&lt;/h4&gt;&#xA;&lt;p&gt;第三个周期：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;该周期会把来自后端的重定向信息的存储一份在寄存器backendRedirectReg中，具体的来说，当上一个周期后端重定向有效时，将后端重定向bits字段（存储实际内容）被写入寄存器的bits字段。&lt;/li&gt;&#xA;&lt;li&gt;而实际决定信号是否有效的valid字段（决定该信号是否有效）则在上一周期真实提前重定向信号有效（表示确实使用了提前重定向的ftqIdx进行重定向）的情况下，被写入false，因为提前重定向发生时，我们直接使用当前的后端重定向信号交给FTQ就可以了。而不需要多保存一个周期。&lt;/li&gt;&#xA;&lt;li&gt;真实提前重定向信号无效时，则由上一周期后端正式重定向的有效值决定，只有信号有效时，我们才需要把它存下来，之后交给FTQ。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-选择重定向信号&#34;&gt;2. 选择重定向信号&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;信号抉择&lt;/strong&gt;：&#xA;是提前获取后端重定向信息还是延迟一个周期从寄存器内读取？&#xA;真实重定向有效时，直接将后端重定向信息传递给FTQ，否则，取重定向寄存器内的信号作为重定向信息传递给FTQ，相当于晚一个周期发送重定向信息。最后被选择的重定向信息作为&lt;strong&gt;后端重定向结果fromBackendRedirect&lt;/strong&gt;发送给FTQ&lt;/p&gt;&#xA;&lt;p&gt;接下来讲讲后端重定向在这三个周期到底通过ftqIdx到底读了哪些FTQ子队列中的信息，以及怎么使用它们。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-整合子队列信号&#34;&gt;3. 整合子队列信号&lt;/h3&gt;&#xA;&lt;h4 id=&#34;31-读取子队列&#34;&gt;3.1 读取子队列&lt;/h4&gt;&#xA;&lt;p&gt;接下来讲讲后端重定向在这三个周期到底通过ftqIdx到底读了哪些FTQ子队列中的信息，以及怎么使用它们。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;后端重定向读取的子队列：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftq_redirect_mem：FTQ会根据后端重定向提供的ftqIdx读出ftq_Redirect_SRAMEntry，借助它提供的信息重定向到之前的状态。&lt;/li&gt;&#xA;&lt;li&gt;ftq_entry_mem：读出重定向指令块对应的FTB项&lt;/li&gt;&#xA;&lt;li&gt;ftq_pd_mem：读出重定向指令块的预译码信息&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;311-发生提前重定向时读取子队列需要两个周期&#34;&gt;3.1.1 发生提前重定向时，读取子队列需要两个周期&lt;/h4&gt;&#xA;&lt;h4 id=&#34;312-未发生提前重定向时读取子队列需要三个周期&#34;&gt;3.1.2 未发生提前重定向时，读取子队列需要三个周期&lt;/h4&gt;&#xA;&lt;p&gt;&lt;strong&gt;读子队列时序：&lt;/strong&gt;&#xA;第一个周期：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提前重定向信号有效时，将子队列的读端口，读有效信号拉高，输入ftqIdxAhead的value字段作为读地址，发起读取请求。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;第二个周期：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;case1. 如果第一周期的提前重定向无效，而现在正式重定向有效，则在此时才拉高读有效信号，使用正式重定向接口的ftqIdx作为读取地址，发起读取请求。&lt;/li&gt;&#xA;&lt;li&gt;case2. 真实提前重定向有效了，此时因为前一个周期已经发起读取请求，此时可以直接从子队列的读端口读出了&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;第三个周期&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;真实提前重定向无效，但至少前一个周期正式重定向发起的读取请求能保证在当前周期从子队列中读出。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;32-将子队列信息整合到后端重定向信号&#34;&gt;3.2 将子队列信息整合到后端重定向信号&lt;/h4&gt;&#xA;&lt;p&gt;&lt;strong&gt;处理读取信息&lt;/strong&gt;&#xA;&lt;em&gt;FTQ会将从子队列中读出的信息整合到fromBackendRedirect中。&lt;/em&gt;&#xA;具体来说：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重定向redirect接口的CfiUpdateInfo接口直接接收ftq_Redirect_SRAMEntry中的同名信号。&lt;/li&gt;&#xA;&lt;li&gt;利用fromBackendRedirect中指示的ftqOffset读取指令块预译码信息中实际跳转指令的预译码信息，该ftqOffset为后端执行过后确定的控制流指令在指令块内的偏移。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;得到的预译码信息被直接连接到CfiUpdateInfo接口的pd接口中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;对于读出的指令块对应的FTB项，我们可以从中得知实际执行时得到的跳转指令，是否在FTB项被预测为跳转指令，或者是被预测为jmp指令，如果是，则cfiUpdateInfo的br_hit接口或者jr_hit接口被拉高，表示对应的分支预测结果正确了。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具体来说：通过发送ftqOffset，ftb项以brIsSaved的方式判断是否br_hit，判断是否jr_hit的方式也是类似的（r_ftb_entry.isJalr &amp;amp;&amp;amp; r_ftb_entry.tailSlot.offset === r_ftqOffset）。&lt;/li&gt;&#xA;&lt;li&gt;在CfiUpdateInfo接口设置为br_hit的时候，还会根据这条发生跳转的分支指令是哪个槽从ftq_Redirect_SRAMEntry重定向接口的sc_disagree统计SC预测错误用的性能计数器中，获取对应值，最后整合到后端重定向接口中（如果没有br_hit，对应计数器的两个值都为0）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;顶层IO&lt;/th&gt;&#xA;          &lt;th&gt;功能&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;fromBackend&lt;/td&gt;&#xA;          &lt;td&gt;接收后端重定向信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;测试点总表&#34;&gt;测试点总表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;功能名称&lt;/th&gt;&#xA;          &lt;th&gt;测试点名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;          &lt;td&gt;RECERIVE_BACKEND_REDIRECT&lt;/td&gt;&#xA;          &lt;td&gt;REDIRECT_AHEAD&lt;/td&gt;&#xA;          &lt;td&gt;后端重定向写回时，首先会从后端到FTQ的IO接口（CtrltoFtqIO）中，看ftqIdx是不是有效信号，且此时后端正式重定向信号redirect无效，这时，提前重定向信号aheadValid有效&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.2&lt;/td&gt;&#xA;          &lt;td&gt;RECERIVE_BACKEND_REDIRECT&lt;/td&gt;&#xA;          &lt;td&gt;REAL_REDIRECT_AHEAD&lt;/td&gt;&#xA;          &lt;td&gt;如果此时后端正式重定向信号有效了，且ftqIdxSelOH拉高，同时上一周期重定向信号aheadValid是有效的，则真实提前重定向信号realAhdValid拉高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.3&lt;/td&gt;&#xA;          &lt;td&gt;RECERIVE_BACKEND_REDIRECT&lt;/td&gt;&#xA;          &lt;td&gt;STORE_REDIRECT&lt;/td&gt;&#xA;          &lt;td&gt;后端真实重定向无效时写入寄存器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;CHOOSE_AHEAD&lt;/td&gt;&#xA;          &lt;td&gt;CHOOSE_AHEAD&lt;/td&gt;&#xA;          &lt;td&gt;真实重定向有效时，直接将后端重定向信息传递给FTQ，否则，取重定向寄存器内的信号作为重定向信息传递给FTQ&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.1.1&lt;/td&gt;&#xA;          &lt;td&gt;READ_FTQ_SUBQUEUE&lt;/td&gt;&#xA;          &lt;td&gt;READ_AHEAD&lt;/td&gt;&#xA;          &lt;td&gt;发生提前重定向时，读取子队列需要两个周期&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.1.2&lt;/td&gt;&#xA;          &lt;td&gt;READ_FTQ_SUBQUEUE&lt;/td&gt;&#xA;          &lt;td&gt;READ_NO_AHEAD&lt;/td&gt;&#xA;          &lt;td&gt;未发生提前重定向时，读取子队列需要三个周期&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.2&lt;/td&gt;&#xA;          &lt;td&gt;ADD_SUBQUEUE_INFO&lt;/td&gt;&#xA;          &lt;td&gt;ADD_SUBQUEUE_INFO&lt;/td&gt;&#xA;          &lt;td&gt;将子队列信息整合到后端重定向信号&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>FTQ接收IFU重定向</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/07_redirectfromifu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/07_redirectfromifu/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;除了后端，IFU也会发送重定向相关消息，和后端不同，IFU的重定向信息来自于预译码写回信息。相同的是，它们都是通过BranchPredictionRedirect的接口传递重定向信息。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;RedirectLevel&lt;/td&gt;&#xA;          &lt;td&gt;重定向等级，重定向请求是否包括本位置，低表示在本位置后重定向，高表示在本位置重定向。它在之后决定了由重定向导致的冲刷信号是否会影响到发生重定向的指令&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-ifu重定向信号生成&#34;&gt;1. IFU重定向信号生成&lt;/h3&gt;&#xA;&lt;h4 id=&#34;流程&#34;&gt;流程&lt;/h4&gt;&#xA;&lt;p&gt;IFU重定向是通过这个BranchPredictionRedirect接口传递的，下面来讲述IFU重定向怎么生成IFU的BranchPredictionRedirect内相应信号的，这个过程需要两个周期&#xA;信号列表：&#xA;&lt;strong&gt;第一个周期&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;11-ifu-重定向触发条件&#34;&gt;1.1 IFU 重定向触发条件&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;valid：当预译码写回pdWb有效，且pdWb的missOffset字段有效表明存在预测错误的指令，同时后端冲刷信号backendFlush无效时，valid信号有效。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;12-ifu生成重定向信号&#34;&gt;1.2 IFU生成重定向信号&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftqIdx：接收pdWb指定的ftqIdx&lt;/li&gt;&#xA;&lt;li&gt;ftqOffset：接收pdWb的missOffset的bits字段&lt;/li&gt;&#xA;&lt;li&gt;level：RedirectLevel.flushAfter，将重定向等级设置为flushAfter&lt;/li&gt;&#xA;&lt;li&gt;BTBMissBubble：true&lt;/li&gt;&#xA;&lt;li&gt;debugIsMemVio：false&lt;/li&gt;&#xA;&lt;li&gt;debugIsCtrl：false&lt;/li&gt;&#xA;&lt;li&gt;cfiUpdate：&#xA;信号列表:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pc：pdWb中记录的指令块中所有指令pc中，missOffset对应的pc&lt;/li&gt;&#xA;&lt;li&gt;pd：pdWb中记录的指令块中所有指令的pd中，missOffset对应的pd&lt;/li&gt;&#xA;&lt;li&gt;predTaken：从cfiIndex_vec子队列中读取pdWb中ftqIdx索引的项是否valid，有效说明指令块内被预测为有控制流指令。&lt;/li&gt;&#xA;&lt;li&gt;target：pdWb中的target&lt;/li&gt;&#xA;&lt;li&gt;taken：pdWb中cfiOffset的valid字段，有效时表明预译码认为指令块中存在指令控制流指令&lt;/li&gt;&#xA;&lt;li&gt;isMisPred：pdWb中missOffset的valid字段，有效时表明预译码认为指令块中存在预测错误的指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;第二个周期：&lt;/strong&gt;&#xA;该周期进行的信号生成是在第一周期valid字段有效的情况下才继续的&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;cifUpdate：&#xA;信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重定向RAS相关信号：通过ftqIdx索引从 ftq_redirect_mem读出ftq_Redirect_SRAMEntry，把其中的所有信号直接传递给cfiUpdate的同名信号中。&lt;/li&gt;&#xA;&lt;li&gt;target：已在第一周期写入cfiUpdate的pd有效，且isRet字段拉高，指明发生预测错误的指令本是一条Ret指令，此时，将target设置为cfiUpdate的topAddr，帮助回到发生错误之前的状态。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-重定向结果生效&#34;&gt;2. 重定向结果生效&lt;/h3&gt;&#xA;&lt;p&gt;两个周期生成完整的重定向信息后，IFU重定向信息才有效，有可能被FTQ采取，完整的&lt;strong&gt;IFU重定向结果记为ifuRedirectToBpu&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-ifu-冲刷信号-ifuflush&#34;&gt;3. IFU 冲刷信号 (&lt;code&gt;ifuFlush&lt;/code&gt;)&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;指令流控制信号&lt;/strong&gt;：&#xA;ifuFlush：来自IFU的冲刷信号，主要是由IFU重定向造成的，生成IFU重定向信息的两个周期内，该信号都拉高&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标志：IFU重定向信息产生接口BranchPredictionRedirect中valid有效，表示开始生成重定向信息，该周期以及下一个周期，ifuFlush拉高&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;顶层IO&lt;/th&gt;&#xA;          &lt;th&gt;作用&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;fromIFU&lt;/td&gt;&#xA;          &lt;td&gt;接收来自IFU的预译码信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;接口时序&#34;&gt;接口时序&lt;/h2&gt;&#xA;&lt;h2 id=&#34;测试点总表&#34;&gt;测试点总表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;功能名称&lt;/th&gt;&#xA;          &lt;th&gt;测试点名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;          &lt;td&gt;IFU_REDIRECT&lt;/td&gt;&#xA;          &lt;td&gt;IFU_REDIRECT_GRN_VALID&lt;/td&gt;&#xA;          &lt;td&gt;当预译码写回pdWb有效，且pdWb的missOffset字段有效表明存在预测错误的指令，同时后端冲刷信号backendFlush无效时，valid信号有效&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.2&lt;/td&gt;&#xA;          &lt;td&gt;IFU_REDIRECT&lt;/td&gt;&#xA;          &lt;td&gt;IFU_REDIRECT_GEN&lt;/td&gt;&#xA;          &lt;td&gt;允许生成IFU重定向时，在两周期内生成具体信号&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;IFU_REDIRECT_TO_BPU&lt;/td&gt;&#xA;          &lt;td&gt;IFU_REDIRECT_TO_BPU&lt;/td&gt;&#xA;          &lt;td&gt;IFU重定向生成后，IFU重定向结果生效&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3&lt;/td&gt;&#xA;          &lt;td&gt;IFU_FLUSH&lt;/td&gt;&#xA;          &lt;td&gt;IFU_FLUSH&lt;/td&gt;&#xA;          &lt;td&gt;生成IFU重定向信息的两个周期内，ifuFlush信号都拉高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/mrs-testpoints&gt;</description>
    </item>
    <item>
      <title>FTQ向后端发送取指目标</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/08_tobackend/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/08_tobackend/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;pc取值目标会发给后端pc mem让他自己进行存储，之后从自己的pc mem取指，此外，最新的FTQ项和对应的跳转目标也会发给后端。&lt;/p&gt;&#xA;&lt;p&gt;怎样算是一个最新的FTQ项，BPU最新发送的预测块可以是最新的FTQ项，其次，重定向发生时，需要回滚到发生错误预测之前的状态，从指定的FTQ项开始重新开始预测，预译码等等，这也可以是被更新的最新的FTQ项。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;暂无&lt;/td&gt;&#xA;          &lt;td&gt;暂无&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h4 id=&#34;流程&#34;&gt;流程&lt;/h4&gt;&#xA;&lt;h4 id=&#34;1发送取值目标到pc-mem&#34;&gt;1.发送取值目标到pc mem&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;发送时机：bpu_in_fire，即BPU向前端发送有效预测信息，或者重定向信息的时候。以此为基础之后的第二个周期，进行发送，通过将toBackend接口的pc_mem_wen设置为true的方式指明开始发送&lt;/li&gt;&#xA;&lt;li&gt;接口信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pc_mem_wen：设置为true&lt;/li&gt;&#xA;&lt;li&gt;pc_mem_waddr：接收bpu_in_fire那个周期BPU发送的ftqIdx&lt;/li&gt;&#xA;&lt;li&gt;pc_mem_wdata：接收bpu_in_fire那个周期，FTQ读取的ftq_pc_mem中的取指目标&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;2更新最新的ftq项&#34;&gt;2.更新最新的FTQ项&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;发送时机：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最新的FTQ项可能是由BPU写入最新预测信息造成的，&lt;strong&gt;发送取值目标到pc mem&lt;/strong&gt;也是因为BPU写入最新预测信息才写入的，如果是这种情况造成的，更新FTQ项和写入pc mem的时机是一致的。&lt;/li&gt;&#xA;&lt;li&gt;此外发生重定向时，也会进行状态回滚更新FTQ项，标志是后端接口fromBackend的重定向redirect信号有效，或者写入BPU的接口toBPU的redirctFromIFU拉高说明当前有来自IFU的重定向&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;em&gt;（注释（可忽略）IFU重定向信号生成有两个周期，可以认为第一个周期预译码信息中missoffset有效说明IFU重定向发生，也可以认为第二个周期redirctFromIFU拉高说明重定向发生，此处取后者）。&lt;/em&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;同样是向toBackend中写入&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;接口信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;newest_entry_en：前面说的发送时机到来时，再延迟一个周期达到真正的写入时机，这时才拉高信号&lt;/li&gt;&#xA;&lt;li&gt;newest_entry_ptr：发送时机到来时的newest_entry_ptr，在真正的写入时机写入&lt;/li&gt;&#xA;&lt;li&gt;newest_entry_target：发送时机到来时的newest_entry_target&#xA;newest_entry_ptr，newest_entry_target这几个都是同名的内部信号，如之前所说，BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，在相应的文档中，对其生成方式做具体的描述。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;顶层IO&lt;/th&gt;&#xA;          &lt;th&gt;作用&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;toBackend&lt;/td&gt;&#xA;          &lt;td&gt;发送取指令目标，让后端进行储存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;测试点总表&#34;&gt;测试点总表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;功能名称&lt;/th&gt;&#xA;          &lt;th&gt;测试点名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;SEND_PC_TO_BACKEND&lt;/td&gt;&#xA;          &lt;td&gt;SEND_PC&lt;/td&gt;&#xA;          &lt;td&gt;发送取值目标到pc mem&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;SEND_PC_TO_BACKEND&lt;/td&gt;&#xA;          &lt;td&gt;UPDATE_NEWEST&lt;/td&gt;&#xA;          &lt;td&gt;更新最新的FTQ项&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/mrs-testpoints&gt;</description>
    </item>
    <item>
      <title>执行单元修改FTQ状态队列</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/09_wbfromexu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/09_wbfromexu/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;后端的写回信息，包括重定向信息和更新信息，实际上都是执行之后，由实际执行单元根据结果发回的&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cfiIndex_vec&lt;/td&gt;&#xA;          &lt;td&gt;控制流指令索引队列，记录每个指令块中控制流指令的索引&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;update_target&lt;/td&gt;&#xA;          &lt;td&gt;更新目标队列，记录每个指令块的跳转目标&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;FTQ最新项&lt;/td&gt;&#xA;          &lt;td&gt;BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，表明我们当前关注的最新FTQ项。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-由后端的写回信号修改ftq状态&#34;&gt;1. 由后端的写回信号修改FTQ状态&lt;/h3&gt;&#xA;&lt;h4 id=&#34;11-修改ftq状态队列&#34;&gt;1.1 修改FTQ状态队列&lt;/h4&gt;&#xA;&lt;p&gt;从后端写回FTQ接口fromBackend中的redirect接口中，我们可以读出valid，ftqPtr，ftqOffset（后端实际执行时确认的控制流指令的偏移），taken，mispred字段，依靠它们来判断，如何修改FTQ的状态队列和相关的变量&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;后端执行单元写回时被修改的队列&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;h4 id=&#34;111-修改cfiindex_vec&#34;&gt;1.1.1 修改cfiIndex_vec&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;cfiIndex_vec：&#xA;修改方式：执行写回修改队列中ftqPtr那一项&#xA;&lt;ul&gt;&#xA;&lt;li&gt;valid：fromBackend中的redirect接口中，valid有效，taken有效，且ftqOffset小于或者等于cfiIndex_vec中ftqPtr那一项指定的偏移：这说明重定向发生，实际执行结果判断ftqPtr索引的指令块确实会发生跳转，且实际执行跳转的指令在被预测为发生跳转的指令之前或等于它。所以这时指令块是会发生跳转的，控制流索引队列的ftqPtr项valid&lt;/li&gt;&#xA;&lt;li&gt;bits：fromBackend中的redirect接口中，valid有效，taken有效，且ftqOffset小于cfiIndex_vec中ftqPtr那一项指定的偏移，偏移量被更新为更小值ftqOffset。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;112-修改update_target&#34;&gt;1.1.2 修改update_target&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;update_target：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftqPtr索引项的跳转目标修改为fromBackend的redirect接口中的cifUpdate中指定的target&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;113-修改mispredict_vec&#34;&gt;1.1.3 修改mispredict_vec&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;mispredict_vec：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果该重定向指令是来自后端的重定向指令， ftqPtr索引项的ftqOffset偏移指令被设置为fromBackend的redirect接口中的cifUpdate中指定的isMisPred&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;12-修改ftq最新项&#34;&gt;1.2 修改FTQ最新项&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;newest_entry_target：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;被修改为重定向接口中cfiUpdate指定的target&lt;/li&gt;&#xA;&lt;li&gt;辅助信号newest_entry_target_modified被指定为true&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;newest_entry_ptr：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;修改为重定向接口指定的ftqIdx&lt;/li&gt;&#xA;&lt;li&gt;辅助信号newest_entry_ptr_modified被指定为true&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-由ifu的写回信号修改ftq状态&#34;&gt;2. 由IFU的写回信号修改FTQ状态&lt;/h3&gt;&#xA;&lt;p&gt;IFU既然也能和后端一样生成重定向信息，那么他也能在产生重定向信息的时候修改这些状态队列和FTQ最新项，区别：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;但是，由于IFU没有真的执行，所以它的预译码结果并不能作为决定指令块是不是真的被错误预测了，所以它不能修改mispredict_vec的状态&lt;/li&gt;&#xA;&lt;li&gt;其次，后端重定向优先级永远高于IFU重定向，两者同时发生时只采用后端重定向。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;所以这个部分也有以下测试点：&lt;/p&gt;&#xA;&lt;h4 id=&#34;211-修改cfiindex_vec&#34;&gt;2.1.1 修改cfiIndex_vec&lt;/h4&gt;&#xA;&lt;h4 id=&#34;212-修改update_target&#34;&gt;2.1.2 修改update_target&lt;/h4&gt;&#xA;&lt;h4 id=&#34;22-修改ftq最新项&#34;&gt;2.2 修改FTQ最新项&lt;/h4&gt;&#xA;&lt;h2 id=&#34;常量说明&#34;&gt;常量说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;常量名&lt;/th&gt;&#xA;          &lt;th&gt;常量值&lt;/th&gt;&#xA;          &lt;th&gt;解释&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;常量1&lt;/td&gt;&#xA;          &lt;td&gt;64&lt;/td&gt;&#xA;          &lt;td&gt;常量1解释&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;常量2&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;常量2解释&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;常量3&lt;/td&gt;&#xA;          &lt;td&gt;16&lt;/td&gt;&#xA;          &lt;td&gt;常量3解释&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;顶层IO&lt;/th&gt;&#xA;          &lt;th&gt;子接口&lt;/th&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;fromBackend&lt;/td&gt;&#xA;          &lt;td&gt;redirect&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;测试点总表&#34;&gt;测试点总表&lt;/h2&gt;&#xA;&lt;p&gt;实际使用下面的表格时，请用有意义的英文大写的功能名称和测试点名称替换下面表格中的名称&lt;/p&gt;</description>
    </item>
    <item>
      <title>冲刷指针和状态队列</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/10_flushptrandstatequeue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/10_flushptrandstatequeue/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;之前讲了，后端和IFU重定向写回会修改一些状态队列。此外，FtqPtr也是一种比较重要的维护信息。由后端或者IFU引起的重定向，需要恢复各种类型用来索引FTQ项的FtqPtr。而当重定向是由后端发起的时候，还要修改提交状态队列，说明指令已经被执行。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;FTQ指针&lt;/td&gt;&#xA;          &lt;td&gt;用来索引FTQ项，有不同类型的FTQ指针，比如bpuPtr，ifuPtr&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;flush&lt;/td&gt;&#xA;          &lt;td&gt;冲刷，发生时需要重置FTQ指针，以及重置其他状态&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;融合指令&lt;/td&gt;&#xA;          &lt;td&gt;一条指令可以和其他指令融合，形成融合指令&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-冲刷ftq指针及提交状态队列&#34;&gt;1. 冲刷FTQ指针及提交状态队列&lt;/h3&gt;&#xA;&lt;h4 id=&#34;流程&#34;&gt;流程&lt;/h4&gt;&#xA;&lt;p&gt;后端和IFU的重定向信号都会冲刷指针，更具体的来说：&lt;/p&gt;&#xA;&lt;h4 id=&#34;11-冲刷条件&#34;&gt;1.1 冲刷条件&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;后端写回接口fromBackend有效，或者IFU重定向有效：（当预译码写回pdWb有效，且pdWb的missOffset字段有效表明存在预测错误的指令，同时后端冲刷信号backendFlush无效）。（参考：从IFU重定向的第一个周期，重定向valid值有效条件）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;12-冲刷指针&#34;&gt;1.2 冲刷指针&lt;/h4&gt;&#xA;&lt;p&gt;第一个周期：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;冲刷指针：确认后端和IFU的重定向信号可能冲刷指针时，从两个重定向来源的redirect接口读出重定向信息，包括ftqIdx，ftqOffset，重定向等级RedirectLevel。有两个来源时，优先后端的重定向信息。&#xA;冲刷指针列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;bpuPtr：ftqIdx+1&lt;/li&gt;&#xA;&lt;li&gt;ifuPtr：ftqIdx+1&lt;/li&gt;&#xA;&lt;li&gt;ifuWbPtr：ftqIdx+1&lt;/li&gt;&#xA;&lt;li&gt;pfPtr：ftqIdx+1&#xA;&lt;em&gt;注：只是在当前周期向指针寄存器写入更新信息，实际生效是在下一个周期。&lt;/em&gt;&#xA;这样一来，所有类型指针当前指向的都是发生重定向的指令块的下一项了，我们从这一项开始重新进行分支预测，预译码，等等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;13-冲刷提交状态队列&#34;&gt;1.3 冲刷提交状态队列&lt;/h4&gt;&#xA;&lt;p&gt;第二个周期：&#xA;如果上一个周期的重定向来源是后端，FTQ会进一步更改提交状态队列&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提交状态队列中，对于重定向的指令块（通过ftqIdx索引），位于ftqOffset后面的指令的状态被设置为c_empty&lt;/li&gt;&#xA;&lt;li&gt;对于正好处于ftqOffset的指令，判断RedirectLevel，低表示在本位置后flush，高表示在本位置flush，所以level为高时，对于的指令提交状态被设置为flush。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-转发到顶层io&#34;&gt;2 转发到顶层IO&lt;/h3&gt;&#xA;&lt;p&gt;实际上，在发生重定向的时候，还涉及一些将重定向信息通过FTQ顶层IO接口转发给其他模块的操作，比如ICache需要flush信号取进行冲刷，IFU也需要后端的重定向信号对它进行重定向，具体来说：&#xA;在&lt;strong&gt;流程&lt;/strong&gt;的第一个周期：&lt;/p&gt;&#xA;&lt;h4 id=&#34;21-flush转发到icacheflush&#34;&gt;2.1 flush转发到icacheFlush&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;flush信号顶层IO转发（icacheFlush）：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;确认后端和IFU的重定向信号可能冲刷指针时，拉高FTQ顶层IO接口中的icacheFlush信号，把重定向产生的flush信号转发给ICache&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;22-重定向信号转发到ifu&#34;&gt;2.2 重定向信号转发到IFU&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重定向信号顶层IO转发（toIFU）：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;redirect：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;bits：接收来自后端的重定向信号&lt;/li&gt;&#xA;&lt;li&gt;valid：后端的重定向信号有效时有效，保持有效，直到下个周期依然有效&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;3-重排序缓冲区提交&#34;&gt;3 重排序缓冲区提交&lt;/h3&gt;&#xA;&lt;p&gt;其实，除了后端重定向会更新提交状态队列，最直接的更新提交状态队列的方式是通过FTQ顶层IO中frombackend里提供的提交信息，rob_commits告知我们哪些指令需要被提交。&lt;/p&gt;&#xA;&lt;p&gt;rob_commits的valid字段有效，可以根据其中信息对指令进行提交，修改状态队列。对于被执行的指令，是如何提交的，如何对应地修改提交状态队列，有两种情况：&lt;/p&gt;&#xA;&lt;h4 id=&#34;31-提交普通指令&#34;&gt;3.1 提交普通指令&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于普通指令，根据rob_commits的ftqIdx和ftqOffset索引提交状态队列中的某条指令，将对应的提交状态设置为c_commited&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;32-提交融合指令&#34;&gt;3.2 提交融合指令&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于融合指令，根据提交类型commitType对被索引的指令和另一与之融合的指令进行提交，将对应的提交状态设置为c_commited&#xA;&lt;ol&gt;&#xA;&lt;li&gt;commitType = 4：同时把被索引指令的下一条指令设为c_commited&lt;/li&gt;&#xA;&lt;li&gt;commitType = 5：同时把被索引指令的之后的第二条指令设为c_commited&lt;/li&gt;&#xA;&lt;li&gt;commitType = 6：同时把被指令块的下一个指令块的第0条指令设为c_commited&lt;/li&gt;&#xA;&lt;li&gt;commitType = 7：同时把被指令块的下一个指令块的第1条指令设为c_commited&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;顶层IO&lt;/th&gt;&#xA;          &lt;th&gt;作用&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;fromBackend&lt;/td&gt;&#xA;          &lt;td&gt;接收后端重定向和指令提交&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;fromIfu&lt;/td&gt;&#xA;          &lt;td&gt;接收IFU重定向&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;icacheFlush&lt;/td&gt;&#xA;          &lt;td&gt;将flush信号转发到icache&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;toIFU&lt;/td&gt;&#xA;          &lt;td&gt;将后端重定向转发到IFU&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;测试点总表&#34;&gt;测试点总表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;功能名称&lt;/th&gt;&#xA;          &lt;th&gt;测试点名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;          &lt;td&gt;FLUSH_FTQPTR_AND_COMMITSTATE&lt;/td&gt;&#xA;          &lt;td&gt;FLUSH_COND&lt;/td&gt;&#xA;          &lt;td&gt;后端写回接口fromBackend有效，或者IFU重定向有效时，进行冲刷&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.2&lt;/td&gt;&#xA;          &lt;td&gt;FLUSH_FTQPTR_AND_COMMITSTATE&lt;/td&gt;&#xA;          &lt;td&gt;FLUSH_FTQ_PTR&lt;/td&gt;&#xA;          &lt;td&gt;优先采用后端重定向信息冲刷FTQ指针&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.3&lt;/td&gt;&#xA;          &lt;td&gt;FLUSH_FTQPTR_AND_COMMITSTATE&lt;/td&gt;&#xA;          &lt;td&gt;FLUSH_COMMIT_STATE&lt;/td&gt;&#xA;          &lt;td&gt;发生后端重定向时，进一步修改提交状态队列&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.1&lt;/td&gt;&#xA;          &lt;td&gt;TRANSFER_TO_TOP&lt;/td&gt;&#xA;          &lt;td&gt;FLUSH&lt;/td&gt;&#xA;          &lt;td&gt;后端和IFU的重定向信号可能冲刷指针，拉高FTQ顶层IO接口中的icacheFlush信号&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.2&lt;/td&gt;&#xA;          &lt;td&gt;TRANSFER_TO_TOP&lt;/td&gt;&#xA;          &lt;td&gt;IFU&lt;/td&gt;&#xA;          &lt;td&gt;将重定向信号转发到IFU&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.1&lt;/td&gt;&#xA;          &lt;td&gt;COMMIT_BY_ROB&lt;/td&gt;&#xA;          &lt;td&gt;NORMAL&lt;/td&gt;&#xA;          &lt;td&gt;对于普通指令，根据rob_commits的ftqIdx和ftqOffset索引提交状态队列中的某条指令，将对应的提交状态设置为c_commited&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.2&lt;/td&gt;&#xA;          &lt;td&gt;COMMIT_BY_ROB&lt;/td&gt;&#xA;          &lt;td&gt;FUSION&lt;/td&gt;&#xA;          &lt;td&gt;对于融合指令，根据提交类型commitType对被索引的指令和另一与之融合的指令进行提交，将对应的提交状态设置为c_commited&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>FTQ向BPU发送更新与重定向信息</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/11_tobpu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/11_tobpu/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;FTQ将已提交指令的更新信息发往BPU进行训练，同时转发重定向信息。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;暂无&lt;/td&gt;&#xA;          &lt;td&gt;暂无&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-转发重定向&#34;&gt;1. 转发重定向&lt;/h3&gt;&#xA;&lt;p&gt;向toBPU接口进行转发：&lt;/p&gt;&#xA;&lt;h4 id=&#34;11-ifu重定向结果有效&#34;&gt;1.1 IFU重定向结果有效&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;redirctFromIFU：IFU重定向结果有效时，拉高该信号（注意：IFU重定向有效的时机有两种说法，因为IFU重定向结果生成需要两个周期，此处取后者，即，IFU重定向生成过程的第二个周期有效，也是IFU生成完整重定向结果的周期）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;12-选择后端重定向或者ifu重定向&#34;&gt;1.2 选择后端重定向或者IFU重定向&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;redirect：如果后端重定向结果fromBackendRedirect有效，选用fromBackendRedirect，否则选用IFU重定向结果ifuRedirectToBpu&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-bpu更新暂停&#34;&gt;2 BPU更新暂停&lt;/h3&gt;&#xA;&lt;p&gt;BPU的更新需要两个周期，故需要三种状态去表明我们当前的更新状态：更新的第一个周期，第二个周期，更新完成。&#xA;当发生更新的时候，会暂停FTQ对指令块的提交以及发送更新信息。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-提交指令块&#34;&gt;3 提交指令块&lt;/h3&gt;&#xA;&lt;p&gt;FTQ需要对当前comPtr指向的当前提交指令块，进行判断是否能够提交。&#xA;这个过程比较复杂。&#xA;由于 香山V2版本 的后端会在 ROB 中重新压缩 FTQ entry，因此并不能保证提交一个 entry 中的每条指令，甚至不能保证每一个 entry 都有指令提交。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;判断一个 entry 是否被提交有如下几种可能&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;robCommPtr 在 commPtr 之后（ptr更大）。也就是说，后端已经开始提交之后 entry 的指令，在 robCommPtr 指向的 entry 之前的 entry 一定都已经提交完成&lt;/li&gt;&#xA;&lt;li&gt;commitStateQueue 中的某个指令块内最后一条有效范围内指令被提交。FTQ项中该指令被提交意味着这FTQ项内的指令已经全部被提交&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在此以外，还必须要考虑到，后端存在 flush itself 的 redirect 请求，这意味着这条指令自身也需要重新执行，这包括异常、load replay 等情况。在这种情况下，这一FTQ项不应当被提交以更新 BPU，否则会导致 BPU 准确率显著下降。&lt;/p&gt;&#xA;&lt;h4 id=&#34;31-cancommit&#34;&gt;3.1 canCommit&lt;/h4&gt;&#xA;&lt;p&gt;具体来看，判断commPtr指向的指令块能否提交，如果可以提交记为canCommit。&lt;/p&gt;&#xA;&lt;p&gt;canCommit的设置条件如下：&lt;/p&gt;&#xA;&lt;h4 id=&#34;311-cond1&#34;&gt;3.1.1 COND1&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当commPtr不等于ifuWbPtr，且没有因为BPU更新而暂停，同时robCommPtr在commPtr之后。之所以要求commPtr不等于ifuWbPtr是因为，前面说过了必须先预译码写回FTQ项才能提交&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;312-cond2&#34;&gt;3.1.2 COND2&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;commitStateQueue 中commPtr对应指令块有指令处于c_toCommit 或c_committed状态。且指令块中最后一条处于c_toCommit 或c_committed状态的指令是c_committed的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这两种情况下，canCommit拉高，说明可以提交该指令块&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
