<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IFU on 万众一芯之香山处理器</title>
    <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/</link>
    <description>Recent content in IFU on 万众一芯之香山处理器</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>F3PreDecoder</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/02_f3predecoder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/02_f3predecoder/</guid>
      <description>子模块：F3PreDecoder模块简介 这个模块是从PreDecoder中时序优化出来的，负责判定CFI指令的类型&#xA;F3PreDecoder功能介绍 CFI指令类型判定 要想确定CFI指令类型，只需要分别尝试匹配JAL、JALR、BR和他们的RVC版本即可，注意，RVC的EBREAK 不应该被视为CFI指令。在匹配的过程中，自然CFI指令的类型就被甄别出来了。在这一步中，我们将所有指令分到四类brType中。&#xA;ret、call判定 然后，我们需要判断是否为call或者ret，这可以通过rd和rs的取值来考察，具体来说，RISCV的RVI指令中，提供了对rd和rs取值的约定， 当二者取到link寄存器的序号（x1为标准的返回地址寄存器，x5为备用的link寄存器），分别对应着压栈和弹栈。详细的对应情况如下：&#xA;F3PreDecoder子模块测试点和功能点 功能点1 CFI指令类型判定 要想确定CFI指令类型，只需要分别尝试匹配JAL、JALR、BR和他们的RVC版本即可，注意，RVC的EBREAK 不应该被视为CFI指令。&#xA;序号 名称 描述 1.1 非CFI判定 对传入的非CFI指令（包括RVC.EBREAK），应该判定为类型0 1.2 BR判定 对传入的BR指令，应该判定为类型1 1.3 JAL判定 对传入的JAL指令，应该判定为类型2 1.4 JALR判定 对传入的JALR指令，应该判定为类型3 功能点2 ret、call判定 然后，需要判断是否为call或者ret，这可以通过rd和rs的取值来考察。当然，首先必须得满足无条件跳转指令。&#xA;对于类型2，只有为RVC指令且目的寄存器rd为link寄存器（x1或x5）时，才为Call。&#xA;对于类型3，当rd为link寄存器时，必为Call。当rs为link寄存器且rd不为时，必为Ret。&#xA;序号 名称 描述 2.1 非CFI和BR不判定 对传入的非CFI和BR指令，都不应判定为call或者ret 2.2.1.1 RVC.JAL判定call 对传入的RVC.JAL指令，当rd设置为1或5，应当判定该指令为call 2.2.1.2 RVC.JAL例外 对传入的RVC.JAL指令，当rd设置为1和5之外的值，不应当判定该指令为call或ret 2.2.2 RVI.JAL不判定 对传入的RVI.JAL指令，无论什么情况都不能判定为call或ret 2.3 JALR和rd为link 传入JALR指令，并且rd为1或5，无论其他取值，都应判定为call 2.3 JALR且仅rs为link 传入JALR指令，rd不为1和5，rs为1或5，应判定为ret 2.3 JALR无link 对传入的JALR指令，若rd和rs均不为link，则不应判定为ret和cal 测试点汇总 序号 功能 名称 描述 1.1 CFI指令类型判定 非CFI判定 对传入的非CFI指令（包括RVC.EBREAK），应该判定为类型0 1.2 CFI指令类型判定 BR判定 对传入的BR指令，应该判定为类型1 1.</description>
    </item>
    <item>
      <title>FrontendTrigger</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/05_frontend_trigger/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/05_frontend_trigger/</guid>
      <description>FrontendTrigger子模块 该子模块的主要作用是在前端设置硬件断点和检查。&#xA;该模块的输入pc有一个隐含条件，那就是这个pc是通过ftq传递的startAddr计算出来的。&#xA;FrontendTrigger功能介绍 断点设置和断点检查 在IFU的FrontendTrigger模块里共4个Trigger，编号为0,1,6,8，每个Trigger的配置信息（断点类型、匹配地址等）保存在tdata寄存器中。&#xA;当软件向CSR寄存器tselect、tdata1/2写入特定的值时，CSR会向IFU发送tUpdate请求，更新FrontendTrigger内的tdata寄存器中的配置信息。 目前前端的Trigger仅可以配置成PC断点（mcontrol(tdata1)寄存器的select位为0；当select=1时，该Trigger将永远不会命中，且不会产生异常）。&#xA;在取指时，IFU的F3流水级会向FrontendTrigger模块发起查询并在同一周期得到结果。后者会对取指块内每一条指令在每一个Trigger上做检查， 当指令的PC和tdata2寄存器内容的关系满足mcontrol的match位所指示的关系（香山支持match位为0、2、3，对应等于、大于、小于）时， 该指令会被标记为Trigger命中，随着执行在后端产生断点异常，进入M-Mode或调试模式。&#xA;链式断点 前端的0、6、8号Trigger支持Chain功能。 当它们对应的Chain位被置时，只有当该Trigger和编号在它后面一位的Trigger同时命中，且timing配置相同时，处理器才会产生异常。其中可以和6,8号trigger实现chain功能的7,9号trigger在后端访存部件中&#xA;FrontEndTrigger测试点和功能点 功能点1 设置断点和断点检查 FrontEndTrigger目前仅支持设置PC断点，这通过设置断点的tdata1寄存器的select位为0实现。 同时，tdata2寄存器的mcontrol位负责设置指令PC和tdata2寄存器的地址需要满足的关系， 关系满足时，该指令会被标记为trigger命中。&#xA;所以，基于以上功能描述，我们需要测试：&#xA;select位为1时，断点是否永远不会触发。&#xA;select位为0时，当PC和tdata2的数据的关系满足tdata2的match位时，是否会设置断点。&#xA;select位为0时，当PC和tdata2的数据的关系不满足tdata2的match位时，断点是否一定不会触发。&#xA;综上所述，我们在这一功能点设计的测试点如下：&#xA;序号 名称 描述 1.1 select1判定 给定tdata1的select位为1，随机构造其它输入，检查断点是否没有触发 1.2.1 select0关系匹配判定 给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位匹配的输入，检查断点是否触发 1.2.2 select0关系不匹配判定 给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位不匹配的输入，检查断点是否触发 功能点2 链式断点 当某一个trigger的chain位被置后，当其后的trigger的chain位未设置，且两个trigger均命中并且两个trigger的timing相同时，后一个trigger才会触发。&#xA;对0号trigger，不需要考虑链式的情况&#xA;由此，我们可以设置几种测试点：&#xA;序号 名称 描述 2.1 chain位测试 对每个trigger，在满足PC断点触发条件的情况下，设置chain位，检查断点是否一定不触发。 2.2 timing测试 对两个trigger，仅设置前一个trigger的chain位，且两trigger的timing位不同，随机设置PC等，测试后一个trigger是否一定不触发。 2.3.1 未命中测试 对两个trigger，仅设置前一个trigger的chain位，且两trigger的timing位相同，设置后一个trigger命中而前一个未命中，检查后一个trigger是否一定不触发。 2.3.2 命中测试 对两个trigger，仅设置前一个trigger的chain位，且两trigger的timing位相同且均命中，检查后一个trigger是否触发。 测试点汇总 序号 功能 名称 描述 1.1 断点设置和检查 select1判定 给定tdata1的select位为1，随机构造其它输入，检查断点是否没有触发 1.2.1 断点设置和检查 select0关系匹配判定 给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位匹配的输入，检查断点是否触发 1.</description>
    </item>
    <item>
      <title>PredChecker</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/04_pred_checker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/04_pred_checker/</guid>
      <description>子模块：PredChecker简介 分支预测检查器PredChecker接收来自IFU的预测块信息（包括预测跳转指令在预测块的位置、预测的跳转目标、预译码得到的指令信息、指令PC以及预译码得到的跳转目标偏移等），在模块内部检查五种类型的分支预测错误。模块内部分为两个流水线stage，分别输出信息，第一个stage输出给f3阶段，用于修正预测块的指令范围和预测结果。第二个stage输出给wb阶段，用于在发现分支预测错误时产生前端重定向以及写回给FTQ正确的预测信息。&#xA;PredChecker功能介绍 JAL预测错误检查 jal指令预测错误的条件是，预测块中有一条jal指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条jal指令之后（即这条jal指令没有被预测跳转）。&#xA;RET预测错误检查 ret指令预测错误的条件是，预测块中有一条ret指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条ret指令之后（即这条ret指令没有被预测跳转）。&#xA;更新指令有效范围向量 PredChecker在检查出Jal/Ret指令预测错误时，需要重新生成指令有效范围向量，有效范围截取到Jal/Ret指令的位置，之后的bit全部置为0。 需要注意的是，jal和ret指令的错误检查都会导致指令有效范围的缩短， 所以需要重新生成指令有效范伟fixedRange，同时修复预测结果（即将原来的预测结果取消，把这个指令块的预测结果根据jal指令的位置重新生成）&#xA;非CFI预测错误检查 非CFI预测错误的条件是被预测跳转的指令根据预译码信息显示不是一条CFI指令。&#xA;无效指令预测错误检查 无效指令预测错误的条件是被预测的指令的位置根据预译码信息中的指令有效向量显示不是一条有效指令的开始。&#xA;目标地址预测错误检查 目标地址预测错误的条件是，被预测的是一条有效的jal或者branch指令，同时预测的跳转目标地址和由指令码计算得到的跳转目标不一致。&#xA;分级输出检查结果 以上PredChecker检查结果会分为两级分别输出，前面已经提到，Jal/Ret指令由于需要重新生成指令有效范围向量和重新指定预测位置， 所以需要在错误产生的当拍（F3）直接输出结果到Ibuffer用于及时更正进入后端的指令 。而由于时序的考虑，其他错误信息（比如五种错误的错误位置、正确的跳转地址等）则是等到下一拍（WB）阶段才返回给IFU做前端重定向。&#xA;PredChecker测试点和功能点 功能点1 BPU预测信息的JAL预测错误检查 PredChecker会对传入的预测块进行JAL预测错误预检查并修正指令有效范围向量和预测的跳转指令。&#xA;对这一模块的测试，我们分为两部分：正确的输入是否会误检和确有JAL检测错误的预测块输入能否检出。&#xA;对于误检，我们设计如下的测试点:&#xA;序号 名称 描述 1.1.1 误检测试1 预测块中没有JAL指令且最终预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JAL预测错误。 1.1.2 误检测试2 预测块中有JAL指令且最终预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JAL预测错误。 对于JAL预测错误的正确检验，我们设计如下的测试点：&#xA;序号 名称 描述 1.2.1 存在JAL未预测 预测块中存在JAL指令，但是最终预测信息未预测跳转，检查PredChecker是否能检测出JAL预测错误。 1.2.2 预测的JAL并非第一条 预测块中存在JAL指令，但是最终预测信息取的跳转指令在第一条JAL指令之后，检查PredChecker是否能检测出JAL预测错误。 功能点2 BPU预测信息的RET预测错误检查 PredChecker会对传入的预测块进行RET预测错误预检查并修正指令有效范围向量和新的预测结果。&#xA;和JAL预测错误类似，我们也按照误检和正检来构造。&#xA;对于误检，我们设计如下的测试点：&#xA;序号 名称 描述 2.1.1 误检测试1 预测块中没有RET指令且最终预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报RET预测错误。 2.1.2 误检测试2 预测块中有RET指令且最终预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报RET预测错误。 对于RET预测错误的正确检出，我们设计如下的测试点：&#xA;序号 名称 描述 2.2.1 存在RET未预测 预测块中存在RET指令，但是最终预测信息未预测跳转，检查PredChecker是否能检测出RET预测错误。 2.2.2 预测的跳转并非第一条 预测块中存在RET指令，但是最终预测信息取的跳转指令在第一条RET指令之后，检查PredChecker是否能检测出RET预测错误。 功能点3 更新指令有效范围向量和预测跳转的指令 PredChecker在检查出Jal/Ret指令预测错误时，需要重新生成指令有效范围向量， 有效范围截取到Jal/Ret指令的位置，之后的bit全部置为0。 同时，还需要根据每条指令的预译码信息和最终的预测信息修复预测跳转的结果。</description>
    </item>
    <item>
      <title>PreDecode</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/01_predecode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/01_predecode/</guid>
      <description>子模块：PreDecoder简介 预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。&#xA;所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。&#xA;预译码器的输出是：16x4B的拼接指令码；对每个4B指令码，该条指令是否为RVI或RVC指令（RVC指令只考虑该4B的低2B）；对每个4B指令码，该条指令的跳转偏移；两个16位的有效指令开始向量，其中第一种向量假定当前预测块的起始2字节为一条有效指令的开始，而第二种向量假定当前预测块的起始2字节为一条有效RVI指令的结束（但是由于第二种向量的前两位必然为0和1,所以编译优化后，第二种向量实际只有14个信号，表示2-15位；同理，第1种向量的第0位因为恒为1,所以也被优化）&#xA;功能介绍 指令码生成 预译码器接受来自IFU完成指令切分的17 × 2字节的初始指令码，并以4字节为窗口，2字节为步进长度， 从第1个2字节开始，直到第16个2字节，选出总共16个4字节的指令码。&#xA;预译码信息生成 预译码器根据指令码产生预译码信息，主要包括：是否是RVC指令、是否是CFI指令、 CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移。&#xA;首先是判断是否是RVC指令，RVC指令的具体格式参阅RISCV手册的描述：&#xA;其中，决定指令是否为RVC的部分在于指令的[1, 0]两位，不为3的情况下都是RVC指令。&#xA;其余的指令性质判定功能（CFI类型、是否为call和ret）被时序优化到了F3PreDecoder中，不过也可以认为是PreDecoder的一部分。&#xA;最后比较麻烦的是CFI指令的目标地址计算偏移，主要是对J和BR分支指令进行的计算，这需要综合RVI和RVC中jal和br指令的结构。 首先，是手册中对于C.J的描述&#xA;这里对imm立即数的注解是，立即数的每一位最后对应到的是偏移的哪一位。&#xA;所以，可以认为立即数是这么重组的：&#xA;instr(12) + instr(8) + instr(10, 9) + instr(6) + instr(7) + instr(2) + instr(11) +instr(5,3) + &amp;ldquo;0&amp;rdquo;&#xA;而RVI中，对于JAL指令，是这么定义的：&#xA;我们可以类似地计算立即数。&#xA;同样的，我们可以查询手册，参考BR类指令的立即数计算RVC和RVI指令对应的偏移。&#xA;PreDecoder测试点和功能点 功能点1 生成指令码 子模块：PreDecoder简介&#xA;预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。&#xA;所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。&#xA;预译码器的输出是：16x4B的拼接指令码；对每个4B指令码，该条指令是否为RVI或RVC指令（RVC指令只考虑该4B的低2B）；对每个4B指令码，该条指令的跳转偏移；两个16位的有效指令开始向量，其中第一种向量假定当前预测块的起始2字节为一条有效指令的开始，而第二种向量假定当前预测块的起始2字节为一条有效RVI指令的结束（但是由于第二种向量的前两位必然为0和1,所以编译优化后，第二种向量实际只有14个信号，表示2-15位；同理，第1种向量的第0位因为恒为1,所以也被优化） 功能介绍 指令码生成&#xA;预译码器接受来自IFU完成指令切分的17 × 2字节的初始指令码，并以4字节为窗口，2字节为步进长度， 从第1个2字节开始，直到第16个2字节，选出总共16个4字节的指令码。 预译码信息生成&#xA;预译码器根据指令码产生预译码信息，主要包括：是否是RVC指令、是否是CFI指令、 CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移。&#xA;预译码器从IFU接收完成指令切分的17 x 2 字节的初始指令码，以4字节为窗口，2字节为步进长度，选出16 x 4字节的指令码</description>
    </item>
    <item>
      <title>RVCExpander</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/03_ifu_rvc_exp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/03_ifu_rvc_exp/</guid>
      <description>子模块：RVCExpander简介 RVCExpander是IFU的子模块，负责对传入的指令进行指令扩展，并解码计算非法信息。&#xA;该模块接收的输入量是两个：一条RVC指令或者RVI指令；CSR对fs.status的使能情况。&#xA;输出量也是两个：输入指令对应的RVI指令；RVC指令是否非法。&#xA;指令扩展 如果是RVI指令，则无需扩展。&#xA;否则对RVC指令，按照手册的约定进行扩展。&#xA;非法指令判断 RVI指令永远判断为合法。&#xA;对于RVC指令的判定，详细内容参阅20240411的RISCV手册的26.8节表格列出的指令条件。&#xA;功能点和测试点 功能点1 指令扩展 RVCExpander负责接收预译码器拼接的指令码，并进行指令扩展，如果是16位RVC指令，需要按照RISCV手册的约定完成扩展&#xA;对此，我们需要随机生成RVI指令和RVC指令，送入预译码器：&#xA;序号 名称 描述 1.1 RVI指令保留 构造RVI指令传入，检查保留情况 1.2 RVC指令扩展 构造RVC指令传入，按手册检查扩展结果 功能点2 非法指令判断 RVCExpander在解析指令时，如发现指令违反了手册的约定，则需要判定该指令非法&#xA;对此，我们需要随机生成非法指令送入RVI中，并检测RVCExpander对合法位的校验；同时，我们还需要校验合法指令是否会被误判为非法指令：&#xA;此外，需要判定C.fp指令在CSR未使能fs.status的情况下，能否将这类指令判定为非法。&#xA;序号 名称 描述 2.1 常规非法指令测试 随机构造非法RVC指令传入，检查判断结果 2.2 合法指令测试 随机构造合法RVC指令传入，检查判断结果 2.3 C.fp指令测试 CSR未使能fs.status的情况下，C.fp指令应该为非法 测试点汇总 序号 功能 名称 描述 1.1 指令扩展 RVI指令保留 构造RVI指令传入，检查保留情况 1.2 指令扩展 RVC指令扩展 构造RVC指令传入，按手册检查扩展结果 2.1 非法指令判断 非法指令测试 随机构造非法RVC指令传入，检查判断结果 2.2 非法指令判断 合法指令测试 随机构造合法RVC指令传入，检查判断结果 2.3 C.fp指令测试 CSR未使能fs.status的情况下，C.fp指令应该为非法 RVC扩展辅助阅读材料 为方便参考模型的书写，在这里根据20240411版本的手册内容整理了部分指令扩展的思路。&#xA;对于RVC指令来说，op = instr(1, 0)；funct = instr(15, 13)</description>
    </item>
  </channel>
</rss>
