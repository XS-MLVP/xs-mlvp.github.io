<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>验证文档规范 on 万众一芯之香山处理器</title>
    <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/</link>
    <description>Recent content in 验证文档规范 on 万众一芯之香山处理器</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>FIFO文档模板</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/00_template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/00_template/</guid>
      <description>以下是一份验证文档的完整模板（请一定同提交的验证报告区分开来）&#xA;# 验证文档各部分说明 ## 文档概述【必填项】 在该部分对整个文档进行简约描述，例如内容概述，待验证模块的基本功能、特殊需求、特定规格、目标读者、知识前置等。目的是通过对该部分，读者便了解是否具有其感兴趣的内容。例如本文档是对验证文档的编写要求进行描述，便于多文档协作，规范验证的数据输入，特定数据标签等。 ## 术语说明 【必填项】 列出术语和关键概念解释，方便读者参考 优先解释模块专有缩写（如TLB， FIFO等），如果有缩写，请用`缩写（全称）的方式填在表格的“名称”栏目中` 对容易混淆的概念请务必明确（如虚拟地址和物理地址等） | 名称 | 定义 | | ------- | ---| | 缩写1（FULL_NAME_1）&#x9;| 描述1 | | 缩写2（FULL_NAME_2）&#x9;| 描述2 | | 概念名1&#x9;| 描述3 | ## 前置知识【可选项】 在阅读文档或进行验证之前，建议掌握一些关键前置知识，以便更深入理解相关内容。例如，在撰写LoadStoreQueue（LSQ）文档时，讲述RAW（Read After Write）违例有助于理解操作之间的依赖关系。在撰写Icache或L2Cache文档时，介绍缓存层级、替换策略和一致性模型等基本概念也有助于读者理解。如果涉及复杂算法，也应对其进行简要描述。 基本要求： 1. 该部分内容应简洁，易于理解。如篇幅较长，可将内容移至附录。 2. 针对较为复杂的内容，可以通过图像、伪代码和案例进行解释，以降低理解难度。 ## 整体框图 【可选项】 若模块含多个子模块或复杂数据流，需提供框图辅助说明 可使用Visio/Draw.io等工具绘制，导出为PNG/SVG格式； 需标注关键信号流向； 框图中子模块命名需与“子模块列表”章节严格一致。 ## 流水级示意图 【可选项】 若为复杂流水线型模块，需说明各级流水功能与时序关系 可使用Visio/Draw.io等工具绘制，导出为PNG/SVG格式； 涉及到的模块名称需要保持一致性 重要数据除了列出名称以外，还需要标明位宽等信息 ## 子模块列表 【可选项】 若模块由多个子模块组成，需在此列出 以下是IFU top文档中的一个示例： | 子模块 | 描述 | | ---------------------- | ------------------- | | [子模块1](子模块1文档位置) | 子模块1描述 | | [子模块2](子模块2文档位置) | 子模块2描述 | | [子模块3](子模块3文档位置) | 子模块3描述 | &amp;lt;mrs-functions&amp;gt; ## 模块功能说明 【必填项】 需按功能树形式逐级分解，每个功能点需对应后续测试点。 请用&amp;lt;mrs-functions&amp;gt;&amp;lt;/functions&amp;gt;包裹整个“模块功能说明”部分。 采用X.</description>
    </item>
    <item>
      <title>FIFO文档案例</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/01_fifo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/01_fifo/</guid>
      <description>以下以FIFO为例，展示了一个简单的文档案例&#xA;`timescale 1ns / 1ps module FIFO ( //data_width = 8 data depth =8 input clk, input rst_n, input wr_en, //写使能 input rd_en, //读使能 input [7:0]wdata, //写入数据输入 output [7:0]rdata, //读取数据输出 output empty, //读空标志信号 output full //写满标志信号 ); reg [7:0] rdata_reg = 8&amp;#39;d0; assign rdata = rdata_reg; reg [7:0] data [7:0]; //数据存储单元(8bit数据8个) reg [3:0] wr_ptr = 4&amp;#39;d0; //写指针 reg [3:0] rd_ptr = 4&amp;#39;d0; //读指针 wire [2:0] wr_addr; //写地址(写指针的低3位) wire [2:0] rd_addr; //读地址(读指针的低3位) assign wr_addr = wr_ptr[2:0]; assign rd_addr = rd_ptr[2:0]; always@(posedge clk or negedge rst_n)begin //写数据 if(!</description>
    </item>
    <item>
      <title>果壳Cache文档案例</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/02_nutshell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/02_nutshell/</guid>
      <description>本文档将以果壳L1Cache作为案例，展示一个具有相当复杂度的模块的验证说明文档例子（请一定同提交的验证报告区分开来）。&#xA;果壳L1Cache验证文档 文档概述 本文档针对NutShell L1Cache的验证需求撰写，通过对其功能进行描述并依据功能给出参考测试点，从而帮助验证人员编制测试用例。&#xA;果壳（NutShell）是一款由5位中国科学院大学本科生设计的基于RISC-V RV64开放指令集的顺序单发射处理器(NutShell·Github), 隶属于国科大与计算所“一生一芯”项目。而果壳Cache（NutShell Cache）是其缓存模块，采用可定制化设计（L1 Cache和L2 Cache采用相同的模板生成，只需要调整参数），具体来说，L1 Cache（指令Cache和数据Cache）大小为32KB，L2 Cache大小为128KB, 在整体结构上，果壳Cache采用三级流水的结构。&#xA;本次验证的目标是L1 Cache，即一级缓存。&#xA;术语说明 名称 定义 MMIO（Memory-Mapped Input/Output） 内存映射IO 写回 Cache需要进行替换时，会将脏替换块写回内存 关键字优先方案 缺失发生时，系统会优先获取CPU所需要的当前指令或数据所对应的字 前置知识 Cache的层次结构 Cache有三种主要的组织方式：直接映射（Direct-Mapped）Cache、组相连（Set-Associative）Cache和全相连（Fully-Associative）Cache。对于物理内存中的一个数据，如果在Cache中只有一个位置可以存放它，这就是直接映射Cache；如果有多个位置可以存放这个数据，这就是组相连Cache；如果Cache中的任何位置都可以存放这个数据，这就是全相连Cache。&#xA;直接映射Cache和全相连Cache实际上是组相连Cache的两种特殊情况。现代处理器中的Cache通常属于这三种方式中的一种。例如，翻译后备缓冲区（TLB）和Victim Cache多采用全相连结构，而普通的指令缓存（I-Cache）和数据缓存（D-Cache）则采用组相连结构。当处理器需要执行一个指令时，它会首先查找该指令是否在I-Cache中。如果在，则直接从I-Cache中读取指令并执行；如果不在，则需要从内存中读取指令到I-Cache中，再执行。与I-Cache类似，当处理器需要读取或写入数据时，会首先查找D-Cache。如果数据在D-Cache中，则直接读取或写入；如果不在，则需要从内存中加载数据到D-Cache中。与I-Cache不同的是，D-Cache需要考虑数据的一致性和写回策略。为了保证数据的一致性，当数据在D-Cache中被修改后，需要同步更新到内存中。&#xA;Cache的写入 在执行写数据时，如果只是向D-Cache中写入数据而不改变其下级存储器中的数据，就会导致D-Cache和下级存储器对于同一地址的数据不一致（non-consistent）。为了保持一致性，一般Cache在写命中状态下采用两种写入方式： （1）写通（Write Through）：数据写入D-Cache的同时也写入其下级存储器。然而，由于下级存储器的访问时间较长，而存储指令的频率较高，频繁地向这种较慢的存储器中写入数据会降低处理器的执行效率。 （2）写回（Write Back）：数据写入D-Cache后，只是在Cache line上做一个标记，并不立即将数据写入更下级的存储器。只有当Cache中这个被标记的line要被替换时，才将其写入下级存储器。这种方式能够减少向较慢存储器写入数据的频率，从而获得更好的性能。然而，这种方式会导致D-Cache和下级存储器中许多地址的数据不一致，给存储器的一致性管理带来一定的负担。&#xA;D-Cache处理写缺失一般有两种策略：&#xA;（1）非写分配（Non-Write Allocate）：直接将数据写入下级存储器，而不将其写入D-Cache。这意味着当发生写缺失时，数据会直接写入到下级存储器，而不会经过D-Cache。&#xA;（2）写分配（Write Allocate）：在发生写缺失时，会先将相应地址的整个数据块从下级存储器中读取到D-Cache中，然后再将要写入的数据合并到这个数据块中，最终将整个数据块写回到D-Cache中。这样做的好处是可以在D-Cache中进行更多的操作，但同时也增加了对内存的访问次数和延迟。 写通（Write Through）和非写分配（Non-Write Allocate）将数据直接写入下级存储器，而写回（Write Back）和写分配（Write Allocate）则会将数据写入到D-Cache中。通常情况下，D-Cache的写策略搭配为写通+非写分配或写回+写分配。&#xA;写通示意图&#xA;写通示意图&#xA;写回示意图&#xA;替换策略 读写D-Cache发生缺失时，需要从对应的Cache Set中找到一个cache行，来存放从下级存储器中读出的数据，如果此时这个Cache Set内的所有Cache行都已经被占用了，那么就需要替换掉其中一个，如何从这些有效的Cache行找到一个并替换它，这就是替换策略，本节介绍几种最常用的替换策略。&#xA;近期最少使用法会选择最近被使用次数最少的Cache行，因此这个算法需要追踪每个Cache行的使用情况，这需要为每个Cache行都设置一个年龄（age）部分，每当一个Cache行被访问时，它对应的年龄部分就会增加，或者减少其他Cache行的年龄值，这样当进行替换时，年龄值最小的那个Cache行就是被使用次数最少的了，会选择它进行替换。&#xA;随机替换算法硬件实现简单，这种方法发生缺失的频率会更高一些，但是随着Cache容量的增大，这个差距是越来越小的。在实际的设计中，很难实现严格的随机，一般采用一种称为时钟算法（clock algorithm）的方法实现近似的随机，它的工作原理本质上是一个时钟计数器，计数器的宽度由Cache的路的个数决定，当要替换时，就根据这个计数器选择相应的行进行替换。这种方法硬件复杂度较低，也不会损失较多的性能，因此是一种折中的方法。&#xA;整体框图和流水级 以下是L1Cache的整体框图和流水级示意：&#xA;子模块列表 以下是NutShell L1Cache的一些子模块：&#xA;子模块 描述 s1 缓存阶段1 s2 缓存阶段2 s3 缓存阶段3 metaArray 以数组形式存储元数据 dataArray 以数组形式存储缓存数据 arb 总线仲裁器 上下游通信总线采用SimpleBus总线，包含了req和resp两个通路，其中req通路的cmd信号表明请求的操作类型，可以通过检查该信号获得访问类型。SimpleBus总线共有七种操作类型，由于NutShell文档未涉及probe和prefetch操作，在验证中只出现五种操作：read、write、readBurst、writeBurst、writeLast，前两种为字读写，后三种为Burst读写，即一次可以操作多个字。</description>
    </item>
  </channel>
</rss>
