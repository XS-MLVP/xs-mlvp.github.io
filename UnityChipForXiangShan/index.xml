<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XiangShan UT Docs on 万众一芯之香山处理器</title>
    <link>https://xs-mlvp.github.io/UnityChipForXiangShan/</link>
    <description>Recent content in XiangShan UT Docs on 万众一芯之香山处理器</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://xs-mlvp.github.io/UnityChipForXiangShan/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>添加编译脚本</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/01_build_script/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/01_build_script/</guid>
      <description>脚本目标 在scripts目录下使用python编写对应rtl的编译文件（例如build_ut_frontend_ifu_rvc_expander.py）。&#xA;该脚本的目标是提供 RTL 到 Python DUT 的编译、目标覆盖文件，以及自定义功能等内容。&#xA;创建过程 确定文件名称 在香山昆明湖 DUT 验证进展中选择需要验证的 UT，如果没有或者进一步细化，可通过编辑configs/dutree/xiangshan-kmh.yaml自行添加。&#xA;比如，我们要验证的是前端部分的ifu模块下的rvc_expander模块，那么需要在configs/dutree/xiangshan-kmh.yaml中添加对应的部分（目前yaml中已经有该模块了，此处为举例）：&#xA;name: &amp;#34;kmh_dut&amp;#34; desc: &amp;#34;所有昆明湖DUT&amp;#34; children: - name: &amp;#34;frontend&amp;#34; desc: &amp;#34;前端模块&amp;#34; children: - name: &amp;#34;ifu&amp;#34; desc: &amp;#34;指令单元 (Instruction Fetch Unit)&amp;#34; children: - name: &amp;#34;rvc_expander&amp;#34; desc: &amp;#34;RVC指令扩充器&amp;#34; 脚本文件的命名格式如下：&#xA;scripts/build_&amp;lt;顶层模块&amp;gt;_&amp;lt;下层模块名&amp;gt;_..._&amp;lt;目标模块名&amp;gt;.py 目前本项目内置了 4 个顶层模块：&#xA;ut_frontend 前端 ut_backend 后端 ut_mem_block 访存 ut_misc 其他 其中的子模块没有ut_前缀（顶层目录有该前缀是为了和其他目录区分开）。&#xA;例如验证目标 DUT 为rvc_expander模块：&#xA;该模块是属于前端的，所以顶级模块为ut_frontend，它的下层模块为ifu，目标模块为rvc_expander。&#xA;通过刚才我们打开的yaml文件也可以知道，frontend的children 为ifu，ifu的children 为rvc_expander。 所以，需要创建的脚本名称为build_ut_frontend_ifu_rvc_expander.py。&#xA;编写 build(cfg) -&amp;gt; bool 函数 build 函数定义如下：&#xA;def build(cfg) -&amp;gt; bool: &amp;#34;&amp;#34;&amp;#34;编译DUT Args: cfg: 运行时配置，可通过它访问配置项，例如 cfg.</description>
    </item>
    <item>
      <title>构建测试环境</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/02_build_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/02_build_env/</guid>
      <description>确定目录结构 UT(Unit Test, 单元测试)所在的目录位置的层级结构应该与名称一致，例如frontend.ifu.rvc_expander应当位于ut_frontend/ifu/rvc_expander目录，且每层目录都需要有__init__.py，便于通过 python 进行import。&#xA;本章节的文件为your_module_wrapper.py（如果你的模块是rvc_expander，那么文件就是rvc_expander_wrapper.py）。&#xA;wrapper 是包装的意思，也就是我们测试中需要用到的方法封装成和dut解耦合的API提供给测试用例使用。&#xA;*注：解耦合是为了测试用例和 DUT 解耦，使得测试用例可以独立于 DUT 进行编写和调试，也就是在测试用例中，不需要知道 DUT 的具体实现细节，只需要知道如何使用 API 即可。可以参照将验证代码与DUT进行解耦&#xA;该文件应该放于ut_frontend_or_backend/top_module/your_module/env（这里依然以rvc_expander举例：rvc_expander属于前端，其顶层目录则应该是ut_frontend；rvc_expander的顶层模块是ifu，那么次级目录就是ifu;之后的就是rvc_expander自己了；最后，由于我们是在构建测试环境，再建一级env目录。将它们连起来就是：ut_frontend_or_backend/top_module/your_module/env）目录下。&#xA;ut_frontend/ifu/rvc_expander ├── classical_version │ ├── env │ │ ├── __init__.py │ │ └── rvc_expander_wrapper.py │ ├── __init__.py │ └── test_rvc_expander.py ├── __init__.py ├── README.md └── toffee_version ├── agent │ └── __init__.py ├── bundle │ └── __init__.py ├── env │ ├── __init__.py │ └── ref_rvc_expand.py ├── __init__.py └── test ├── __init__.py ├── rvc_expander_fixture.</description>
    </item>
    <item>
      <title>添加测试用例</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/03_add_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/03_add_test/</guid>
      <description>命名要求 所有测试用例文件请以test_*.py的方式进行命名，*用测试目标替换（例如test_rvc_expander.py）。所有测试用例也需要以test_前缀开头。用例名称需要具有明确意义。&#xA;命名举例如下：&#xA;def test_a(): # 不合理，无法通过a判断测试目标 pass def test_rvc_expand_16bit_full(): # 合理，可以通过用例名称大体知道测试内容 pass 使用 Assert 在每个测试用例中，都需要通过assert来判断本测试是否通过。 pytest统计的是assert语句的结果，因此assert语句需要保证能够通过。&#xA;以下内容位于ut_frontend/ifu/rvc_expander/classical_version/test_rvc_expander.py中：&#xA;def rvc_expand(rvc_expander, ref_insts, is_32bit=False, fsIsOff=False): &amp;#34;&amp;#34;&amp;#34;compare the RVC expand result with the reference Args: rvc_expander (warpper): the fixture of the RVC expander ref_insts (list[int]]): the reference instruction list &amp;#34;&amp;#34;&amp;#34; find_error = 0 for insn in ref_insts: insn_disasm = disasmbly(insn) value, instr_ex = rvc_expander.expand(insn, fsIsOff) if is_32bit: assert value == insn, &amp;#34;RVC expand error, 32bit instruction need to be the same&amp;#34; if (insn_disasm == &amp;#34;unknown&amp;#34;) and (instr_ex == 0): debug(f&amp;#34;find bad inst:{insn}, ref: 1, dut: 0&amp;#34;) find_error +=1 elif (insn_disasm !</description>
    </item>
    <item>
      <title>代码覆盖率</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</guid>
      <description>代码覆盖率是一项评价指标，它衡量了被测代码中哪些部分被执行了，哪些部分没有被执行。通过统计代码覆盖率，可以评估测试的有效性和覆盖程度。&#xA;代码覆盖率包括：&#xA;行覆盖率(line coverage): 被测代码中被执行的行数，最简单的指标，一般期望达到 100%。 条件覆盖率(branch coverage): 每一个控制结构的每个分支是否均被执行。例如，给定一个 if 语句，其 true 和 false 分支是否均被执行？ 有限状态机覆盖率(fsm coverage): 状态机所有状态是否都达到过。 翻转覆盖率(toggle coverage): 统计被测代码中被执行的翻转语句，检查电路的每个节点是否都有 0 -&amp;gt; 1 和 1 -&amp;gt; 0 的跳变。 路径覆盖率(path coverage): 检查路径的覆盖情况。在 always 语句块和 initial 语句块中，有时会使用 if &amp;hellip; else 和 case 语句，在电路结构上便会产生一系列的数据路径。。 *我们主要使用的模拟器是 Verilator,优先考虑行覆盖率。Verilator 支持覆盖率统计，因此我们在构建 DUT 时，如果要开启覆盖率统计，需要在编译选项中添加-c参数。&#xA;本项目中相关涉及位置 开启覆盖率需要在编译时（使用 picker 命令时）加上“-c”参数（参考 picker 的参数解释），同时在文件中设置启用行覆盖率，这样在使用 toffee 测试时，才能够生成覆盖率统计文件。&#xA;结合上面的描述，在本项目中也就是编译，编写和启用行覆盖率函数和测试的时候会涉及到代码覆盖率：&#xA;添加编译脚本部分 编写编译脚本&#xA;# 省略前面 if not os.path.exists(get_root_dir(&amp;#34;dut/RVCExpander&amp;#34;)): info(&amp;#34;Exporting RVCExpander.sv&amp;#34;) s, out, err = exe_cmd(f&amp;#39;picker export --cp_lib false {get_rtl_dir(&amp;#34;rtl/RVCExpander.</description>
    </item>
    <item>
      <title>功能覆盖率</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</guid>
      <description>功能覆盖率（Functional Coverage）是一种用户定义的度量标准，用于度量验证中已执行的设计规范的比例。功能覆盖率关注的是设计的功能和特性是否被测试用例覆盖到了。&#xA;反标是指将功能点与测试用例对应起来。这样，在统计时，就能看到每个功能点对应了哪些测试用例，从而方便查看哪些功能点用的测试用例多，哪些功能点用的测试用例少，有利于后期的测试用例优化。&#xA;本项目中相关涉及位置 功能覆盖率需要我们先定义了才能统计，主要是在构建测试环境的时候涉及。&#xA;在构建测试环境中：&#xA;定义功能覆盖率： 创建了功能覆盖率组,添加观察点和反标 定义必要 fixture： 把统计结果传递给 toffee-report 统计覆盖率： 添加观察点和反标 其他：&#xA;在 Test case 中使用，可以在每个测试用例里也编写一个功能点。 功能覆盖率使用流程 指定 Group 名称 测试报告通过 Group 名字和 DUT 名字进行匹配，利用 comm.UT_FCOV 获取 DUT 前缀，例如在 Python 模块ut_frontend/ifu/rvc_expander/classical_version/env/rvc_expander_wrapper.py中进行如下调用：&#xA;from comm import UT_FCOV # 本模块名为：ut_frontend.ifu.rvc_expander.classical_version.env.rvc_expander_wrapper # 通过../../../去掉了classical_version和上级模块env，rvc_expander_wrapper # UT_FCOV会默认去掉前缀 ut_ g = fc.CovGroup(UT_FCOV(&amp;#34;../../../CLASSIC&amp;#34;)) # name = UT_FCOV(&amp;#34;../../../CLASSIC&amp;#34;) name 的值为frontend.ifu.rvc_expander.CLASSIC，在最后统计结果时，会按照最长前缀匹配到目标 UT（即匹配到：frontend.ifu.rvc_expander 模块）&#xA;创建覆盖率组 使用toffee的funcov可以创建覆盖率组。&#xA;import toffee.funcov as fc # 使用上面指定的GROUP名字 g = fc.CovGroup(name) 这两步也可以合成一句g = fc.CovGroup(UT_FCOV(&amp;quot;../../../CLASSIC&amp;quot;))。 创建的g对象就表示了一个功能覆盖率组，可以使用其来提供观察点和反标。</description>
    </item>
    <item>
      <title>F3PreDecoder</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/02_f3predecoder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/02_f3predecoder/</guid>
      <description>子模块：F3PreDecoder模块简介 这个模块是从PreDecoder中时序优化出来的，负责判定CFI指令的类型&#xA;F3PreDecoder功能介绍 CFI指令类型判定 要想确定CFI指令类型，只需要分别尝试匹配JAL、JALR、BR和他们的RVC版本即可，注意，RVC的EBREAK 不应该被视为CFI指令。在匹配的过程中，自然CFI指令的类型就被甄别出来了。在这一步中，我们将所有指令分到四类brType中。&#xA;ret、call判定 然后，我们需要判断是否为call或者ret，这可以通过rd和rs的取值来考察，具体来说，RISCV的RVI指令中，提供了对rd和rs取值的约定， 当二者取到link寄存器的序号（x1为标准的返回地址寄存器，x5为备用的link寄存器），分别对应着压栈和弹栈。详细的对应情况如下：&#xA;F3PreDecoder子模块测试点和功能点 功能点1 CFI指令类型判定 要想确定CFI指令类型，只需要分别尝试匹配JAL、JALR、BR和他们的RVC版本即可，注意，RVC的EBREAK 不应该被视为CFI指令。&#xA;序号 名称 描述 1.1 非CFI判定 对传入的非CFI指令（包括RVC.EBREAK），应该判定为类型0 1.2 BR判定 对传入的BR指令，应该判定为类型1 1.3 JAL判定 对传入的JAL指令，应该判定为类型2 1.4 JALR判定 对传入的JALR指令，应该判定为类型3 功能点2 ret、call判定 然后，需要判断是否为call或者ret，这可以通过rd和rs的取值来考察。当然，首先必须得满足无条件跳转指令。&#xA;对于类型2，只有为RVC指令且目的寄存器rd为link寄存器（x1或x5）时，才为Call。&#xA;对于类型3，当rd为link寄存器时，必为Call。当rs为link寄存器且rd不为时，必为Ret。&#xA;序号 名称 描述 2.1 非CFI和BR不判定 对传入的非CFI和BR指令，都不应判定为call或者ret 2.2.1.1 RVC.JAL判定call 对传入的RVC.JAL指令，当rd设置为1或5，应当判定该指令为call 2.2.1.2 RVC.JAL例外 对传入的RVC.JAL指令，当rd设置为1和5之外的值，不应当判定该指令为call或ret 2.2.2 RVI.JAL不判定 对传入的RVI.JAL指令，无论什么情况都不能判定为call或ret 2.3 JALR和rd为link 传入JALR指令，并且rd为1或5，无论其他取值，都应判定为call 2.3 JALR且仅rs为link 传入JALR指令，rd不为1和5，rs为1或5，应判定为ret 2.3 JALR无link 对传入的JALR指令，若rd和rs均不为link，则不应判定为ret和cal 测试点汇总 序号 功能 名称 描述 1.1 CFI指令类型判定 非CFI判定 对传入的非CFI指令（包括RVC.EBREAK），应该判定为类型0 1.2 CFI指令类型判定 BR判定 对传入的BR指令，应该判定为类型1 1.</description>
    </item>
    <item>
      <title>FrontendTrigger</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/05_frontend_trigger/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/05_frontend_trigger/</guid>
      <description>FrontendTrigger子模块 该子模块的主要作用是在前端设置硬件断点和检查。&#xA;FrontendTrigger功能介绍 断点设置和断点检查 在IFU的FrontendTrigger模块里共4个Trigger，编号为0,1,6,8，每个Trigger的配置信息（断点类型、匹配地址等）保存在tdata寄存器中。&#xA;当软件向CSR寄存器tselect、tdata1/2写入特定的值时，CSR会向IFU发送tUpdate请求，更新FrontendTrigger内的tdata寄存器中的配置信息。 目前前端的Trigger仅可以配置成PC断点（mcontrol(tdata1)寄存器的select位为0；当select=1时，该Trigger将永远不会命中，且不会产生异常）。&#xA;在取指时，IFU的F3流水级会向FrontendTrigger模块发起查询并在同一周期得到结果。后者会对取指块内每一条指令在每一个Trigger上做检查， 当指令的PC和tdata2寄存器内容的关系满足mcontrol的match位所指示的关系（香山支持match位为0、2、3，对应等于、大于、小于）时， 该指令会被标记为Trigger命中，随着执行在后端产生断点异常，进入M-Mode或调试模式。&#xA;链式断点 前端的0、6、8号Trigger支持Chain功能。 当它们对应的Chain位被置时，只有当该Trigger和编号在它后面一位的Trigger同时命中，且timing配置相同时，处理器才会产生异常。其中可以和6,8号trigger实现chain功能的7,9号trigger在后端访存部件中&#xA;FrontEndTrigger测试点和功能点 功能点1 设置断点和断点检查 FrontEndTrigger目前仅支持设置PC断点，这通过设置断点的tdata1寄存器的select位为0实现。 同时，tdata2寄存器的mcontrol位负责设置指令PC和tdata2寄存器的地址需要满足的关系， 关系满足时，该指令会被标记为trigger命中。&#xA;所以，基于以上功能描述，我们需要测试：&#xA;select位为1时，断点是否永远不会触发。&#xA;select位为0时，当PC和tdata2的数据的关系满足tdata2的match位时，是否会设置断点。&#xA;select位为0时，当PC和tdata2的数据的关系不满足tdata2的match位时，断点是否一定不会触发。&#xA;综上所述，我们在这一功能点设计的测试点如下：&#xA;序号 名称 描述 1.1 select1判定 给定tdata1的select位为1，随机构造其它输入，检查断点是否没有触发 1.2.1 select0关系匹配判定 给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位匹配的输入，检查断点是否触发 1.2.2 select0关系不匹配判定 给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位不匹配的输入，检查断点是否触发 功能点2 链式断点 当某一个trigger的chain位被置后，当其后的trigger的chain位未设置，且两个trigger均命中并且两个trigger的timing相同时，后一个trigger才会触发。&#xA;对0号trigger，不需要考虑链式的情况&#xA;由此，我们可以设置几种测试点：&#xA;序号 名称 描述 2.1 chain位测试 对每个trigger，在满足PC断点触发条件的情况下，设置chain位，检查断点是否一定不触发。 2.2 timing测试 对两个trigger，仅设置前一个trigger的chain位，且两trigger的timing位不同，随机设置PC等，测试后一个trigger是否一定不触发。 2.3.1 未命中测试 对两个trigger，仅设置前一个trigger的chain位，且两trigger的timing位相同，设置后一个trigger命中而前一个未命中，检查后一个trigger是否一定不触发。 2.3.2 命中测试 对两个trigger，仅设置前一个trigger的chain位，且两trigger的timing位相同且均命中，检查后一个trigger是否触发。 测试点汇总 序号 功能 名称 描述 1.1 断点设置和检查 select1判定 给定tdata1的select位为1，随机构造其它输入，检查断点是否没有触发 1.2.1 断点设置和检查 select0关系匹配判定 给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位匹配的输入，检查断点是否触发 1.</description>
    </item>
    <item>
      <title>PredChecker</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/04_pred_checker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/04_pred_checker/</guid>
      <description>子模块：PredChecker简介 分支预测检查器PredChecker接收来自IFU的预测块信息（包括预测跳转指令在预测块的位置、预测的跳转目标、预译码得到的指令信息、指令PC以及预译码得到的跳转目标偏移等），在模块内部检查五种类型的分支预测错误。模块内部分为两个流水线stage，分别输出信息，第一个stage输出给f3阶段，用于修正预测块的指令范围和预测结果。第二个stage输出给wb阶段，用于在发现分支预测错误时产生前端重定向以及写回给FTQ正确的预测信息。&#xA;PredChecker功能介绍 JAL预测错误检查 jal指令预测错误的条件是，预测块中有一条jal指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条jal指令之后（即这条jal指令没有被预测跳转）。&#xA;RET预测错误检查 ret指令预测错误的条件是，预测块中有一条ret指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条ret指令之后（即这条ret指令没有被预测跳转）。&#xA;更新指令有效范围向量 PredChecker在检查出Jal/Ret指令预测错误时，需要重新生成指令有效范围向量，有效范围截取到Jal/Ret指令的位置，之后的bit全部置为0。 需要注意的是，jal和ret指令的错误检查都会导致指令有效范围的缩短， 所以需要重新生成指令有效范伟fixedRange，同时修复预测结果（即将原来的预测结果取消，把这个指令块的预测结果根据jal指令的位置重新生成）&#xA;非CFI预测错误检查 非CFI预测错误的条件是被预测跳转的指令根据预译码信息显示不是一条CFI指令。&#xA;无效指令预测错误检查 无效指令预测错误的条件是被预测的指令的位置根据预译码信息中的指令有效向量显示不是一条有效指令的开始。&#xA;目标地址预测错误检查 目标地址预测错误的条件是，被预测的是一条有效的jal或者branch指令，同时预测的跳转目标地址和由指令码计算得到的跳转目标不一致。&#xA;分级输出检查结果 以上PredChecker检查结果会分为两级分别输出，前面已经提到，Jal/Ret指令由于需要重新生成指令有效范围向量和重新指定预测位置， 所以需要在错误产生的当拍（F3）直接输出结果到Ibuffer用于及时更正进入后端的指令 。而由于时序的考虑，其他错误信息（比如五种错误的错误位置、正确的跳转地址等）则是等到下一拍（WB）阶段才返回给IFU做前端重定向。&#xA;PredChecker测试点和功能点 功能点1 BPU预测信息的JAL预测错误检查 PredChecker会对传入的预测块进行JAL预测错误预检查并修正指令有效范围向量和预测的跳转指令。&#xA;对这一模块的测试，我们分为两部分：正确的输入是否会误检和确有JAL检测错误的预测块输入能否检出。&#xA;对于误检，我们设计如下的测试点:&#xA;序号 名称 描述 1.1.1 误检测试1 预测块中没有JAL指令且最终预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JAL预测错误。 1.1.2 误检测试2 预测块中有JAL指令且最终预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JAL预测错误。 对于JAL预测错误的正确检验，我们设计如下的测试点：&#xA;序号 名称 描述 1.2.1 存在JAL未预测 预测块中存在JAL指令，但是最终预测信息未预测跳转，检查PredChecker是否能检测出JAL预测错误。 1.2.2 预测的JAL并非第一条 预测块中存在JAL指令，但是最终预测信息取的跳转指令在第一条JAL指令之后，检查PredChecker是否能检测出JAL预测错误。 功能点2 BPU预测信息的RET预测错误检查 PredChecker会对传入的预测块进行RET预测错误预检查并修正指令有效范围向量和新的预测结果。&#xA;和JAL预测错误类似，我们也按照误检和正检来构造。&#xA;对于误检，我们设计如下的测试点：&#xA;序号 名称 描述 2.1.1 误检测试1 预测块中没有RET指令且最终预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报RET预测错误。 2.1.2 误检测试2 预测块中有RET指令且最终预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报RET预测错误。 对于RET预测错误的正确检出，我们设计如下的测试点：&#xA;序号 名称 描述 2.2.1 存在RET未预测 预测块中存在RET指令，但是最终预测信息未预测跳转，检查PredChecker是否能检测出RET预测错误。 2.2.2 预测的跳转并非第一条 预测块中存在RET指令，但是最终预测信息取的跳转指令在第一条RET指令之后，检查PredChecker是否能检测出RET预测错误。 功能点3 更新指令有效范围向量和预测跳转的指令 PredChecker在检查出Jal/Ret指令预测错误时，需要重新生成指令有效范围向量， 有效范围截取到Jal/Ret指令的位置，之后的bit全部置为0。 同时，还需要根据每条指令的预译码信息和最终的预测信息修复预测跳转的结果。</description>
    </item>
    <item>
      <title>PreDecode</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/01_predecode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/01_predecode/</guid>
      <description>子模块：PreDecoder简介 预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。&#xA;所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。&#xA;预译码器的输出是：16x4B的拼接指令码；对每个4B指令码，该条指令是否为RVI或RVC指令（RVC指令只考虑该4B的低2B）；对每个4B指令码，该条指令的跳转偏移；两个16位的有效指令开始向量，其中第一种向量假定当前预测块的起始2字节为一条有效指令的开始，而第二种向量假定当前预测块的起始2字节为一条有效RVI指令的结束（但是由于第二种向量的前两位必然为0和1,所以编译优化后，第二种向量实际只有14个信号，表示2-15位；同理，第1种向量的第0位因为恒为1,所以也被优化）&#xA;功能介绍 指令码生成 预译码器接受来自IFU完成指令切分的17 × 2字节的初始指令码，并以4字节为窗口，2字节为步进长度， 从第1个2字节开始，直到第16个2字节，选出总共16个4字节的指令码。&#xA;预译码信息生成 预译码器根据指令码产生预译码信息，主要包括：是否是RVC指令、是否是CFI指令、 CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移。&#xA;首先是判断是否是RVC指令，RVC指令的具体格式参阅RISCV手册的描述：&#xA;其中，决定指令是否为RVC的部分在于指令的[1, 0]两位，不为3的情况下都是RVC指令。&#xA;其余的指令性质判定功能（CFI类型、是否为call和ret）被时序优化到了F3PreDecoder中，不过也可以认为是PreDecoder的一部分。&#xA;最后比较麻烦的是CFI指令的目标地址计算偏移，主要是对J和BR分支指令进行的计算，这需要综合RVI和RVC中jal和br指令的结构。 首先，是手册中对于C.J的描述&#xA;这里对imm立即数的注解是，立即数的每一位最后对应到的是偏移的哪一位。&#xA;所以，可以认为立即数是这么重组的：&#xA;instr(12) + instr(10, 9) + instr(6) + instr(7) + instr(2) + instr(11) +instr(5,3) + &amp;ldquo;0&amp;rdquo;&#xA;而RVI中，对于JAL指令，是这么定义的：&#xA;我们可以类似地计算立即数。&#xA;同样的，我们可以查询手册，参考BR类指令的立即数计算RVC和RVI指令对应的偏移。&#xA;PreDecoder测试点和功能点 功能点1 生成指令码eDecode 子模块：PreDecoder简介&#xA;预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。&#xA;所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。&#xA;预译码器的输出是：16x4B的拼接指令码；对每个4B指令码，该条指令是否为RVI或RVC指令（RVC指令只考虑该4B的低2B）；对每个4B指令码，该条指令的跳转偏移；两个16位的有效指令开始向量，其中第一种向量假定当前预测块的起始2字节为一条有效指令的开始，而第二种向量假定当前预测块的起始2字节为一条有效RVI指令的结束（但是由于第二种向量的前两位必然为0和1,所以编译优化后，第二种向量实际只有14个信号，表示2-15位；同理，第1种向量的第0位因为恒为1,所以也被优化） 功能介绍 指令码生成&#xA;预译码器接受来自IFU完成指令切分的17 × 2字节的初始指令码，并以4字节为窗口，2字节为步进长度， 从第1个2字节开始，直到第16个2字节，选出总共16个4字节的指令码。 预译码信息生成&#xA;预译码器根据指令码产生预译码信息，主要包括：是否是RVC指令、是否是CFI指令、 CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移。&#xA;预译码器从IFU接收完成指令切分的17 x 2 字节的初始指令码，以4字节为窗口，2字节为步进长度，选出16 x 4字节的指令码&#xA;我们需要随机生成初始指令码，并测试拼接的结果。&#xA;序号 名称 描述 1 拼接测试 随机生成17 x 2字节的初始指令码，检验PreDecoder拼接结果 功能点2 生成预译码信息 预译码器会根据指令码产生预译码信息，包括RVC指令的判定和CFI指令的目标地址计算偏移。</description>
    </item>
    <item>
      <title>RVCExpander</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/03_ifu_rvc_exp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/03_ifu_rvc_exp/</guid>
      <description>子模块：RVCExpander简介 RVCExpander是IFU的子模块，负责对传入的指令进行指令扩展，并解码计算非法信息。&#xA;该模块接收的输入量是两个：一条RVC指令或者RVI指令；CSR对fs.status的使能情况。&#xA;输出量也是两个：输入指令对应的RVI指令；RVC指令是否非法。&#xA;指令扩展 如果是RVI指令，则无需扩展。&#xA;否则对RVC指令，按照手册的约定进行扩展。&#xA;非法指令判断 RVI指令永远判断为合法。&#xA;对于RVC指令的判定，详细内容参阅20240411的RISCV手册的26.8节表格列出的指令条件。&#xA;功能点和测试点 功能点1 指令扩展 RVCExpander负责接收预译码器拼接的指令码，并进行指令扩展，如果是16位RVC指令，需要按照RISCV手册的约定完成扩展&#xA;对此，我们需要随机生成RVI指令和RVC指令，送入预译码器：&#xA;序号 名称 描述 1.1 RVI指令保留 构造RVI指令传入，检查保留情况 1.2 RVC指令扩展 构造RVC指令传入，按手册检查扩展结果 功能点2 非法指令判断 RVCExpander在解析指令时，如发现指令违反了手册的约定，则需要判定该指令非法&#xA;对此，我们需要随机生成非法指令送入RVI中，并检测RVCExpander对合法位的校验；同时，我们还需要校验合法指令是否会被误判为非法指令：&#xA;此外，需要判定C.fp指令在CSR未使能fs.status的情况下，能否将这类指令判定为非法。&#xA;序号 名称 描述 2.1 常规非法指令测试 随机构造非法RVC指令传入，检查判断结果 2.2 合法指令测试 随机构造合法RVC指令传入，检查判断结果 2.3 C.fp指令测试 CSR未使能fs.status的情况下，C.fp指令应该为非法 测试点汇总 序号 功能 名称 描述 1.1 指令扩展 RVI指令保留 构造RVI指令传入，检查保留情况 1.2 指令扩展 RVC指令扩展 构造RVC指令传入，按手册检查扩展结果 2.1 非法指令判断 非法指令测试 随机构造非法RVC指令传入，检查判断结果 2.2 非法指令判断 合法指令测试 随机构造合法RVC指令传入，检查判断结果 2.3 C.fp指令测试 CSR未使能fs.status的情况下，C.fp指令应该为非法 RVC扩展辅助阅读材料 为方便参考模型的书写，在这里根据20240411版本的手册内容整理了部分指令扩展的思路。&#xA;对于RVC指令来说，op = instr(1, 0)；funct = instr(15, 13)</description>
    </item>
    <item>
      <title>目标验证单元</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/00_unitychip_for_xiangshan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/00_unitychip_for_xiangshan/</guid>
      <description>当前版本： 20241220061304-main-187577e01df03a8ff7ffc828b79070bd5e582436 20241218062220-main-a866912fc3a6df3d17b857a1a898f6f9e5c5957c 20241217100236-main-53f30b46ed6e6eeb261894c4a71a60f69777ef8c 20241216044913-main-7d081626cef0910d9490d169053ee32a8e0c51db 20241213025923-main-d09f78a58caeeb64347ca2587f1f3f2b2a59e6a0 20241212091919-main-c54c0c2e590cf334b986f8ef3eacc53329f4ed1e 20241204085334-main-335e7e0d4ffc2c7a17f8d95e7c75cbd428b14a61 20241204062337-main-f8903a8c4021ba3e310bf097b07147892729341c 20241201142531-main-365f53f574ba5c6875b3389824a3c898c642ed2b 20241129112435-main-79ccae9d5df92c4e167547564b97bd8846b7ecb6 20241129111104-main-8e0cb45a86ec3ffd779723e17ede379081431c42 查看测试报告 上图共有-个模块，默认情况下模块为灰色，当模块中的测试用例数大于-时，该模块被完全点亮。目前已经完全点亮的模块为-个，待点亮的模块有-个。&#xA;通用处理器模块简介 高性能处理器是现代计算设备的核心，它们通常由三个主要部分组成：前端、后端和访存系统。这些部分协同工作，以确保处理器能够高效地执行复杂的计算任务。&#xA;前端：前端部分，也被称为指令获取和解码阶段，负责从内存中获取指令并将其解码成处理器可以理解的格式。这一阶段是处理器性能的关键，因为它直接影响到处理器可以多快地开始执行指令。前端通常包括指令缓存、分支预测单元和指令解码器。指令缓存用于存储最近访问过的指令，以减少对主内存的访问次数，从而提高处理速度。分支预测单元则尝试预测程序中的条件分支，以便提前获取和解码后续指令，这样可以减少等待分支结果的时间。&#xA;后端：后端部分，也称为执行阶段，是处理器中负责实际执行指令的地方。这一阶段包括了算术逻辑单元（ALU）、浮点单元（FPU）和各种执行单元。这些单元负责进行算术运算、逻辑运算、数据传输和其他处理器操作。后端的设计通常非常复杂，因为它需要支持多种指令集架构（ISA）并优化性能。为了提高效率，现代处理器通常采用超标量架构，这意味着它们可以同时执行多条指令。&#xA;访存：访存系统是处理器与内存之间交互的桥梁。它包括了数据缓存、内存控制器和高速缓存一致性协议。数据缓存用于存储处理器频繁访问的数据，以减少对主内存的访问次数。内存控制器负责管理处理器与内存之间的数据传输。高速缓存一致性协议确保在多处理器系统中，所有处理器看到的内存状态是一致的。&#xA;高性能处理器的设计需要在这三个部分之间找到平衡，以实现最佳的性能。这通常涉及到复杂的微架构设计，以及对处理器流水线的优化。</description>
    </item>
    <item>
      <title>准备验证环境</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/01_verfiy_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/01_verfiy_env/</guid>
      <description>基础环境需求 本项目基于Python编程语言进行UT验证，采用的工具和测试框架为picker和toffe，环境需求如下：&#xA;Linux操作系统。建议WSL2下安装Ubuntu22.04。 Python。建议Python3.11。 picker。按照快速开始中的提示安装最新版本。 lcov 用于后续test阶段报告生成。使用包管理器即可下载：sudo apt install lcov 环境配置完成后，clone仓库：&#xA;git clone https://github.com/XS-MLVP/UnityChipForXiangShan.git cd UnityChipForXiangShan pip3 install -r requirements.txt # 安装python依赖（例如 toffee） 下载RTL代码： 默认从仓库https://github.com/XS-MLVP/UnityChipXiangShanRTLs中下载。用户也可以自行按照XiangShan文档编译生成RTL。&#xA;make rtl # 该命下载最新的rtl代码，并解压至rtl目录，并创建软连接 所有RTL下载包请在UnityChipXiangShanRTLs中查看。&#xA;RTL压缩包的命名规范为：名称-微架构-Git标记-日期编号.tar.gz，例如openxiangshan-kmh-97e37a2237-24092701.tar.gz。在使用时，仓库代码会过滤掉git标记和后缀，例如通过 cfg.rtl.version 访问到的版本号为：openxiangshan-kmh-24092701。压缩包内的目录结构为：&#xA;openxiangshan-kmh-97e37a2237-24092701.tar.gz └── rtl # 目录 |-- *.sv # 所有sv文件 `-- *.v # 所有v文件 编译DUT 该过程的目的是将RTL通过picker工具打包为Python模块。可以通过make命令指定被打包DUT，也可以一次性打包所有DUT。&#xA;如果想要自行打包某个dut，需要创建编写scripts目录中的build_ut_&amp;lt;name&amp;gt;.py脚本。这一脚本必须实现一个build方法，在打包时会被自动调用。此外还有一个line_coverage_files方法，用于指定行覆盖率参考的文件。&#xA;picker的打包支持内部信号的加入，详见picker的--internal参数，传递给其一个自定义的yaml即可。&#xA;# 调用scripts目录中的build_ut_&amp;lt;name&amp;gt;.py中的build方法，创建待验证的Python版DUT make dut DUTS=&amp;lt;name&amp;gt; # DUTS的值如果有多个，需要用逗号隔开，支持通配符。DUTS默认值为 &amp;#34;*&amp;#34;，编译所有DUT # 例如： make dut DUTS=backend_ctrl_block_decode 以make dut DUTS=backend_ctrl_block_decode为例，命令执行完成后，会在dut目录下生成对应的Python包：&#xA;dut/ ├── __init__.py ├── DecodeStage ├── Predecode └── RVCExpander 完成转换后，在测试用例代码中可以import对应的DUT，例如：</description>
    </item>
    <item>
      <title>运行测试</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/02_run_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/02_run_test/</guid>
      <description>本项目基于PyTest测试框架进行验证。运行测试时，PyTest框架自动搜索所有test_*.py文件，并自动执行其中所有以test_开头的测试用例（Test Case）。&#xA;# 执行所有ut_*目录中的test case make test_all # 执行指定目录下的test case make test target=&amp;lt;dir&amp;gt; # 例如执行ut_backend/ctrl_block/decode目录中所有的test case make test target=ut_backend/ctrl_block/decode 可通过args参数传递Pytest的运行参数，例如启动x-dist插件的多核功能：&#xA;make test args=&amp;#34;-n 4&amp;#34; # 启用 4 个进程 make test args=&amp;#34;-n auto&amp;#34; # 让框架自动选择启用多少个进程 *注：x-dist可以在多节点上并发运行测试，可参考其文档&#xA;运行完成后，默认在out/report目录会生成html版本的测试报告，其 html 文件可通过浏览器直接打开查看（VS Code IDE建议安装Open In Default Browser插件）。&#xA;运行测试主要完成以下三部分内容：&#xA;按要求运行Test Case，可通过cfg.tests中的选项进行配置 统计测试结果，输出测试报告。有toffee-report自动生成 (总测试报告，所有Test的结果合并在一起) 根据需要（cfg.doc_result.disable = True）在测试报告上进行进一步数据统计 </description>
    </item>
    <item>
      <title>如何参与本项目</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/06_join_us/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/06_join_us/</guid>
      <description>如何提交Bug 按 ISSUE 模板进行提交，标记上对应的标签（bug，bug等级等）&#xA;对应模块的维护者进行检查，并修改他给出的标记和香山分支&#xA;如何提交文档 本仓库文档以PR的形式在本仓库提交，DUT文档在仓库UnityChipForXiangShan/documents/content/zh-cn/docs/98_UT中进行提交。&#xA;本项目欢迎任何人以ISSUE、DISCUSS、Fork、PR的方式参与。&#xA;万众一芯QQ交流群：</description>
    </item>
    <item>
      <title>模板-PR</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/08_template_pr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/08_template_pr/</guid>
      <description># Description Please include a summary of the changes and the related issue. Please also include relevant motivation and context. List any dependencies that are required for this change. Fixes # (issue) ## Type of change Please delete options that are not relevant. - [ ] Bug fix (non-breaking change which fixes an issue) - [ ] New feature (non-breaking change which adds functionality) - [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected) - [ ] This change requires a documentation update # How Has This Been Tested?</description>
    </item>
    <item>
      <title>模板-ISSUE</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/09_template_issue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/09_template_issue/</guid>
      <description>## Description A brief description of the issue. ## Steps to Reproduce 1. Describe the first step 2. Describe the second step 3. Describe the third step 4. ... ## Expected Result Describe what you expected to happen. ## Actual Result Describe what actually happened. ## Screenshots If applicable, add screenshots to help explain your problem. ## Environment - OS: [e.g. Windows 10, macOS 10.15, Ubuntu 20.04] - Browser: [e.g. Chrome 86, Firefox 82, Safari 14] - Version: [e.</description>
    </item>
    <item>
      <title>模板-UT-README</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/10_template_ut_readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/10_template_ut_readme/</guid>
      <description># 模块名称 ## 测试目标 &amp;lt;测试目标、测试方法描述&amp;gt; ## 测试环境 &amp;lt;测试环境描述，依赖描述&amp;gt; ## 功能检测 &amp;lt;给出目标待测功能与对应的检测方法&amp;gt; |序号|所属模块|功能描述|检查点描述|检查标识|检查项| |-|-|-|-|-|-| |-|-|-|-|-|-| ## 验证接口 &amp;lt;接口的描述&amp;gt; ## 用例说明 #### 测试用例1 |步骤|操作内容|预期结果|覆盖功能点| |-|-|-|-| |-|-|-|-| #### 测试用例2 |步骤|操作内容|预期结果|覆盖功能点| |-|-|-|-| |-|-|-|-| ## 目录结构 &amp;lt;对本模块的目录结构进行描述&amp;gt; ## 检测列表 - [ ] 本文档符合指定[模板]()要求 - [ ] Env提供的API不包含任何DUT引脚和时序信息 - [ ] Env的API保持稳定（共有[ X ]个） - [ ] Env中对所支持的RTL版本（支持版本[ X ]）进行了检查 - [ ] 功能点（共有[ X ]个）与[设计文档]()一致 - [ ] 检查点（共有[ X ]个）覆盖所有功能点 - [ ] 检查点的输入不依赖任何DUT引脚，仅依赖Env的标准API - [ ] 所有测试用例（共有[ X ]个）都对功能检查点进行了反标 - [ ] 所有测试用例都是通过 assert 进行的结果判断 - [ ] 所有DUT或对应wrapper都是通过fixture创建 - [ ] 在上述fixture中对RTL版本进行了检查 - [ ] 创建DUT或对应wrapper的fixture进行了功能和代码行覆盖率统计 - [ ] 设置代码行覆盖率时对过滤需求进行了检查 展示效果如下：</description>
    </item>
    <item>
      <title>常用API</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/95_api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/95_api/</guid>
      <description>comm 模块 在comm中提供了部分可公用的API，可通过以下方式进行调用：&#xA;# import all from comm import * # or direct import functions you need from com import function_you_need # or access from module import comm comm.function_you_need() cfg 子模块 get_config(cfg=None) 获取当前的Config配置&#xA;输入：如果cfg不为空，则返回cfg。否则则自动通过toffee获取全局Config。 返回：Config对象 import comm cfg = comm.get_config() print(cfg.rtl.version) cfg_as_str(cfg: CfgObject): 把config对象转换为字符类型&#xA;输入：Config对象 返回：编码后的Config对象 import comm cfg_str = comm.cfg_as_str(comm.get_config()) cfg_from_str(cfg_str) 把字符类型的Config对象还原&#xA;输入：编码后的Config对象 返回：Config对象 import comm cfg = comm.cfg_from_str(cfg_str) dump_cfg(cfg: CfgObject = None, cfg_file=None) 把config对象保持到文件&#xA;输入： cfg 需要保存的config cfg_file 目标文件 import comm cfg = comm.</description>
    </item>
    <item>
      <title>其他</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/96_others/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/96_others/</guid>
      <description>测试用例管理 如果测试用例和目标RTL版本紧密相关，RTL发生变化，之前的测试用例不一定适用。此外，不同场景下有不同需求，例如验证测试环境时，不运行耗时太长的用例等。因此需要对用例进行管理，让用户能在在特定场景下跳过某些用例。为了实现该目标，我们需要通过pytest.mark.toffee_tags对于每个用例进行tag和version标记。然后在配置文件中设置需要跳过哪些tag或者只运行哪些tag的测试。&#xA;@pytest.mark.toffee_tags(&amp;#34;my_tag&amp;#34;, &amp;#34;version1 &amp;lt; version13&amp;#34;) def test_case_1(): ... 例如上述test_case_1被标记上了标签my_tag，支持版本设置为version1到version13。因此可以在配置文件中指定test.skip-tags=[&amp;quot;my_tag&amp;quot;]，来表示运行过程中跳过该用例。&#xA;pytest.mark.toffee_tags的参数说明如下：&#xA;@pytest.mark.toffee_tags( tag: Optional[list, str] = [] # 用例标签 version: Optional[list, str] = [], # 用例rtl版本需求 skip: callable = None, # 自定义是否调过该用例，skip(tag, version, item): (skip, reason) ) toffee_tags函数的参数tag支持str和list[str]类型。version参数也可以是str和list[str]类型，当为list类型时，进行精确匹配，如果为str则匹配规则如下：&#xA;name-number1 &amp;lt; namer-number2: 表示版本需要在number1和number2之间（包含边界，number表示数字，也可以为小数，eg 1.11） name-number1+：表示number1版本以及以后的版本 name-number1-：表示number1版本以及以前的版本 如果不存在上述情况，且有*或者?表示通配符类型。其他情况为精确匹配。&#xA;预定义标签，可以在comm/constants.py中查看，例如：&#xA;# Predefined tags for test cases TAG_LONG_TIME_RUN = &amp;#34;LONG_TIME_RUN&amp;#34; # 运行时间长 TAG_SMOKE = &amp;#34;SMOKE&amp;#34; # 冒烟测试 TAG_RARELY_USED = &amp;#34;RARELY_USED&amp;#34; # 非常少用 TAG_REGRESSION = &amp;#34;REGRESSION&amp;#34; # 回归测试 TAG_PERFORMANCE = &amp;#34;PERFORMANCE&amp;#34; # 性能测试 TAG_STABILITY = &amp;#34;STABILITY&amp;#34; # 稳定测试 TAG_SECURITY = &amp;#34;SECURITY&amp;#34; # 安全测试 TAG_COMPATIBILITY = &amp;#34;COMPATIBILITY&amp;#34; # 兼容测试 TAG_OTHER = &amp;#34;OTHER&amp;#34; # 其他 TAG_CI = &amp;#34;CI&amp;#34; # 集成测试 TAG_DEBUG = &amp;#34;DEBUG&amp;#34; # 测试 TAG_DEMO = &amp;#34;DEMO&amp;#34; # demo 在默认配置中(config/_default.</description>
    </item>
    <item>
      <title>必要规范</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/97_constraint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/97_constraint/</guid>
      <description>为了方便将所有人的贡献集合在一起，需要在编码、环境、文档编写等方面采用相同的“规范”。&#xA;环境要求 python： 在python编码过程中，尽可能的采用标准库，采用兼容Python3大部分版本的通用语法（尽可能的在Python3.6 - Python3.12中通用），不要使用过旧或者过新的语法。 操作系统： 建议Ubuntu 22.04，windows下，建议使用WSL2环境。 hugo 建议版本 0.124.1（版本过旧不支持软连接） 少依赖 尽可能少的使用第三方C++/C库 picker 建议使用wheel安装picker工具和xspcomm库 测试用例 代码风格 建议采用 PEP 8 规范 build脚本 需要按DUT的命名结构进行规范命名，不然无法正确收集验证结果。例如backend.ctrl_block.decodeUT在scripts目录中对应的build文件名称应该为build_ut_backend_ctrl_block_decode.py(以固定前缀build_ut_开始，点.用下划线_进行替换)。在脚本中实现 build(cfg) -&amp;gt; bool 和 line_coverage_files(cfg) -&amp;gt; list[str] 方法。build用于编译DUT为python模块，line_coverage_files方法用于返回需要统计的代码行覆盖率文件。 用例标签 如果用例无法做到版本通用，需要用pytest.mark.toffee_tags标记支持的版本。 用例抽象 编写的测试用例输入不能出现DUT的具体引脚等强耦合内容，只能调用基于DUT之上的函数封装。例如对于加法器 adder，需要把dut的目标功能封装为 dut_wrapper.add(a: int, b: int) -&amp;gt; int, bool，在test_case中仅仅调用 sum, c = add(a, b)进行测试。 覆盖抽象 在编写功能覆盖率时，其检查点函数的输入也不能有DUT引脚。 环境抽象 对于一个验证，通常分为2部分：Test Case 和 Env （用例以外的都统一称为Env，它包含DUT、驱动、监控等），其中Env需要提供对外的功能抽象接口，不能对外呈现出太多细节。 测试说明 在每个DUT的验证环境中，需要通过README.md对该环境进行说明，例如需要对Env提供给Case的接口进行说明，目录结构说明等。 PR编写 标题 简洁明了，能概括PR的主要内容。 详细描述 详细说明PR的目的，修改的内容以及相关背景信息。入解决已有的问题需要给出链接（例如Issue）。 关联问题 在描述中关联相关问题，例如 Fixes #123，以便在合并PR时关闭关联问题。 测试 需要进行测试，并对测试结果进行描述 文档 PR涉及到的文档需要同步修改 分解 当PR涉及到的修改很多时，需要判断是否拆分成多个PR 检查清单 检查编译是否通过、代码风格是否合理、是否测试通过、是否有必要的注释等 模板 以及提供的PR模块请参考链接。 ISSUE编写 要求同上</description>
    </item>
    <item>
      <title>维护者</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/99_maintain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/99_maintain/</guid>
      <description>在提交 issue、pull request、discussion 时，如果指定对应模块的 maintainer 能更及时的得到响应。目前已有的维护人员如下（首字母排名）：&#xA;验证工具：&#xA;picker：Makiras, SFangYy, yaozhicheng toffee/toffe-test：Miical, yaozhicheng 主UT模块：&#xA;frontend：Gao-Zeyu backend: TBD mem_block: TBD misc: TBD 子UT模块：&#xA;frontend.bpu.ftb&#x9;: TBD frontend.bpu.uftb&#x9;: TBD frontend.bpu.ittage&#x9;: TBD frontend.bpu.tagesc&#x9;: FrankOu2001 frontend.bpu.ras&#x9;: TBD frontend.ftq&#x9;: TBD frontend.ibuffer&#x9;: TBD frontend.icache&#x9;: TBD frontend.ifu&#x9;: TBD frontend.instr_uncache&#x9;: TBD frontend.itlb&#x9;: TBD frontend.pmp&#x9;: TBD backend.ctrl_block.decode&#x9;: my-mayfly, TheKiteRunner24 backend.ctrl_block.rename.*: TBD backend.ctrl_block.dispatch*: TBD backend.ctrl_block.mem_ctrl: TBD backend.ctrl_block.redirect_gen: TBD backend.ctrl_block.rob: TBD backend.</description>
    </item>
    <item>
      <title>搜索结果</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/search/</guid>
      <description></description>
    </item>
  </channel>
</rss>
