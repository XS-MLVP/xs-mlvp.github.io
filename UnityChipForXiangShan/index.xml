<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XiangShan UT Docs on 万众一芯之香山处理器</title>
    <link>https://open-verify.cc/UnityChipForXiangShan/</link>
    <description>Recent content in XiangShan UT Docs on 万众一芯之香山处理器</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/UnityChipForXiangShan/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>添加编译脚本</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/01_build_script/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/01_build_script/</guid>
      <description>脚本目标 在scripts目录下使用python编写对应rtl的编译文件（例如build_ut_frontend_ifu_rvc_expander.py）。&#xA;该脚本的目标是提供 RTL 到 Python DUT 的编译、目标覆盖文件，以及自定义功能等内容。&#xA;创建过程 确定文件名称 在香山昆明湖 DUT 验证进展中选择需要验证的 UT，如果没有或者进一步细化，可通过编辑configs/dutree/xiangshan-kmh.yaml自行添加。&#xA;比如，我们要验证的是前端部分的ifu模块下的rvc_expander模块，那么需要在configs/dutree/xiangshan-kmh.yaml中添加对应的部分（目前yaml中已经有该模块了，此处为举例）：&#xA;name: &amp;#34;kmh_dut&amp;#34; desc: &amp;#34;所有昆明湖DUT&amp;#34; children: - name: &amp;#34;frontend&amp;#34; desc: &amp;#34;前端模块&amp;#34; children: - name: &amp;#34;ifu&amp;#34; desc: &amp;#34;指令单元 (Instruction Fetch Unit)&amp;#34; children: - name: &amp;#34;rvc_expander&amp;#34; desc: &amp;#34;RVC指令扩充器&amp;#34; 脚本文件的命名格式如下：&#xA;scripts/build_&amp;lt;顶层模块&amp;gt;_&amp;lt;下层模块名&amp;gt;_..._&amp;lt;目标模块名&amp;gt;.py 目前本项目内置了 4 个顶层模块：&#xA;ut_frontend 前端 ut_backend 后端 ut_mem_block 访存 ut_misc 其他 其中的子模块没有ut_前缀（顶层目录有该前缀是为了和其他目录区分开）。&#xA;例如验证目标 DUT 为rvc_expander模块：&#xA;该模块是属于前端的，所以顶级模块为ut_frontend，它的下层模块为ifu，目标模块为rvc_expander。&#xA;通过刚才我们打开的yaml文件也可以知道，frontend的children 为ifu，ifu的children 为rvc_expander。 所以，需要创建的脚本名称为build_ut_frontend_ifu_rvc_expander.py。&#xA;编写 build(cfg) -&amp;gt; bool 函数 build 函数定义如下：&#xA;def build(cfg) -&amp;gt; bool: &amp;#34;&amp;#34;&amp;#34;编译DUT Args: cfg: 运行时配置，可通过它访问配置项，例如 cfg.</description>
    </item>
    <item>
      <title>文档模板</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/00_template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/00_template/</guid>
      <description>以下是一份验证文档的完整模板（请一定同提交的验证报告区分开来）&#xA;# 验证文档各部分说明 ## 文档概述【必填项】 在该部分对整个文档进行简约描述，例如内容概述，待验证模块的基本功能、特殊需求、特定规格、目标读者、知识前置等。目的是通过对该部分，读者便了解是否具有其感兴趣的内容。例如本文档是对验证文档的编写要求进行描述，便于多文档协作，规范验证的数据输入，特定数据标签等。 ## 术语说明 【必填项】 列出术语和关键概念解释，方便读者参考 优先解释模块专有缩写（如TLB， FIFO等），如果有缩写，请用`缩写（全称）的方式填在表格的“名称”栏目中` 对容易混淆的概念请务必明确（如虚拟地址和物理地址等） | 名称 | 定义 | | ------- | ---| | 缩写1（FULL_NAME_1）&#x9;| 描述1 | | 缩写2（FULL_NAME_2）&#x9;| 描述2 | | 概念名1&#x9;| 描述3 | ## 前置知识【可选项】 在阅读文档或进行验证之前，建议掌握一些关键前置知识，以便更深入理解相关内容。例如，在撰写LoadStoreQueue（LSQ）文档时，讲述RAW（Read After Write）违例有助于理解操作之间的依赖关系。在撰写Icache或L2Cache文档时，介绍缓存层级、替换策略和一致性模型等基本概念也有助于读者理解。如果涉及复杂算法，也应对其进行简要描述。 基本要求： 1. 该部分内容应简洁，易于理解。如篇幅较长，可将内容移至附录。 2. 针对较为复杂的内容，可以通过图像、伪代码和案例进行解释，以降低理解难度。 ## 整体框图 【可选项】 若模块含多个子模块或复杂数据流，需提供框图辅助说明 可使用Visio/Draw.io等工具绘制，导出为PNG/SVG格式； 需标注关键信号流向； 框图中子模块命名需与“子模块列表”章节严格一致。 ## 流水级示意图 【可选项】 若为复杂流水线型模块，需说明各级流水功能与时序关系 可使用Visio/Draw.io等工具绘制，导出为PNG/SVG格式； 涉及到的模块名称需要保持一致性 重要数据除了列出名称以外，还需要标明位宽等信息 ## 子模块列表 【可选项】 若模块由多个子模块组成，需在此列出 以下是IFU top文档中的一个示例： | 子模块 | 描述 | | ---------------------- | ------------------- | | [子模块1](子模块1文档位置) | 子模块1描述 | | [子模块2](子模块2文档位置) | 子模块2描述 | | [子模块3](子模块3文档位置) | 子模块3描述 | &amp;lt;mrs-functions&amp;gt; ## 模块功能说明 【必填项】 需按功能树形式逐级分解，每个功能点需对应后续测试点。 请用&amp;lt;mrs-functions&amp;gt;&amp;lt;/functions&amp;gt;包裹整个“模块功能说明”部分。 采用X.</description>
    </item>
    <item>
      <title>构建测试环境</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/02_build_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/02_build_env/</guid>
      <description>确定目录结构 UT(Unit Test, 单元测试)所在的目录位置的层级结构应该与名称一致，例如frontend.ifu.rvc_expander应当位于ut_frontend/ifu/rvc_expander目录，且每层目录都需要有__init__.py，便于通过 python 进行import。&#xA;本章节的文件为your_module_wrapper.py（如果你的模块是rvc_expander，那么文件就是rvc_expander_wrapper.py）。&#xA;wrapper 是包装的意思，也就是我们测试中需要用到的方法封装成和dut解耦合的API提供给测试用例使用。&#xA;*注：解耦合是为了测试用例和 DUT 解耦，使得测试用例可以独立于 DUT 进行编写和调试，也就是在测试用例中，不需要知道 DUT 的具体实现细节，只需要知道如何使用 API 即可。可以参照将验证代码与DUT进行解耦&#xA;该文件应该放于ut_frontend_or_backend/top_module/your_module/env（这里依然以rvc_expander举例：rvc_expander属于前端，其顶层目录则应该是ut_frontend；rvc_expander的顶层模块是ifu，那么次级目录就是ifu;之后的就是rvc_expander自己了；最后，由于我们是在构建测试环境，再建一级env目录。将它们连起来就是：ut_frontend_or_backend/top_module/your_module/env）目录下。&#xA;ut_frontend/ifu/rvc_expander ├── classical_version │ ├── env │ │ ├── __init__.py │ │ └── rvc_expander_wrapper.py │ ├── __init__.py │ └── test_rvc_expander.py ├── __init__.py ├── README.md └── toffee_version ├── agent │ └── __init__.py ├── bundle │ └── __init__.py ├── env │ ├── __init__.py │ └── ref_rvc_expand.py ├── __init__.py └── test ├── __init__.py ├── rvc_expander_fixture.</description>
    </item>
    <item>
      <title>添加测试用例</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/03_add_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/03_add_test/</guid>
      <description>命名要求 所有测试用例文件请以test_*.py的方式进行命名，*用测试目标替换（例如test_rvc_expander.py）。所有测试用例也需要以test_前缀开头。用例名称需要具有明确意义。&#xA;命名举例如下：&#xA;def test_a(): # 不合理，无法通过a判断测试目标 pass def test_rvc_expand_16bit_full(): # 合理，可以通过用例名称大体知道测试内容 pass 使用 Assert 在每个测试用例中，都需要通过assert来判断本测试是否通过。 pytest统计的是assert语句的结果，因此assert语句需要保证能够通过。&#xA;以下内容位于ut_frontend/ifu/rvc_expander/classical_version/test_rvc_expander.py中：&#xA;def rvc_expand(rvc_expander, ref_insts, is_32bit=False, fsIsOff=False): &amp;#34;&amp;#34;&amp;#34;compare the RVC expand result with the reference Args: rvc_expander (warpper): the fixture of the RVC expander ref_insts (list[int]]): the reference instruction list &amp;#34;&amp;#34;&amp;#34; find_error = 0 for insn in ref_insts: insn_disasm = disasmbly(insn) value, instr_ex = rvc_expander.expand(insn, fsIsOff) if is_32bit: assert value == insn, &amp;#34;RVC expand error, 32bit instruction need to be the same&amp;#34; if (insn_disasm == &amp;#34;unknown&amp;#34;) and (instr_ex == 0): debug(f&amp;#34;find bad inst:{insn}, ref: 1, dut: 0&amp;#34;) find_error +=1 elif (insn_disasm !</description>
    </item>
    <item>
      <title>FIFO文档案例</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/01_fifo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/01_fifo/</guid>
      <description>以下以FIFO为例，展示了一个简单的文档案例&#xA;`timescale 1ns / 1ps module FIFO ( //data_width = 8 data depth =8 input clk, input rst_n, input wr_en, //写使能 input rd_en, //读使能 input [7:0]wdata, //写入数据输入 output [7:0]rdata, //读取数据输出 output empty, //读空标志信号 output full //写满标志信号 ); reg [7:0] rdata_reg = 8&amp;#39;d0; assign rdata = rdata_reg; reg [7:0] data [7:0]; //数据存储单元(8bit数据8个) reg [3:0] wr_ptr = 4&amp;#39;d0; //写指针 reg [3:0] rd_ptr = 4&amp;#39;d0; //读指针 wire [2:0] wr_addr; //写地址(写指针的低3位) wire [2:0] rd_addr; //读地址(读指针的低3位) assign wr_addr = wr_ptr[2:0]; assign rd_addr = rd_ptr[2:0]; always@(posedge clk or negedge rst_n)begin //写数据 if(!</description>
    </item>
    <item>
      <title>代码覆盖率</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</guid>
      <description>代码覆盖率是一项评价指标，它衡量了被测代码中哪些部分被执行了，哪些部分没有被执行。通过统计代码覆盖率，可以评估测试的有效性和覆盖程度。&#xA;代码覆盖率包括：&#xA;行覆盖率(line coverage): 被测代码中被执行的行数，最简单的指标，一般期望达到 100%。 条件覆盖率(branch coverage): 每一个控制结构的每个分支是否均被执行。例如，给定一个 if 语句，其 true 和 false 分支是否均被执行？ 有限状态机覆盖率(fsm coverage): 状态机所有状态是否都达到过。 翻转覆盖率(toggle coverage): 统计被测代码中被执行的翻转语句，检查电路的每个节点是否都有 0 -&amp;gt; 1 和 1 -&amp;gt; 0 的跳变。 路径覆盖率(path coverage): 检查路径的覆盖情况。在 always 语句块和 initial 语句块中，有时会使用 if &amp;hellip; else 和 case 语句，在电路结构上便会产生一系列的数据路径。。 *我们主要使用的模拟器是 Verilator,优先考虑行覆盖率。Verilator 支持覆盖率统计，因此我们在构建 DUT 时，如果要开启覆盖率统计，需要在编译选项中添加-c参数。&#xA;本项目中相关涉及位置 开启覆盖率需要在编译时（使用 picker 命令时）加上“-c”参数（参考 picker 的参数解释），同时在文件中设置启用行覆盖率，这样在使用 toffee 测试时，才能够生成覆盖率统计文件。&#xA;结合上面的描述，在本项目中也就是编译，编写和启用行覆盖率函数和测试的时候会涉及到代码覆盖率：&#xA;添加编译脚本部分 编写编译脚本&#xA;# 省略前面 if not os.path.exists(get_root_dir(&amp;#34;dut/RVCExpander&amp;#34;)): info(&amp;#34;Exporting RVCExpander.sv&amp;#34;) s, out, err = exe_cmd(f&amp;#39;picker export --cp_lib false {get_rtl_dir(&amp;#34;rtl/RVCExpander.</description>
    </item>
    <item>
      <title>功能覆盖率</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</guid>
      <description>功能覆盖率（Functional Coverage）是一种用户定义的度量标准，用于度量验证中已执行的设计规范的比例。功能覆盖率关注的是设计的功能和特性是否被测试用例覆盖到了。&#xA;反标是指将功能点与测试用例对应起来。这样，在统计时，就能看到每个功能点对应了哪些测试用例，从而方便查看哪些功能点用的测试用例多，哪些功能点用的测试用例少，有利于后期的测试用例优化。&#xA;本项目中相关涉及位置 功能覆盖率需要我们先定义了才能统计，主要是在构建测试环境的时候涉及。&#xA;在构建测试环境中：&#xA;定义功能覆盖率： 创建了功能覆盖率组,添加观察点和反标 定义必要 fixture： 把统计结果传递给 toffee-report 统计覆盖率： 添加观察点和反标 其他：&#xA;在 Test case 中使用，可以在每个测试用例里也编写一个功能点。 功能覆盖率使用流程 指定 Group 名称 测试报告通过 Group 名字和 DUT 名字进行匹配，利用 comm.UT_FCOV 获取 DUT 前缀，例如在 Python 模块ut_frontend/ifu/rvc_expander/classical_version/env/rvc_expander_wrapper.py中进行如下调用：&#xA;from comm import UT_FCOV # 本模块名为：ut_frontend.ifu.rvc_expander.classical_version.env.rvc_expander_wrapper # 通过../../../去掉了classical_version和上级模块env，rvc_expander_wrapper # UT_FCOV会默认去掉前缀 ut_ g = fc.CovGroup(UT_FCOV(&amp;#34;../../../CLASSIC&amp;#34;)) # name = UT_FCOV(&amp;#34;../../../CLASSIC&amp;#34;) name 的值为frontend.ifu.rvc_expander.CLASSIC，在最后统计结果时，会按照最长前缀匹配到目标 UT（即匹配到：frontend.ifu.rvc_expander 模块）&#xA;创建覆盖率组 使用toffee的funcov可以创建覆盖率组。&#xA;import toffee.funcov as fc # 使用上面指定的GROUP名字 g = fc.CovGroup(name) 这两步也可以合成一句g = fc.CovGroup(UT_FCOV(&amp;quot;../../../CLASSIC&amp;quot;))。 创建的g对象就表示了一个功能覆盖率组，可以使用其来提供观察点和反标。</description>
    </item>
    <item>
      <title>果壳Cache文档案例</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/02_nutshell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/02_nutshell/</guid>
      <description>本文档将以果壳L1Cache作为案例，展示一个具有相当复杂度的模块的验证说明文档例子（请一定同提交的验证报告区分开来）。&#xA;果壳L1Cache验证文档 文档概述 本文档针对NutShell L1Cache的验证需求撰写，通过对其功能进行描述并依据功能给出参考测试点，从而帮助验证人员编制测试用例。&#xA;果壳（NutShell）是一款由5位中国科学院大学本科生设计的基于RISC-V RV64开放指令集的顺序单发射处理器(NutShell·Github), 隶属于国科大与计算所“一生一芯”项目。而果壳Cache（NutShell Cache）是其缓存模块，采用可定制化设计（L1 Cache和L2 Cache采用相同的模板生成，只需要调整参数），具体来说，L1 Cache（指令Cache和数据Cache）大小为32KB，L2 Cache大小为128KB, 在整体结构上，果壳Cache采用三级流水的结构。&#xA;本次验证的目标是L1 Cache，即一级缓存。&#xA;术语说明 名称 定义 MMIO（Memory-Mapped Input/Output） 内存映射IO 写回 Cache需要进行替换时，会将脏替换块写回内存 关键字优先方案 缺失发生时，系统会优先获取CPU所需要的当前指令或数据所对应的字 前置知识 Cache的层次结构 Cache有三种主要的组织方式：直接映射（Direct-Mapped）Cache、组相连（Set-Associative）Cache和全相连（Fully-Associative）Cache。对于物理内存中的一个数据，如果在Cache中只有一个位置可以存放它，这就是直接映射Cache；如果有多个位置可以存放这个数据，这就是组相连Cache；如果Cache中的任何位置都可以存放这个数据，这就是全相连Cache。&#xA;直接映射Cache和全相连Cache实际上是组相连Cache的两种特殊情况。现代处理器中的Cache通常属于这三种方式中的一种。例如，翻译后备缓冲区（TLB）和Victim Cache多采用全相连结构，而普通的指令缓存（I-Cache）和数据缓存（D-Cache）则采用组相连结构。当处理器需要执行一个指令时，它会首先查找该指令是否在I-Cache中。如果在，则直接从I-Cache中读取指令并执行；如果不在，则需要从内存中读取指令到I-Cache中，再执行。与I-Cache类似，当处理器需要读取或写入数据时，会首先查找D-Cache。如果数据在D-Cache中，则直接读取或写入；如果不在，则需要从内存中加载数据到D-Cache中。与I-Cache不同的是，D-Cache需要考虑数据的一致性和写回策略。为了保证数据的一致性，当数据在D-Cache中被修改后，需要同步更新到内存中。&#xA;Cache的写入 在执行写数据时，如果只是向D-Cache中写入数据而不改变其下级存储器中的数据，就会导致D-Cache和下级存储器对于同一地址的数据不一致（non-consistent）。为了保持一致性，一般Cache在写命中状态下采用两种写入方式： （1）写通（Write Through）：数据写入D-Cache的同时也写入其下级存储器。然而，由于下级存储器的访问时间较长，而存储指令的频率较高，频繁地向这种较慢的存储器中写入数据会降低处理器的执行效率。 （2）写回（Write Back）：数据写入D-Cache后，只是在Cache line上做一个标记，并不立即将数据写入更下级的存储器。只有当Cache中这个被标记的line要被替换时，才将其写入下级存储器。这种方式能够减少向较慢存储器写入数据的频率，从而获得更好的性能。然而，这种方式会导致D-Cache和下级存储器中许多地址的数据不一致，给存储器的一致性管理带来一定的负担。&#xA;D-Cache处理写缺失一般有两种策略：&#xA;（1）非写分配（Non-Write Allocate）：直接将数据写入下级存储器，而不将其写入D-Cache。这意味着当发生写缺失时，数据会直接写入到下级存储器，而不会经过D-Cache。&#xA;（2）写分配（Write Allocate）：在发生写缺失时，会先将相应地址的整个数据块从下级存储器中读取到D-Cache中，然后再将要写入的数据合并到这个数据块中，最终将整个数据块写回到D-Cache中。这样做的好处是可以在D-Cache中进行更多的操作，但同时也增加了对内存的访问次数和延迟。 写通（Write Through）和非写分配（Non-Write Allocate）将数据直接写入下级存储器，而写回（Write Back）和写分配（Write Allocate）则会将数据写入到D-Cache中。通常情况下，D-Cache的写策略搭配为写通+非写分配或写回+写分配。&#xA;写通示意图&#xA;写通示意图&#xA;写回示意图&#xA;替换策略 读写D-Cache发生缺失时，需要从对应的Cache Set中找到一个cache行，来存放从下级存储器中读出的数据，如果此时这个Cache Set内的所有Cache行都已经被占用了，那么就需要替换掉其中一个，如何从这些有效的Cache行找到一个并替换它，这就是替换策略，本节介绍几种最常用的替换策略。&#xA;近期最少使用法会选择最近被使用次数最少的Cache行，因此这个算法需要追踪每个Cache行的使用情况，这需要为每个Cache行都设置一个年龄（age）部分，每当一个Cache行被访问时，它对应的年龄部分就会增加，或者减少其他Cache行的年龄值，这样当进行替换时，年龄值最小的那个Cache行就是被使用次数最少的了，会选择它进行替换。&#xA;随机替换算法硬件实现简单，这种方法发生缺失的频率会更高一些，但是随着Cache容量的增大，这个差距是越来越小的。在实际的设计中，很难实现严格的随机，一般采用一种称为时钟算法（clock algorithm）的方法实现近似的随机，它的工作原理本质上是一个时钟计数器，计数器的宽度由Cache的路的个数决定，当要替换时，就根据这个计数器选择相应的行进行替换。这种方法硬件复杂度较低，也不会损失较多的性能，因此是一种折中的方法。&#xA;整体框图和流水级 以下是L1Cache的整体框图和流水级示意：&#xA;子模块列表 以下是NutShell L1Cache的一些子模块：&#xA;子模块 描述 s1 缓存阶段1 s2 缓存阶段2 s3 缓存阶段3 metaArray 以数组形式存储元数据 dataArray 以数组形式存储缓存数据 arb 总线仲裁器 上下游通信总线采用SimpleBus总线，包含了req和resp两个通路，其中req通路的cmd信号表明请求的操作类型，可以通过检查该信号获得访问类型。SimpleBus总线共有七种操作类型，由于NutShell文档未涉及probe和prefetch操作，在验证中只出现五种操作：read、write、readBurst、writeBurst、writeLast，前两种为字读写，后三种为Burst读写，即一次可以操作多个字。</description>
    </item>
    <item>
      <title>F3PreDecoder</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/02_f3predecoder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/02_f3predecoder/</guid>
      <description>子模块：F3PreDecoder模块简介 这个模块是从PreDecoder中时序优化出来的，负责判定CFI指令的类型&#xA;F3PreDecoder功能介绍 CFI指令类型判定 要想确定CFI指令类型，只需要分别尝试匹配JAL、JALR、BR和他们的RVC版本即可，注意，RVC的EBREAK 不应该被视为CFI指令。在匹配的过程中，自然CFI指令的类型就被甄别出来了。在这一步中，我们将所有指令分到如下四类brType中：&#xA;CFI指令类型 brType类型编码 非CFI 00 branch指令 01 jal指令 10 jalr指令 11 ret、call判定 然后，我们需要判断是否为call或者ret，这可以通过rd和rs的取值来考察，具体来说，RISCV的RVI指令中，提供了对rd和rs取值的约定， 当二者取到link寄存器的序号（x1为标准的返回地址寄存器，x5为备用的link寄存器），分别对应着压栈和弹栈。详细的对应情况如下：&#xA;F3Predecoder接口说明 in_instr: 传递 16 x 4B的拼接指令码&#xA;out_pd：每条指令的预译码信息，在F3Predecoder分析得到的是brType、isCall和isRet&#xA;F3PreDecoder子模块测试点和功能点 功能点1 CFI指令类型判定 要想确定CFI指令类型，只需要分别尝试匹配JAL、JALR、BR和他们的RVC版本即可，注意，RVC的EBREAK 不应该被视为CFI指令。&#xA;序号 名称 描述 1.1 非CFI判定 对传入的非CFI指令（包括RVC.EBREAK），应该判定为类型0 1.2 BR判定 对传入的BR指令，应该判定为类型1 1.3 JAL判定 对传入的JAL指令，应该判定为类型2 1.4 JALR判定 对传入的JALR指令，应该判定为类型3 功能点2 ret、call判定 然后，需要判断是否为call或者ret，这可以通过rd和rs的取值来考察。当然，首先必须得满足无条件跳转指令。&#xA;对于类型2，只有不为RVC指令且目的寄存器rd为link寄存器（x1或x5）时，才为Call。&#xA;对于类型3，在RVI指令下，当rd为link寄存器时，必为Call。当rs为link寄存器且rd不为时，必为Ret。 在RVC指令下，对C.JALR指令，为call，对C.JR指令，当rs1为link时，为Ret&#xA;序号 名称 描述 2.1 非CFI和BR不判定 对传入的非CFI和BR指令，都不应判定为call或者ret 2.2.1.1 RVI.JAL判定call 对传入的RVI.JAL指令，当rd设置为1或5，应当判定该指令为call 2.2.1.2 RVI.JAL例外 对传入的RVI.JAL指令，当rd设置为1和5之外的值，不应当判定该指令为call或ret 2.2.2 RVC.JAL不判定 对传入的RVC.JAL指令，无论什么情况都不能判定为call或ret 2.3.1.1 RVI.JALR和rd为link 传入RVI.</description>
    </item>
    <item>
      <title>FrontendTrigger</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/05_frontend_trigger/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/05_frontend_trigger/</guid>
      <description>FrontendTrigger子模块 该子模块的主要作用是在前端设置硬件断点和检查。&#xA;该模块的输入pc有一个隐含条件，那就是这个pc是通过ftq传递的startAddr计算出来的。&#xA;FrontendTrigger功能介绍 断点设置和断点检查 在IFU的FrontendTrigger模块里共4个Trigger，编号为0,1,2,3，每个Trigger的配置信息（断点类型、匹配地址等）保存在tdata寄存器中。&#xA;当软件向CSR寄存器tselect、tdata1/2写入特定的值时，CSR会向IFU发送tUpdate请求，更新FrontendTrigger内的tdata寄存器中的配置信息。 目前前端的Trigger仅可以配置成PC断点mcontrol.tdata1寄存器的select位为0；当select=1时，该Trigger将永远不会命中，且不会产生异常）。&#xA;在取指时，IFU的F3流水级会向FrontendTrigger模块发起查询并在同一周期得到结果。后者会对取指块内每一条指令在每一个Trigger上做检查， 当指令的PC和tdata2寄存器内容的关系满足mcontrol.match位所指示的关系（香山支持match位为0、2、3，对应等于、大于等于、小于）时， 该指令会被标记为Trigger命中，随着执行在后端产生断点异常，进入M-Mode或调试模式。&#xA;链式断点 根据RISCV的debug spec，香山实现的是mcontrol6。&#xA;当它们对应的Chain位被置时，只有当该Trigger和编号在它后面一位的Trigger同时命中，且timing配置相同时（在最新的手册中，这一要求已被删除），处理器才会产生异常。&#xA;在过去（riscv-debug-spec-draft，对应 XiangShan 2024.10.05 合入的 PR#3693 前）的版本中，Chain 还需要满足两个 Trigger 的 mcontrol.timing 是相同的。而在新版（riscv-debug-spec-v1.0.0）中，mcontrol.timing 被移除。目前 XiangShan 的 scala 实现仍保留了这一位，但其值永远为 0 且不可写入，编译生成的 verilog 代码中没有这一位。&#xA;FrontendTrigger 接口说明 设计上并没有提供一个或一组对外的接口来查询某个断点的状态，因此，要在测试中检查断点状态，要么需要检查内部信号的情况（仓库中提供的构建脚本已经暴露了所有内部信号），要么通过具体执行过程中，断点的触发情况来判定。&#xA;输入接口 主要分为控制接口和执行信息（目前执行信息只有pc）&#xA;控制接口 io_frontendTrigger 本接口存储了frontendTrigger的控制信息，包含以下信号/信号组：&#xA;debugMode 当前是否处于debug模式下&#xA;tEnableVec 对FrontendTrigger的每个断点，指示其是否有效。&#xA;tUpdate 更新断点的控制信息，包含以下信号/信号组：&#xA;valid：此次更新是否有效/是否更新。&#xA;bits_addr：此次更新的是哪个断点（0~3）&#xA;bits_tdata_action：断点触发条件达成后的行为&#xA;bits_tdata_chain：断点是否链式传导&#xA;bits_tdata_matchType：断点匹配类型（等于、大于、小于三种）&#xA;bits_tdata_select：目前为止，select为0时为pc断点&#xA;bits_tdata_tdata2：用于和PC比较的基准值&#xA;triggerCanRaiseBpExp trigger是否可以引起异常&#xA;pc pc有一个隐含条件，就是16条指令的pc必定是连续的&#xA;输出接口 triggered：16条指令的断点触发情况。&#xA;FrontEndTrigger 测试点和功能点 功能点1 设置断点和断点检查 FrontEndTrigger目前仅支持设置PC断点，这通过设置断点的tdata1寄存器的select位为0实现。 同时，tdata2寄存器的mcontrol位负责设置指令PC和tdata2寄存器的地址需要满足的关系， 关系满足时，该指令会被标记为trigger命中。</description>
    </item>
    <item>
      <title>FTQ顶层</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/01_topio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/01_topio/</guid>
      <description>简述 在FTQ概述中，我们已经知道了，FTQ的作用就是多个模块交互的中转站，大致了解了它接受其他模块的哪些信息，它如何接受并存储这些信息在FTQ中，并如何把这些存储信息传递给需要的模块。 下面我们来具体了解一下FTQ与其他模块的交互接口，我们会对这种交互有一个更具体的认识。&#xA;IO一览 模块间IO fromBpu：接受BPU预测结果的接口（BpuToFtqIO） fromIfu：接受IFU预译码写回的接口（IfuToFtqIO） fromBackend：接受后端执行结果和commit信号的接口（CtrlToFtqIO） toBpu：向BPU发送训练信息和重定向信息的接口（FtqToBpuIO） toIfu：向IFU发送取值目标和重定向信息的接口（FtqToIfuIO） toICache：向ICache发送取值目标的接口（FtqToICacheIO) toBackend：向后端发送取值目标的接口（FtqToCtrlIO） toPrefetch：向Prefetch发送取值目标的接口（FtqToPrefetchIO） mmio 其他 上述是主要的IO接口，此外，还有一些用于性能统计的IO接口，比如对BPU预测正确和错误结果次数进行统计，并进行转发的IO, 还有转发BPU各预测器预测信息的IO。&#xA;BpuToFtqIO IfuToFtqIO 我们知道从IFU，我们会得到预译码信息和重定向信息，而后者其实也是从预译码信息中生成。所以从IFU到FTQ的接口主要就是用来传递预译码信息的&#xA;pdWb：IFU向FTQ写回某个FTQ项的预译码信息 接口类型：PredecodeWritebackBundle 信号列表： pc：一个分支预测块覆盖的预测范围内的所有pc 接口类型：Vec(PredictWidth, UInt(VAddrBits.W)) pd：预测范围内所有指令的预译码信息 接口类型：Vec(PredictWidth, new PreDecodeInfo) PreDecodeInfo：每条指令的预译码信息 接口类型：PreDecodeInfo 信号列表： valid：预译码有效信号 接口类型：Bool isRVC：是RVC指令 接口类型：Bool brType：跳转指令类型 接口类型：UInt(2.W) 说明：根据brType的值判断跳转指令类型 b01：对应分支指令 b10：对应jal b11：对应jalr b00：对应非控制流指令 isCall：是Call指令 接口类型：Bool isRet：是Ret指令 接口类型：Bool ftqIdx：FTQ项的索引，标记写回到哪个FTQ项 接口类型：FtqPtr ftqOffset：由BPU预测结果得到的，在该指令块中指令控制流指令的位置（指令控制流指令就是实际发生跳转的指令） 接口类型：UInt(log2Ceil(PredictWidth).W) misOffset：预译码发现发生预测错误的指令在指令块中的位置 接口类型：ValidUndirectioned(UInt(log2Ceil(PredictWidth).W)) 说明：它的valid信号拉高表示该信号有效，也就说明存在预测错误，会引发重定向 cfiOffset：由预译码结果得到的，在该指令块中指令控制流指令的位置（指令控制流指令就是实际发生跳转的指令） 接口类型：ValidUndirectioned(UInt(log2Ceil(PredictWidth).W)) target：该指令块的目标地址 接口类型：UInt(VAddrBits.W) 说明：所谓目标地址，即在指令块中有控制流指令时，控制流指令的地址，在没有控制流指令时，指令块顺序执行，该指令块最后一条指令的下一条指令 jalTarget：jal指令的跳转地址 接口类型：UInt(VAddrBits.W) instrRange：有效指令范围 接口类型：Vec(PredictWidth, Bool()) 说明：表示该条指令是不是在这个预测块的有效指令范围内（第一条有效跳转指令之前的指令） CtrlToFtqIO 后端控制块向FTQ发送指令提交信息，后端执行结果的接口。&#xA;rob_commits：一个提交宽度内的RobCommitInfo信息。 接口类型：Vec(CommitWidth, Valid(new RobCommitInfo)) 详情链接：RobCommitInfo redirect：后端提供重定向信息的接口。 接口类型：Valid(new Redirect) 详情链接：Redirect ftqIdxAhead：提前重定向的FTQ指针，将要重定向的FTQ项的指针提前发送 接口类型： Vec(BackendRedirectNum, Valid(new FtqPtr)) 说明：虽然有三个接口，但实际上只用到了第一个接口，后面两个弃用了 ftqIdxSelOH：独热码，本来是依靠该信号从提前重定向ftqIdxAhead中选择一个，但现在只有一个接口了，独热码也只有一位了。 接口类型：Valid(UInt((BackendRedirectNum).</description>
    </item>
    <item>
      <title>FTQ接收BPU分支预测结果</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/03_enqfrombpu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/03_enqfrombpu/</guid>
      <description>FTQ接收BPU分支预测结果 文档概述 BPU会将分支预测结果和meta数据发给FTQ。&#xA;从分支预测结果中，我们可以提取出分支预测块对应的取值目标，比如，一个不跨缓存行且所有指令均为RVC指令的分支预测块对应的取值目标，是从分支预测块起始地址开始的以2B为间隔的连续16条指令。 meta信息则存储了各个预测器相关的预测信息，由于BPU预测有三个流水级，每个流水级都有相应的预测器，所以只有到s3阶段才有可能收集到所有预测器的预测信息，直到此时FTQ才接受到完整的meta，这些信息会在该分支预测块的全部指令被后端提交时交给BPU进行训练 FTBEntry：严格来说，它其实也是meta的一部分，但是因为更新的时候ftb_entry需要在原来的基础上继续修改，为了不重新读一遍ftb，另外给它存储一个副本。 术语说明 名称 定义 BPU (Branch Prediction Unit) 分支预测单元 FTQ (Fetch Target Queue) 采集目标队列 IFU (Instruction Fetch Unit) 指令采集单元 RAS (Return Address Stack) 返回地址堆 FTQ Entry FTQ队列中的单个表项 模块功能说明 。 1. 新的预测块进队条件 1.1 成功接收数据 1.1.1 FTQ准备好接收信号 FTQ准备好接收信号： 当FTQ队列中元素小于FtqSize或者可以提交指令块（canCommit拉高，说明可以提交指令块，在后面的文档: FTQ向BPU发送更新信息中介绍怎么判断是否可以提交指令块）的时候，来自BPU的新的指令预测块可以进入FTQ队列，队列准备好接收新的预测块，fromBpu的resp接口ready信号拉高。 1.1.2 BPU准备好要发送的信号 BPU准备好要发送的信号： 当BPU发往FTQ的接口vaid信号拉高，表示发送信号准备好 满足以上两个条件时,fromBpu的resp接口fire，表示接口数据被成功发送到FTQ中。&#xA;1.2 允许BPU入队allowBpuIn 重定向发生时，会回滚到之前的状态，新发送的BPU预测信息自然就不需要了。允许BPU入队时不能发生重定向 1.2.1 后端重定向发生 后端重定向发生： 标志：接收后端写回信息的接口fromBackend的重定向接口redirect有效，则该周期不允许入队，如果没有发生真实提前重定向realAhdValid(参见FTQ接收后端重定向一文)，则下一个周期也不允许入队。 1.2.2 IFU重定向发生 IFU重定向发生： 标志：IFU重定向信息生成的两个周期，均不许入队（参见FTQ接收IFU重定向一文了解IFU重定向信息的生成） 只要避免上述两种重定向出现的情况，就可以允许BPU入队,即可以把发送到FTQ的数据，写入FTQ项&#xA;1.3 以BPU预测结果重定向的方式入队 上述的BPU入队方式是一个全新的预测块进队，即BPU分支预测的s1阶段结果入队，此时未发生预测结果重定向。&#xA;当BPU发生预测结果重定向时，只要允许BPU入队allowBpuIn，也可以看作预测结果入队，不过这种入队是覆写队列中已有的FTQ项，没有写入新的指令块。&#xA;BPU预测结果发生重定向的具体标志：fromBpu的resp接口的s2（s2阶段的预测信息）有效，且s2的hasRedirect拉高，表示在s2阶段发生了重定向，s3阶段重定向是一样的。 综合两种形式的BPU入队，这里称之为广义BPU入队方便区分，记为bpu_in_fire，该信号拉高，表明发生广义BPU入队。&#xA;2. 写入FTQ项 之前已经说明过了，FTQ项只是一个抽象的概念，FTQ有很多个子队列组成，它们的项共同构成一个FTQ项，所以，向FTQ中写入FTQ项，实际上就是就是把BPU的预测信息写到对应的FTQ子队列中。&#xA;FTQ主要获取以下信息作为bpu_in_resp</description>
    </item>
    <item>
      <title>FTQ接收IFU重定向</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/07_redirectfromifu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/07_redirectfromifu/</guid>
      <description>FTQ接收IFU重定向 文档概述 除了后端，IFU也会发送重定向相关消息，和后端不同，IFU的重定向信息来自于预译码写回信息。相同的是，它们都是通过BranchPredictionRedirect的接口传递重定向信息。&#xA;术语说明 名称 定义 RedirectLevel 重定向等级，重定向请求是否包括本位置，低表示在本位置后重定向，高表示在本位置重定向。它在之后决定了由重定向导致的冲刷信号是否会影响到发生重定向的指令 模块功能说明 1. IFU重定向信号生成 流程 IFU重定向是通过这个BranchPredictionRedirect接口传递的，下面来讲述IFU重定向怎么生成IFU的BranchPredictionRedirect内相应信号的，这个过程需要两个周期 信号列表： 第一个周期&#xA;1.1 IFU 重定向触发条件 valid：当预译码写回pdWb有效，且pdWb的missOffset字段有效表明存在预测错误的指令，同时后端冲刷信号backendFlush无效时，valid信号有效。 1.2 IFU生成重定向信号 ftqIdx：接收pdWb指定的ftqIdx ftqOffset：接收pdWb的missOffset的bits字段 level：RedirectLevel.flushAfter，将重定向等级设置为flushAfter BTBMissBubble：true debugIsMemVio：false debugIsCtrl：false cfiUpdate： 信号列表: pc：pdWb中记录的指令块中所有指令pc中，missOffset对应的pc pd：pdWb中记录的指令块中所有指令的pd中，missOffset对应的pd predTaken：从cfiIndex_vec子队列中读取pdWb中ftqIdx索引的项是否valid，有效说明指令块内被预测为有控制流指令。 target：pdWb中的target taken：pdWb中cfiOffset的valid字段，有效时表明预译码认为指令块中存在指令控制流指令 isMisPred：pdWb中missOffset的valid字段，有效时表明预译码认为指令块中存在预测错误的指令 第二个周期： 该周期进行的信号生成是在第一周期valid字段有效的情况下才继续的&#xA;cifUpdate： 信号列表： 重定向RAS相关信号：通过ftqIdx索引从 ftq_redirect_mem读出ftq_Redirect_SRAMEntry，把其中的所有信号直接传递给cfiUpdate的同名信号中。 target：已在第一周期写入cfiUpdate的pd有效，且isRet字段拉高，指明发生预测错误的指令本是一条Ret指令，此时，将target设置为cfiUpdate的topAddr，帮助回到发生错误之前的状态。 2. 重定向结果生效 两个周期生成完整的重定向信息后，IFU重定向信息才有效，有可能被FTQ采取，完整的IFU重定向结果记为ifuRedirectToBpu&#xA;3. IFU 冲刷信号 (ifuFlush) 指令流控制信号： ifuFlush：来自IFU的冲刷信号，主要是由IFU重定向造成的，生成IFU重定向信息的两个周期内，该信号都拉高&#xA;标志：IFU重定向信息产生接口BranchPredictionRedirect中valid有效，表示开始生成重定向信息，该周期以及下一个周期，ifuFlush拉高 接口说明 顶层IO 作用 fromIFU 接收来自IFU的预译码信息 接口时序 测试点总表 序号 功能名称 测试点名称 描述 1.1 IFU_REDIRECT IFU_REDIRECT_GRN_VALID 当预译码写回pdWb有效，且pdWb的missOffset字段有效表明存在预测错误的指令，同时后端冲刷信号backendFlush无效时，valid信号有效 1.2 IFU_REDIRECT IFU_REDIRECT_GEN 允许生成IFU重定向时，在两周期内生成具体信号 2 IFU_REDIRECT_TO_BPU IFU_REDIRECT_TO_BPU IFU重定向生成后，IFU重定向结果生效 3 IFU_FLUSH IFU_FLUSH 生成IFU重定向信息的两个周期内，ifuFlush信号都拉高 </description>
    </item>
    <item>
      <title>FTQ接收后端重定向</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/06_-redirectfrombackend/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/06_-redirectfrombackend/</guid>
      <description>FTQ接收后端重定向 文档概述 FTQ重定向信息有两个来源，分别是IFU 和 后端。两者的 重定向接口大致相似，但重定向的过程有一定区别。&#xA;对于重定向，后端有提前重定向机制，为了实现提前一拍读出在ftq中存储的重定向数据，减少redirect损失，后端会向ftq提前一拍（相对正式的后端redirect信号）传送ftqIdxAhead信号和ftqIdxSelOH信号。ftqIdxSelOH信号出现的原因，是早期版本要读多个ftqIdxAhead信号，以独热码的形式选其中一路作为最终确认的提前索引值，但现在只需要从一个端口获取ftqIdx信号了，ftqIdxAhead只能确认这一个端口了。&#xA;术语说明 名称 定义 sc_disagree 统计SC预测错误用的性能计数器中需要用到的值，SC预测器是BPU子预测器TAGE-SC预测器的一个部分 模块功能说明 1. 接收后端重定向信号 时序 1.1 提前重定向 第一个周期：&#xA;后端重定向写回时，首先会从后端到FTQ的IO接口（CtrltoFtqIO）中，看ftqIdx是不是有效信号，且此时后端正式重定向信号redirect无效(因为提前重定向会比正式重定向提前一拍，所以此时正式重定向无效)，这时，提前重定向信号aheadValid有效, 将使用提前获取的重定向ftqIdx， 1.2 真实提前重定向 第二个周期：&#xA;如果此时后端正式重定向信号有效了，且ftqIdxSelOH拉高，说明在正式重定向阶段成功对ftqIdxAhead信号进行选中，同时上一周期重定向信号aheadValid是有效的，则真实提前重定向信号realAhdValid拉高，在此时读取 1.3 存储后端重定向信号 第三个周期：&#xA;该周期会把来自后端的重定向信息的存储一份在寄存器backendRedirectReg中，具体的来说，当上一个周期后端重定向有效时，将后端重定向bits字段（存储实际内容）被写入寄存器的bits字段。 而实际决定信号是否有效的valid字段（决定该信号是否有效）则在上一周期真实提前重定向信号有效（表示确实使用了提前重定向的ftqIdx进行重定向）的情况下，被写入false，因为提前重定向发生时，我们直接使用当前的后端重定向信号交给FTQ就可以了。而不需要多保存一个周期。 真实提前重定向信号无效时，则由上一周期后端正式重定向的有效值决定，只有信号有效时，我们才需要把它存下来，之后交给FTQ。 2. 选择重定向信号 信号抉择： 是提前获取后端重定向信息还是延迟一个周期从寄存器内读取？ 真实重定向有效时，直接将后端重定向信息传递给FTQ，否则，取重定向寄存器内的信号作为重定向信息传递给FTQ，相当于晚一个周期发送重定向信息。最后被选择的重定向信息作为后端重定向结果fromBackendRedirect发送给FTQ&#xA;接下来讲讲后端重定向在这三个周期到底通过ftqIdx到底读了哪些FTQ子队列中的信息，以及怎么使用它们。&#xA;3. 整合子队列信号 3.1 读取子队列 接下来讲讲后端重定向在这三个周期到底通过ftqIdx到底读了哪些FTQ子队列中的信息，以及怎么使用它们。&#xA;后端重定向读取的子队列：&#xA;ftq_redirect_mem：FTQ会根据后端重定向提供的ftqIdx读出ftq_Redirect_SRAMEntry，借助它提供的信息重定向到之前的状态。 ftq_entry_mem：读出重定向指令块对应的FTB项 ftq_pd_mem：读出重定向指令块的预译码信息 3.1.1 发生提前重定向时，读取子队列需要两个周期 3.1.2 未发生提前重定向时，读取子队列需要三个周期 读子队列时序： 第一个周期：&#xA;提前重定向信号有效时，将子队列的读端口，读有效信号拉高，输入ftqIdxAhead的value字段作为读地址，发起读取请求。 第二个周期：&#xA;case1. 如果第一周期的提前重定向无效，而现在正式重定向有效，则在此时才拉高读有效信号，使用正式重定向接口的ftqIdx作为读取地址，发起读取请求。 case2. 真实提前重定向有效了，此时因为前一个周期已经发起读取请求，此时可以直接从子队列的读端口读出了 第三个周期&#xA;真实提前重定向无效，但至少前一个周期正式重定向发起的读取请求能保证在当前周期从子队列中读出。 3.2 将子队列信息整合到后端重定向信号 处理读取信息 FTQ会将从子队列中读出的信息整合到fromBackendRedirect中。 具体来说：&#xA;重定向redirect接口的CfiUpdateInfo接口直接接收ftq_Redirect_SRAMEntry中的同名信号。 利用fromBackendRedirect中指示的ftqOffset读取指令块预译码信息中实际跳转指令的预译码信息，该ftqOffset为后端执行过后确定的控制流指令在指令块内的偏移。 得到的预译码信息被直接连接到CfiUpdateInfo接口的pd接口中 对于读出的指令块对应的FTB项，我们可以从中得知实际执行时得到的跳转指令，是否在FTB项被预测为跳转指令，或者是被预测为jmp指令，如果是，则cfiUpdateInfo的br_hit接口或者jr_hit接口被拉高，表示对应的分支预测结果正确了。 具体来说：通过发送ftqOffset，ftb项以brIsSaved的方式判断是否br_hit，判断是否jr_hit的方式也是类似的（r_ftb_entry.isJalr &amp;amp;&amp;amp; r_ftb_entry.</description>
    </item>
    <item>
      <title>FTQ向BPU发送更新与重定向信息</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/11_tobpu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/11_tobpu/</guid>
      <description>FTQ向BPU发送更新与重定向信息 文档概述 FTQ将已提交指令的更新信息发往BPU进行训练，同时转发重定向信息。&#xA;术语说明 名称 定义 暂无 暂无 模块功能说明 1. 转发重定向 向toBPU接口进行转发：&#xA;1.1 IFU重定向结果有效 redirctFromIFU：IFU重定向结果有效时，拉高该信号（注意：IFU重定向有效的时机有两种说法，因为IFU重定向结果生成需要两个周期，此处取后者，即，IFU重定向生成过程的第二个周期有效，也是IFU生成完整重定向结果的周期） 1.2 选择后端重定向或者IFU重定向 redirect：如果后端重定向结果fromBackendRedirect有效，选用fromBackendRedirect，否则选用IFU重定向结果ifuRedirectToBpu 2 BPU更新暂停 BPU的更新需要两个周期，故需要三种状态去表明我们当前的更新状态：更新的第一个周期，第二个周期，更新完成。 当发生更新的时候，会暂停FTQ对指令块的提交以及发送更新信息。&#xA;3 提交指令块 FTQ需要对当前comPtr指向的当前提交指令块，进行判断是否能够提交。 这个过程比较复杂。 由于 香山V2版本 的后端会在 ROB 中重新压缩 FTQ entry，因此并不能保证提交一个 entry 中的每条指令，甚至不能保证每一个 entry 都有指令提交。&#xA;判断一个 entry 是否被提交有如下几种可能：&#xA;robCommPtr 在 commPtr 之后（ptr更大）。也就是说，后端已经开始提交之后 entry 的指令，在 robCommPtr 指向的 entry 之前的 entry 一定都已经提交完成 commitStateQueue 中的某个指令块内最后一条有效范围内指令被提交。FTQ项中该指令被提交意味着这FTQ项内的指令已经全部被提交 在此以外，还必须要考虑到，后端存在 flush itself 的 redirect 请求，这意味着这条指令自身也需要重新执行，这包括异常、load replay 等情况。在这种情况下，这一FTQ项不应当被提交以更新 BPU，否则会导致 BPU 准确率显著下降。&#xA;3.1 canCommit 具体来看，判断commPtr指向的指令块能否提交，如果可以提交记为canCommit。&#xA;canCommit的设置条件如下：&#xA;3.1.1 COND1 当commPtr不等于ifuWbPtr，且没有因为BPU更新而暂停，同时robCommPtr在commPtr之后。之所以要求commPtr不等于ifuWbPtr是因为，前面说过了必须先预译码写回FTQ项才能提交 3.</description>
    </item>
    <item>
      <title>FTQ向IFU发送取指目标</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/04_toifu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/04_toifu/</guid>
      <description>FTQ向IFU发送取指目标 文档概述 IFU需要取FTQ中的项进行取指令操作，同时也会简单地对指令进行解析，并写回错误的指令 FTQ发送给IFU的信号同时也需发送给ICache一份，ICache是指令缓存，帮助快速读取指令。&#xA;术语说明 ifuPtr：该寄存器信号指示了当前FTQ中需要读取的项的指针。直接发送给io.toIfu.req接口的ftqIdx。 entry_is_to_send：entry_fetch_status存储每个FTQ项的发送状态，初始化并默认为当前ifuptr指向的项对应的发送状态，后续可能因为旁路逻辑等改变 entry_ftq_offset: 从cfiIndex_vec中初始化并默认为当前ifuptr指向项的跳转指令在预测块中的偏移，后续可能因为旁路逻辑等改变 entry_next：本次取指结束后下一次取值的开始地址 pc_mem_ifu_ptr_rdata：获取ifuptr指向FTQ项的取指信息（从ftq_pc_mem的读取接口ifuPtr_rdata中获取） pc_mem_ifu_plus1_rdata：获取ifuptr+1指向FTQ项的pc相关信息（从ftq_pc_mem的读取接口ifuPtrPlus1_rdata中） copied_ifu_plus1_to_send：多个相同的复制信号，entry_fetch_status中指向ifuPtrPlus1的项是f_to_send状态或者上一周期bpu_in_fire,同时旁路bpu指针bpu_in_bypass_ptr等于ifuptr+1时，信号copied_ifu_plus1_to_send在一周期后拉高 copied_ifu_ptr_to_send：同理，只是把ifuptr+1改成了ifuptr 模块功能说明 1. 获取取指目标信息 获取取指目标有两个来源，一个是BPU写入信息时，直接将取指目标旁路出来，一种则是从存储取指目标的队列ftq_pc_mem中读取。使用前一种方式的前提，是刚好ifuPtr指向的读取项刚好就是旁路指针信号bpu_in_resp_ptr（BPU入队时写入项的ftqIdx）&#xA;旁路逻辑：pc信号在被写入存储子队列时就被旁路一份，写入信号ftq_pc_mem.io.wdata在bpu_in_fire信号拉高时被旁路到旁路信号寄存器bpu_in_bypass_buf中。同时被旁路的还有指针信号bpu_in_resp_ptr，在同样的条件下被旁路到寄存器bpu_in_bypass_ptr中 读取ftq_pc_mem: 存储pc相关的取指目标，该存储队列有多个读接口，对所有ftqptr的写入信号（比如ifuPtr_write, ifuPtrPlus1_write等）被直接连接到存储队列的读取接口，这样，在ftqPtr寄存器正式被更新时，就可以同时直接从对应的读取接口中返回对应指针的读取结果，比如ftq_pc_mem.io.ifuPtr_rdata 1.1 准备发往ICache的取指目标 有以下三种情况，分别对应测试点1.1.1，1.1.2，1.1.3&#xA;旁路生效，即旁路bpu指针等于ifuptr，且上一周期bpu输入有效结果（last_cycle_bpu_in表示上一周期bpu_in_fire）有效（也就相当于该旁路指针是有效的），此时，直接向toICache接口输入旁路pc信息bpu_in_bypass_buf 不满足情况1，但是上一周期发生ifu_fire（即FTQ发往IFU的接口发生fire），成功传输信号，此toICache中被写入pc存储子队列ftq_pc_mem中ifuptr+1对应项的结果，这是因为此时发生了ifu_fire，新的ifuptr还未来得及更新（即加1），所以直接从后一项中获取新的发送数据 前两种情况都不满足，此时toICache接口中被写入pc存储队列中ifuptr对应项的结果 1.2 提前一周期准备发往Prefetch的取指目标 有以下三种情况，分别对应测试点1.2.1，1.2.2，1.2.3 同样有三种情况：&#xA;bpu有信号写入（bpu_in_fire），同时bpu_in_resp_ptr等于pfptr的写入信号pfptr_write, （此时pfptr_write还没有正式被写入pfptr中），读取bpu向pc存储队列的写入信号wdata，下一周期写入ToPrefetch xxxptr_write：是相应FTQptr寄存器的write信号，连接到寄存器的写端口，寄存器在时钟上升沿成功写入write信号 不满足情况1，且由bpu到prefetch的接口发生fire，即bpu向预取单元成功发送信号，pc存储单元的pfPtrPlus1_rdata下一周期写入ToPrefetch接口，选择指针加1对应项的原因与toICache类似。 不满足以上两种情况：pc存储单元的pfPtr_rdata在下一周期被写入ToPrefetch接口 1.3 设置下一个发送的指令块的起始地址 有以下三种情况，分别对应测试点1.3.1，1.3.2，1.3.3&#xA;target（entry_next_addr）旁路逻辑： 有三种情况：&#xA;上一周期bpu写入信号，且旁路指针等于ifuptr： toIfu：写入旁路pc信息bpu_in_bypass_buf entry_is_to_send ：拉高 entry_next_addr ：bpu预测结果中跳转地址last_cycle_bpu_target entry_ftq_offset ：bpu预测结果中跳转指令在预测块中的偏移last_cycle_cfiIndex 不满足情况1，bpu到ifu的接口发生fire，信号成功写入 toIfu：写入pc存储队列的读出信号ifuPtrPlus1_rdata，这同样是因为ifuptr还没来得及更改，所以直接使用ifuptr+1对应项的rdata entry_is_to_send ：发送状态队列中ifuPtrPlus1对应项为f_to_send或者在上一周期bpu有写入时旁路bpu指针等于ifuptr加1，entry_is_to_send拉高。 entry_next_addr ： 如果上一周期bpu有写入且bpu旁路指针等于ifuptr+1，写入bpu旁路pc信号的startAddr字段，而这个项的pc信息还没有写入，正在pc旁路信号中，这是因为ifuptr+1对应下一个指令预测块，它的起始地址实际上就是ifuptr对应指令的预测块的跳转目标。 如果不满足该条件， ifuptr等于newest_entry_ptr: 使用newest_entry_target作为entry_next_addr，newest_entry_ptr，newest_entry_target这几个内部信号，表明我们当前队列中最新的有效的FTQ项。如之前所说，BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，在相应的文档中，对其生成方式做具体的描述。 不满足条件1：使用pc存储队列的ifuPtrPlus2_rdata.startAddr 不满足情况1，2： toIfu：写入pc存储队列的读出信号ifuPtr_rdata entry_is_to_send ：发送状态队列中ifuPtr对应项为f_to_send或者在上一周期bpu有写入时旁路bpu指针等于ifuptr entry_next_addr ： 如果上一周期bpu有写入且bpu旁路指针等于ifuptr+1，写入bpu旁路pc信号的startAddr字段。 如果不满足该条件， 1. ifuptr等于newest_entry_ptr: 使用newest_entry_target作为entry_next_addr。 2.</description>
    </item>
    <item>
      <title>FTQ向后端发送取指目标</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/08_tobackend/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/08_tobackend/</guid>
      <description>FTQ向后端发送取指目标 文档概述 pc取值目标会发给后端pc mem让他自己进行存储，之后从自己的pc mem取指，此外，最新的FTQ项和对应的跳转目标也会发给后端。&#xA;怎样算是一个最新的FTQ项，BPU最新发送的预测块可以是最新的FTQ项，其次，重定向发生时，需要回滚到发生错误预测之前的状态，从指定的FTQ项开始重新开始预测，预译码等等，这也可以是被更新的最新的FTQ项。&#xA;术语说明 名称 定义 暂无 暂无 模块功能说明 流程 1.发送取值目标到pc mem 发送时机：bpu_in_fire，即BPU向前端发送有效预测信息，或者重定向信息的时候。以此为基础之后的第二个周期，进行发送，通过将toBackend接口的pc_mem_wen设置为true的方式指明开始发送 接口信号列表： pc_mem_wen：设置为true pc_mem_waddr：接收bpu_in_fire那个周期BPU发送的ftqIdx pc_mem_wdata：接收bpu_in_fire那个周期，FTQ读取的ftq_pc_mem中的取指目标 2.更新最新的FTQ项 发送时机： 最新的FTQ项可能是由BPU写入最新预测信息造成的，发送取值目标到pc mem也是因为BPU写入最新预测信息才写入的，如果是这种情况造成的，更新FTQ项和写入pc mem的时机是一致的。 此外发生重定向时，也会进行状态回滚更新FTQ项，标志是后端接口fromBackend的重定向redirect信号有效，或者写入BPU的接口toBPU的redirctFromIFU拉高说明当前有来自IFU的重定向 （注释（可忽略）IFU重定向信号生成有两个周期，可以认为第一个周期预译码信息中missoffset有效说明IFU重定向发生，也可以认为第二个周期redirctFromIFU拉高说明重定向发生，此处取后者）。 同样是向toBackend中写入 接口信号列表： newest_entry_en：前面说的发送时机到来时，再延迟一个周期达到真正的写入时机，这时才拉高信号 newest_entry_ptr：发送时机到来时的newest_entry_ptr，在真正的写入时机写入 newest_entry_target：发送时机到来时的newest_entry_target newest_entry_ptr，newest_entry_target这几个都是同名的内部信号，如之前所说，BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，在相应的文档中，对其生成方式做具体的描述。 接口说明 顶层IO 作用 toBackend 发送取指令目标，让后端进行储存 测试点总表 序号 功能名称 测试点名称 描述 1 SEND_PC_TO_BACKEND SEND_PC 发送取值目标到pc mem 2 SEND_PC_TO_BACKEND UPDATE_NEWEST 更新最新的FTQ项 </description>
    </item>
    <item>
      <title>FTQ子队列</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/02_subqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/02_subqueue/</guid>
      <description>FTQ子队列 文档概述 在之前的介绍中，我们采用FTQ项这个术语描述描述FTQ队列中的每一个元素，实际上，这只是一种便于抽象的说法。&#xA;实际上的FTQ队列，是由好多个子队列共同构成的，一些子队列维护一类信息，另一些子队列维护另一类信息，相同ftqIdx索引的子队列信息共同构成一个完整的FTQ项。&#xA;为什么要把它们分开成多个子队列呢？因为某些模块只需要FTQ项中的某一些信息，比如IFU想要取值目标，它只需要专门存储取值目标的子队列提供的信息就行了。另外，在我们更改FTQ项的内容时，也只需要写入需要更新的子队列，比如IFU预译码写回时，只需要写回专门存储预译码信息的队列了。&#xA;下面来介绍一些FTQ的主要子队列，以及它们内部存储的数据结构。此外，FTQ还有一些存储中间状态的更小的队列&#xA;术语说明 名称 定义 暂无 暂无 子模块列表 子模块 描述 ftq_redirect_mem&#xA;重定向存储子队列，存储来自分支预测结果的重定向信息 ftq_pd_mem 预译码存储子队列，存储来自IFU的对指令块的预译码信息 ftb_entry_mem FTB项存储子队列，存储自分支预测结果中的ftb项 ftq_pc_mem 取指目标子队列，存储来自分支预测结果的取指目标 模块功能说明 1. ftq_redirect_mem存储重定向信息 ftq_redirect_mem是香山ftq的一个子队列。它记录了重定向需要的一些信息，帮助重定向回正确状态，这些信息来自于BPU分支预测中的RAS预测器，以及顶层的分支历史指针，如果想要了解，可以参考BPU的RAS子文档了解如何通过这些信息回溯到之前的状态。&#xA;它是一个寄存器堆，由64（FtqSize）个表项（Ftq_Redirect_SRAMEntry）构成。支持同步读写操作。有3个读端口和1个写端口，每个读端口负责与不同的模块交互。&#xA;1.1 ftq_redirect_mem读操作 读操作： 输入： 需要使能ren，这是一个向量，可指定任意读端口可读 对应接口：ren 从任意读端口中输入要读取的元素在ftq_redirect_mem中的地址，这是一个从0到ftqsize-1的索引 对应接口：raddr 输出： 从发起输入的读端口对应的读出端口中读出Ftq_Redirect_SRAMEntry。 对应接口：rdata 1.2 ftq_redirect_mem写操作 写操作 输入： 需要使能wen，可指定写端口可写 对应接口：wen 向写端口中输入要写入的元素在ftq_redirect_mem中的地址，这是一个从0到ftqsize-1的索引 对应接口：waddr 向wdata中写入Ftq_Redirect_SRAMEntry 对应接口：wdata 多端口读：可以从多个读端口读取结果 每个子队列的读写基本都是类似的，后面不再赘述&#xA;Ftq_Redirect_SRAMEntry ftq_redirect_mem存储的表项。继承自SpeculativeInfo，存储RAS预测器相关重定向信息，根据这些信息回溯到之前的状态&#xA;sc_disagree：统计分支指令在sc预测器中预测是否发生错误 接口类型：Some(Vec(numBr, Bool())) 说明：Option 类型，表明这个值可能不存在，在非FPGA平台才有，否则为none 信号列表： SpeculativeInfo：推测信息，帮助BPU在发生重定向的时候回归正常的状态 接口列表: histPtr：重定向请求需要恢复的全局历史指针，可参见BPU顶层文档了解详情 接口类型：CGHPtr 说明：以下都属于RAS重定向信息,可参见BPU文档了解如何利用这些信息进行重定向 ssp：重定向请求指令对应的 RAS 推测栈栈顶在提交栈位置的指针 接口类型：UInt(log2Up(RasSize).W) sctr：重定向请求指令对应的 RAS 推测栈栈顶递归计数 Counter 接口类型：RasCtrSize.</description>
    </item>
    <item>
      <title>IFU向FTQ写回预译码信息</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/05_wbfromifu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/05_wbfromifu/</guid>
      <description>IFU向FTQ写回预译码信息 文档概述 IFU获取来自BPU的预测信息之后，会执行预译码，并将FTQ项写回FTQ中去。我们会比对FTQ中原BPU预测项和预译码的结果，判断是否有预测错误&#xA;基本流程 预译码写回ftq_pd_mem：&#xA;FTQ从pdWb接口中获取IFU的写回信息，FTQ首先将预译码写回信息写回到ftq_pd_mem, 更新提交状态队列commitStateQueue：&#xA;然后根据写回信息中指令的有效情况更新提交状态队列commitStateQueue。 比对错误：&#xA;同时，从ftb_entry_mem读出ifu_Wb_idx所指的FTB项，将该FTB项的预测结果与预译码写回结果进行对比，看两者对分支的预测结果是否有所不同。 综合错误：&#xA;之后就综合根据预译码信息可能得到的错误：有前面说的比对BPU的预测结果和预译码结果得到的错误，也有直接根据预译码得到的错误预测信息。根据错误预测结果更新命中状态队列。 更新写回指针&#xA;最后，如果IFU成功写回，ifu_Wb_idx更新加1。 术语说明 名称 定义 预译码 IFU会对取指目标进预译码，之后写回FTQ ifuWbPtr IFU写回指针，知识IFU预译码要写入FTQ的位置 模块功能说明 1. 预译码写回ftq_pd_mem 写回有效：预译码信息pdWb有效时，写有效 写回地址：pdWb的ftqIdx的value 写回值：解析整个pdWb的结果&#xA;2. 更新提交状态队列 当预译码信息pdWb有效时，相当于写回有效，此时，根据预译码信息中每条指令的有效情况和该指令是否在有效范围内，判断指令的提交状态是否可以修改，若可以修改，则将提交状态队列，写回项中的指令状态修改&#xA;详细信号表示 pdWb有效时，ifu_wb_valid拉高。 此时，对于预译码信息中每一条指令的预译码结果pd做判断： 如果预译码结果valid，且指令在有效范围内（根据insrtRange的bool数组指示），则提交状态队列commitStateQueue中，写回项中的指令状态修改为c_toCommit，表示可以提交，这是因为只有在FTQ项被预译码写回后，才能根据后端提交信息提交该FTQ项，之后会把预译码信息一并发往更新通道。&#xA;3. 比对预测结果与预译码结果 从ftb存储队列ftb_entry_mem中的读取ifu写回指针ifuwbptr的对应项：&#xA;pdWb有效的时候，读有效，读取地址为预译码信息中指示的ftqIdx。 当命中状态队列指示待比对项ftb命中，且回写有效时，读取出FTB存储队列中对应的项，与预译码信息进行比对，当BPU预测的FTB项指示指令是有效分支指令，而预译码信息中则指示不是有效分支指令时，发生分支预测错误，当BPU预测的FTB项指示指令是有效jmp指令，而预译码信息中则指示不是有效jmp指令时，发生跳转预测错误 详细信号表示： ifu_wb_valid回写有效时，ftb_entry_mem回写指针对应读使能端口ren有效，读取地址为ifu_wb_idx预测译码信息中指示的ftqIdx的value值。 回写项命中且回写有效，hit_pd_valid信号有效，此时，读取ftb存储队列中的FTB项，读出brSlots与tailSlot，并进行比对：&#xA;3.1 判断是否有分支预测错误br_false_hit 测试点3.1.1和3.1.2对应以下两种条件导致的br_false_hit 判断是否有分支预测错误br_false_hit： brSlots的任意一项有效，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高表明是分支指令， taiSlot有效且sharing字段拉高表明该slot为分支slot，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高表明是分支指令 满足任意条件可判断发生分支预测错误br_false_hit，该信号拉高 3.2 判断是否发生jmp预测错误jal_false_hit 判断是否发生jmp预测错误jal_false_hit： 预测结果中必须指明指令预测有效，且其中isJal拉高表面是jal指令或者指明是isjalr指令 4. 预译码错误 直接从预测结果中获取错误预测相关信息，如果回写项ftb命中且missoffset字段有效表明有错误预测的指令，hit_pd_mispred信号拉高，表示预译码结果中直接指明有预测错误的指令。&#xA;5. 综合错误 综合比对预测结果与预译码结果得到的错误信息，与预译码错误直接获得的预测错误，任意一种发生时has_false_hit拉高表示有预测错误，此时，命中状态队列entry_hit_status中写回项的状态置为h_false_hit&#xA;6. 更新写回指针 ifu_wb_valid拉高，表示写回有效，将ifuWbPtr更新为原值加1。&#xA;接口说明 顶层IO 子接口 fromIfu pdWb 测试点总表 序号 功能名称 测试点名称 描述 1 WB_PD WB_PD 向ftq_pd_mem中写回预译码信息 2 UPDATE_COMMITSTATE UPDATE_COMMITSTATE 当预译码信息pdWb有效时，根据预译码信息中每条指令的有效情况和该指令是否在有效范围内，判断指令的提交状态是否可以修改，若可以修改，则将提交状态队列，写回项中的指令状态修改 3.</description>
    </item>
    <item>
      <title>IO接口说明</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/04_io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/04_io/</guid>
      <description>香山实例化 TLB.sv 接口说明（ITLB） 基本控制信号 clock: 时钟信号，驱动 TLB 的时序逻辑。 reset: 复位信号，用于重置 TLB 的状态。 刷新（SFENCE）接口信号 io_sfence_valid: SFENCE 操作的有效性标志。 io_sfence_bits_rs1: SFENCE 操作是否使用寄存器 rs1 的值。 io_sfence_bits_rs2: SFENCE 操作是否使用寄存器 rs2 的值。 io_sfence_bits_addr: SFENCE 操作指定的地址，用于选择性刷新特定地址的 TLB 条目。 io_sfence_bits_id: 刷新操作指定的 asid/vmid，用于选择性刷新特定地址空间的 TLB 条目。 io_sfence_bits_flushPipe: 刷新整个管道。 io_sfence_bits_hv: 指示指令是否为 HFENCE.VVMA，即是否刷新虚拟化下由 vsatp 寄存器控制的条目。 io_sfence_bits_hg: 指示指令是否为 HFENCE.GVMA，即是否刷新由 hgatp 寄存器控制的条目。 控制与状态寄存器（CSR）接口信号 io_csr_satp_mode: SATP 寄存器的模式字段（如裸模式、Sv32、Sv39 等）。 io_csr_satp_asid: 当前 SATP 寄存器的 ASID（地址空间标识符）。 io_csr_satp_changed: 指示 SATP 寄存器的值是否已更改。 io_csr_vsatp_mode: VSATP 寄存器的模式字段。 io_csr_vsatp_asid: VSATP 寄存器的 ASID。 io_csr_vsatp_changed: 指示 VSATP 寄存器的值是否已更改。 io_csr_hgatp_mode: HGATP 寄存器的模式字段。 io_csr_hgatp_vmid: HGATP 寄存器的 VMID（虚拟机标识符）。 io_csr_hgatp_changed: 指示 HGATP 寄存器的值是否已更改。 io_csr_priv_virt: 指示是否在虚拟模式下运行。 io_csr_priv_imode: 指令模式的特权级（如用户态、内核态等）。 请求者（Requestor）接口信号 Requestor 0 信号 io_requestor_0_req_valid: requestor0 的请求有效信号。 io_requestor_0_req_bits_vaddr: requestor0 的请求虚拟地址。 io_requestor_0_resp_bits_paddr_0: requestor0 的物理地址响应信号。 io_requestor_0_resp_bits_gpaddr_0: requestor0 的物理地址转换为 GPA（Guest Physical Address）的响应信号。 io_requestor_0_resp_bits_miss: requestor0 请求的地址未命中的信号。 io_requestor_0_resp_bits_excp_0_gpf_instr: requestor0 出现 General Protection Fault (GPF) 异常的信号。 io_requestor_0_resp_bits_excp_0_pf_instr: requestor0 出现 Page Fault (PF) 异常的信号。 io_requestor_0_resp_bits_excp_0_af_instr: requestor0 出现 Access Fault (AF) 异常的信号。 Requestor 1 信号 io_requestor_1_req_valid: requestor1 的请求有效信号。 io_requestor_1_req_bits_vaddr: requestor1 的请求虚拟地址。 io_requestor_1_resp_bits_paddr_0: requestor1 的物理地址响应信号。 io_requestor_1_resp_bits_gpaddr_0: requestor1 的 GPA 响应信号。 io_requestor_1_resp_bits_miss: requestor1 的未命中信号。 io_requestor_1_resp_bits_excp_0_gpf_instr: requestor1 出现 GPF 异常的信号。 io_requestor_1_resp_bits_excp_0_pf_instr: requestor1 出现 PF 异常的信号。 io_requestor_1_resp_bits_excp_0_af_instr: requestor1 出现 AF 异常的信号。 Requestor 2 信号 io_requestor_2_req_ready: requestor2 的请求就绪信号。 io_requestor_2_req_valid: requestor2 的请求有效信号。 io_requestor_2_req_bits_vaddr: requestor2 的请求虚拟地址。 io_requestor_2_resp_ready: requestor2 的响应就绪信号。 io_requestor_2_resp_valid: requestor2 的响应有效信号。 io_requestor_2_resp_bits_paddr_0: requestor2 的物理地址响应信号。 io_requestor_2_resp_bits_gpaddr_0: requestor2 的 GPA 响应信号。 io_requestor_2_resp_bits_excp_0_gpf_instr: requestor2 出现 GPF 异常的信号。 io_requestor_2_resp_bits_excp_0_pf_instr: requestor2 出现 PF 异常的信号。 io_requestor_2_resp_bits_excp_0_af_instr: requestor2 出现 AF 异常的信号。 刷新管道（Flush Pipe）信号 io_flushPipe_0: 刷新管道 0 的信号。 io_flushPipe_1: 刷新管道 1 的信号。 io_flushPipe_2: 刷新管道 2 的信号。 页表遍历（Page Table Walker, PTW）接口信号 PTW 请求信号 io_ptw_req_0_valid: PTW req0 有效信号。 io_ptw_req_0_bits_vpn: PTW req0 的虚拟页号（VPN）。 io_ptw_req_0_bits_s2xlate: 指示 PTW req0 的转换模式。 io_ptw_req_0_bits_getGpa: PTW req0 的获取 GPA 信号。 io_ptw_req_1_valid: PTW req1 有效信号。 io_ptw_req_1_bits_vpn: PTW req1 的虚拟页号。 io_ptw_req_1_bits_s2xlate: 指示 PTW req1 的转换模式。 io_ptw_req_1_bits_getGpa: PTW req1 的获取 GPA 信号。 io_ptw_req_2_ready: PTW req2 就绪信号。 io_ptw_req_2_valid: PTW req2 有效信号。 io_ptw_req_2_bits_vpn: PTW req2 的虚拟页号。 io_ptw_req_2_bits_s2xlate: 指示 PTW req2 的转换模式。 io_ptw_req_2_bits_getGpa: PTW req2 的获取 GPA 信号。 PTW 响应信号 io_ptw_resp_valid: PTW resp 有效信号。 io_ptw_resp_bits_s2xlate: 指示 PTW resp 的地址转换类型。 io_ptw_resp_bits_s1_entry_tag: PTW resp 的第一阶段页表条目标签。 io_ptw_resp_bits_s1_entry_asid: PTW resp 的第一阶段页表条目 ASID。 io_ptw_resp_bits_s1_entry_vmid: PTW resp 的第一阶段页表条目 VMID。 io_ptw_resp_bits_s1_entry_perm_d: PTW resp 的第一阶段页表条目可写位。 io_ptw_resp_bits_s1_entry_perm_a: PTW resp 的第一阶段页表条目已访问位。 io_ptw_resp_bits_s1_entry_perm_g: PTW resp 的第一阶段页表条目全局位。 io_ptw_resp_bits_s1_entry_perm_u: PTW resp 的第一阶段页表条目用户模式位。 io_ptw_resp_bits_s1_entry_perm_x: PTW resp 的第一阶段页表条目可执行位。 io_ptw_resp_bits_s1_entry_perm_w: PTW resp 的第一阶段页表条目可写位。 io_ptw_resp_bits_s1_entry_perm_r: PTW resp 的第一阶段页表条目可读位。 io_ptw_resp_bits_s1_entry_level: PTW resp 的第一阶段页表条目级别。 io_ptw_resp_bits_s1_entry_ppn: PTW resp 的第一阶段页表条目物理页号（PPN）。 io_ptw_resp_bits_s1_addr_low: PTW resp 的第一阶段页表条目地址低位。 io_ptw_resp_bits_s1_ppn_low_*: PTW resp 的第一阶段页表条目 PPN 低位。 io_ptw_resp_bits_s1_valididx_*: PTW resp 的第一阶段页表条目有效索引。 io_ptw_resp_bits_s1_pteidx_*: PTW resp 的第一阶段页表条目 PTE 索引。 io_ptw_resp_bits_s1_pf: PTW resp 的第一阶段页表条目出现 PF。 io_ptw_resp_bits_s1_af: PTW resp 的第一阶段页表条目出现 AF。 io_ptw_resp_bits_s2_entry_tag: PTW resp 的第二阶段页表条目标签。 io_ptw_resp_bits_s2_entry_vmid: PTW resp 的第二阶段页表条目 VMID。 io_ptw_resp_bits_s2_entry_ppn: PTW resp 的第二阶段页表条目 PPN。 io_ptw_resp_bits_s2_entry_perm_*: PTW resp 的第二阶段页表条目的权限位。 io_ptw_resp_bits_s2_entry_level: PTW resp 的第二阶段页表条目级别。 io_ptw_resp_bits_s2_gpf: PTW resp 的第二阶段页表条目 GPF 信号。 io_ptw_resp_bits_s2_gaf: PTW resp 的第二阶段页表条目 GAF 信号。 io_ptw_resp_bits_getGpa: PTW resp 的获取 GPA 信号。 </description>
    </item>
    <item>
      <title>PredChecker</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/04_pred_checker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/04_pred_checker/</guid>
      <description>子模块：PredChecker简介 分支预测检查器PredChecker接收来自IFU的预测块信息（包括预测跳转指令在预测块的位置、预测的跳转目标、预译码得到的指令信息、指令PC以及预译码得到的跳转目标偏移等），在模块内部检查五种类型的分支预测错误。模块内部分为两个流水线stage，分别输出信息，第一个stage输出给IFU的f3阶段，用于修正预测块的指令范围和预测结果。第二个stage输出给wb阶段，用于在发现分支预测错误时产生前端重定向以及写回给FTQ（Fetch Target Queue）正确的预测信息。&#xA;PredChecker功能介绍 JAL预测错误检查 jal指令预测错误的条件是，预测块中有一条有效jal指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条jal指令之后（即这条jal指令没有被预测跳转）。&#xA;JALR预测错误检查 jalr指令预测错误的条件是，预测块中有一条有效jalr指令（由预译码信息给出），而且这个指令不是ret指令，但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条jalr指令之后（即这条jalr指令没有被预测跳转）。&#xA;RET预测错误检查 ret指令预测错误的条件是，预测块中有一条有效ret指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条ret指令之后（即这条ret指令没有被预测跳转）。&#xA;更新指令有效范围向量 PredChecker在检查出Jal/Ret/JALR指令预测错误时，需要重新生成指令有效范围向量，有效范围截取到Jal/Ret指令的位置，之后的bit全部置为0。 需要注意的是，jal和ret指令的错误检查都会导致指令有效范围的缩短， 所以需要重新生成指令有效范伟fixedRange，同时修复预测结果。需要注意的是，这个修复只会针对RET预测错误和JAL预测错误导致的范围错误，对于后续要介绍的非CFI（控制流指令）预测错误和无效指令预测错误，尽管他们会造成预测块的范围偏小，但是不会进行修复，而是直接在这里进行重定向。这样，重定向后重新取的指令会从这个出错的指令开始。&#xA;非CFI预测错误检查 非CFI预测错误的条件是被预测跳转的指令根据预译码信息显示不是一条CFI指令。&#xA;无效指令预测错误检查 无效指令预测错误的条件是被预测的指令的位置根据预译码信息中的指令有效向量显示不是一条有效指令的开始。&#xA;目标地址预测错误检查 目标地址预测错误的条件是，被预测的是一条有效的jal或者branch指令，同时预测的跳转目标地址和由指令码计算得到的跳转目标不一致。&#xA;分级输出检查结果 以上PredChecker检查结果会分为两级分别输出，前面已经提到，Jal/Ret指令由于需要重新生成指令有效范围向量和重新指定预测位置， 所以需要在错误产生的当拍（F3）直接输出结果到Ibuffer用于及时更正进入后端的指令 。而由于时序的考虑，其他错误信息（比如五种错误的错误位置、正确的跳转地址等）则是等到下一拍（WB）阶段才返回给IFU做前端重定向。&#xA;PredChecker接口说明 输入接口 fire_in：这个信号可以简单认为是模块有效性的控制信号。&#xA;ftqOffset：来自BPU（分支预测单元）的预测信息，表示该预测块的跳转指令是否存在（valid），以及跳转指令的序号（bits）。&#xA;instrRange：来自PreDecode的预译码信息，对每条指令，表示该指令是否在预测块的有效指令范围内。&#xA;instrValid：来自PreDecode的预译码信息，表示的是对于每条32位的拼接指令，其是否为一条有效的指令（即低16位为一条RVC指令，或者整个32位为一条RVI指令）。&#xA;jumpOffset：来自PreDecode的预译码信息，如果某一指令为跳转指令，jumpOffset表示这个指令的跳转目标。&#xA;pc：指令的pc。&#xA;pds：来自PreDecode模块的预译码信息，包含指令的brType、是否为Ret（isRet）、是否为RVC指令（isRVC）。&#xA;target：来自BPU，下个预测块的开始地址。&#xA;输出接口 第一阶段输出 fixedRange：修复的指令有效范围向量，对每条指令i，fixedRange_i为真表示这条指令是否在当前预测块的有效指令范围内&#xA;fixedTaken：修复过后的CFI指令选取情况，对每条指令，fixedTaken_i为真表示这条指令是否是这个预测块的第一条CFI指令&#xA;第二阶段输出 fixedMissPred：对每条指令，PredChecker检查出的存在预测错误的情况，fixedMissPred_i为真表示这条指令存在预测错误&#xA;fixedTarget：对每条指令，给出修复过的下一条指令的位置（可以是常规的pc+2或+4，或者如果是跳转指令，给出跳转目标）。&#xA;jalTarget：对每条指令，给出跳转目标。&#xA;faultType：每条指令的错误类型，取指范围包含noFault，jalFault，retFault，targetFault，notCFIFault，invalidTaken，jalrFault，分别对应数字0～6&#xA;PredChecker测试点和功能点 功能点1 BPU预测信息的JAL预测错误检查 PredChecker会对传入的预测块进行JAL预测错误预检查并修正指令有效范围向量和预测的跳转指令。&#xA;对这一模块的测试，我们分为两部分：正确的输入是否会误检和确有JAL检测错误的预测块输入能否检出。&#xA;对于误检，我们设计如下的测试点:&#xA;序号 名称 描述 1.1.1 误检测试1 预测块中没有JAL指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JAL预测错误。 1.1.2 误检测试2 预测块中有JAL指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JAL预测错误。 对于JAL预测错误的正确检验，我们设计如下的测试点：&#xA;序号 名称 描述 1.2.1 存在JAL未预测 预测块中存在JAL指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出JAL预测错误。 1.2.2 预测的JAL并非第一条 预测块中存在JAL指令，但是BPU预测信息取的跳转指令在第一条JAL指令之后，检查PredChecker是否能检测出JAL预测错误。 功能点2 BPU预测信息的RET预测错误检查 PredChecker会对传入的预测块进行RET预测错误预检查并修正指令有效范围向量和新的预测结果。</description>
    </item>
    <item>
      <title>PreDecode</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/01_predecode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/01_predecode/</guid>
      <description>子模块：PreDecoder简介 预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。&#xA;所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。&#xA;预译码器的输出是：16x4B的拼接指令码；对每个4B指令码，该条指令是否为RVI或RVC指令（RVC指令只考虑该4B的低2B）；对每个4B指令码，该条指令的跳转偏移；两个16位的有效指令开始向量，其中第一种向量假定当前预测块的起始2字节为一条有效指令的开始，而第二种向量假定当前预测块的起始2字节为一条有效RVI指令的结束（但是由于第二种向量的前两位必然为0和1,所以编译优化后，第二种向量实际只有14个信号，表示2-15位；同理，第1种向量的第0位因为恒为1,所以也被优化）&#xA;功能介绍 指令码生成 预译码器接受来自IFU完成指令切分的17 × 2字节的初始指令码，并以4字节为窗口，2字节为步进长度， 从第1个2字节开始，直到第16个2字节，选出总共16个4字节的指令码。&#xA;预译码信息生成 预译码器根据指令码产生预译码信息，主要包括：是否是RVC指令、是否是CFI指令、 CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移。&#xA;首先是判断是否是RVC指令，RVC指令的具体格式参阅RISCV手册的描述：&#xA;其中，决定指令是否为RVC的部分在于指令的[1, 0]两位，不为3的情况下都是RVC指令。&#xA;其余的指令性质判定功能（CFI类型、是否为call和ret）被时序优化到了F3PreDecoder中，不过也可以认为是PreDecoder的一部分，可以设置测试点进行测试&#xA;最后比较麻烦的是CFI指令的目标地址计算偏移，主要是对J和BR分支指令进行的计算，这需要综合RVI和RVC中jal和br指令的结构。 首先，是手册中对于C.J的描述&#xA;这里对imm立即数的注解是，立即数的每一位最后对应到的是偏移的哪一位。&#xA;所以，可以认为立即数是这么重组的：&#xA;instr(12) + instr(8) + instr(10, 9) + instr(6) + instr(7) + instr(2) + instr(11) +instr(5,3) + &amp;ldquo;0&amp;rdquo;&#xA;而RVI中，对于JAL指令，是这么定义的：&#xA;我们可以类似地计算立即数。&#xA;同样的，我们可以查询手册，参考BR类指令的立即数计算RVC和RVI指令对应的偏移。&#xA;PreDecode接口说明 输入接口 in_bits_data 17 x 2B的初始指令码，其中，每2个字节既可以代表一条RVC指令，也可以代表一个RVI指令的一半。&#xA;输出接口 instr：拼接后的 16 x 4B的初始指令码&#xA;jumpOffset：如果这条指令是跳转指令，则jumpOffset表示其跳转偏移&#xA;pd：每条指令预译码信息，包括valid、isRVC、brType、isRet、isCall。其中第0条指令的valid已经被优化了&#xA;hasHalfValid：这个信号需要和pd的valid结合起来看，PreDecode的一个功能是求出指令开始向量，也就是对每个4B的拼接指令，判断其低2B是否为一条有效指令的开始（即一条RVI指令的前半部分，或者一条RVC指令），但是需要分类讨论该预测块的第一个2B是否为一条有效指令的开始。hasHalfValid表示的是当前预测块的第一个2B指令为一条RVI指令的后半部分时，给出的指令开始向量。类似地，pd中的valid指的是当前预测块的第一个2B指令为一条指令的开始时，给出的指令开始向量。&#xA;PreDecoder测试点和功能点 功能点1 生成指令码 子模块：PreDecoder简介&#xA;预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。&#xA;所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。&#xA;预译码器的输出是：16x4B的拼接指令码；对每个4B指令码，该条指令是否为RVI或RVC指令（RVC指令只考虑该4B的低2B）；对每个4B指令码，该条指令的跳转偏移；两个16位的有效指令开始向量，其中第一种向量假定当前预测块的起始2字节为一条有效指令的开始，而第二种向量假定当前预测块的起始2字节为一条有效RVI指令的结束（但是由于第二种向量的前两位必然为0和1,所以编译优化后，第二种向量实际只有14个信号，表示2-15位；同理，第1种向量的第0位因为恒为1,所以也被优化） 功能介绍 指令码生成</description>
    </item>
    <item>
      <title>RVCExpander</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/03_ifu_rvc_exp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/03_ifu_rvc_exp/</guid>
      <description>子模块：RVCExpander简介 RVCExpander是IFU的子模块，负责对传入的指令进行指令扩展，并解码计算非法信息。&#xA;该模块接收的输入量是两个：一条RVC指令或者RVI指令；CSR对fs.status的使能情况。&#xA;输出量也是两个：输入指令对应的RVI指令；RVC指令是否非法。&#xA;指令扩展 如果是RVI指令，则无需扩展。&#xA;否则对RVC指令，按照手册的约定进行扩展。&#xA;非法指令判断 RVI指令永远判断为合法。&#xA;对于RVC指令的判定，详细内容参阅20240411的RISCV手册的26.8节表格列出的指令条件。&#xA;RVCExpander接口说明 输入接口 fsIsOff：表示CSR是否使能fs.status&#xA;in：传入一个32位数据，其可以是一个完整的RVI指令，也可以是低16位RVC指令+高16位为RVI指令的一半（当然低16位也有可能是RVI指令的后半部分，但是RVCExpander不会区分，可以认为RVCExpander假定传入的32位数据的低16位一定为一条指令的开始）&#xA;输出接口 ill：表示这条指令是否为非法指令&#xA;out_bits：对RVI指令，直接返回，对RVC指令，返回扩展后的32位指令。&#xA;功能点和测试点 功能点1 指令扩展 RVCExpander负责接收预译码器拼接的指令码，并进行指令扩展，如果是16位RVC指令，需要按照RISCV手册的约定完成扩展&#xA;对此，我们需要随机生成RVI指令和RVC指令，送入预译码器：&#xA;序号 名称 描述 1.1 RVI指令保留 构造RVI指令传入，检查保留情况 1.2 RVC指令扩展 构造RVC指令传入，按手册检查扩展结果 功能点2 非法指令判断 RVCExpander在解析指令时，如发现指令违反了手册的约定，则需要判定该指令非法&#xA;对此，我们需要随机生成非法指令送入RVI中，并检测RVCExpander对合法位的校验；同时，我们还需要校验合法指令是否会被误判为非法指令：&#xA;此外，需要判定C.fp指令在CSR未使能fs.status的情况下，能否将这类指令判定为非法。&#xA;序号 名称 描述 2.1 常规非法指令测试 随机构造非法RVC指令传入，检查判断结果 2.2 合法指令测试 随机构造合法RVC指令传入，检查判断结果 2.3 C.fp指令测试 CSR未使能fs.status的情况下，C.fp指令应该为非法 测试点汇总 序号 功能 名称 描述 1.1 指令扩展 RVI指令保留 构造RVI指令传入，检查保留情况 1.2 指令扩展 RVC指令扩展 构造RVC指令传入，按手册检查扩展结果 2.1 非法指令判断 非法指令测试 随机构造非法RVC指令传入，检查判断结果 2.2 非法指令判断 合法指令测试 随机构造合法RVC指令传入，检查判断结果 2.</description>
    </item>
    <item>
      <title>冲刷指针和状态队列</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/10_flushptrandstatequeue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/10_flushptrandstatequeue/</guid>
      <description>冲刷FTQ指针和状态队列 文档概述 之前讲了，后端和IFU重定向写回会修改一些状态队列。此外，FtqPtr也是一种比较重要的维护信息。由后端或者IFU引起的重定向，需要恢复各种类型用来索引FTQ项的FtqPtr。而当重定向是由后端发起的时候，还要修改提交状态队列，说明指令已经被执行。&#xA;术语说明 名称 定义 FTQ指针 用来索引FTQ项，有不同类型的FTQ指针，比如bpuPtr，ifuPtr flush 冲刷，发生时需要重置FTQ指针，以及重置其他状态 融合指令 一条指令可以和其他指令融合，形成融合指令 模块功能说明 1. 冲刷FTQ指针及提交状态队列 流程 后端和IFU的重定向信号都会冲刷指针，更具体的来说：&#xA;1.1 冲刷条件 后端写回接口fromBackend有效，或者IFU重定向有效：（当预译码写回pdWb有效，且pdWb的missOffset字段有效表明存在预测错误的指令，同时后端冲刷信号backendFlush无效）。（参考：从IFU重定向的第一个周期，重定向valid值有效条件） 1.2 冲刷指针 第一个周期：&#xA;冲刷指针：确认后端和IFU的重定向信号可能冲刷指针时，从两个重定向来源的redirect接口读出重定向信息，包括ftqIdx，ftqOffset，重定向等级RedirectLevel。有两个来源时，优先后端的重定向信息。 冲刷指针列表： bpuPtr：ftqIdx+1 ifuPtr：ftqIdx+1 ifuWbPtr：ftqIdx+1 pfPtr：ftqIdx+1 注：只是在当前周期向指针寄存器写入更新信息，实际生效是在下一个周期。 这样一来，所有类型指针当前指向的都是发生重定向的指令块的下一项了，我们从这一项开始重新进行分支预测，预译码，等等。 1.3 冲刷提交状态队列 第二个周期： 如果上一个周期的重定向来源是后端，FTQ会进一步更改提交状态队列&#xA;提交状态队列中，对于重定向的指令块（通过ftqIdx索引），位于ftqOffset后面的指令的状态被设置为c_empty 对于正好处于ftqOffset的指令，判断RedirectLevel，低表示在本位置后flush，高表示在本位置flush，所以level为高时，对于的指令提交状态被设置为flush。 2 转发到顶层IO 实际上，在发生重定向的时候，还涉及一些将重定向信息通过FTQ顶层IO接口转发给其他模块的操作，比如ICache需要flush信号取进行冲刷，IFU也需要后端的重定向信号对它进行重定向，具体来说： 在流程的第一个周期：&#xA;2.1 flush转发到icacheFlush flush信号顶层IO转发（icacheFlush）： 确认后端和IFU的重定向信号可能冲刷指针时，拉高FTQ顶层IO接口中的icacheFlush信号，把重定向产生的flush信号转发给ICache 2.2 重定向信号转发到IFU 重定向信号顶层IO转发（toIFU）： redirect： bits：接收来自后端的重定向信号 valid：后端的重定向信号有效时有效，保持有效，直到下个周期依然有效 3 重排序缓冲区提交 其实，除了后端重定向会更新提交状态队列，最直接的更新提交状态队列的方式是通过FTQ顶层IO中frombackend里提供的提交信息，rob_commits告知我们哪些指令需要被提交。&#xA;rob_commits的valid字段有效，可以根据其中信息对指令进行提交，修改状态队列。对于被执行的指令，是如何提交的，如何对应地修改提交状态队列，有两种情况：&#xA;3.1 提交普通指令 对于普通指令，根据rob_commits的ftqIdx和ftqOffset索引提交状态队列中的某条指令，将对应的提交状态设置为c_commited 3.2 提交融合指令 对于融合指令，根据提交类型commitType对被索引的指令和另一与之融合的指令进行提交，将对应的提交状态设置为c_commited commitType = 4：同时把被索引指令的下一条指令设为c_commited commitType = 5：同时把被索引指令的之后的第二条指令设为c_commited commitType = 6：同时把被指令块的下一个指令块的第0条指令设为c_commited commitType = 7：同时把被指令块的下一个指令块的第1条指令设为c_commited 接口说明 顶层IO 作用 fromBackend 接收后端重定向和指令提交 fromIfu 接收IFU重定向 icacheFlush 将flush信号转发到icache toIFU 将后端重定向转发到IFU 所有顶层信号均在FTQ顶层IO一文中详述。 测试点总表 序号 功能名称 测试点名称 描述 1.</description>
    </item>
    <item>
      <title>功能详述</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_func/</guid>
      <description>支持 SV48 分页机制 SV48 （Supervisor-mode Virtual Memory）是一种基于 RISC-V 的页表虚拟内存寻址模式，指定了 48 位虚拟地址空间的结构，支持 256TB 的虚拟内存地址空间。使用四级页表结构：&#xA;在 SV48 的一个 PTE 中包含了如下字段：&#xA;N:&#xA;指示是否为 NAPOT PTE。供 Svnapot 扩展使用，如果未实现 Svnapot 则该位必须由软件置 0，否则应当出现 Page Fault。目前香山昆明湖架构尚未支持此扩展。 PBMT:&#xA;Page-Based Memory Types，即基于页面的内存类型，供 Svpbmt 扩展使用，允许操作系统为每个页面指定不同的内存访问属性。 0: None，没有特定的内存属性。 1: NC，非缓存、幂等、弱序（RVWMO），适用于主存。 2: IO，非缓存、非幂等、强序（I/O 排序），适用于 I/O 设备。 3: Reserved，保留供将来标准使用。 同样的，如果未实现 Svpbmt 则这两位必须由软件置 0，否则应当出现 Page Fault。&#xA;Reserved:&#xA;保留位，供未来的标准使用。如果有任意一位不是 0 则会触发 PF 异常。 PPN:&#xA;表示物理页框号，指向实际的物理内存页。PPN 与页面内偏移结合形成完整的物理地址，用于地址转换。 RSW:&#xA;保留供软件使用的位，通常用于特定的标志或操作，以便在软件实现中提供灵活性。 D:&#xA;脏位，指示该页面是否被写入。如果该位为 1，表示该页的数据已被修改，需在换出时写回到存储设备。 A:&#xA;访问位，指示该页是否被访问过。如果该位为 1，表示该页已被读取或写入，用于页面替换算法。 G:</description>
    </item>
    <item>
      <title>关键信号说明</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/03_keysignal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/03_keysignal/</guid>
      <description>相关 CSR 寄存器 val csr = Input(new TlbCsrBundle) csr：包含 satp、vsatp、hgatp 三个寄存器的信息以及一些权限信息。&#xA;class TlbCsrBundle(implicit p: Parameters) extends XSBundle { val satp = new TlbSatpBundle() val vsatp = new TlbSatpBundle() val hgatp = new TlbHgatpBundle() val priv = new Bundle { val mxr = Bool() val sum = Bool() val vmxr = Bool() val vsum = Bool() val virt = Bool() val spvp = UInt(1.W) val imode = UInt(2.W) val dmode = UInt(2.</description>
    </item>
    <item>
      <title>环境配置</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_env/</guid>
      <description>推荐使用WSL2+Ubuntu22.04+GTKWave 我们推荐Windows10/11用户通过WSL2进行开发，在此给出通过此方法进行环境配置的教程集锦，仅供参考。如环境安装过程中出现任何问题，欢迎在QQ群（群号：976081653）中提出，我们将尽力帮助解决。此页面将收集大家提出的所有环境配置相关问题并提供解决方案，欢迎随时向我们提问！&#xA;1、在Windows下安装WSL2（Ubuntu22.04） 参考资源：&#xA;&amp;mdash; 微软官方教程：如何使用 WSL 在 Windows 上安装 Linux&#xA;&amp;mdash; 其它资源：安装WSL2和Ubuntu22.04版本&#xA;2、打开WSL，换源 推荐使用清华源：清华大学开源软件镜像站-Ubuntu软件仓库&#xA;3、配置验证环境 请参照开放验证平台学习资源-快速开始-搭建验证环境配置picker环境。&#xA;4、使用 GTKWave 使用重庆大学硬件综合设计实验文档-Windows原生GTKWave给出的方法，可以通过在WSL中输入 gtkwave.exe wave.fst 打开在Windows下安装的GTKWave。请注意，gtkwave在使用中需要进入fst文件所在文件夹，否则会出现无法 initialize的情况。&#xA;cd out gtkwave.exe {test_name}.fst cd .. 5、使用VSCode插件Live Server查看验证报告 成功安装插件Live Server后，打开文件列表，定位到 /out/report/2025*-itlb-doc-*/index.html 右键并选择 Open With Live Server，之后在浏览器中打开提示的端口（默认为//localhost:5500）即可。</description>
    </item>
    <item>
      <title>目标验证单元</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/00_unitychip_for_xiangshan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/00_unitychip_for_xiangshan/</guid>
      <description>当前版本： 20250318070200-main-2eb4fd1378bb957db14afbae18a0f9ca0eb36523 20250317023055-main-ec9b2b3fda9ed0706f5c70c4413765c042062eb3 20250306075137-main-0ca85ce5acfa0894762be5d008a2bf85bed08101 20250306021736-main-8fcdd79da758da0a651aa1a763732a98d640589e 20250303064534-main-3baa11d910f8949c77dadf50b0f8d95fd78cfc08 20250221085945-main-1bcaa98e96a9bc8404c5e71c8490aca66f56722b 20250210003155-main-2b529583954cafe6f145a5d8d49740ebd4d0fa4c 20250206064001-main-8e09f7c86acf67eb7649bd67df3ec51dccc77aaa 20250201121154-main-9595c680af64cc08a12f22a1d595ce111249f153 20250123032900-main-88fa1057ab93bd8286fc2705a1fd203397995702 20250121015322-main-2f2073ab1f56cc01fed1da01d6ddc6ed52880693 20241223133801-main-2a8c1ab351e4ea786c55435dd18f60c0c523cc8a 20241220061304-main-187577e01df03a8ff7ffc828b79070bd5e582436 20241218062220-main-a866912fc3a6df3d17b857a1a898f6f9e5c5957c 20241217100236-main-53f30b46ed6e6eeb261894c4a71a60f69777ef8c 20241216044913-main-7d081626cef0910d9490d169053ee32a8e0c51db 20241213025923-main-d09f78a58caeeb64347ca2587f1f3f2b2a59e6a0 20241212091919-main-c54c0c2e590cf334b986f8ef3eacc53329f4ed1e 20241204085334-main-335e7e0d4ffc2c7a17f8d95e7c75cbd428b14a61 20241204062337-main-f8903a8c4021ba3e310bf097b07147892729341c 20241201142531-main-365f53f574ba5c6875b3389824a3c898c642ed2b 20241129112435-main-79ccae9d5df92c4e167547564b97bd8846b7ecb6 20241129111104-main-8e0cb45a86ec3ffd779723e17ede379081431c42 查看测试报告 上图共有-个模块，默认情况下模块为灰色，当模块中的测试用例数大于-时，该模块被完全点亮。目前已经完全点亮的模块为-个，待点亮的模块有-个。&#xA;通用处理器模块简介 高性能处理器是现代计算设备的核心，它们通常由三个主要部分组成：前端、后端和访存系统。这些部分协同工作，以确保处理器能够高效地执行复杂的计算任务。&#xA;前端：前端部分，也被称为指令获取和解码阶段，负责从内存中获取指令并将其解码成处理器可以理解的格式。这一阶段是处理器性能的关键，因为它直接影响到处理器可以多快地开始执行指令。前端通常包括指令缓存、分支预测单元和指令解码器。指令缓存用于存储最近访问过的指令，以减少对主内存的访问次数，从而提高处理速度。分支预测单元则尝试预测程序中的条件分支，以便提前获取和解码后续指令，这样可以减少等待分支结果的时间。&#xA;后端：后端部分，也称为执行阶段，是处理器中负责实际执行指令的地方。这一阶段包括了算术逻辑单元（ALU）、浮点单元（FPU）和各种执行单元。这些单元负责进行算术运算、逻辑运算、数据传输和其他处理器操作。后端的设计通常非常复杂，因为它需要支持多种指令集架构（ISA）并优化性能。为了提高效率，现代处理器通常采用超标量架构，这意味着它们可以同时执行多条指令。&#xA;访存：访存系统是处理器与内存之间交互的桥梁。它包括了数据缓存、内存控制器和高速缓存一致性协议。数据缓存用于存储处理器频繁访问的数据，以减少对主内存的访问次数。内存控制器负责管理处理器与内存之间的数据传输。高速缓存一致性协议确保在多处理器系统中，所有处理器看到的内存状态是一致的。&#xA;高性能处理器的设计需要在这三个部分之间找到平衡，以实现最佳的性能。这通常涉及到复杂的微架构设计，以及对处理器流水线的优化。</description>
    </item>
    <item>
      <title>执行单元修改FTQ状态队列</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/09_wbfromexu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/09_wbfromexu/</guid>
      <description>执行单元修改FTQ状态队列 文档概述 后端的写回信息，包括重定向信息和更新信息，实际上都是执行之后，由实际执行单元根据结果发回的&#xA;术语说明 名称 定义 cfiIndex_vec 控制流指令索引队列，记录每个指令块中控制流指令的索引 update_target 更新目标队列，记录每个指令块的跳转目标 FTQ最新项 BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，表明我们当前关注的最新FTQ项。 模块功能说明 1. 由后端的写回信号修改FTQ状态 1.1 修改FTQ状态队列 从后端写回FTQ接口fromBackend中的redirect接口中，我们可以读出valid，ftqPtr，ftqOffset（后端实际执行时确认的控制流指令的偏移），taken，mispred字段，依靠它们来判断，如何修改FTQ的状态队列和相关的变量&#xA;后端执行单元写回时被修改的队列：&#xA;1.1.1 修改cfiIndex_vec cfiIndex_vec： 修改方式：执行写回修改队列中ftqPtr那一项 valid：fromBackend中的redirect接口中，valid有效，taken有效，且ftqOffset小于或者等于cfiIndex_vec中ftqPtr那一项指定的偏移：这说明重定向发生，实际执行结果判断ftqPtr索引的指令块确实会发生跳转，且实际执行跳转的指令在被预测为发生跳转的指令之前或等于它。所以这时指令块是会发生跳转的，控制流索引队列的ftqPtr项valid bits：fromBackend中的redirect接口中，valid有效，taken有效，且ftqOffset小于cfiIndex_vec中ftqPtr那一项指定的偏移，偏移量被更新为更小值ftqOffset。 1.1.2 修改update_target update_target： ftqPtr索引项的跳转目标修改为fromBackend的redirect接口中的cifUpdate中指定的target 1.1.3 修改mispredict_vec mispredict_vec： 如果该重定向指令是来自后端的重定向指令， ftqPtr索引项的ftqOffset偏移指令被设置为fromBackend的redirect接口中的cifUpdate中指定的isMisPred 1.2 修改FTQ最新项 newest_entry_target： 被修改为重定向接口中cfiUpdate指定的target 辅助信号newest_entry_target_modified被指定为true newest_entry_ptr： 修改为重定向接口指定的ftqIdx 辅助信号newest_entry_ptr_modified被指定为true 2. 由IFU的写回信号修改FTQ状态 IFU既然也能和后端一样生成重定向信息，那么他也能在产生重定向信息的时候修改这些状态队列和FTQ最新项，区别：&#xA;但是，由于IFU没有真的执行，所以它的预译码结果并不能作为决定指令块是不是真的被错误预测了，所以它不能修改mispredict_vec的状态 其次，后端重定向优先级永远高于IFU重定向，两者同时发生时只采用后端重定向。 所以这个部分也有以下测试点：&#xA;2.1.1 修改cfiIndex_vec 2.1.2 修改update_target 2.2 修改FTQ最新项 常量说明 常量名 常量值 解释 常量1 64 常量1解释 常量2 8 常量2解释 常量3 16 常量3解释 接口说明 顶层IO 子接口 fromBackend redirect 测试点总表 实际使用下面的表格时，请用有意义的英文大写的功能名称和测试点名称替换下面表格中的名称</description>
    </item>
    <item>
      <title>准备验证环境</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/01_verfiy_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/01_verfiy_env/</guid>
      <description>基础环境需求 本项目基于Python编程语言进行UT验证，采用的工具和测试框架为picker和toffee，环境需求如下：&#xA;Linux操作系统。建议WSL2下安装Ubuntu22.04。 Python。建议Python3.11。 picker。按照快速开始中的提示安装最新版本。 toffee。将在后面自动安装。也可按照快速开始中的提示手动安装最新版本。 lcov。用于后续test阶段报告生成。使用包管理器即可下载：sudo apt install lcov 环境配置完成后，clone仓库：&#xA;git clone https://github.com/XS-MLVP/UnityChipForXiangShan.git cd UnityChipForXiangShan pip3 install -r requirements.txt # 安装python依赖（例如 toffee） 下载RTL代码： 默认从仓库https://github.com/XS-MLVP/UnityChipXiangShanRTLs中下载。用户也可以自行按照XiangShan文档编译生成RTL。&#xA;make rtl # 该命下载最新的rtl代码，并解压至rtl目录，并创建软连接 可以用以下命令指定下载的rtl版本：&#xA;make rtl args=&amp;#34;rtl.version=\&amp;#39;openxiangshan-kmh-fad7803d-24120901\&amp;#39;&amp;#34; 所有RTL下载包请在UnityChipXiangShanRTLs中查看。&#xA;RTL压缩包的命名规范为：名称-微架构-Git标记-日期编号.tar.gz，例如openxiangshan-kmh-97e37a2237-24092701.tar.gz。在使用时，仓库代码会过滤掉git标记和后缀，例如通过 cfg.rtl.version 访问到的版本号为：openxiangshan-kmh-24092701。压缩包内的目录结构为：&#xA;openxiangshan-kmh-97e37a2237-24092701.tar.gz └── rtl # 目录 |-- *.sv # 所有sv文件 `-- *.v # 所有v文件 编译DUT 该过程的目的是将RTL通过picker工具打包为Python模块。可以通过make命令指定被打包DUT，也可以一次性打包所有DUT。&#xA;如果想要自行打包某个dut，需要创建编写scripts目录中的build_ut_&amp;lt;name&amp;gt;.py脚本。这一脚本必须实现一个build方法，在打包时会被自动调用。此外还有一个line_coverage_files方法，用于指定行覆盖率参考的文件。&#xA;picker的打包支持内部信号的加入，详见picker的--internal参数，传递给其一个自定义的yaml即可。&#xA;# 调用scripts目录中的build_ut_&amp;lt;name&amp;gt;.py中的build方法，创建待验证的Python版DUT make dut DUTS=&amp;lt;name&amp;gt; # DUTS的值如果有多个，需要用逗号隔开，支持通配符。DUTS默认值为 &amp;#34;*&amp;#34;，编译所有DUT # 例如： make dut DUTS=backend_ctrl_block_decode 以make dut DUTS=backend_ctrl_block_decode为例，命令执行完成后，会在dut目录下生成对应的Python包：</description>
    </item>
    <item>
      <title>运行测试</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/02_run_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/02_run_test/</guid>
      <description>本项目基于PyTest测试框架进行验证。运行测试时，PyTest框架自动搜索所有test_*.py文件，并自动执行其中所有以test_开头的测试用例（Test Case）。&#xA;# 执行所有ut_*目录中的test case make test_all # 执行指定目录下的test case make test target=&amp;lt;dir&amp;gt; # 例如执行ut_backend/ctrl_block/decode目录中所有的test case make test target=ut_backend/ctrl_block/decode 可通过args参数传递Pytest的运行参数，例如启动x-dist插件的多核功能：&#xA;make test args=&amp;#34;-n 4&amp;#34; # 启用 4 个进程 make test args=&amp;#34;-n auto&amp;#34; # 让框架自动选择启用多少个进程 *注：x-dist可以在多节点上并发运行测试，可参考其文档&#xA;运行完成后，默认在out/report目录会生成html版本的测试报告，其 html 文件可通过浏览器直接打开查看（VS Code IDE建议安装Open In Default Browser插件）。&#xA;运行测试主要完成以下三部分内容：&#xA;按要求运行Test Case，可通过cfg.tests中的选项进行配置 统计测试结果，输出测试报告。有toffee-report自动生成 (总测试报告，所有Test的结果合并在一起) 根据需要（cfg.doc_result.disable = True）在测试报告上进行进一步数据统计 </description>
    </item>
    <item>
      <title>如何参与本项目</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/06_join_us/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/06_join_us/</guid>
      <description>如何提交Bug 按 ISSUE 模板进行提交，标记上对应的标签（bug，bug等级等）&#xA;对应模块的维护者进行检查，并修改他给出的标记和香山分支&#xA;如何提交文档 本仓库文档以PR的形式在本仓库提交，DUT文档在仓库UnityChipForXiangShan/documents/content/zh-cn/docs/98_UT中进行提交。&#xA;本项目欢迎任何人以ISSUE、DISCUSS、Fork、PR的方式参与。&#xA;万众一芯QQ交流群：</description>
    </item>
    <item>
      <title>模板-PR</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/08_template_pr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/08_template_pr/</guid>
      <description># Description Please include a summary of the changes and the related issue. Please also include relevant motivation and context. List any dependencies that are required for this change. Fixes # (issue) ## Type of change Please delete options that are not relevant. - [ ] Bug fix (non-breaking change which fixes an issue) - [ ] New feature (non-breaking change which adds functionality) - [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected) - [ ] This change requires a documentation update # How Has This Been Tested?</description>
    </item>
    <item>
      <title>模板-ISSUE</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/09_template_issue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/09_template_issue/</guid>
      <description>## Description A brief description of the issue. ## Steps to Reproduce 1. Describe the first step 2. Describe the second step 3. Describe the third step 4. ... ## Expected Result Describe what you expected to happen. ## Actual Result Describe what actually happened. ## Screenshots If applicable, add screenshots to help explain your problem. ## Environment - OS: [e.g. Windows 10, macOS 10.15, Ubuntu 20.04] - Browser: [e.g. Chrome 86, Firefox 82, Safari 14] - Version: [e.</description>
    </item>
    <item>
      <title>模板-UT-README</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/10_template_ut_readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/10_template_ut_readme/</guid>
      <description># 模块名称 ## 测试目标 &amp;lt;测试目标、测试方法描述&amp;gt; ## 测试环境 &amp;lt;测试环境描述，依赖描述&amp;gt; ## 功能检测 &amp;lt;给出目标待测功能与对应的检测方法&amp;gt; |序号|所属模块|功能描述|检查点描述|检查标识|检查项| |-|-|-|-|-|-| |-|-|-|-|-|-| ## 验证接口 &amp;lt;接口的描述&amp;gt; ## 用例说明 #### 测试用例1 |步骤|操作内容|预期结果|覆盖功能点| |-|-|-|-| |-|-|-|-| #### 测试用例2 |步骤|操作内容|预期结果|覆盖功能点| |-|-|-|-| |-|-|-|-| ## 目录结构 &amp;lt;对本模块的目录结构进行描述&amp;gt; ## 检测列表 - [ ] 本文档符合指定[模板]()要求 - [ ] Env提供的API不包含任何DUT引脚和时序信息 - [ ] Env的API保持稳定（共有[ X ]个） - [ ] Env中对所支持的RTL版本（支持版本[ X ]）进行了检查 - [ ] 功能点（共有[ X ]个）与[设计文档]()一致 - [ ] 检查点（共有[ X ]个）覆盖所有功能点 - [ ] 检查点的输入不依赖任何DUT引脚，仅依赖Env的标准API - [ ] 所有测试用例（共有[ X ]个）都对功能检查点进行了反标 - [ ] 所有测试用例都是通过 assert 进行的结果判断 - [ ] 所有DUT或对应wrapper都是通过fixture创建 - [ ] 在上述fixture中对RTL版本进行了检查 - [ ] 创建DUT或对应wrapper的fixture进行了功能和代码行覆盖率统计 - [ ] 设置代码行覆盖率时对过滤需求进行了检查 展示效果如下：</description>
    </item>
    <item>
      <title>常用API</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/95_api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/95_api/</guid>
      <description>comm 模块 在comm中提供了部分可公用的API，可通过以下方式进行调用：&#xA;# import all from comm import * # or direct import functions you need from com import function_you_need # or access from module import comm comm.function_you_need() cfg 子模块 get_config(cfg=None) 获取当前的Config配置&#xA;输入：如果cfg不为空，则返回cfg。否则则自动通过toffee获取全局Config。 返回：Config对象 import comm cfg = comm.get_config() print(cfg.rtl.version) cfg_as_str(cfg: CfgObject): 把config对象转换为字符类型&#xA;输入：Config对象 返回：编码后的Config对象 import comm cfg_str = comm.cfg_as_str(comm.get_config()) cfg_from_str(cfg_str) 把字符类型的Config对象还原&#xA;输入：编码后的Config对象 返回：Config对象 import comm cfg = comm.cfg_from_str(cfg_str) dump_cfg(cfg: CfgObject = None, cfg_file=None) 把config对象保持到文件&#xA;输入： cfg 需要保存的config cfg_file 目标文件 import comm cfg = comm.</description>
    </item>
    <item>
      <title>其他</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/96_others/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/96_others/</guid>
      <description>测试用例管理 如果测试用例和目标RTL版本紧密相关，RTL发生变化，之前的测试用例不一定适用。此外，不同场景下有不同需求，例如验证测试环境时，不运行耗时太长的用例等。因此需要对用例进行管理，让用户能在在特定场景下跳过某些用例。为了实现该目标，我们需要通过pytest.mark.toffee_tags对于每个用例进行tag和version标记。然后在配置文件中设置需要跳过哪些tag或者只运行哪些tag的测试。&#xA;@pytest.mark.toffee_tags(&amp;#34;my_tag&amp;#34;, &amp;#34;version1 &amp;lt; version13&amp;#34;) def test_case_1(): ... 例如上述test_case_1被标记上了标签my_tag，支持版本设置为version1到version13。因此可以在配置文件中指定test.skip-tags=[&amp;quot;my_tag&amp;quot;]，来表示运行过程中跳过该用例。&#xA;pytest.mark.toffee_tags的参数说明如下：&#xA;@pytest.mark.toffee_tags( tag: Optional[list, str] = [] # 用例标签 version: Optional[list, str] = [], # 用例rtl版本需求 skip: callable = None, # 自定义是否调过该用例，skip(tag, version, item): (skip, reason) ) toffee_tags函数的参数tag支持str和list[str]类型。version参数也可以是str和list[str]类型，当为list类型时，进行精确匹配，如果为str则匹配规则如下：&#xA;name-number1 &amp;lt; namer-number2: 表示版本需要在number1和number2之间（包含边界，number表示数字，也可以为小数，eg 1.11） name-number1+：表示number1版本以及以后的版本 name-number1-：表示number1版本以及以前的版本 如果不存在上述情况，且有*或者?表示通配符类型。其他情况为精确匹配。&#xA;预定义标签，可以在comm/constants.py中查看，例如：&#xA;# Predefined tags for test cases TAG_LONG_TIME_RUN = &amp;#34;LONG_TIME_RUN&amp;#34; # 运行时间长 TAG_SMOKE = &amp;#34;SMOKE&amp;#34; # 冒烟测试 TAG_RARELY_USED = &amp;#34;RARELY_USED&amp;#34; # 非常少用 TAG_REGRESSION = &amp;#34;REGRESSION&amp;#34; # 回归测试 TAG_PERFORMANCE = &amp;#34;PERFORMANCE&amp;#34; # 性能测试 TAG_STABILITY = &amp;#34;STABILITY&amp;#34; # 稳定测试 TAG_SECURITY = &amp;#34;SECURITY&amp;#34; # 安全测试 TAG_COMPATIBILITY = &amp;#34;COMPATIBILITY&amp;#34; # 兼容测试 TAG_OTHER = &amp;#34;OTHER&amp;#34; # 其他 TAG_CI = &amp;#34;CI&amp;#34; # 集成测试 TAG_DEBUG = &amp;#34;DEBUG&amp;#34; # 测试 TAG_DEMO = &amp;#34;DEMO&amp;#34; # demo 在默认配置中(config/_default.</description>
    </item>
    <item>
      <title>必要规范</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/97_constraint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/97_constraint/</guid>
      <description>为了方便将所有人的贡献集合在一起，需要在编码、环境、文档编写等方面采用相同的“规范”。&#xA;环境要求 python： 在python编码过程中，尽可能的采用标准库，采用兼容Python3大部分版本的通用语法（尽可能的在Python3.6 - Python3.12中通用），不要使用过旧或者过新的语法。 操作系统： 建议Ubuntu 22.04，windows下，建议使用WSL2环境。 hugo 建议版本 0.124.1（版本过旧不支持软连接） 少依赖 尽可能少的使用第三方C++/C库 picker 建议使用wheel安装picker工具和xspcomm库 测试用例 代码风格 建议采用 PEP 8 规范 build脚本 需要按DUT的命名结构进行规范命名，不然无法正确收集验证结果。例如backend.ctrl_block.decodeUT在scripts目录中对应的build文件名称应该为build_ut_backend_ctrl_block_decode.py(以固定前缀build_ut_开始，点.用下划线_进行替换)。在脚本中实现 build(cfg) -&amp;gt; bool 和 line_coverage_files(cfg) -&amp;gt; list[str] 方法。build用于编译DUT为python模块，line_coverage_files方法用于返回需要统计的代码行覆盖率文件。 用例标签 如果用例无法做到版本通用，需要用pytest.mark.toffee_tags标记支持的版本。 用例抽象 编写的测试用例输入不能出现DUT的具体引脚等强耦合内容，只能调用基于DUT之上的函数封装。例如对于加法器 adder，需要把dut的目标功能封装为 dut_wrapper.add(a: int, b: int) -&amp;gt; int, bool，在test_case中仅仅调用 sum, c = add(a, b)进行测试。 覆盖抽象 在编写功能覆盖率时，其检查点函数的输入也不能有DUT引脚。 环境抽象 对于一个验证，通常分为2部分：Test Case 和 Env （用例以外的都统一称为Env，它包含DUT、驱动、监控等），其中Env需要提供对外的功能抽象接口，不能对外呈现出太多细节。 测试说明 在每个DUT的验证环境中，需要通过README.md对该环境进行说明，例如需要对Env提供给Case的接口进行说明，目录结构说明等。 PR编写 标题 简洁明了，能概括PR的主要内容。 详细描述 详细说明PR的目的，修改的内容以及相关背景信息。入解决已有的问题需要给出链接（例如Issue）。 关联问题 在描述中关联相关问题，例如 Fixes #123，以便在合并PR时关闭关联问题。 测试 需要进行测试，并对测试结果进行描述 文档 PR涉及到的文档需要同步修改 分解 当PR涉及到的修改很多时，需要判断是否拆分成多个PR 检查清单 检查编译是否通过、代码风格是否合理、是否测试通过、是否有必要的注释等 模板 以及提供的PR模块请参考链接。 ISSUE编写 要求同上</description>
    </item>
    <item>
      <title>维护者</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/99_maintain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/99_maintain/</guid>
      <description>在提交 issue、pull request、discussion 时，如果指定对应模块的 maintainer 能更及时的得到响应。目前已有的维护人员如下（首字母排名）：&#xA;验证工具：&#xA;picker：Makiras, SFangYy, yaozhicheng toffee/toffe-test：Miical, yaozhicheng 当前版本： 20250318070200-main-2eb4fd1378bb957db14afbae18a0f9ca0eb36523 20250317023055-main-ec9b2b3fda9ed0706f5c70c4413765c042062eb3 20250306075137-main-0ca85ce5acfa0894762be5d008a2bf85bed08101 20250306021736-main-8fcdd79da758da0a651aa1a763732a98d640589e 20250303064534-main-3baa11d910f8949c77dadf50b0f8d95fd78cfc08 20250221085945-main-1bcaa98e96a9bc8404c5e71c8490aca66f56722b 20250210003155-main-2b529583954cafe6f145a5d8d49740ebd4d0fa4c 20250206064001-main-8e09f7c86acf67eb7649bd67df3ec51dccc77aaa 20250201121154-main-9595c680af64cc08a12f22a1d595ce111249f153 20250123032900-main-88fa1057ab93bd8286fc2705a1fd203397995702 20250121015322-main-2f2073ab1f56cc01fed1da01d6ddc6ed52880693 20241223133801-main-2a8c1ab351e4ea786c55435dd18f60c0c523cc8a 20241220061304-main-187577e01df03a8ff7ffc828b79070bd5e582436 20241218062220-main-a866912fc3a6df3d17b857a1a898f6f9e5c5957c 20241217100236-main-53f30b46ed6e6eeb261894c4a71a60f69777ef8c 20241216044913-main-7d081626cef0910d9490d169053ee32a8e0c51db 20241213025923-main-d09f78a58caeeb64347ca2587f1f3f2b2a59e6a0 20241212091919-main-c54c0c2e590cf334b986f8ef3eacc53329f4ed1e 20241204085334-main-335e7e0d4ffc2c7a17f8d95e7c75cbd428b14a61 20241204062337-main-f8903a8c4021ba3e310bf097b07147892729341c 20241201142531-main-365f53f574ba5c6875b3389824a3c898c642ed2b 20241129112435-main-79ccae9d5df92c4e167547564b97bd8846b7ecb6 20241129111104-main-8e0cb45a86ec3ffd779723e17ede379081431c42 主UT模块&#xA;子UT模块&#xA;*其他维护者陆续更新中&#xA;如果您对本项目感兴趣，欢迎申请成为本项目中的维护者。</description>
    </item>
    <item>
      <title>搜索结果</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/search/</guid>
      <description></description>
    </item>
  </channel>
</rss>
