<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XiangShan UT Docs on 万众一芯之香山处理器</title>
    <link>https://open-verify.cc/UnityChipForXiangShan/</link>
    <description>Recent content in XiangShan UT Docs on 万众一芯之香山处理器</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/UnityChipForXiangShan/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>FIFO文档模板</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/00_template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/00_template/</guid>
      <description>以下是一份验证文档的完整模板（请一定同提交的验证报告区分开来）&#xA;# 验证文档各部分说明 ## 文档概述【必填项】 在该部分对整个文档进行简约描述，例如内容概述，待验证模块的基本功能、特殊需求、特定规格、目标读者、知识前置等。目的是通过对该部分，读者便了解是否具有其感兴趣的内容。例如本文档是对验证文档的编写要求进行描述，便于多文档协作，规范验证的数据输入，特定数据标签等。 ## 术语说明 【必填项】 列出术语和关键概念解释，方便读者参考 优先解释模块专有缩写（如TLB， FIFO等），如果有缩写，请用`缩写（全称）的方式填在表格的“名称”栏目中` 对容易混淆的概念请务必明确（如虚拟地址和物理地址等） | 名称 | 定义 | | ------- | ---| | 缩写1（FULL_NAME_1）&#x9;| 描述1 | | 缩写2（FULL_NAME_2）&#x9;| 描述2 | | 概念名1&#x9;| 描述3 | ## 前置知识【可选项】 在阅读文档或进行验证之前，建议掌握一些关键前置知识，以便更深入理解相关内容。例如，在撰写LoadStoreQueue（LSQ）文档时，讲述RAW（Read After Write）违例有助于理解操作之间的依赖关系。在撰写Icache或L2Cache文档时，介绍缓存层级、替换策略和一致性模型等基本概念也有助于读者理解。如果涉及复杂算法，也应对其进行简要描述。 基本要求： 1. 该部分内容应简洁，易于理解。如篇幅较长，可将内容移至附录。 2. 针对较为复杂的内容，可以通过图像、伪代码和案例进行解释，以降低理解难度。 ## 整体框图 【可选项】 若模块含多个子模块或复杂数据流，需提供框图辅助说明 可使用Visio/Draw.io等工具绘制，导出为PNG/SVG格式； 需标注关键信号流向； 框图中子模块命名需与“子模块列表”章节严格一致。 ## 流水级示意图 【可选项】 若为复杂流水线型模块，需说明各级流水功能与时序关系 可使用Visio/Draw.io等工具绘制，导出为PNG/SVG格式； 涉及到的模块名称需要保持一致性 重要数据除了列出名称以外，还需要标明位宽等信息 ## 子模块列表 【可选项】 若模块由多个子模块组成，需在此列出 以下是IFU top文档中的一个示例： | 子模块 | 描述 | | ---------------------- | ------------------- | | [子模块1](子模块1文档位置) | 子模块1描述 | | [子模块2](子模块2文档位置) | 子模块2描述 | | [子模块3](子模块3文档位置) | 子模块3描述 | &amp;lt;mrs-functions&amp;gt; ## 模块功能说明 【必填项】 需按功能树形式逐级分解，每个功能点需对应后续测试点。 请用&amp;lt;mrs-functions&amp;gt;&amp;lt;/functions&amp;gt;包裹整个“模块功能说明”部分。 采用X.</description>
    </item>
    <item>
      <title>添加编译脚本</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/01_build_script/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/01_build_script/</guid>
      <description>脚本目标 在scripts目录下使用python编写对应rtl的编译文件（例如build_ut_frontend_ifu_rvc_expander.py）。&#xA;该脚本的目标是提供 RTL 到 Python DUT 的编译、目标覆盖文件，以及自定义功能等内容。&#xA;创建过程 确定文件名称 在香山昆明湖 DUT 验证进展中选择需要验证的 UT，如果没有或者进一步细化，可通过编辑configs/dutree/xiangshan-kmh.yaml自行添加。&#xA;比如，我们要验证的是前端部分的ifu模块下的rvc_expander模块，那么需要在configs/dutree/xiangshan-kmh.yaml中添加对应的部分（目前yaml中已经有该模块了，此处为举例）：&#xA;name: &amp;#34;kmh_dut&amp;#34; desc: &amp;#34;所有昆明湖DUT&amp;#34; children: - name: &amp;#34;frontend&amp;#34; desc: &amp;#34;前端模块&amp;#34; children: - name: &amp;#34;ifu&amp;#34; desc: &amp;#34;指令单元 (Instruction Fetch Unit)&amp;#34; children: - name: &amp;#34;rvc_expander&amp;#34; desc: &amp;#34;RVC指令扩充器&amp;#34; 脚本文件的命名格式如下：&#xA;scripts/build_&amp;lt;顶层模块&amp;gt;_&amp;lt;下层模块名&amp;gt;_..._&amp;lt;目标模块名&amp;gt;.py 目前本项目内置了 4 个顶层模块：&#xA;ut_frontend 前端 ut_backend 后端 ut_mem_block 访存 ut_misc 其他 其中的子模块没有ut_前缀（顶层目录有该前缀是为了和其他目录区分开）。&#xA;例如验证目标 DUT 为rvc_expander模块：&#xA;该模块是属于前端的，所以顶级模块为ut_frontend，它的下层模块为ifu，目标模块为rvc_expander。&#xA;通过刚才我们打开的yaml文件也可以知道，frontend的children 为ifu，ifu的children 为rvc_expander。 所以，需要创建的脚本名称为build_ut_frontend_ifu_rvc_expander.py。&#xA;编写 build(cfg) -&amp;gt; bool 函数 build 函数定义如下：&#xA;def build(cfg) -&amp;gt; bool: &amp;#34;&amp;#34;&amp;#34;编译DUT Args: cfg: 运行时配置，可通过它访问配置项，例如 cfg.</description>
    </item>
    <item>
      <title>构建测试环境</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/02_build_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/02_build_env/</guid>
      <description>确定目录结构 UT(Unit Test, 单元测试)所在的目录位置的层级结构应该与名称一致，例如frontend.ifu.rvc_expander应当位于ut_frontend/ifu/rvc_expander目录，且每层目录都需要有__init__.py，便于通过 python 进行import。&#xA;本章节的文件为your_module_wrapper.py（如果你的模块是rvc_expander，那么文件就是rvc_expander_wrapper.py）。&#xA;wrapper 是包装的意思，也就是我们测试中需要用到的方法封装成和dut解耦合的API提供给测试用例使用。&#xA;*注：解耦合是为了测试用例和 DUT 解耦，使得测试用例可以独立于 DUT 进行编写和调试，也就是在测试用例中，不需要知道 DUT 的具体实现细节，只需要知道如何使用 API 即可。可以参照将验证代码与DUT进行解耦&#xA;该文件应该放于ut_frontend_or_backend/top_module/your_module/env（这里依然以rvc_expander举例：rvc_expander属于前端，其顶层目录则应该是ut_frontend；rvc_expander的顶层模块是ifu，那么次级目录就是ifu;之后的就是rvc_expander自己了；最后，由于我们是在构建测试环境，再建一级env目录。将它们连起来就是：ut_frontend_or_backend/top_module/your_module/env）目录下。&#xA;ut_frontend/ifu/rvc_expander ├── classical_version │ ├── env │ │ ├── __init__.py │ │ └── rvc_expander_wrapper.py │ ├── __init__.py │ └── test_rvc_expander.py ├── __init__.py ├── README.md └── toffee_version ├── agent │ └── __init__.py ├── bundle │ └── __init__.py ├── env │ ├── __init__.py │ └── ref_rvc_expand.py ├── __init__.py └── test ├── __init__.py ├── rvc_expander_fixture.</description>
    </item>
    <item>
      <title>添加测试用例</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/03_add_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/03_add_test/</guid>
      <description>命名要求 所有测试用例文件请以test_*.py的方式进行命名，*用测试目标替换（例如test_rvc_expander.py）。所有测试用例也需要以test_前缀开头。用例名称需要具有明确意义。&#xA;命名举例如下：&#xA;def test_a(): # 不合理，无法通过a判断测试目标 pass def test_rvc_expand_16bit_full(): # 合理，可以通过用例名称大体知道测试内容 pass 使用 Assert 在每个测试用例中，都需要通过assert来判断本测试是否通过。 pytest统计的是assert语句的结果，因此assert语句需要保证能够通过。&#xA;以下内容位于ut_frontend/ifu/rvc_expander/classical_version/test_rvc_expander.py中：&#xA;def rvc_expand(rvc_expander, ref_insts, is_32bit=False, fsIsOff=False): &amp;#34;&amp;#34;&amp;#34;compare the RVC expand result with the reference Args: rvc_expander (warpper): the fixture of the RVC expander ref_insts (list[int]]): the reference instruction list &amp;#34;&amp;#34;&amp;#34; find_error = 0 for insn in ref_insts: insn_disasm = disasmbly(insn) value, instr_ex = rvc_expander.expand(insn, fsIsOff) if is_32bit: assert value == insn, &amp;#34;RVC expand error, 32bit instruction need to be the same&amp;#34; if (insn_disasm == &amp;#34;unknown&amp;#34;) and (instr_ex == 0): debug(f&amp;#34;find bad inst:{insn}, ref: 1, dut: 0&amp;#34;) find_error +=1 elif (insn_disasm !</description>
    </item>
    <item>
      <title>FIFO文档案例</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/01_fifo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/01_fifo/</guid>
      <description>以下以FIFO为例，展示了一个简单的文档案例&#xA;`timescale 1ns / 1ps module FIFO ( //data_width = 8 data depth =8 input clk, input rst_n, input wr_en, //写使能 input rd_en, //读使能 input [7:0]wdata, //写入数据输入 output [7:0]rdata, //读取数据输出 output empty, //读空标志信号 output full //写满标志信号 ); reg [7:0] rdata_reg = 8&amp;#39;d0; assign rdata = rdata_reg; reg [7:0] data [7:0]; //数据存储单元(8bit数据8个) reg [3:0] wr_ptr = 4&amp;#39;d0; //写指针 reg [3:0] rd_ptr = 4&amp;#39;d0; //读指针 wire [2:0] wr_addr; //写地址(写指针的低3位) wire [2:0] rd_addr; //读地址(读指针的低3位) assign wr_addr = wr_ptr[2:0]; assign rd_addr = rd_ptr[2:0]; always@(posedge clk or negedge rst_n)begin //写数据 if(!</description>
    </item>
    <item>
      <title>代码覆盖率</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</guid>
      <description>代码覆盖率是一项评价指标，它衡量了被测代码中哪些部分被执行了，哪些部分没有被执行。通过统计代码覆盖率，可以评估测试的有效性和覆盖程度。&#xA;代码覆盖率包括：&#xA;行覆盖率(line coverage): 被测代码中被执行的行数，最简单的指标，一般期望达到 100%。 条件覆盖率(branch coverage): 每一个控制结构的每个分支是否均被执行。例如，给定一个 if 语句，其 true 和 false 分支是否均被执行？ 有限状态机覆盖率(fsm coverage): 状态机所有状态是否都达到过。 翻转覆盖率(toggle coverage): 统计被测代码中被执行的翻转语句，检查电路的每个节点是否都有 0 -&amp;gt; 1 和 1 -&amp;gt; 0 的跳变。 路径覆盖率(path coverage): 检查路径的覆盖情况。在 always 语句块和 initial 语句块中，有时会使用 if &amp;hellip; else 和 case 语句，在电路结构上便会产生一系列的数据路径。。 *我们主要使用的模拟器是 Verilator,优先考虑行覆盖率。Verilator 支持覆盖率统计，因此我们在构建 DUT 时，如果要开启覆盖率统计，需要在编译选项中添加-c参数。&#xA;本项目中相关涉及位置 开启覆盖率需要在编译时（使用 picker 命令时）加上“-c”参数（参考 picker 的参数解释），同时在文件中设置启用行覆盖率，这样在使用 toffee 测试时，才能够生成覆盖率统计文件。&#xA;结合上面的描述，在本项目中也就是编译，编写和启用行覆盖率函数和测试的时候会涉及到代码覆盖率：&#xA;添加编译脚本部分 编写编译脚本&#xA;# 省略前面 if not os.path.exists(get_root_dir(&amp;#34;dut/RVCExpander&amp;#34;)): info(&amp;#34;Exporting RVCExpander.sv&amp;#34;) s, out, err = exe_cmd(f&amp;#39;picker export --cp_lib false {get_rtl_dir(&amp;#34;rtl/RVCExpander.</description>
    </item>
    <item>
      <title>功能覆盖率</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</guid>
      <description>功能覆盖率（Functional Coverage）是一种用户定义的度量标准，用于度量验证中已执行的设计规范的比例。功能覆盖率关注的是设计的功能和特性是否被测试用例覆盖到了。&#xA;反标是指将功能点与测试用例对应起来。这样，在统计时，就能看到每个功能点对应了哪些测试用例，从而方便查看哪些功能点用的测试用例多，哪些功能点用的测试用例少，有利于后期的测试用例优化。&#xA;本项目中相关涉及位置 功能覆盖率需要我们先定义了才能统计，主要是在构建测试环境的时候涉及。&#xA;在构建测试环境中：&#xA;定义功能覆盖率： 创建了功能覆盖率组,添加观察点和反标 定义必要 fixture： 把统计结果传递给 toffee-report 统计覆盖率： 添加观察点和反标 其他：&#xA;在 Test case 中使用，可以在每个测试用例里也编写一个功能点。 功能覆盖率使用流程 指定 Group 名称 测试报告通过 Group 名字和 DUT 名字进行匹配，利用 comm.UT_FCOV 获取 DUT 前缀，例如在 Python 模块ut_frontend/ifu/rvc_expander/classical_version/env/rvc_expander_wrapper.py中进行如下调用：&#xA;from comm import UT_FCOV # 本模块名为：ut_frontend.ifu.rvc_expander.classical_version.env.rvc_expander_wrapper # 通过../../../去掉了classical_version和上级模块env，rvc_expander_wrapper # UT_FCOV会默认去掉前缀 ut_ g = fc.CovGroup(UT_FCOV(&amp;#34;../../../CLASSIC&amp;#34;)) # name = UT_FCOV(&amp;#34;../../../CLASSIC&amp;#34;) name 的值为frontend.ifu.rvc_expander.CLASSIC，在最后统计结果时，会按照最长前缀匹配到目标 UT（即匹配到：frontend.ifu.rvc_expander 模块）&#xA;创建覆盖率组 使用toffee的funcov可以创建覆盖率组。&#xA;import toffee.funcov as fc # 使用上面指定的GROUP名字 g = fc.CovGroup(name) 这两步也可以合成一句g = fc.CovGroup(UT_FCOV(&amp;quot;../../../CLASSIC&amp;quot;))。 创建的g对象就表示了一个功能覆盖率组，可以使用其来提供观察点和反标。</description>
    </item>
    <item>
      <title>果壳Cache文档案例</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/02_nutshell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/02_nutshell/</guid>
      <description>本文档将以果壳L1Cache作为案例，展示一个具有相当复杂度的模块的验证说明文档例子（请一定同提交的验证报告区分开来）。&#xA;果壳L1Cache验证文档 文档概述 本文档针对NutShell L1Cache的验证需求撰写，通过对其功能进行描述并依据功能给出参考测试点，从而帮助验证人员编制测试用例。&#xA;果壳（NutShell）是一款由5位中国科学院大学本科生设计的基于RISC-V RV64开放指令集的顺序单发射处理器(NutShell·Github), 隶属于国科大与计算所“一生一芯”项目。而果壳Cache（NutShell Cache）是其缓存模块，采用可定制化设计（L1 Cache和L2 Cache采用相同的模板生成，只需要调整参数），具体来说，L1 Cache（指令Cache和数据Cache）大小为32KB，L2 Cache大小为128KB, 在整体结构上，果壳Cache采用三级流水的结构。&#xA;本次验证的目标是L1 Cache，即一级缓存。&#xA;术语说明 名称 定义 MMIO（Memory-Mapped Input/Output） 内存映射IO 写回 Cache需要进行替换时，会将脏替换块写回内存 关键字优先方案 缺失发生时，系统会优先获取CPU所需要的当前指令或数据所对应的字 前置知识 Cache的层次结构 Cache有三种主要的组织方式：直接映射（Direct-Mapped）Cache、组相连（Set-Associative）Cache和全相连（Fully-Associative）Cache。对于物理内存中的一个数据，如果在Cache中只有一个位置可以存放它，这就是直接映射Cache；如果有多个位置可以存放这个数据，这就是组相连Cache；如果Cache中的任何位置都可以存放这个数据，这就是全相连Cache。&#xA;直接映射Cache和全相连Cache实际上是组相连Cache的两种特殊情况。现代处理器中的Cache通常属于这三种方式中的一种。例如，翻译后备缓冲区（TLB）和Victim Cache多采用全相连结构，而普通的指令缓存（I-Cache）和数据缓存（D-Cache）则采用组相连结构。当处理器需要执行一个指令时，它会首先查找该指令是否在I-Cache中。如果在，则直接从I-Cache中读取指令并执行；如果不在，则需要从内存中读取指令到I-Cache中，再执行。与I-Cache类似，当处理器需要读取或写入数据时，会首先查找D-Cache。如果数据在D-Cache中，则直接读取或写入；如果不在，则需要从内存中加载数据到D-Cache中。与I-Cache不同的是，D-Cache需要考虑数据的一致性和写回策略。为了保证数据的一致性，当数据在D-Cache中被修改后，需要同步更新到内存中。&#xA;Cache的写入 在执行写数据时，如果只是向D-Cache中写入数据而不改变其下级存储器中的数据，就会导致D-Cache和下级存储器对于同一地址的数据不一致（non-consistent）。为了保持一致性，一般Cache在写命中状态下采用两种写入方式： （1）写通（Write Through）：数据写入D-Cache的同时也写入其下级存储器。然而，由于下级存储器的访问时间较长，而存储指令的频率较高，频繁地向这种较慢的存储器中写入数据会降低处理器的执行效率。 （2）写回（Write Back）：数据写入D-Cache后，只是在Cache line上做一个标记，并不立即将数据写入更下级的存储器。只有当Cache中这个被标记的line要被替换时，才将其写入下级存储器。这种方式能够减少向较慢存储器写入数据的频率，从而获得更好的性能。然而，这种方式会导致D-Cache和下级存储器中许多地址的数据不一致，给存储器的一致性管理带来一定的负担。&#xA;D-Cache处理写缺失一般有两种策略：&#xA;（1）非写分配（Non-Write Allocate）：直接将数据写入下级存储器，而不将其写入D-Cache。这意味着当发生写缺失时，数据会直接写入到下级存储器，而不会经过D-Cache。&#xA;（2）写分配（Write Allocate）：在发生写缺失时，会先将相应地址的整个数据块从下级存储器中读取到D-Cache中，然后再将要写入的数据合并到这个数据块中，最终将整个数据块写回到D-Cache中。这样做的好处是可以在D-Cache中进行更多的操作，但同时也增加了对内存的访问次数和延迟。 写通（Write Through）和非写分配（Non-Write Allocate）将数据直接写入下级存储器，而写回（Write Back）和写分配（Write Allocate）则会将数据写入到D-Cache中。通常情况下，D-Cache的写策略搭配为写通+非写分配或写回+写分配。&#xA;写通示意图&#xA;写通示意图&#xA;写回示意图&#xA;替换策略 读写D-Cache发生缺失时，需要从对应的Cache Set中找到一个cache行，来存放从下级存储器中读出的数据，如果此时这个Cache Set内的所有Cache行都已经被占用了，那么就需要替换掉其中一个，如何从这些有效的Cache行找到一个并替换它，这就是替换策略，本节介绍几种最常用的替换策略。&#xA;近期最少使用法会选择最近被使用次数最少的Cache行，因此这个算法需要追踪每个Cache行的使用情况，这需要为每个Cache行都设置一个年龄（age）部分，每当一个Cache行被访问时，它对应的年龄部分就会增加，或者减少其他Cache行的年龄值，这样当进行替换时，年龄值最小的那个Cache行就是被使用次数最少的了，会选择它进行替换。&#xA;随机替换算法硬件实现简单，这种方法发生缺失的频率会更高一些，但是随着Cache容量的增大，这个差距是越来越小的。在实际的设计中，很难实现严格的随机，一般采用一种称为时钟算法（clock algorithm）的方法实现近似的随机，它的工作原理本质上是一个时钟计数器，计数器的宽度由Cache的路的个数决定，当要替换时，就根据这个计数器选择相应的行进行替换。这种方法硬件复杂度较低，也不会损失较多的性能，因此是一种折中的方法。&#xA;整体框图和流水级 以下是L1Cache的整体框图和流水级示意：&#xA;子模块列表 以下是NutShell L1Cache的一些子模块：&#xA;子模块 描述 s1 缓存阶段1 s2 缓存阶段2 s3 缓存阶段3 metaArray 以数组形式存储元数据 dataArray 以数组形式存储缓存数据 arb 总线仲裁器 上下游通信总线采用SimpleBus总线，包含了req和resp两个通路，其中req通路的cmd信号表明请求的操作类型，可以通过检查该信号获得访问类型。SimpleBus总线共有七种操作类型，由于NutShell文档未涉及probe和prefetch操作，在验证中只出现五种操作：read、write、readBurst、writeBurst、writeLast，前两种为字读写，后三种为Burst读写，即一次可以操作多个字。</description>
    </item>
    <item>
      <title>F3PreDecoder</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/02_f3predecoder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/02_f3predecoder/</guid>
      <description>子模块：F3PreDecoder模块简介 这个模块是从PreDecoder中时序优化出来的，负责判定CFI指令的类型&#xA;F3PreDecoder功能介绍 CFI指令类型判定 要想确定CFI指令类型，只需要分别尝试匹配JAL、JALR、BR和他们的RVC版本即可，注意，RVC的EBREAK 不应该被视为CFI指令。在匹配的过程中，自然CFI指令的类型就被甄别出来了。在这一步中，我们将所有指令分到如下四类brType中：&#xA;CFI指令类型 brType类型编码 非CFI 00 branch指令 01 jal指令 10 jalr指令 11 ret、call判定 然后，我们需要判断是否为call或者ret，这可以通过rd和rs的取值来考察，具体来说，RISCV的RVI指令中，提供了对rd和rs取值的约定， 当二者取到link寄存器的序号（x1为标准的返回地址寄存器，x5为备用的link寄存器），分别对应着压栈和弹栈。详细的对应情况如下：&#xA;F3Predecoder接口说明 in_instr: 传递 16 x 4B的拼接指令码&#xA;out_pd：每条指令的预译码信息，在F3Predecoder分析得到的是brType、isCall和isRet&#xA;F3PreDecoder子模块测试点和功能点 功能点1 CFI指令类型判定 要想确定CFI指令类型，只需要分别尝试匹配JAL、JALR、BR和他们的RVC版本即可，注意，RVC的EBREAK 不应该被视为CFI指令。&#xA;序号 名称 描述 1.1 非CFI判定 对传入的非CFI指令（包括RVC.EBREAK），应该判定为类型0 1.2 BR判定 对传入的BR指令，应该判定为类型1 1.3 JAL判定 对传入的JAL指令，应该判定为类型2 1.4 JALR判定 对传入的JALR指令，应该判定为类型3 功能点2 ret、call判定 然后，需要判断是否为call或者ret，这可以通过rd和rs的取值来考察。当然，首先必须得满足无条件跳转指令。&#xA;对于类型2，只有不为RVC指令且目的寄存器rd为link寄存器（x1或x5）时，才为Call。&#xA;对于类型3，在RVI指令下，当rd为link寄存器时，必为Call。当rs为link寄存器且rd不为时，必为Ret。 在RVC指令下，对C.JALR指令，为call，对C.JR指令，当rs1为link时，为Ret&#xA;序号 名称 描述 2.1 非CFI和BR不判定 对传入的非CFI和BR指令，都不应判定为call或者ret 2.2.1.1 RVI.JAL判定call 对传入的RVI.JAL指令，当rd设置为1或5，应当判定该指令为call 2.2.1.2 RVI.JAL例外 对传入的RVI.JAL指令，当rd设置为1和5之外的值，不应当判定该指令为call或ret 2.2.2 RVC.JAL不判定 对传入的RVC.JAL指令，无论什么情况都不能判定为call或ret 2.3.1.1 RVI.JALR和rd为link 传入RVI.</description>
    </item>
    <item>
      <title>FrontendTrigger</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/05_frontend_trigger/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/05_frontend_trigger/</guid>
      <description>FrontendTrigger子模块 该子模块的主要作用是在前端设置硬件断点和检查。&#xA;该模块的输入pc有一个隐含条件，那就是这个pc是通过ftq传递的startAddr计算出来的。&#xA;FrontendTrigger功能介绍 断点设置和断点检查 在IFU的FrontendTrigger模块里共4个Trigger，编号为0,1,2,3，每个Trigger的配置信息（断点类型、匹配地址等）保存在tdata寄存器中。&#xA;当软件向CSR寄存器tselect、tdata1/2写入特定的值时，CSR会向IFU发送tUpdate请求，更新FrontendTrigger内的tdata寄存器中的配置信息。 目前前端的Trigger仅可以配置成PC断点mcontrol.tdata1寄存器的select位为0；当select=1时，该Trigger将永远不会命中，且不会产生异常）。&#xA;在取指时，IFU的F3流水级会向FrontendTrigger模块发起查询并在同一周期得到结果。后者会对取指块内每一条指令在每一个Trigger上做检查， 当指令的PC和tdata2寄存器内容的关系满足mcontrol.match位所指示的关系（香山支持match位为0、2、3，对应等于、大于等于、小于）时， 该指令会被标记为Trigger命中，随着执行在后端产生断点异常，进入M-Mode或调试模式。&#xA;链式断点 根据RISCV的debug spec，香山实现的是mcontrol6。&#xA;当它们对应的Chain位被置时，只有当该Trigger和编号在它后面一位的Trigger同时命中，且timing配置相同时（在最新的手册中，这一要求已被删除），处理器才会产生异常。&#xA;在过去（riscv-debug-spec-draft，对应 XiangShan 2024.10.05 合入的 PR#3693 前）的版本中，Chain 还需要满足两个 Trigger 的 mcontrol.timing 是相同的。而在新版（riscv-debug-spec-v1.0.0）中，mcontrol.timing 被移除。目前 XiangShan 的 scala 实现仍保留了这一位，但其值永远为 0 且不可写入，编译生成的 verilog 代码中没有这一位。&#xA;FrontendTrigger 接口说明 设计上并没有提供一个或一组对外的接口来查询某个断点的状态，因此，要在测试中检查断点状态，要么需要检查内部信号的情况（仓库中提供的构建脚本已经暴露了所有内部信号），要么通过具体执行过程中，断点的触发情况来判定。&#xA;输入接口 主要分为控制接口和执行信息（目前执行信息只有pc）&#xA;控制接口 io_frontendTrigger 本接口存储了frontendTrigger的控制信息，包含以下信号/信号组：&#xA;debugMode 当前是否处于debug模式下&#xA;tEnableVec 对FrontendTrigger的每个断点，指示其是否有效。&#xA;tUpdate 更新断点的控制信息，包含以下信号/信号组：&#xA;valid：此次更新是否有效/是否更新。&#xA;bits_addr：此次更新的是哪个断点（0~3）&#xA;bits_tdata_action：断点触发条件达成后的行为&#xA;bits_tdata_chain：断点是否链式传导&#xA;bits_tdata_matchType：断点匹配类型（等于、大于、小于三种）&#xA;bits_tdata_select：目前为止，select为0时为pc断点&#xA;bits_tdata_tdata2：用于和PC比较的基准值&#xA;triggerCanRaiseBpExp trigger是否可以引起异常&#xA;pc pc有一个隐含条件，就是16条指令的pc必定是连续的&#xA;输出接口 triggered：16条指令的断点触发情况。&#xA;FrontEndTrigger 测试点和功能点 功能点1 设置断点和断点检查 FrontEndTrigger目前仅支持设置PC断点，这通过设置断点的tdata1寄存器的select位为0实现。 同时，tdata2寄存器的mcontrol位负责设置指令PC和tdata2寄存器的地址需要满足的关系， 关系满足时，该指令会被标记为trigger命中。</description>
    </item>
    <item>
      <title>IO接口说明</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/04_io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/04_io/</guid>
      <description>香山实例化 TLB.sv 接口说明（ITLB） 基本控制信号 clock: 时钟信号，驱动 TLB 的时序逻辑。 reset: 复位信号，用于重置 TLB 的状态。 刷新（SFENCE）接口信号 io_sfence_valid: SFENCE 操作的有效性标志。 io_sfence_bits_rs1: SFENCE 操作是否使用寄存器 rs1 的值。 io_sfence_bits_rs2: SFENCE 操作是否使用寄存器 rs2 的值。 io_sfence_bits_addr: SFENCE 操作指定的地址，用于选择性刷新特定地址的 TLB 条目。 io_sfence_bits_id: 刷新操作指定的 asid/vmid，用于选择性刷新特定地址空间的 TLB 条目。 io_sfence_bits_flushPipe: 刷新整个管道。 io_sfence_bits_hv: 指示指令是否为 HFENCE.VVMA，即是否刷新虚拟化下由 vsatp 寄存器控制的条目。 io_sfence_bits_hg: 指示指令是否为 HFENCE.GVMA，即是否刷新由 hgatp 寄存器控制的条目。 控制与状态寄存器（CSR）接口信号 io_csr_satp_mode: SATP 寄存器的模式字段（如裸模式、Sv32、Sv39 等）。 io_csr_satp_asid: 当前 SATP 寄存器的 ASID（地址空间标识符）。 io_csr_satp_changed: 指示 SATP 寄存器的值是否已更改。 io_csr_vsatp_mode: VSATP 寄存器的模式字段。 io_csr_vsatp_asid: VSATP 寄存器的 ASID。 io_csr_vsatp_changed: 指示 VSATP 寄存器的值是否已更改。 io_csr_hgatp_mode: HGATP 寄存器的模式字段。 io_csr_hgatp_vmid: HGATP 寄存器的 VMID（虚拟机标识符）。 io_csr_hgatp_changed: 指示 HGATP 寄存器的值是否已更改。 io_csr_priv_virt: 指示是否在虚拟模式下运行。 io_csr_priv_imode: 指令模式的特权级（如用户态、内核态等）。 请求者（Requestor）接口信号 Requestor 0 信号 io_requestor_0_req_valid: requestor0 的请求有效信号。 io_requestor_0_req_bits_vaddr: requestor0 的请求虚拟地址。 io_requestor_0_resp_bits_paddr_0: requestor0 的物理地址响应信号。 io_requestor_0_resp_bits_gpaddr_0: requestor0 的物理地址转换为 GPA（Guest Physical Address）的响应信号。 io_requestor_0_resp_bits_miss: requestor0 请求的地址未命中的信号。 io_requestor_0_resp_bits_excp_0_gpf_instr: requestor0 出现 General Protection Fault (GPF) 异常的信号。 io_requestor_0_resp_bits_excp_0_pf_instr: requestor0 出现 Page Fault (PF) 异常的信号。 io_requestor_0_resp_bits_excp_0_af_instr: requestor0 出现 Access Fault (AF) 异常的信号。 Requestor 1 信号 io_requestor_1_req_valid: requestor1 的请求有效信号。 io_requestor_1_req_bits_vaddr: requestor1 的请求虚拟地址。 io_requestor_1_resp_bits_paddr_0: requestor1 的物理地址响应信号。 io_requestor_1_resp_bits_gpaddr_0: requestor1 的 GPA 响应信号。 io_requestor_1_resp_bits_miss: requestor1 的未命中信号。 io_requestor_1_resp_bits_excp_0_gpf_instr: requestor1 出现 GPF 异常的信号。 io_requestor_1_resp_bits_excp_0_pf_instr: requestor1 出现 PF 异常的信号。 io_requestor_1_resp_bits_excp_0_af_instr: requestor1 出现 AF 异常的信号。 Requestor 2 信号 io_requestor_2_req_ready: requestor2 的请求就绪信号。 io_requestor_2_req_valid: requestor2 的请求有效信号。 io_requestor_2_req_bits_vaddr: requestor2 的请求虚拟地址。 io_requestor_2_resp_ready: requestor2 的响应就绪信号。 io_requestor_2_resp_valid: requestor2 的响应有效信号。 io_requestor_2_resp_bits_paddr_0: requestor2 的物理地址响应信号。 io_requestor_2_resp_bits_gpaddr_0: requestor2 的 GPA 响应信号。 io_requestor_2_resp_bits_excp_0_gpf_instr: requestor2 出现 GPF 异常的信号。 io_requestor_2_resp_bits_excp_0_pf_instr: requestor2 出现 PF 异常的信号。 io_requestor_2_resp_bits_excp_0_af_instr: requestor2 出现 AF 异常的信号。 刷新管道（Flush Pipe）信号 io_flushPipe_0: 刷新管道 0 的信号。 io_flushPipe_1: 刷新管道 1 的信号。 io_flushPipe_2: 刷新管道 2 的信号。 页表遍历（Page Table Walker, PTW）接口信号 PTW 请求信号 io_ptw_req_0_valid: PTW req0 有效信号。 io_ptw_req_0_bits_vpn: PTW req0 的虚拟页号（VPN）。 io_ptw_req_0_bits_s2xlate: 指示 PTW req0 的转换模式。 io_ptw_req_0_bits_getGpa: PTW req0 的获取 GPA 信号。 io_ptw_req_1_valid: PTW req1 有效信号。 io_ptw_req_1_bits_vpn: PTW req1 的虚拟页号。 io_ptw_req_1_bits_s2xlate: 指示 PTW req1 的转换模式。 io_ptw_req_1_bits_getGpa: PTW req1 的获取 GPA 信号。 io_ptw_req_2_ready: PTW req2 就绪信号。 io_ptw_req_2_valid: PTW req2 有效信号。 io_ptw_req_2_bits_vpn: PTW req2 的虚拟页号。 io_ptw_req_2_bits_s2xlate: 指示 PTW req2 的转换模式。 io_ptw_req_2_bits_getGpa: PTW req2 的获取 GPA 信号。 PTW 响应信号 io_ptw_resp_valid: PTW resp 有效信号。 io_ptw_resp_bits_s2xlate: 指示 PTW resp 的地址转换类型。 io_ptw_resp_bits_s1_entry_tag: PTW resp 的第一阶段页表条目标签。 io_ptw_resp_bits_s1_entry_asid: PTW resp 的第一阶段页表条目 ASID。 io_ptw_resp_bits_s1_entry_vmid: PTW resp 的第一阶段页表条目 VMID。 io_ptw_resp_bits_s1_entry_perm_d: PTW resp 的第一阶段页表条目可写位。 io_ptw_resp_bits_s1_entry_perm_a: PTW resp 的第一阶段页表条目已访问位。 io_ptw_resp_bits_s1_entry_perm_g: PTW resp 的第一阶段页表条目全局位。 io_ptw_resp_bits_s1_entry_perm_u: PTW resp 的第一阶段页表条目用户模式位。 io_ptw_resp_bits_s1_entry_perm_x: PTW resp 的第一阶段页表条目可执行位。 io_ptw_resp_bits_s1_entry_perm_w: PTW resp 的第一阶段页表条目可写位。 io_ptw_resp_bits_s1_entry_perm_r: PTW resp 的第一阶段页表条目可读位。 io_ptw_resp_bits_s1_entry_level: PTW resp 的第一阶段页表条目级别。 io_ptw_resp_bits_s1_entry_ppn: PTW resp 的第一阶段页表条目物理页号（PPN）。 io_ptw_resp_bits_s1_addr_low: PTW resp 的第一阶段页表条目地址低位。 io_ptw_resp_bits_s1_ppn_low_*: PTW resp 的第一阶段页表条目 PPN 低位。 io_ptw_resp_bits_s1_valididx_*: PTW resp 的第一阶段页表条目有效索引。 io_ptw_resp_bits_s1_pteidx_*: PTW resp 的第一阶段页表条目 PTE 索引。 io_ptw_resp_bits_s1_pf: PTW resp 的第一阶段页表条目出现 PF。 io_ptw_resp_bits_s1_af: PTW resp 的第一阶段页表条目出现 AF。 io_ptw_resp_bits_s2_entry_tag: PTW resp 的第二阶段页表条目标签。 io_ptw_resp_bits_s2_entry_vmid: PTW resp 的第二阶段页表条目 VMID。 io_ptw_resp_bits_s2_entry_ppn: PTW resp 的第二阶段页表条目 PPN。 io_ptw_resp_bits_s2_entry_perm_*: PTW resp 的第二阶段页表条目的权限位。 io_ptw_resp_bits_s2_entry_level: PTW resp 的第二阶段页表条目级别。 io_ptw_resp_bits_s2_gpf: PTW resp 的第二阶段页表条目 GPF 信号。 io_ptw_resp_bits_s2_gaf: PTW resp 的第二阶段页表条目 GAF 信号。 io_ptw_resp_bits_getGpa: PTW resp 的获取 GPA 信号。 </description>
    </item>
    <item>
      <title>PredChecker</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/04_pred_checker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/04_pred_checker/</guid>
      <description>子模块：PredChecker简介 分支预测检查器PredChecker接收来自IFU的预测块信息（包括预测跳转指令在预测块的位置、预测的跳转目标、预译码得到的指令信息、指令PC以及预译码得到的跳转目标偏移等），在模块内部检查五种类型的分支预测错误。模块内部分为两个流水线stage，分别输出信息，第一个stage输出给IFU的f3阶段，用于修正预测块的指令范围和预测结果。第二个stage输出给wb阶段，用于在发现分支预测错误时产生前端重定向以及写回给FTQ（Fetch Target Queue）正确的预测信息。&#xA;PredChecker功能介绍 JAL预测错误检查 jal指令预测错误的条件是，预测块中有一条有效jal指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条jal指令之后（即这条jal指令没有被预测跳转）。&#xA;JALR预测错误检查 jalr指令预测错误的条件是，预测块中有一条有效jalr指令（由预译码信息给出），而且这个指令不是ret指令，但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条jalr指令之后（即这条jalr指令没有被预测跳转）。&#xA;RET预测错误检查 ret指令预测错误的条件是，预测块中有一条有效ret指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条ret指令之后（即这条ret指令没有被预测跳转）。&#xA;更新指令有效范围向量 PredChecker在检查出Jal/Ret/JALR指令预测错误时，需要重新生成指令有效范围向量，有效范围截取到Jal/Ret指令的位置，之后的bit全部置为0。 需要注意的是，jal和ret指令的错误检查都会导致指令有效范围的缩短， 所以需要重新生成指令有效范伟fixedRange，同时修复预测结果。需要注意的是，这个修复只会针对RET预测错误和JAL预测错误导致的范围错误，对于后续要介绍的非CFI（控制流指令）预测错误和无效指令预测错误，尽管他们会造成预测块的范围偏小，但是不会进行修复，而是直接在这里进行重定向。这样，重定向后重新取的指令会从这个出错的指令开始。&#xA;非CFI预测错误检查 非CFI预测错误的条件是被预测跳转的指令根据预译码信息显示不是一条CFI指令。&#xA;无效指令预测错误检查 无效指令预测错误的条件是被预测的指令的位置根据预译码信息中的指令有效向量显示不是一条有效指令的开始。&#xA;目标地址预测错误检查 目标地址预测错误的条件是，被预测的是一条有效的jal或者branch指令，同时预测的跳转目标地址和由指令码计算得到的跳转目标不一致。&#xA;分级输出检查结果 以上PredChecker检查结果会分为两级分别输出，前面已经提到，Jal/Ret指令由于需要重新生成指令有效范围向量和重新指定预测位置， 所以需要在错误产生的当拍（F3）直接输出结果到Ibuffer用于及时更正进入后端的指令 。而由于时序的考虑，其他错误信息（比如五种错误的错误位置、正确的跳转地址等）则是等到下一拍（WB）阶段才返回给IFU做前端重定向。&#xA;PredChecker接口说明 输入接口 fire_in：这个信号可以简单认为是模块有效性的控制信号。&#xA;ftqOffset：来自BPU（分支预测单元）的预测信息，表示该预测块的跳转指令是否存在（valid），以及跳转指令的序号（bits）。&#xA;instrRange：来自PreDecode的预译码信息，对每条指令，表示该指令是否在预测块的有效指令范围内。&#xA;instrValid：来自PreDecode的预译码信息，表示的是对于每条32位的拼接指令，其是否为一条有效的指令（即低16位为一条RVC指令，或者整个32位为一条RVI指令）。&#xA;jumpOffset：来自PreDecode的预译码信息，如果某一指令为跳转指令，jumpOffset表示这个指令的跳转目标。&#xA;pc：指令的pc。&#xA;pds：来自PreDecode模块的预译码信息，包含指令的brType、是否为Ret（isRet）、是否为RVC指令（isRVC）。&#xA;target：来自BPU，下个预测块的开始地址。&#xA;输出接口 第一阶段输出 fixedRange：修复的指令有效范围向量，对每条指令i，fixedRange_i为真表示这条指令是否在当前预测块的有效指令范围内&#xA;fixedTaken：修复过后的CFI指令选取情况，对每条指令，fixedTaken_i为真表示这条指令是否是这个预测块的第一条CFI指令&#xA;第二阶段输出 fixedMissPred：对每条指令，PredChecker检查出的存在预测错误的情况，fixedMissPred_i为真表示这条指令存在预测错误&#xA;fixedTarget：对每条指令，给出修复过的下一条指令的位置（可以是常规的pc+2或+4，或者如果是跳转指令，给出跳转目标）。&#xA;jalTarget：对每条指令，给出跳转目标。&#xA;faultType：每条指令的错误类型，取指范围包含noFault，jalFault，retFault，targetFault，notCFIFault，invalidTaken，jalrFault，分别对应数字0～6&#xA;PredChecker测试点和功能点 功能点1 BPU预测信息的JAL预测错误检查 PredChecker会对传入的预测块进行JAL预测错误预检查并修正指令有效范围向量和预测的跳转指令。&#xA;对这一模块的测试，我们分为两部分：正确的输入是否会误检和确有JAL检测错误的预测块输入能否检出。&#xA;对于误检，我们设计如下的测试点:&#xA;序号 名称 描述 1.1.1 误检测试1 预测块中没有JAL指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JAL预测错误。 1.1.2 误检测试2 预测块中有JAL指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JAL预测错误。 对于JAL预测错误的正确检验，我们设计如下的测试点：&#xA;序号 名称 描述 1.2.1 存在JAL未预测 预测块中存在JAL指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出JAL预测错误。 1.2.2 预测的JAL并非第一条 预测块中存在JAL指令，但是BPU预测信息取的跳转指令在第一条JAL指令之后，检查PredChecker是否能检测出JAL预测错误。 功能点2 BPU预测信息的RET预测错误检查 PredChecker会对传入的预测块进行RET预测错误预检查并修正指令有效范围向量和新的预测结果。</description>
    </item>
    <item>
      <title>PreDecode</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/01_predecode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/01_predecode/</guid>
      <description>子模块：PreDecoder简介 预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。&#xA;所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。&#xA;预译码器的输出是：16x4B的拼接指令码；对每个4B指令码，该条指令是否为RVI或RVC指令（RVC指令只考虑该4B的低2B）；对每个4B指令码，该条指令的跳转偏移；两个16位的有效指令开始向量，其中第一种向量假定当前预测块的起始2字节为一条有效指令的开始，而第二种向量假定当前预测块的起始2字节为一条有效RVI指令的结束（但是由于第二种向量的前两位必然为0和1,所以编译优化后，第二种向量实际只有14个信号，表示2-15位；同理，第1种向量的第0位因为恒为1,所以也被优化）&#xA;功能介绍 指令码生成 预译码器接受来自IFU完成指令切分的17 × 2字节的初始指令码，并以4字节为窗口，2字节为步进长度， 从第1个2字节开始，直到第16个2字节，选出总共16个4字节的指令码。&#xA;预译码信息生成 预译码器根据指令码产生预译码信息，主要包括：是否是RVC指令、是否是CFI指令、 CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移。&#xA;首先是判断是否是RVC指令，RVC指令的具体格式参阅RISCV手册的描述：&#xA;其中，决定指令是否为RVC的部分在于指令的[1, 0]两位，不为3的情况下都是RVC指令。&#xA;其余的指令性质判定功能（CFI类型、是否为call和ret）被时序优化到了F3PreDecoder中，不过也可以认为是PreDecoder的一部分，可以设置测试点进行测试&#xA;最后比较麻烦的是CFI指令的目标地址计算偏移，主要是对J和BR分支指令进行的计算，这需要综合RVI和RVC中jal和br指令的结构。 首先，是手册中对于C.J的描述&#xA;这里对imm立即数的注解是，立即数的每一位最后对应到的是偏移的哪一位。&#xA;所以，可以认为立即数是这么重组的：&#xA;instr(12) + instr(8) + instr(10, 9) + instr(6) + instr(7) + instr(2) + instr(11) +instr(5,3) + &amp;ldquo;0&amp;rdquo;&#xA;而RVI中，对于JAL指令，是这么定义的：&#xA;我们可以类似地计算立即数。&#xA;同样的，我们可以查询手册，参考BR类指令的立即数计算RVC和RVI指令对应的偏移。&#xA;PreDecode接口说明 输入接口 in_bits_data 17 x 2B的初始指令码，其中，每2个字节既可以代表一条RVC指令，也可以代表一个RVI指令的一半。&#xA;输出接口 instr：拼接后的 16 x 4B的初始指令码&#xA;jumpOffset：如果这条指令是跳转指令，则jumpOffset表示其跳转偏移&#xA;pd：每条指令预译码信息，包括valid、isRVC、brType、isRet、isCall。其中第0条指令的valid已经被优化了&#xA;hasHalfValid：这个信号需要和pd的valid结合起来看，PreDecode的一个功能是求出指令开始向量，也就是对每个4B的拼接指令，判断其低2B是否为一条有效指令的开始（即一条RVI指令的前半部分，或者一条RVC指令），但是需要分类讨论该预测块的第一个2B是否为一条有效指令的开始。hasHalfValid表示的是当前预测块的第一个2B指令为一条RVI指令的后半部分时，给出的指令开始向量。类似地，pd中的valid指的是当前预测块的第一个2B指令为一条指令的开始时，给出的指令开始向量。&#xA;PreDecoder测试点和功能点 功能点1 生成指令码 子模块：PreDecoder简介&#xA;预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。&#xA;所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。&#xA;预译码器的输出是：16x4B的拼接指令码；对每个4B指令码，该条指令是否为RVI或RVC指令（RVC指令只考虑该4B的低2B）；对每个4B指令码，该条指令的跳转偏移；两个16位的有效指令开始向量，其中第一种向量假定当前预测块的起始2字节为一条有效指令的开始，而第二种向量假定当前预测块的起始2字节为一条有效RVI指令的结束（但是由于第二种向量的前两位必然为0和1,所以编译优化后，第二种向量实际只有14个信号，表示2-15位；同理，第1种向量的第0位因为恒为1,所以也被优化） 功能介绍 指令码生成</description>
    </item>
    <item>
      <title>RVCExpander</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/03_ifu_rvc_exp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/03_ifu_rvc_exp/</guid>
      <description>子模块：RVCExpander简介 RVCExpander是IFU的子模块，负责对传入的指令进行指令扩展，并解码计算非法信息。&#xA;该模块接收的输入量是两个：一条RVC指令或者RVI指令；CSR对fs.status的使能情况。&#xA;输出量也是两个：输入指令对应的RVI指令；RVC指令是否非法。&#xA;指令扩展 如果是RVI指令，则无需扩展。&#xA;否则对RVC指令，按照手册的约定进行扩展。&#xA;非法指令判断 RVI指令永远判断为合法。&#xA;对于RVC指令的判定，详细内容参阅20240411的RISCV手册的26.8节表格列出的指令条件。&#xA;RVCExpander接口说明 输入接口 fsIsOff：表示CSR是否使能fs.status&#xA;in：传入一个32位数据，其可以是一个完整的RVI指令，也可以是低16位RVC指令+高16位为RVI指令的一半（当然低16位也有可能是RVI指令的后半部分，但是RVCExpander不会区分，可以认为RVCExpander假定传入的32位数据的低16位一定为一条指令的开始）&#xA;输出接口 ill：表示这条指令是否为非法指令&#xA;out_bits：对RVI指令，直接返回，对RVC指令，返回扩展后的32位指令。&#xA;功能点和测试点 功能点1 指令扩展 RVCExpander负责接收预译码器拼接的指令码，并进行指令扩展，如果是16位RVC指令，需要按照RISCV手册的约定完成扩展&#xA;对此，我们需要随机生成RVI指令和RVC指令，送入预译码器：&#xA;序号 名称 描述 1.1 RVI指令保留 构造RVI指令传入，检查保留情况 1.2 RVC指令扩展 构造RVC指令传入，按手册检查扩展结果 功能点2 非法指令判断 RVCExpander在解析指令时，如发现指令违反了手册的约定，则需要判定该指令非法&#xA;对此，我们需要随机生成非法指令送入RVI中，并检测RVCExpander对合法位的校验；同时，我们还需要校验合法指令是否会被误判为非法指令：&#xA;此外，需要判定C.fp指令在CSR未使能fs.status的情况下，能否将这类指令判定为非法。&#xA;序号 名称 描述 2.1 常规非法指令测试 随机构造非法RVC指令传入，检查判断结果 2.2 合法指令测试 随机构造合法RVC指令传入，检查判断结果 2.3 C.fp指令测试 CSR未使能fs.status的情况下，C.fp指令应该为非法 测试点汇总 序号 功能 名称 描述 1.1 指令扩展 RVI指令保留 构造RVI指令传入，检查保留情况 1.2 指令扩展 RVC指令扩展 构造RVC指令传入，按手册检查扩展结果 2.1 非法指令判断 非法指令测试 随机构造非法RVC指令传入，检查判断结果 2.2 非法指令判断 合法指令测试 随机构造合法RVC指令传入，检查判断结果 2.</description>
    </item>
    <item>
      <title>功能详述</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_func/</guid>
      <description>支持 SV48 分页机制 SV48 （Supervisor-mode Virtual Memory）是一种基于 RISC-V 的页表虚拟内存寻址模式，指定了 48 位虚拟地址空间的结构，支持 256TB 的虚拟内存地址空间。使用四级页表结构：&#xA;在 SV48 的一个 PTE 中包含了如下字段：&#xA;N:&#xA;指示是否为 NAPOT PTE。供 Svnapot 扩展使用，如果未实现 Svnapot 则该位必须由软件置 0，否则应当出现 Page Fault。目前香山昆明湖架构尚未支持此扩展。 PBMT:&#xA;Page-Based Memory Types，即基于页面的内存类型，供 Svpbmt 扩展使用，允许操作系统为每个页面指定不同的内存访问属性。 0: None，没有特定的内存属性。 1: NC，非缓存、幂等、弱序（RVWMO），适用于主存。 2: IO，非缓存、非幂等、强序（I/O 排序），适用于 I/O 设备。 3: Reserved，保留供将来标准使用。 同样的，如果未实现 Svpbmt 则这两位必须由软件置 0，否则应当出现 Page Fault。&#xA;Reserved:&#xA;保留位，供未来的标准使用。如果有任意一位不是 0 则会触发 PF 异常。 PPN:&#xA;表示物理页框号，指向实际的物理内存页。PPN 与页面内偏移结合形成完整的物理地址，用于地址转换。 RSW:&#xA;保留供软件使用的位，通常用于特定的标志或操作，以便在软件实现中提供灵活性。 D:&#xA;脏位，指示该页面是否被写入。如果该位为 1，表示该页的数据已被修改，需在换出时写回到存储设备。 A:&#xA;访问位，指示该页是否被访问过。如果该位为 1，表示该页已被读取或写入，用于页面替换算法。 G:</description>
    </item>
    <item>
      <title>关键信号说明</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/03_keysignal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/03_keysignal/</guid>
      <description>相关 CSR 寄存器 val csr = Input(new TlbCsrBundle) csr：包含 satp、vsatp、hgatp 三个寄存器的信息以及一些权限信息。&#xA;class TlbCsrBundle(implicit p: Parameters) extends XSBundle { val satp = new TlbSatpBundle() val vsatp = new TlbSatpBundle() val hgatp = new TlbHgatpBundle() val priv = new Bundle { val mxr = Bool() val sum = Bool() val vmxr = Bool() val vsum = Bool() val virt = Bool() val spvp = UInt(1.W) val imode = UInt(2.W) val dmode = UInt(2.</description>
    </item>
    <item>
      <title>环境配置</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_env/</guid>
      <description>推荐使用WSL2+Ubuntu22.04+GTKWave 我们推荐Windows10/11用户通过WSL2进行开发，在此给出通过此方法进行环境配置的教程集锦，仅供参考。如环境安装过程中出现任何问题，欢迎在QQ群（群号：976081653）中提出，我们将尽力帮助解决。此页面将收集大家提出的所有环境配置相关问题并提供解决方案，欢迎随时向我们提问！&#xA;1、在Windows下安装WSL2（Ubuntu22.04） 参考资源：&#xA;&amp;mdash; 微软官方教程：如何使用 WSL 在 Windows 上安装 Linux&#xA;&amp;mdash; 其它资源：安装WSL2和Ubuntu22.04版本&#xA;2、打开WSL，换源 推荐使用清华源：清华大学开源软件镜像站-Ubuntu软件仓库&#xA;3、配置验证环境 请参照开放验证平台学习资源-快速开始-搭建验证环境配置picker环境。&#xA;4、使用 GTKWave 使用重庆大学硬件综合设计实验文档-Windows原生GTKWave给出的方法，可以通过在WSL中输入 gtkwave.exe wave.fst 打开在Windows下安装的GTKWave。请注意，gtkwave在使用中需要进入fst文件所在文件夹，否则会出现无法 initialize的情况。&#xA;cd out gtkwave.exe {test_name}.fst cd .. 5、使用VSCode插件Live Server查看验证报告 成功安装插件Live Server后，打开文件列表，定位到 /out/report/2025*-itlb-doc-*/index.html 右键并选择 Open With Live Server，之后在浏览器中打开提示的端口（默认为//localhost:5500）即可。</description>
    </item>
    <item>
      <title>目标验证单元</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/00_unitychip_for_xiangshan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/00_unitychip_for_xiangshan/</guid>
      <description>当前版本： 20250318070200-main-2eb4fd1378bb957db14afbae18a0f9ca0eb36523 20250317023055-main-ec9b2b3fda9ed0706f5c70c4413765c042062eb3 20250306075137-main-0ca85ce5acfa0894762be5d008a2bf85bed08101 20250306021736-main-8fcdd79da758da0a651aa1a763732a98d640589e 20250303064534-main-3baa11d910f8949c77dadf50b0f8d95fd78cfc08 20250221085945-main-1bcaa98e96a9bc8404c5e71c8490aca66f56722b 20250210003155-main-2b529583954cafe6f145a5d8d49740ebd4d0fa4c 20250206064001-main-8e09f7c86acf67eb7649bd67df3ec51dccc77aaa 20250201121154-main-9595c680af64cc08a12f22a1d595ce111249f153 20250123032900-main-88fa1057ab93bd8286fc2705a1fd203397995702 20250121015322-main-2f2073ab1f56cc01fed1da01d6ddc6ed52880693 20241223133801-main-2a8c1ab351e4ea786c55435dd18f60c0c523cc8a 20241220061304-main-187577e01df03a8ff7ffc828b79070bd5e582436 20241218062220-main-a866912fc3a6df3d17b857a1a898f6f9e5c5957c 20241217100236-main-53f30b46ed6e6eeb261894c4a71a60f69777ef8c 20241216044913-main-7d081626cef0910d9490d169053ee32a8e0c51db 20241213025923-main-d09f78a58caeeb64347ca2587f1f3f2b2a59e6a0 20241212091919-main-c54c0c2e590cf334b986f8ef3eacc53329f4ed1e 20241204085334-main-335e7e0d4ffc2c7a17f8d95e7c75cbd428b14a61 20241204062337-main-f8903a8c4021ba3e310bf097b07147892729341c 20241201142531-main-365f53f574ba5c6875b3389824a3c898c642ed2b 20241129112435-main-79ccae9d5df92c4e167547564b97bd8846b7ecb6 20241129111104-main-8e0cb45a86ec3ffd779723e17ede379081431c42 查看测试报告 上图共有-个模块，默认情况下模块为灰色，当模块中的测试用例数大于-时，该模块被完全点亮。目前已经完全点亮的模块为-个，待点亮的模块有-个。&#xA;通用处理器模块简介 高性能处理器是现代计算设备的核心，它们通常由三个主要部分组成：前端、后端和访存系统。这些部分协同工作，以确保处理器能够高效地执行复杂的计算任务。&#xA;前端：前端部分，也被称为指令获取和解码阶段，负责从内存中获取指令并将其解码成处理器可以理解的格式。这一阶段是处理器性能的关键，因为它直接影响到处理器可以多快地开始执行指令。前端通常包括指令缓存、分支预测单元和指令解码器。指令缓存用于存储最近访问过的指令，以减少对主内存的访问次数，从而提高处理速度。分支预测单元则尝试预测程序中的条件分支，以便提前获取和解码后续指令，这样可以减少等待分支结果的时间。&#xA;后端：后端部分，也称为执行阶段，是处理器中负责实际执行指令的地方。这一阶段包括了算术逻辑单元（ALU）、浮点单元（FPU）和各种执行单元。这些单元负责进行算术运算、逻辑运算、数据传输和其他处理器操作。后端的设计通常非常复杂，因为它需要支持多种指令集架构（ISA）并优化性能。为了提高效率，现代处理器通常采用超标量架构，这意味着它们可以同时执行多条指令。&#xA;访存：访存系统是处理器与内存之间交互的桥梁。它包括了数据缓存、内存控制器和高速缓存一致性协议。数据缓存用于存储处理器频繁访问的数据，以减少对主内存的访问次数。内存控制器负责管理处理器与内存之间的数据传输。高速缓存一致性协议确保在多处理器系统中，所有处理器看到的内存状态是一致的。&#xA;高性能处理器的设计需要在这三个部分之间找到平衡，以实现最佳的性能。这通常涉及到复杂的微架构设计，以及对处理器流水线的优化。</description>
    </item>
    <item>
      <title>准备验证环境</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/01_verfiy_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/01_verfiy_env/</guid>
      <description>基础环境需求 本项目基于Python编程语言进行UT验证，采用的工具和测试框架为picker和toffee，环境需求如下：&#xA;Linux操作系统。建议WSL2下安装Ubuntu22.04。 Python。建议Python3.11。 picker。按照快速开始中的提示安装最新版本。 toffee。将在后面自动安装。也可按照快速开始中的提示手动安装最新版本。 lcov。用于后续test阶段报告生成。使用包管理器即可下载：sudo apt install lcov 环境配置完成后，clone仓库：&#xA;git clone https://github.com/XS-MLVP/UnityChipForXiangShan.git cd UnityChipForXiangShan pip3 install -r requirements.txt # 安装python依赖（例如 toffee） 下载RTL代码： 默认从仓库https://github.com/XS-MLVP/UnityChipXiangShanRTLs中下载。用户也可以自行按照XiangShan文档编译生成RTL。&#xA;make rtl # 该命下载最新的rtl代码，并解压至rtl目录，并创建软连接 可以用以下命令指定下载的rtl版本：&#xA;make rtl args=&amp;#34;rtl.version=\&amp;#39;openxiangshan-kmh-fad7803d-24120901\&amp;#39;&amp;#34; 所有RTL下载包请在UnityChipXiangShanRTLs中查看。&#xA;RTL压缩包的命名规范为：名称-微架构-Git标记-日期编号.tar.gz，例如openxiangshan-kmh-97e37a2237-24092701.tar.gz。在使用时，仓库代码会过滤掉git标记和后缀，例如通过 cfg.rtl.version 访问到的版本号为：openxiangshan-kmh-24092701。压缩包内的目录结构为：&#xA;openxiangshan-kmh-97e37a2237-24092701.tar.gz └── rtl # 目录 |-- *.sv # 所有sv文件 `-- *.v # 所有v文件 编译DUT 该过程的目的是将RTL通过picker工具打包为Python模块。可以通过make命令指定被打包DUT，也可以一次性打包所有DUT。&#xA;如果想要自行打包某个dut，需要创建编写scripts目录中的build_ut_&amp;lt;name&amp;gt;.py脚本。这一脚本必须实现一个build方法，在打包时会被自动调用。此外还有一个line_coverage_files方法，用于指定行覆盖率参考的文件。&#xA;picker的打包支持内部信号的加入，详见picker的--internal参数，传递给其一个自定义的yaml即可。&#xA;# 调用scripts目录中的build_ut_&amp;lt;name&amp;gt;.py中的build方法，创建待验证的Python版DUT make dut DUTS=&amp;lt;name&amp;gt; # DUTS的值如果有多个，需要用逗号隔开，支持通配符。DUTS默认值为 &amp;#34;*&amp;#34;，编译所有DUT # 例如： make dut DUTS=backend_ctrl_block_decode 以make dut DUTS=backend_ctrl_block_decode为例，命令执行完成后，会在dut目录下生成对应的Python包：</description>
    </item>
    <item>
      <title>运行测试</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/02_run_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/02_run_test/</guid>
      <description>本项目基于PyTest测试框架进行验证。运行测试时，PyTest框架自动搜索所有test_*.py文件，并自动执行其中所有以test_开头的测试用例（Test Case）。&#xA;# 执行所有ut_*目录中的test case make test_all # 执行指定目录下的test case make test target=&amp;lt;dir&amp;gt; # 例如执行ut_backend/ctrl_block/decode目录中所有的test case make test target=ut_backend/ctrl_block/decode 可通过args参数传递Pytest的运行参数，例如启动x-dist插件的多核功能：&#xA;make test args=&amp;#34;-n 4&amp;#34; # 启用 4 个进程 make test args=&amp;#34;-n auto&amp;#34; # 让框架自动选择启用多少个进程 *注：x-dist可以在多节点上并发运行测试，可参考其文档&#xA;运行完成后，默认在out/report目录会生成html版本的测试报告，其 html 文件可通过浏览器直接打开查看（VS Code IDE建议安装Open In Default Browser插件）。&#xA;运行测试主要完成以下三部分内容：&#xA;按要求运行Test Case，可通过cfg.tests中的选项进行配置 统计测试结果，输出测试报告。有toffee-report自动生成 (总测试报告，所有Test的结果合并在一起) 根据需要（cfg.doc_result.disable = True）在测试报告上进行进一步数据统计 </description>
    </item>
    <item>
      <title>如何参与本项目</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/06_join_us/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/06_join_us/</guid>
      <description>如何提交Bug 按 ISSUE 模板进行提交，标记上对应的标签（bug，bug等级等）&#xA;对应模块的维护者进行检查，并修改他给出的标记和香山分支&#xA;如何提交文档 本仓库文档以PR的形式在本仓库提交，DUT文档在仓库UnityChipForXiangShan/documents/content/zh-cn/docs/98_UT中进行提交。&#xA;本项目欢迎任何人以ISSUE、DISCUSS、Fork、PR的方式参与。&#xA;万众一芯QQ交流群：</description>
    </item>
    <item>
      <title>模板-PR</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/08_template_pr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/08_template_pr/</guid>
      <description># Description Please include a summary of the changes and the related issue. Please also include relevant motivation and context. List any dependencies that are required for this change. Fixes # (issue) ## Type of change Please delete options that are not relevant. - [ ] Bug fix (non-breaking change which fixes an issue) - [ ] New feature (non-breaking change which adds functionality) - [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected) - [ ] This change requires a documentation update # How Has This Been Tested?</description>
    </item>
    <item>
      <title>模板-ISSUE</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/09_template_issue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/09_template_issue/</guid>
      <description>## Description A brief description of the issue. ## Steps to Reproduce 1. Describe the first step 2. Describe the second step 3. Describe the third step 4. ... ## Expected Result Describe what you expected to happen. ## Actual Result Describe what actually happened. ## Screenshots If applicable, add screenshots to help explain your problem. ## Environment - OS: [e.g. Windows 10, macOS 10.15, Ubuntu 20.04] - Browser: [e.g. Chrome 86, Firefox 82, Safari 14] - Version: [e.</description>
    </item>
    <item>
      <title>模板-UT-README</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/10_template_ut_readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/10_template_ut_readme/</guid>
      <description># 模块名称 ## 测试目标 &amp;lt;测试目标、测试方法描述&amp;gt; ## 测试环境 &amp;lt;测试环境描述，依赖描述&amp;gt; ## 功能检测 &amp;lt;给出目标待测功能与对应的检测方法&amp;gt; |序号|所属模块|功能描述|检查点描述|检查标识|检查项| |-|-|-|-|-|-| |-|-|-|-|-|-| ## 验证接口 &amp;lt;接口的描述&amp;gt; ## 用例说明 #### 测试用例1 |步骤|操作内容|预期结果|覆盖功能点| |-|-|-|-| |-|-|-|-| #### 测试用例2 |步骤|操作内容|预期结果|覆盖功能点| |-|-|-|-| |-|-|-|-| ## 目录结构 &amp;lt;对本模块的目录结构进行描述&amp;gt; ## 检测列表 - [ ] 本文档符合指定[模板]()要求 - [ ] Env提供的API不包含任何DUT引脚和时序信息 - [ ] Env的API保持稳定（共有[ X ]个） - [ ] Env中对所支持的RTL版本（支持版本[ X ]）进行了检查 - [ ] 功能点（共有[ X ]个）与[设计文档]()一致 - [ ] 检查点（共有[ X ]个）覆盖所有功能点 - [ ] 检查点的输入不依赖任何DUT引脚，仅依赖Env的标准API - [ ] 所有测试用例（共有[ X ]个）都对功能检查点进行了反标 - [ ] 所有测试用例都是通过 assert 进行的结果判断 - [ ] 所有DUT或对应wrapper都是通过fixture创建 - [ ] 在上述fixture中对RTL版本进行了检查 - [ ] 创建DUT或对应wrapper的fixture进行了功能和代码行覆盖率统计 - [ ] 设置代码行覆盖率时对过滤需求进行了检查 展示效果如下：</description>
    </item>
    <item>
      <title>常用API</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/95_api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/95_api/</guid>
      <description>comm 模块 在comm中提供了部分可公用的API，可通过以下方式进行调用：&#xA;# import all from comm import * # or direct import functions you need from com import function_you_need # or access from module import comm comm.function_you_need() cfg 子模块 get_config(cfg=None) 获取当前的Config配置&#xA;输入：如果cfg不为空，则返回cfg。否则则自动通过toffee获取全局Config。 返回：Config对象 import comm cfg = comm.get_config() print(cfg.rtl.version) cfg_as_str(cfg: CfgObject): 把config对象转换为字符类型&#xA;输入：Config对象 返回：编码后的Config对象 import comm cfg_str = comm.cfg_as_str(comm.get_config()) cfg_from_str(cfg_str) 把字符类型的Config对象还原&#xA;输入：编码后的Config对象 返回：Config对象 import comm cfg = comm.cfg_from_str(cfg_str) dump_cfg(cfg: CfgObject = None, cfg_file=None) 把config对象保持到文件&#xA;输入： cfg 需要保存的config cfg_file 目标文件 import comm cfg = comm.</description>
    </item>
    <item>
      <title>其他</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/96_others/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/96_others/</guid>
      <description>测试用例管理 如果测试用例和目标RTL版本紧密相关，RTL发生变化，之前的测试用例不一定适用。此外，不同场景下有不同需求，例如验证测试环境时，不运行耗时太长的用例等。因此需要对用例进行管理，让用户能在在特定场景下跳过某些用例。为了实现该目标，我们需要通过pytest.mark.toffee_tags对于每个用例进行tag和version标记。然后在配置文件中设置需要跳过哪些tag或者只运行哪些tag的测试。&#xA;@pytest.mark.toffee_tags(&amp;#34;my_tag&amp;#34;, &amp;#34;version1 &amp;lt; version13&amp;#34;) def test_case_1(): ... 例如上述test_case_1被标记上了标签my_tag，支持版本设置为version1到version13。因此可以在配置文件中指定test.skip-tags=[&amp;quot;my_tag&amp;quot;]，来表示运行过程中跳过该用例。&#xA;pytest.mark.toffee_tags的参数说明如下：&#xA;@pytest.mark.toffee_tags( tag: Optional[list, str] = [] # 用例标签 version: Optional[list, str] = [], # 用例rtl版本需求 skip: callable = None, # 自定义是否调过该用例，skip(tag, version, item): (skip, reason) ) toffee_tags函数的参数tag支持str和list[str]类型。version参数也可以是str和list[str]类型，当为list类型时，进行精确匹配，如果为str则匹配规则如下：&#xA;name-number1 &amp;lt; namer-number2: 表示版本需要在number1和number2之间（包含边界，number表示数字，也可以为小数，eg 1.11） name-number1+：表示number1版本以及以后的版本 name-number1-：表示number1版本以及以前的版本 如果不存在上述情况，且有*或者?表示通配符类型。其他情况为精确匹配。&#xA;预定义标签，可以在comm/constants.py中查看，例如：&#xA;# Predefined tags for test cases TAG_LONG_TIME_RUN = &amp;#34;LONG_TIME_RUN&amp;#34; # 运行时间长 TAG_SMOKE = &amp;#34;SMOKE&amp;#34; # 冒烟测试 TAG_RARELY_USED = &amp;#34;RARELY_USED&amp;#34; # 非常少用 TAG_REGRESSION = &amp;#34;REGRESSION&amp;#34; # 回归测试 TAG_PERFORMANCE = &amp;#34;PERFORMANCE&amp;#34; # 性能测试 TAG_STABILITY = &amp;#34;STABILITY&amp;#34; # 稳定测试 TAG_SECURITY = &amp;#34;SECURITY&amp;#34; # 安全测试 TAG_COMPATIBILITY = &amp;#34;COMPATIBILITY&amp;#34; # 兼容测试 TAG_OTHER = &amp;#34;OTHER&amp;#34; # 其他 TAG_CI = &amp;#34;CI&amp;#34; # 集成测试 TAG_DEBUG = &amp;#34;DEBUG&amp;#34; # 测试 TAG_DEMO = &amp;#34;DEMO&amp;#34; # demo 在默认配置中(config/_default.</description>
    </item>
    <item>
      <title>必要规范</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/97_constraint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/97_constraint/</guid>
      <description>为了方便将所有人的贡献集合在一起，需要在编码、环境、文档编写等方面采用相同的“规范”。&#xA;环境要求 python： 在python编码过程中，尽可能的采用标准库，采用兼容Python3大部分版本的通用语法（尽可能的在Python3.6 - Python3.12中通用），不要使用过旧或者过新的语法。 操作系统： 建议Ubuntu 22.04，windows下，建议使用WSL2环境。 hugo 建议版本 0.124.1（版本过旧不支持软连接） 少依赖 尽可能少的使用第三方C++/C库 picker 建议使用wheel安装picker工具和xspcomm库 测试用例 代码风格 建议采用 PEP 8 规范 build脚本 需要按DUT的命名结构进行规范命名，不然无法正确收集验证结果。例如backend.ctrl_block.decodeUT在scripts目录中对应的build文件名称应该为build_ut_backend_ctrl_block_decode.py(以固定前缀build_ut_开始，点.用下划线_进行替换)。在脚本中实现 build(cfg) -&amp;gt; bool 和 line_coverage_files(cfg) -&amp;gt; list[str] 方法。build用于编译DUT为python模块，line_coverage_files方法用于返回需要统计的代码行覆盖率文件。 用例标签 如果用例无法做到版本通用，需要用pytest.mark.toffee_tags标记支持的版本。 用例抽象 编写的测试用例输入不能出现DUT的具体引脚等强耦合内容，只能调用基于DUT之上的函数封装。例如对于加法器 adder，需要把dut的目标功能封装为 dut_wrapper.add(a: int, b: int) -&amp;gt; int, bool，在test_case中仅仅调用 sum, c = add(a, b)进行测试。 覆盖抽象 在编写功能覆盖率时，其检查点函数的输入也不能有DUT引脚。 环境抽象 对于一个验证，通常分为2部分：Test Case 和 Env （用例以外的都统一称为Env，它包含DUT、驱动、监控等），其中Env需要提供对外的功能抽象接口，不能对外呈现出太多细节。 测试说明 在每个DUT的验证环境中，需要通过README.md对该环境进行说明，例如需要对Env提供给Case的接口进行说明，目录结构说明等。 PR编写 标题 简洁明了，能概括PR的主要内容。 详细描述 详细说明PR的目的，修改的内容以及相关背景信息。入解决已有的问题需要给出链接（例如Issue）。 关联问题 在描述中关联相关问题，例如 Fixes #123，以便在合并PR时关闭关联问题。 测试 需要进行测试，并对测试结果进行描述 文档 PR涉及到的文档需要同步修改 分解 当PR涉及到的修改很多时，需要判断是否拆分成多个PR 检查清单 检查编译是否通过、代码风格是否合理、是否测试通过、是否有必要的注释等 模板 以及提供的PR模块请参考链接。 ISSUE编写 要求同上</description>
    </item>
    <item>
      <title>维护者</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/99_maintain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/99_maintain/</guid>
      <description>在提交 issue、pull request、discussion 时，如果指定对应模块的 maintainer 能更及时的得到响应。目前已有的维护人员如下（首字母排名）：&#xA;验证工具：&#xA;picker：Makiras, SFangYy, yaozhicheng toffee/toffe-test：Miical, yaozhicheng 当前版本： 20250318070200-main-2eb4fd1378bb957db14afbae18a0f9ca0eb36523 20250317023055-main-ec9b2b3fda9ed0706f5c70c4413765c042062eb3 20250306075137-main-0ca85ce5acfa0894762be5d008a2bf85bed08101 20250306021736-main-8fcdd79da758da0a651aa1a763732a98d640589e 20250303064534-main-3baa11d910f8949c77dadf50b0f8d95fd78cfc08 20250221085945-main-1bcaa98e96a9bc8404c5e71c8490aca66f56722b 20250210003155-main-2b529583954cafe6f145a5d8d49740ebd4d0fa4c 20250206064001-main-8e09f7c86acf67eb7649bd67df3ec51dccc77aaa 20250201121154-main-9595c680af64cc08a12f22a1d595ce111249f153 20250123032900-main-88fa1057ab93bd8286fc2705a1fd203397995702 20250121015322-main-2f2073ab1f56cc01fed1da01d6ddc6ed52880693 20241223133801-main-2a8c1ab351e4ea786c55435dd18f60c0c523cc8a 20241220061304-main-187577e01df03a8ff7ffc828b79070bd5e582436 20241218062220-main-a866912fc3a6df3d17b857a1a898f6f9e5c5957c 20241217100236-main-53f30b46ed6e6eeb261894c4a71a60f69777ef8c 20241216044913-main-7d081626cef0910d9490d169053ee32a8e0c51db 20241213025923-main-d09f78a58caeeb64347ca2587f1f3f2b2a59e6a0 20241212091919-main-c54c0c2e590cf334b986f8ef3eacc53329f4ed1e 20241204085334-main-335e7e0d4ffc2c7a17f8d95e7c75cbd428b14a61 20241204062337-main-f8903a8c4021ba3e310bf097b07147892729341c 20241201142531-main-365f53f574ba5c6875b3389824a3c898c642ed2b 20241129112435-main-79ccae9d5df92c4e167547564b97bd8846b7ecb6 20241129111104-main-8e0cb45a86ec3ffd779723e17ede379081431c42 主UT模块&#xA;子UT模块&#xA;*其他维护者陆续更新中&#xA;如果您对本项目感兴趣，欢迎申请成为本项目中的维护者。</description>
    </item>
    <item>
      <title>搜索结果</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/search/</guid>
      <description></description>
    </item>
  </channel>
</rss>
