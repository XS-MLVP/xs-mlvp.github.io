<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XiangShan UT Docs on 万众一芯之香山处理器</title>
    <link>https://open-verify.cc/UnityChipForXiangShan/</link>
    <description>Recent content in XiangShan UT Docs on 万众一芯之香山处理器</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/UnityChipForXiangShan/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bitmap Checker</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/modules/00_bm_checker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/modules/00_bm_checker/</guid>
      <description>&lt;h1 id=&#34;bitmap-checker硬件模块&#34;&gt;Bitmap Checker硬件模块&lt;/h1&gt;&#xA;&lt;h2 id=&#34;bitmap-checker简介&#34;&gt;Bitmap checker简介&lt;/h2&gt;&#xA;&lt;p&gt;Bitmap checker 的作用是将来自外部（ptw/lptw/hptw）的请求发送至cache，并根据是否命中进行内存访问查权限。最后将cache返回的或者内存访问得到的权限发送回请求源。&lt;/p&gt;&#xA;&lt;p&gt;此外，bitmap（walker）支持non blocking 特性，每一个请求来源都有FSM负责录入请求进行处理。但是一次只能有一个fsm进行cache访问。&lt;/p&gt;&#xA;&lt;h2 id=&#34;状态机描述&#34;&gt;状态机描述&lt;/h2&gt;&#xA;&lt;p&gt;为了保持non blocking，有8个独立的状态机（entries）并行运行。每个 entry 维护独立的状态和数据处理。当有请求进入时，从下到上依次将fsm填满，由于总共就8个请求来源，因此不会出现无空闲fsm可用的情况。&lt;/p&gt;&#xA;&lt;p&gt;当entry的PA重复时，仅有一个fsm会进行一次查cache 或者访问memory，其余重复fsm项的状态会被部分跳过。重复表示PA的tag位[47:18] 一致。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;PA&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;段&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;tag&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;Bitmap offset&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;Page offset&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;位&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;[47:18]&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;[17:12]&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;[11:0]&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h4 id=&#34;bitmap-checker-模块状态机&#34;&gt;Bitmap checker 模块状态机&lt;/h4&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../modul00_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;状态机状态&#34;&gt;状态机状态&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;状态&lt;/th&gt;&#xA;          &lt;th&gt;说明&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;state_idle&lt;/td&gt;&#xA;          &lt;td&gt;标明该fsm状态为空，可以录入新请求&lt;br/&gt;当io.req.fire时，切换到新状态&lt;br/&gt;转换条件：&lt;br/&gt;&lt;ul&gt;&lt;li&gt;io.req.fire → state_addr_check (无重复请求)&lt;/li&gt;&lt;li&gt;io.req.fire &amp;amp;&amp;amp; to_wait → state_mem_waiting (检测到重复请求在等待) 同时写入重复项的id到fsm&lt;/li&gt;&lt;li&gt;io.req.fire &amp;amp;&amp;amp; to_mem_out → state_mem_out (重复请求已完成) 同时写入重复项的id到fsm&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;state_addr_check&lt;/td&gt;&#xA;          &lt;td&gt;进行pmp检查&lt;br/&gt;转换条件：&lt;br/&gt;&lt;ul&gt;&lt;li&gt;accessFault=true → state_mem_out (检查失败)&lt;/li&gt;&lt;li&gt;accessFault=false → state_cache_req (检查通过)&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;state_cache_req&lt;/td&gt;&#xA;          &lt;td&gt;将cachereq拉高，fire后→ state_cache_resp&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;state_cache_resp&lt;/td&gt;&#xA;          &lt;td&gt;Cache resp fire后更新：&lt;ul&gt;&lt;li&gt;hit=true → state_mem_out (缓存命中)&lt;/li&gt;&lt;li&gt;hit=false &amp;amp;&amp;amp; cm_to_mem_out → state_mem_out (重复请求已完成) 同时写入重复项的id到fsm&lt;/li&gt;&lt;li&gt;hit=false &amp;amp;&amp;amp; cm_to_wait → state_mem_waiting (检测到重复请求) 同时写入重复项的id到fsm&lt;/li&gt;&lt;li&gt;hit=false → state_mem_req (无重复请求) &lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;state_mem_req&lt;/td&gt;&#xA;          &lt;td&gt;拉高valid 并等待，mem req fire时，将所有重复项目的id跟新为本fsm id，并将所有重复和本机 state 设置为mem wait&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;state_mem_waiting&lt;/td&gt;&#xA;          &lt;td&gt;Fire时→state_mem_out，并将所有的符合id项目内值全部跟新为mem返回值&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;state_mem_out&lt;/td&gt;&#xA;          &lt;td&gt;拉高 resp valid ，fire时→ state_idle&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;接口信号&#34;&gt;接口信号&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;信号&lt;/th&gt;&#xA;          &lt;th&gt;位宽&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Io.mem&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;内存访问相关信号&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.mem.resp.bits.id&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;memory 响应返回的 ID(需为bitmap编号)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.mem.resp.bits.value&lt;/td&gt;&#xA;          &lt;td&gt;512&lt;/td&gt;&#xA;          &lt;td&gt;memory 返回的 bitmap 数据块&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.mem.req_mask&lt;/td&gt;&#xA;          &lt;td&gt;20&lt;/td&gt;&#xA;          &lt;td&gt;Memory 请求屏蔽位&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.mem.req.bits.addr&lt;/td&gt;&#xA;          &lt;td&gt;56&lt;/td&gt;&#xA;          &lt;td&gt;memory 请求的 bitmap 数据地址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.mem.req.bits.id&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;memory 请求的编号(恒定为bitmap编号)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.mem.req.bits.hptw_bypassed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Io.Req&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;请求信号&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.req.bits.bmppn&lt;/td&gt;&#xA;          &lt;td&gt;27&lt;/td&gt;&#xA;          &lt;td&gt;被检查的物理页号 PPN&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.req.bits.id&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;请求编号，用于标识请求来源（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.req.bits.vpn&lt;/td&gt;&#xA;          &lt;td&gt;27&lt;/td&gt;&#xA;          &lt;td&gt;对应虚拟页号VPN&lt;/font&gt;，用于唤醒&lt;/font&gt;pagecache&lt;/font&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.req.bits.level&lt;/td&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;所查询页表的级别信息（&lt;/font&gt;0/1/2&lt;/font&gt;），用于唤醒&lt;/font&gt;pagecache&lt;/font&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.req.bits.way_info&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;TLB way &lt;/font&gt;编号用于唤醒&lt;/font&gt;pagecache&lt;/font&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.req.bits.hptw_bypassed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;用于唤醒&lt;/font&gt;pagecache&lt;/font&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Io.resp&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;返回结果&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.resp.bits.cf&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;检查权限是否允许访问&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.resp.bits.cfs&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;相邻8个（3bit地址空间）的权限&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.resp.bits.id&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;响应对应的请求id&lt;/font&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Io.pmp&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;Pmp&lt;/font&gt;查&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.pmp.req.bits.addr&lt;/td&gt;&#xA;          &lt;td&gt;56&lt;/td&gt;&#xA;          &lt;td&gt;进行PMP检查的物理地址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.pmp.req.bits.cmd&lt;/td&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;读/写权限请求类型（恒定为读）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.pmp.req.bits.size&lt;/td&gt;&#xA;          &lt;td&gt;3&lt;/td&gt;&#xA;          &lt;td&gt;请求访问大小（恒定）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.pmp.resp.ld&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;PMP Load 权限检查结果&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.pmp.resp.mmio&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;PMP MMIO 检查结果&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Io.wakeup&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;Resp&lt;/font&gt;时且非&lt;/font&gt;hptw bypassed &lt;/font&gt;进行重填pagecache&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.wakeup.bits.setIndex&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;唤醒用的setIndex&lt;/font&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.wakeup.bits.tag&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;唤醒tag&lt;/font&gt;（&lt;/font&gt;VPN&lt;/font&gt;高位）（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.wakeup.bits.isSp&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;是否为&lt;/font&gt;superpage&lt;/font&gt;（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.wakeup.bits.way_info&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;TLB&lt;/font&gt;对应的way &lt;/font&gt;信息（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.wakeup.bits.pte_index&lt;/td&gt;&#xA;          &lt;td&gt;6&lt;/td&gt;&#xA;          &lt;td&gt;PTE &lt;/font&gt;在段页表中的索引位置（和&lt;/font&gt;bitmap &lt;/font&gt;模块内部无关）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.wakeup.bits.check_success&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;是否 bitmap 检查通过&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Refill&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io.refill.bits.data&lt;/td&gt;&#xA;          &lt;td&gt;64&lt;/td&gt;&#xA;          &lt;td&gt;要写入cache &lt;/font&gt;的bitmap &lt;/font&gt;数据&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CSR&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_sfence_valid&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;SFENCE &lt;/font&gt;操作有效信号（为高刷新&lt;/font&gt;fsm&lt;/font&gt;）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_satp_changed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;SATP &lt;/font&gt;寄存器变更标志（为高刷新&lt;/font&gt;fsm&lt;/font&gt;）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_vsatp_changed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;VSATP &lt;/font&gt;寄存器变更标志（为高刷新&lt;/font&gt;fsm&lt;/font&gt;）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_hgatp_changed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;HGATP &lt;/font&gt;寄存器变更标志（为高刷新&lt;/font&gt;fsm&lt;/font&gt;）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_mbmc_BMA&lt;/td&gt;&#xA;          &lt;td&gt;58&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap &lt;/font&gt;基址寄存器值&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>背景描述</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/basic/00_bm_background/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/basic/00_bm_background/</guid>
      <description>&lt;h2 id=&#34;背景描述&#34;&gt;背景描述&lt;/h2&gt;&#xA;&lt;p&gt;自计算机问世以来，数据安全始终是至关重要的议题。在个人计算机时代，数据安全主要集中在单机硬盘等存储设备的安全性上。随着互联网时代的到来，数据安全的范畴扩展到了计算机之间数据传输的安全性，促使了安全传输协议的设计与发展。如今，在云计算时代，用户的大量数据被存储和处理在云端。在云环境中存储、共享和计算的数据面临着多重安全威胁。在云计算环境下，不同类型的负载面临各自的威胁模型包括但不限于：&lt;/p&gt;&#xA;&lt;p&gt;计算型负载：恶意软件可能侵入操作系统或固件，攻击 CPU 和内存资源，导致数据泄露或系统性能下降。&lt;/p&gt;&#xA;&lt;p&gt;内存型负载：恶意软件或进程可能试图访问内存型负载使用的内存区域，导致数据泄露或篡改。&lt;/p&gt;&#xA;&lt;p&gt;存储型负载：存储设备及其 DMA 功能可能被攻击者利用，直接访问或篡改存储设备内存，绕过传统安全检查。&lt;/p&gt;&#xA;&lt;p&gt;网络型负载：网络攻击可能利用网络接口控制器（NIC）等网络设备漏洞入侵系统，通过 DMA 功能访问或篡改内存中的敏感数据。&lt;/p&gt;&#xA;&lt;h4 id=&#34;不同工作负载面临的安全威胁&#34;&gt;不同工作负载面临的安全威胁&lt;/h4&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../basic00_1.png&#34; alt=&#34;不同工作负载面临的安全威胁&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;威胁模型&#34;&gt;威胁模型&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;类别&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;安全准则&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;内存分配&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;动态分配安全/非安全内存的能力&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;安全内存应根据需求动态分配或释放。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;内存机密性&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;内存隔离&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;防止非可信计算基（non-TCB）组件读取可信执行环境（TEE）的内存。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;抵御软件攻击的内存完整性&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;防止软件攻击（如内存重映射、别名攻击、重放攻击、数据破坏等）。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;共享内存&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;TEE控制与非TCB组件的数据共享&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;防止非TCB代码在未经TEE同意的情况下泄露信息。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;TEE控制与其他TEE的数据共DUT 享&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;支持TEE之间安全共享内存的能力。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;I/O保护&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;防止非TCB设备通过DMA访问TEE内存&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;禁止未被TCB接纳的外设设备访问TEE内存。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;来自TCB内设备的可信I/O&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;通过准入控制将设备绑定到TEE。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>单元验证</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/verification/00_bm_verification/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/verification/00_bm_verification/</guid>
      <description>&lt;h2 id=&#34;单元验证&#34;&gt;单元验证&lt;/h2&gt;&#xA;&lt;h3 id=&#34;tlb-相关功能验证&#34;&gt;TLB 相关功能验证&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;验证功能编号&lt;/th&gt;&#xA;          &lt;th&gt;验证描述&lt;/th&gt;&#xA;          &lt;th&gt;覆盖方法&lt;/th&gt;&#xA;          &lt;th&gt;排列组合示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TLB_001&lt;/td&gt;&#xA;          &lt;td&gt;ITLB hit/miss 场景验证&lt;/td&gt;&#xA;          &lt;td&gt;设计测试用例覆盖 ITLB 命中和未命中&lt;/td&gt;&#xA;          &lt;td&gt;4K/2M/1G/512G 页大小&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TLB_002&lt;/td&gt;&#xA;          &lt;td&gt;DTLB hit/miss 场景验证&lt;/td&gt;&#xA;          &lt;td&gt;设计测试用例覆盖 DTLB 命中和未命中&lt;/td&gt;&#xA;          &lt;td&gt;4K/2M/1G/512G 页大小&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TLB_003&lt;/td&gt;&#xA;          &lt;td&gt;L2TLB hit/miss 场景验证&lt;/td&gt;&#xA;          &lt;td&gt;设计测试用例覆盖 L2TLB 命中和替换&lt;/td&gt;&#xA;          &lt;td&gt;4K/2M/1G/512G 页大小&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TLB_004&lt;/td&gt;&#xA;          &lt;td&gt;L2TLB 压缩功能验证&lt;br/&gt;注：仅支持一阶段地址转换压缩，最多压缩8项&lt;/td&gt;&#xA;          &lt;td&gt;测试TLB 压缩场景下，Bitmap 查询结果是否正确&lt;/td&gt;&#xA;          &lt;td&gt;TLB 压缩启用 + 4K 页大小&lt;br/&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;bitmap-cache-相关功能验证&#34;&gt;Bitmap Cache 相关功能验证&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;验证功能编号&lt;/th&gt;&#xA;          &lt;th&gt;验证描述&lt;/th&gt;&#xA;          &lt;th&gt;覆盖方法&lt;/th&gt;&#xA;          &lt;th&gt;排列组合示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BITMAP_001&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap Cache hit/miss 场景验证&lt;/td&gt;&#xA;          &lt;td&gt;设计测试用例覆盖命中和未命中&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap Y/N + 跨bitmap cache line&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BITMAP_002&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap check 功能验证&lt;/td&gt;&#xA;          &lt;td&gt;验证 bitmap check 的正确性&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap check 启用 + 4K 页大小&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BITMAP_003&lt;/td&gt;&#xA;          &lt;td&gt;跨bitmap cache line 场景验证&lt;/td&gt;&#xA;          &lt;td&gt;测试跨 cache line 的访问行为&lt;/td&gt;&#xA;          &lt;td&gt;跨bitmap cache line + 2M 页大小&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BITMAP_004&lt;/td&gt;&#xA;          &lt;td&gt;NAPOT 拓展开启，验证Bitmap 的行为&lt;/td&gt;&#xA;          &lt;td&gt;开启NAPOT，设置PTE.n 位，验证Bitmap 检测流程&lt;/td&gt;&#xA;          &lt;td&gt;跨bitmap cache line + 64K 页大小切换PTE.n 位&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;bitmap-cache-和-tlb-组合相关功能验证&#34;&gt;Bitmap Cache 和 TLB 组合相关功能验证&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;验证功能编号&lt;/th&gt;&#xA;          &lt;th&gt;验证描述&lt;/th&gt;&#xA;          &lt;th&gt;覆盖方法&lt;/th&gt;&#xA;          &lt;th&gt;排列组合示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;TLB_BITMAP_001&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap与TLB混合命中场景验证&lt;/td&gt;&#xA;          &lt;td&gt;组合Bitmap命中与各级TLB命中，验证多级缓存协同&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap hit + ITLB/DTLB/L2TLB全命中&lt;br/&gt;&lt;br/&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;TLB_BITMAP_002&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;全未命中极端场景验证&lt;/td&gt;&#xA;          &lt;td&gt;设计冷启动或冲刷缓存后首次访问的全未命中用例&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap miss + ITLB/DTLB/L2TLB全miss + 触发页表遍历&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;TLB_BITMAP_003&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap跨行与TLB替换场景验证&lt;/td&gt;&#xA;          &lt;td&gt;强制Bitmap跨cache line访问并触发TLB替换（如duplicate access或页表更新）&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap跨行 + DTLB miss + L2TLB替换&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;TLB_BITMAP_004&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;重复访问与Cache/TLB交互验证&lt;/td&gt;&#xA;          &lt;td&gt;通过相同地址重复访问验证Bitmap/TLB的重复访问优化&lt;/td&gt;&#xA;          &lt;td&gt;Bitmap重复命中 + ITLB重复命中 + 无替换&lt;br/&gt;Bitmap重复Miss + ITLB重复Miss + 替换&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;页表遍历ptw相关功能验证&#34;&gt;页表遍历（PTW）相关功能验证&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;验证功能编号&lt;/th&gt;&#xA;          &lt;th&gt;验证描述&lt;/th&gt;&#xA;          &lt;th&gt;覆盖方法&lt;/th&gt;&#xA;          &lt;th&gt;排列组合示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;PTW_001&lt;/td&gt;&#xA;          &lt;td&gt;PTW/HPTW/LLPTW 优先级验证&lt;/td&gt;&#xA;          &lt;td&gt;测试多级页表遍历的优先级&lt;/td&gt;&#xA;          &lt;td&gt;PTW + HPTW 并发&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;PTW_002&lt;/td&gt;&#xA;          &lt;td&gt;PTW 返回异常（access fault）验证&lt;/td&gt;&#xA;          &lt;td&gt;模拟 PTW 返回异常的场景&lt;/td&gt;&#xA;          &lt;td&gt;PTW return af + 跨Page&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;PTW_003&lt;/td&gt;&#xA;          &lt;td&gt;PTE 合法性验证&lt;/td&gt;&#xA;          &lt;td&gt;测试非法 PTE 的处理&lt;/td&gt;&#xA;          &lt;td&gt;非法 PTE + PMP check&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;异常与重放replay功能验证&#34;&gt;异常与重放（Replay）功能验证&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;验证功能编号&lt;/th&gt;&#xA;          &lt;th&gt;验证描述&lt;/th&gt;&#xA;          &lt;th&gt;覆盖方法&lt;/th&gt;&#xA;          &lt;th&gt;排列组合示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;REPLAY_001&lt;/td&gt;&#xA;          &lt;td&gt;标量 replay 场景验证&lt;/td&gt;&#xA;          &lt;td&gt;测试标量指令重放行为&lt;/td&gt;&#xA;          &lt;td&gt;标量 replay + access fault&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;REPLAY_002&lt;/td&gt;&#xA;          &lt;td&gt;向量访存 replay 场景验证&lt;/td&gt;&#xA;          &lt;td&gt;测试向量指令重放行为&lt;/td&gt;&#xA;          &lt;td&gt;向量 replay + 跨MMO&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;EXCEPT_001&lt;/td&gt;&#xA;          &lt;td&gt;异常优先级验证（access/page fault/guest page fault）&lt;/td&gt;&#xA;          &lt;td&gt;验证异常触发的优先级&lt;/td&gt;&#xA;          &lt;td&gt;page fault/guest page fault&lt;br/&gt;page table walker 过程中的PMP/bitmap 检测失败&lt;br/&gt;转换之后的物理地址PMP 检测失败&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;特权级与扩展功能验证&#34;&gt;特权级与扩展功能验证&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;验证功能编号&lt;/th&gt;&#xA;          &lt;th&gt;验证描述&lt;/th&gt;&#xA;          &lt;th&gt;覆盖方法&lt;/th&gt;&#xA;          &lt;th&gt;排列组合示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;PRIV_001&lt;/td&gt;&#xA;          &lt;td&gt;U/S/M 特权级切换验证&lt;/td&gt;&#xA;          &lt;td&gt;测试不同特权级下的访问权限&lt;/td&gt;&#xA;          &lt;td&gt;U/S/M + 4K/2M 页大小&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;EXT_001&lt;/td&gt;&#xA;          &lt;td&gt;H-extension 功能验证&lt;/td&gt;&#xA;          &lt;td&gt;测试 H-extension 启用和禁用场景&lt;/td&gt;&#xA;          &lt;td&gt;H-extension + 跨tlb entry&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;PMP_001&lt;/td&gt;&#xA;          &lt;td&gt;PMP check 功能验证&lt;/td&gt;&#xA;          &lt;td&gt;测试bitmap 内PMP 权限检查&lt;/td&gt;&#xA;          &lt;td&gt;PMP Y/N + 跨Page&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;fense验证&#34;&gt;Fense验证&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;验证功能编号&lt;/th&gt;&#xA;          &lt;th&gt;验证描述&lt;/th&gt;&#xA;          &lt;th&gt;覆盖方法&lt;/th&gt;&#xA;          &lt;th&gt;排列组合示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;MISC_001&lt;/td&gt;&#xA;          &lt;td&gt;Fence 操作验证&lt;/td&gt;&#xA;          &lt;td&gt;测试 fence 指令的同步效果&lt;/td&gt;&#xA;          &lt;td&gt;Fence + 切换Cmode&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;验证方法说明&#34;&gt;验证方法说明&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;覆盖方法&lt;/strong&gt;：通过随机测试、定向测试和边界值测试覆盖功能点。&lt;/p&gt;</description>
    </item>
    <item>
      <title>机器模式Bitmap控制状态寄存器</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/feature/00_bm_csr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/feature/00_bm_csr/</guid>
      <description>&lt;h2 id=&#34;机器模式-bitmap控制状态寄存器&#34;&gt;机器模式 Bitmap控制状态寄存器&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基本信息&#34;&gt;基本信息&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;寄存器名称&lt;/th&gt;&#xA;          &lt;th&gt;MBMC（Machine BitMap Control）&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;特权模式&lt;/td&gt;&#xA;          &lt;td&gt;机器模式&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;寄存器编号&lt;/td&gt;&#xA;          &lt;td&gt;0xBC2&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;读写权限&lt;/td&gt;&#xA;          &lt;td&gt;可读可写&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;功能描述&lt;/td&gt;&#xA;          &lt;td&gt;用来控制Shield-bitmap 的使能、同步、Shield-XS Bitmap 基地址等&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;字段描述&#34;&gt;字段描述&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;地址&lt;/th&gt;&#xA;          &lt;th&gt;字段&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;[61:3]&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;strong&gt;BMA (Bitmap Address)&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;Shield-XS Bitmap 基地址指定 Bitmap 数据结构在物理内存中的起始地址。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;CMODE (Current Mode)&lt;/td&gt;&#xA;          &lt;td&gt;表明当前执行模式CMODE = 1，表示安全模式CMODE = 0, 表示非安全模式。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;BCLEAR (Bitmap Clear)&lt;/td&gt;&#xA;          &lt;td&gt;Shield-XS Bitmap 同步位BCLEAR = 1，表示刷新所有Shield-bit 副本。&lt;br/&gt;&lt;strong&gt;注：实际使用过程，可结合HFence 指令&lt;/strong&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;0&lt;/td&gt;&#xA;          &lt;td&gt;BME (Bitmap Enable)&lt;/td&gt;&#xA;          &lt;td&gt;Shield-XS 使能位当 BME 置为 1 时，启用 Bitmap 功能。一旦启用，无法关闭，也无法修改 Bitmap 的基地址。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../feature00_1.png&#34; alt=&#34;Shield-XS Bitmap数据结构&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;shield-xs-bitmap数据结构&#34;&gt;Shield-XS Bitmap数据结构&lt;/h4&gt;&#xA;&lt;p&gt;上图为Shield-XS Bitmap的数据结构，所有的Shield-XS Bitmap权限数据都被存放在一块连续的物理内存区域中。其中基地址是存放Shield-XS Bitmap 数据结构的内存区域的起始物理地址。这个地址可以通过MBMC寄存器中的 BMA字段进行配置。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bitmap Cache</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/modules/01_bm_cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/modules/01_bm_cache/</guid>
      <description>&lt;h3 id=&#34;bitmap-cache硬件模块&#34;&gt;Bitmap Cache硬件模块&lt;/h3&gt;&#xA;&lt;h4 id=&#34;bitmap-cache简介&#34;&gt;Bitmap cache简介&lt;/h4&gt;&#xA;&lt;p&gt;Bitmap cache用于缓存 bitmap 数据块以减少 memory 访问延迟，存储最近访问的 bitmap 数据，&lt;strong&gt;共16个entry。每个 entry 存储一个 64-bit 数据段&lt;/strong&gt;。使用plru替换策略。&lt;/p&gt;&#xA;&lt;h4 id=&#34;bitmap模块结构&#34;&gt;Bitmap模块结构&lt;/h4&gt;&#xA;&lt;p&gt;Cache 一回合出结果，不需要pipeline。此外，refill也只需要一回合。Refill使用plru进行充填。&lt;/p&gt;&#xA;&lt;h4 id=&#34;bitmap-cache接口&#34;&gt;Bitmap cache接口&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;io_req&lt;/th&gt;&#xA;          &lt;th&gt;位宽&lt;/th&gt;&#xA;          &lt;th&gt;Bm 发起请求&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_req_bits_tag&lt;/td&gt;&#xA;          &lt;td&gt;36&lt;/td&gt;&#xA;          &lt;td&gt;Tag for cache lookup ([35:6] = tag)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_req_bits_order&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;发起请求的Fsm编号&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Io resp&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;返回bm请求&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_resp_bits_hit&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;是否hit cache&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_resp_bits_order&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;发起请求的Fsm编号&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_resp_bits_cfs&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;相邻8个的权限&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Io refill&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;Refill接口，来自bm，bm resp valid时发起重填&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_refill_bits_tag&lt;/td&gt;&#xA;          &lt;td&gt;36&lt;/td&gt;&#xA;          &lt;td&gt;Tag for cache refill ([35:6] = tag)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_refill_bits_data&lt;/td&gt;&#xA;          &lt;td&gt;64&lt;/td&gt;&#xA;          &lt;td&gt;Data to refill into cache&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_resp_bits_hit&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;是否hit cache&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CSR&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_sfence_valid&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;同步刷新请求有效（触发缓存刷新）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_satp_changed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;SATP CSR 变更标志（触发缓存刷新）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_vsatp_changed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;VSATP CSR 变更标志（触发缓存刷新）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_hgatp_changed&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;HGATP CSR 变更标志（触发缓存刷新）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_csr_mbmc_BCLEAR&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;缓存清除信号（触发缓存刷新）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>Shield-Bitmap Cache</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/feature/01_bm_acceleration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/feature/01_bm_acceleration/</guid>
      <description>&lt;h2 id=&#34;shield-bitmap-cache-性能加速&#34;&gt;Shield-Bitmap Cache 性能加速&lt;/h2&gt;&#xA;&lt;p&gt;当访问一个物理地址 (PA) 时，硬件通过查找 Shield-XS Bitmap 数据结构中对应的位置来确定该页是否具有安全属性。&lt;/p&gt;&#xA;&lt;p&gt;查找安全属性的物理地址计算公式如下：&lt;/p&gt;&#xA;&lt;p&gt;即 &lt;strong&gt;Shield-Bitmap 访问地址 = MBMC.BMA + PA[ XLEN-1 : 12 + log&lt;sub&gt;2&lt;/sub&gt;(XLEN/8) ]&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;随后用选出对应该 4KB 页的权限。如果对应比特位为 1 ，则表示该页具有安全属性，只能被安全敏感型负载访问；如果为 0 ，则表示该页不具有安全属性，可以被非安全敏感型负载访问。&lt;/p&gt;&#xA;&lt;h5 id=&#34;shield-xs-直接从内存中读取安全属性&#34;&gt;Shield-XS 直接从内存中读取安全属性&lt;/h5&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../feature01_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;开启Shield-XS 隔离之后，CPU 内部发起的任何一笔访存操作，都需要对标记安全属性的存储空间发起访问，从内存中获取安全属性的延迟过长，使得系统的性能变差。&lt;/p&gt;&#xA;&lt;p&gt;为了Shield-XS 隔离带来的性能损失，利用了程序的局部性，增加了Shield-Bitmap Cache,&#xA;当任何一笔访存需要获取安全属性时，优先从Shield-Bitmap Cache 中读取，只有Shield-Bitmap Cache Miss时，才会发起访存请求。&lt;/p&gt;&#xA;&lt;h5 id=&#34;shield-xs优先从shield-bitmap-cache中读取安全属性&#34;&gt;Shield-XS优先从Shield-BitMap Cache中读取安全属性&lt;/h5&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../feature01_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>添加编译脚本</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/01_build_script/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/01_build_script/</guid>
      <description>&lt;h2 id=&#34;脚本目标&#34;&gt;脚本目标&lt;/h2&gt;&#xA;&lt;p&gt;在&lt;code&gt;scripts&lt;/code&gt;目录下使用python编写对应rtl的编译文件（例如&lt;code&gt;build_ut_frontend_ifu_rvc_expander.py&lt;/code&gt;）。&lt;br&gt;&#xA;该脚本的目标是提供 RTL 到 Python DUT 的编译、目标覆盖文件，以及自定义功能等内容。&lt;/p&gt;&#xA;&lt;h2 id=&#34;创建过程&#34;&gt;创建过程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;确定文件名称&#34;&gt;确定文件名称&lt;/h3&gt;&#xA;&lt;p&gt;在&lt;a href=&#34;&#34;&gt;香山昆明湖 DUT 验证进展&lt;/a&gt;中选择需要验证的 UT，如果没有或者进一步细化，可通过编辑&lt;code&gt;configs/dutree/xiangshan-kmh.yaml&lt;/code&gt;自行添加。&lt;br&gt;&#xA;比如，我们要验证的是前端部分的&lt;code&gt;ifu&lt;/code&gt;模块下的&lt;code&gt;rvc_expander&lt;/code&gt;模块，那么需要在&lt;code&gt;configs/dutree/xiangshan-kmh.yaml&lt;/code&gt;中添加对应的部分（目前yaml中已经有该模块了，此处为举例）：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;kmh_dut&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;desc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;所有昆明湖DUT&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;children&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;- &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;frontend&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;desc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;前端模块&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;children&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;ifu&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;desc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;指令单元 (Instruction Fetch Unit)&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;children&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;          &lt;/span&gt;- &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;rvc_expander&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;            &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;desc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;RVC指令扩充器&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;脚本文件的命名格式如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;scripts/build_&amp;lt;顶层模块&amp;gt;_&amp;lt;下层模块名&amp;gt;_..._&amp;lt;目标模块名&amp;gt;.py&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;目前本项目内置了 4 个顶层模块：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;ut_frontend 前端&lt;/li&gt;&#xA;&lt;li&gt;ut_backend 后端&lt;/li&gt;&#xA;&lt;li&gt;ut_mem_block 访存&lt;/li&gt;&#xA;&lt;li&gt;ut_misc 其他&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;其中的子模块没有&lt;code&gt;ut_&lt;/code&gt;前缀（顶层目录有该前缀是为了和其他目录区分开）。&lt;/p&gt;&#xA;&lt;p&gt;例如验证目标 DUT 为&lt;code&gt;rvc_expander&lt;/code&gt;模块：&lt;br&gt;&#xA;该模块是属于前端的，所以顶级模块为&lt;code&gt;ut_frontend&lt;/code&gt;，它的下层模块为&lt;code&gt;ifu&lt;/code&gt;，目标模块为&lt;code&gt;rvc_expander&lt;/code&gt;。&lt;br&gt;&#xA;通过刚才我们打开的&lt;code&gt;yaml&lt;/code&gt;文件也可以知道，&lt;code&gt;frontend&lt;/code&gt;的children 为&lt;code&gt;ifu&lt;/code&gt;，&lt;code&gt;ifu&lt;/code&gt;的children 为&lt;code&gt;rvc_expander&lt;/code&gt;。 &lt;br&gt;&#xA;所以，需要创建的脚本名称为&lt;code&gt;build_ut_frontend_ifu_rvc_expander.py&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;编写-buildcfg---bool-函数&#34;&gt;编写 build(cfg) -&amp;gt; bool 函数&lt;/h3&gt;&#xA;&lt;p&gt;build 函数定义如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>文档模板</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/00_template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/00_template/</guid>
      <description>&lt;p&gt;以下是一份验证文档的完整模板（请一定同提交的验证报告区分开来）&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000080;font-weight:bold&#34;&gt;# 验证文档各部分说明&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 文档概述【必填项】 &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;在该部分对整个文档进行简约描述，例如内容概述，待验证模块的基本功能、特殊需求、特定规格、目标读者、知识前置等。目的是通过对该部分，读者便了解是否具有其感兴趣的内容。例如本文档是对验证文档的编写要求进行描述，便于多文档协作，规范验证的数据输入，特定数据标签等。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 术语说明 【必填项】 列出术语和关键概念解释，方便读者参考&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;优先解释模块专有缩写（如TLB， FIFO等），如果有缩写，请用&lt;span style=&#34;color:#4e9a06&#34;&gt;`缩写（全称）的方式填在表格的“名称”栏目中`&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;对容易混淆的概念请务必明确（如虚拟地址和物理地址等）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 名称 | 定义 |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| ------- | ---|&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 缩写1（FULL_NAME_1）&#x9;| 描述1 |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 缩写2（FULL_NAME_2）&#x9;| 描述2 |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 概念名1&#x9;| 描述3 |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 前置知识【可选项】&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;在阅读文档或进行验证之前，建议掌握一些关键前置知识，以便更深入理解相关内容。例如，在撰写LoadStoreQueue（LSQ）文档时，讲述RAW（Read After Write）违例有助于理解操作之间的依赖关系。在撰写Icache或L2Cache文档时，介绍缓存层级、替换策略和一致性模型等基本概念也有助于读者理解。如果涉及复杂算法，也应对其进行简要描述。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;基本要求：&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;1.&lt;/span&gt; 该部分内容应简洁，易于理解。如篇幅较长，可将内容移至附录。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;2.&lt;/span&gt; 针对较为复杂的内容，可以通过图像、伪代码和案例进行解释，以降低理解难度。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 整体框图 【可选项】 若模块含多个子模块或复杂数据流，需提供框图辅助说明&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;可使用Visio/Draw.io等工具绘制，导出为PNG/SVG格式；&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;需标注关键信号流向；&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;框图中子模块命名需与“子模块列表”章节严格一致。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 流水级示意图 【可选项】 若为复杂流水线型模块，需说明各级流水功能与时序关系&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;可使用Visio/Draw.io等工具绘制，导出为PNG/SVG格式；&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;涉及到的模块名称需要保持一致性&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;重要数据除了列出名称以外，还需要标明位宽等信息&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 子模块列表 【可选项】 若模块由多个子模块组成，需在此列出&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;以下是IFU top文档中的一个示例：&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 子模块                 | 描述                |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| ---------------------- | ------------------- |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| [&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;子模块1&lt;/span&gt;](&lt;span style=&#34;color:#c4a000&#34;&gt;子模块1文档位置&lt;/span&gt;) | 子模块1描述       |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| [&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;子模块2&lt;/span&gt;](&lt;span style=&#34;color:#c4a000&#34;&gt;子模块2文档位置&lt;/span&gt;) | 子模块2描述       |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| [&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;子模块3&lt;/span&gt;](&lt;span style=&#34;color:#c4a000&#34;&gt;子模块3文档位置&lt;/span&gt;) | 子模块3描述       |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mrs-functions&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 模块功能说明 【必填项】 需按功能树形式逐级分解，每个功能点需对应后续测试点。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;请用&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mrs-functions&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;functions&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;包裹整个“模块功能说明”部分。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;采用X.Y.Z多级编号（如1.2.3表示主功能1→子功能2→测试点3，也可以继续细分）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;功能描述需明确输入条件、处理过程、输出结果&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;### 1. 功能A说明&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;针对功能A分解测试点&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;如果测试点较多可以先列一个小表格&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;### 2. 功能B说明&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;针对功能B分解测试点&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;如果测试点较多可以先列一个小表格&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;### 3. 功能C说明&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;针对功能C分解测试点&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;如果测试点较多可以先列一个小表格；针对每个测试点，给出设置cov_group的建议&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mrs-functions&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 常量说明 【可选项】 需列出模块中所有可配置参数及其物理意义&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 常量名 | 常量值 | 解释 |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| ---- | ---- | ---- |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 常量1 | 64 | 常量1解释 |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 常量2 | 8 | 常量2解释 |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 常量3 | 16 | 常量3解释 |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 接口说明 【必填项】 详细解释各种接口的含义、来源&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;信号按功能（如时钟复位、数据输入、控制信号等）或来源（其他模块）分组；&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;可以将一些同质的信号一起解释；&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;特殊协议信号需注明时序要求（如AXI的VALID/READY握手）。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;使用时，请将下面的接口组名称和说明替换为符合您模块实际意义的内容&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;### 接口组1说明&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;请在这里填充接口组1的说明&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;#### 接口组1_1说明&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;请在这里填充接口组1_1的说明&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;如果不能细分，请进一步说明该组中所有接口&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;### 接口组2说明&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;请在这里填充接口组2的说明&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;如果不能细分，请进一步说明该组中所有接口&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 接口时序 【可选项】 对复杂接口，提供波形图的案例&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;### 案例1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;请在这里填充时序案例1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;### 案例2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;请在这里填充时序案例2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 测试点总表 (【必填项】针对细分的测试点，列出表格)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;实际使用下面的表格时，请用有意义的英文大写的功能名称和测试点名称替换下面表格中的名称&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mrs-testpoints&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 序号 |  功能名称 | 测试点名称      | 描述                  |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| ----- |-----------------|---------------------|------------------------------------|&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 1\.1\.1 | FUNCTION_1_1 | TESTPOINT_A | 功能1\.1的测试点A，使用时请替换为您的测试点的输入输出和判断方法 | &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 1\.1\.2 | FUNCTION_1_1 | TESTPOINT_B | 功能1\.1的测试点B，使用时请替换为您的测试点的输入输出和判断方法 | &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 1\.1\.3 | FUNCTION_1_1 | TESTPOINT_C | 功能1\.1的测试点C，使用时请替换为您的测试点的输入输出和判断方法 | &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 1\.2\.1 | FUNCTION_1_2 | TESTPOINT_X | 功能1\.2的测试点X，使用时请替换为您的测试点的输入输出和判断方法 | &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 1\.2\.2 | FUNCTION_1_2 | TESTPOINT_Y | 功能1\.2的测试点Y，使用时请替换为您的测试点的输入输出和判断方法 | &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 2\.1 | FUNCTION_2 | TESTPOINT_2A | 功能2的测试点2A，使用时请替换为您的测试点的输入输出和判断方法 | &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;| 2\.2 | FUNCTION_2 | TESTPOINT_2B | 功能2的测试点2B，使用时请替换为您的测试点的输入输出和判断方法 | &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;mrs-testpoints&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 附录【可选项】 &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;此部分用于存放正文的补充内容，以便进行扩展和详细说明，旨在使文档格式更加清晰，排版更加合理。&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>香山 bitmap 防御原理</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/basic/01_bm_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/basic/01_bm_principle/</guid>
      <description>&lt;h2 id=&#34;防御原理&#34;&gt;防御原理&lt;/h2&gt;&#xA;&lt;p&gt;针对日益复杂的负载的安全威胁，香山轻量动态隔离模型为经典负载机密虚拟机和容器设计了一种动态隔离机制，用来保护正在使用中的数据的机密性和完整性。依据不同的应用场景，将负载从安全的维度进行划分，分为安全敏感型负载和非安全敏感型负载。&lt;/p&gt;&#xA;&lt;p&gt;安全敏感型负载需要运行在可信执行环境下，用来保护正在使用中数据和代码的机密性和完整性。非安全敏感型负载对数据没有安全性保护需求，执行在开放的执行环境下，保证执行的效率。&lt;/p&gt;&#xA;&lt;p&gt;基于bitmap的安全隔离的防御机制，其核心原理是通过可信根在软件层面的标记（Shield-bit）来隔离和保护敏感工作负载（Sensitive Workloads）与普通工作负载（Normal Workloads），从而增强系统的安全性。以下是其防御原理的详细描述：&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-分类与标记&#34;&gt;1. 分类与标记&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;工作负载分类&lt;/strong&gt;：系统将工作负载分为两类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;敏感工作负载（Sensitive Workloads）&lt;/strong&gt;：需要高安全级别的任务，如机密虚拟机、安全容器的任务（隐私数据的访问、处理）等。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;普通工作负载（Normal Workloads）&lt;/strong&gt;：常规任务，代表系统中普通的应用程序或进程，安全要求较低。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;Shield-bit 标记&lt;/strong&gt;：通过 “Shield-bit”（&lt;strong&gt;每比特代表 4KB&lt;/strong&gt;）对敏感工作负载使用的资源进行标记，依据需此标记动态调整资源访问权限：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;Shield-bit = 1&lt;/code&gt; 表示&lt;strong&gt;安全敏感资源&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;Shield-bit = 0&lt;/code&gt; 表示&lt;strong&gt;非安全敏感资源&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-资源隔离&#34;&gt;2. 资源隔离&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;资源池划分&lt;/strong&gt;：&lt;a href=&#34;https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/basic/01_bm_principle/#light_model_img&#34;&gt;图中&lt;/a&gt;显示资源池中包含混合的敏感和普通工作负载，但通过 Shield-bit 实现逻辑隔离。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;资源类型保护&lt;/strong&gt;：敏感工作负载访问特定资源（如内存、IO设备、中断等）时，Shield-bit 会触发保护机制，防止普通工作负载或恶意程序越权访问。例如：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;内存隔离&lt;/strong&gt;：敏感数据的内存区域仅对标记为敏感的工作负载可访问。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;设备与中断保护&lt;/strong&gt;：关键外设或中断仅允许敏感工作负载调用。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;3-bypass-机制&#34;&gt;3. Bypass 机制&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;Bypass Shield-bit&lt;/strong&gt;：在单向隔离的情况下（仅对普通负载的资源访问作限制），安全敏感负载可绕过 Shield-bit 的机制直接访问资源提升性能。&lt;/p&gt;&#xA;&lt;h3 id=&#34;4-防御目标&#34;&gt;4. 防御目标&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;防止横向渗透&lt;/strong&gt;：攻击者通过普通工作负载漏洞无法访问敏感资源。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;最小权限原则&lt;/strong&gt;：每个工作负载仅能访问其必需的资源，降低攻击面。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;动态安全调整&lt;/strong&gt;：根据工作负载的敏感程度动态切换保护状态。&lt;/p&gt;&#xA;&lt;h3 id=&#34;5-技术实现&#34;&gt;5. 技术实现&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;硬件支持&lt;/strong&gt;：依赖内存管理单元（MMU）的扩展功能。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;软件协同&lt;/strong&gt;：由可信计算基负责标记管理和资源调度。&lt;/p&gt;&#xA;&lt;span id=&#34;light_model_img&#34;/&gt;&#xA;&lt;h4 id=&#34;香山shield-xs-轻量隔离模型&#34;&gt;香山Shield-XS 轻量隔离模型&lt;/h4&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../basic01_1.png&#34; alt=&#34;香山Shield-XS 轻量隔离模型&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;6-核心工作流程&#34;&gt;6. 核心工作流程&lt;/h3&gt;&#xA;&lt;h4 id=&#34;shield-xs-隔离模型工作流程&#34;&gt;Shield-XS 隔离模型工作流程&lt;/h4&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../basic01_2.png&#34; alt=&#34;Shield-XS 隔离模型工作流程&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;A. 启动&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;系统初始化，加载固件（Firmware TCB）和可信执行环境（TEE TCB）。&lt;/p&gt;&#xA;&lt;p&gt;开启Bitmap安全检测功能。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;B. 配置&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;设定安全策略，例如定义受保护资源（内存、IO、中断等）访问权限。&lt;/p&gt;&#xA;&lt;p&gt;TEE-TCB 依据应用需求配置不同资源的安全/非安全属性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bitmap 与L2TLB交互</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/modules/02_bm_l2tlb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/modules/02_bm_l2tlb/</guid>
      <description>&lt;h3 id=&#34;bitmap-与l2tlb内的交互&#34;&gt;Bitmap 与L2TLB内的交互&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../module02_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;page-cache-与-bitmap-检测机制的交互&#34;&gt;Page Cache 与 Bitmap 检测机制的交互&lt;/h4&gt;&#xA;&lt;h5 id=&#34;新增信号&#34;&gt;新增信号&lt;/h5&gt;&#xA;&lt;p&gt;发向 PTW 的 bitmap check 信号：用于触发 PTW 进行 bitmap 检测。&lt;/p&gt;&#xA;&lt;p&gt;发向 HPTW 的 bitmap check 信号：用于触发 HPTW 进行 bitmap 检测。&lt;/p&gt;&#xA;&lt;p&gt;接收来自 bitmap 的重填信号（bitmap wakeup）：用于接收 bitmap 检测结果并更新缓存。&lt;/p&gt;&#xA;&lt;h5 id=&#34;bitmap-wakeup接口-refill-bitmap&#34;&gt;Bitmap Wakeup接口: refill bitmap&lt;/h5&gt;&#xA;&lt;p&gt;功能描述：当接收到 wake up valid 信号时，将 check_success 结果写入对应的 sp 或 l0 的 cache bitmap reg 中。&lt;/p&gt;&#xA;&lt;p&gt;工作原理：cache bitmap reg 用于标识缓存项是否通过 bitmap 检测。值为 1 表示已通过检测；值为 0 表示检测未通过或尚未检测。如果发现 PtwCache 命中的表项未通过检测，则触发 Bitmap 检测流程，并通过 bitmap wakeup 更新缓存项。此外，在走表过程中所有bitmap返回的项都会回填page cache。&lt;/p&gt;</description>
    </item>
    <item>
      <title>bitmap的工作流程</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/basic/02_bm_workflow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/basic/02_bm_workflow/</guid>
      <description>&lt;h2 id=&#34;bitmap的工作流程是怎样的&#34;&gt;bitmap的工作流程是怎样的？&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../basic02_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-识别负载类型&#34;&gt;1. 识别负载类型&lt;/h3&gt;&#xA;&lt;p&gt;根据应用场景和安全需求，将负载分为安全敏感型负载和非安全敏感型负载：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;安全敏感型负载&lt;/strong&gt;：需要在可信执行环境中运行，以保护数据和代码的机密性和完整性。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;非安全敏感型负载&lt;/strong&gt;：可以在开放的执行环境中运行，主要关注执行效率。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-设置隔离属性&#34;&gt;2. 设置隔离属性&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;定义隔离属性&lt;/strong&gt;：为不同类型负载设置隔离属性，包括单向隔离和双向隔离。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;单向隔离&lt;/strong&gt;：允许安全敏感型负载访问非安全敏感型负载的资源，但不允许反向访问。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;双向隔离&lt;/strong&gt;：安全敏感型负载和非安全敏感型负载之间互相不能访问对方的资源。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;3-划分资源池&#34;&gt;3. 划分资源池&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;划分物理内存资源&lt;/strong&gt;：将物理内存划分为不同的资源池以支持不同负载的隔离需求。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;安全资源池&lt;/strong&gt;：分配给安全敏感型负载。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;非安全资源池&lt;/strong&gt;：分配给非安全敏感型负载。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;4-配置安全属性&#34;&gt;4. 配置安全属性&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;设置内存页安全状态&lt;/strong&gt;：使用Bitmap数据结构标记每个物理内存页的安全状态。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;安全页&lt;/strong&gt;：标记为1，表示该页属于安全资源池。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;非安全页&lt;/strong&gt;：标记为0，表示该页属于非安全资源池。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;5-动态分配资源&#34;&gt;5. 动态分配资源&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;按需分配内存&lt;/strong&gt;：根据负载的启动和运行时需求，动态分配相应的内存资源。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;安全敏感型负载&lt;/strong&gt;：从安全资源池分配内存，并确保其访问受限于安全页。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;非安全敏感型负载&lt;/strong&gt;：从非安全资源池分配内存，允许其访问非安全页。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;6-隔离检测判断&#34;&gt;6. 隔离检测判断&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;判断隔离类型&lt;/strong&gt;：判断当前负载是否需要单向隔离或者双向隔离。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;单向隔离&lt;/strong&gt;：仅对非安全敏感型负载进行安全性检测，确保其不访问安全资源。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;双向隔离&lt;/strong&gt;：对所有负载类型进行隔离检测，确保不同负载之间互不干扰。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;7-安全性检测&#34;&gt;7. 安全性检测&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;执行访问控制检查&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于单向隔离情况，检查非安全敏感型负载是否试图访问安全资源。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于双向隔离情况，检查所有负载类型是否试图越界访问其他类型的资源。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;8-动态回收资源&#34;&gt;8. 动态回收资源&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;释放不再使用的资源&lt;/strong&gt;：负载执行完毕后，其占用的内存资源被回收并返回到相应的资源池中，以便后续其他负载的使用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>构建测试环境</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/02_build_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/02_build_env/</guid>
      <description>&lt;h2 id=&#34;确定目录结构&#34;&gt;确定目录结构&lt;/h2&gt;&#xA;&lt;p&gt;UT(Unit Test, 单元测试)所在的目录位置的层级结构应该与名称一致，例如&lt;code&gt;frontend.ifu.rvc_expander&lt;/code&gt;应当位于&lt;code&gt;ut_frontend/ifu/rvc_expander&lt;/code&gt;目录，且每层目录都需要有&lt;code&gt;__init__.py&lt;/code&gt;，便于通过 python 进行&lt;code&gt;import&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;本章节的文件为&lt;code&gt;your_module_wrapper.py&lt;/code&gt;&lt;/strong&gt;（如果你的模块是&lt;code&gt;rvc_expander&lt;/code&gt;，那么文件就是&lt;code&gt;rvc_expander_wrapper.py&lt;/code&gt;）。&lt;/p&gt;&#xA;&lt;p&gt;wrapper 是包装的意思，也就是我们测试中需要用到的方法封装成和dut解耦合的API提供给测试用例使用。&lt;/p&gt;&#xA;&lt;p&gt;*注：解耦合是为了测试用例和 DUT 解耦，使得测试用例可以独立于 DUT 进行编写和调试，也就是在测试用例中，不需要知道 DUT 的具体实现细节，只需要知道如何使用 API 即可。可以参照&lt;a href=&#34;https://open-verify.cc/mlvp/docs/mlvp/canonical_env/#%E5%B0%86%E9%AA%8C%E8%AF%81%E4%BB%A3%E7%A0%81%E4%B8%8Edut%E8%BF%9B%E8%A1%8C%E8%A7%A3%E8%80%A6&#34;&gt;将验证代码与DUT进行解耦&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;该文件应该放于&lt;code&gt;ut_frontend_or_backend/top_module/your_module/env&lt;/code&gt;（这里依然以&lt;code&gt;rvc_expander&lt;/code&gt;举例：&lt;code&gt;rvc_expander&lt;/code&gt;属于前端，其顶层目录则应该是&lt;code&gt;ut_frontend&lt;/code&gt;；&lt;code&gt;rvc_expander&lt;/code&gt;的顶层模块是&lt;code&gt;ifu&lt;/code&gt;，那么次级目录就是&lt;code&gt;ifu&lt;/code&gt;;之后的就是&lt;code&gt;rvc_expander&lt;/code&gt;自己了；最后，由于我们是在&lt;strong&gt;构建测试环境&lt;/strong&gt;，再建一级&lt;code&gt;env&lt;/code&gt;目录。将它们连起来就是：&lt;code&gt;ut_frontend_or_backend/top_module/your_module/env&lt;/code&gt;）目录下。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ut_frontend/ifu/rvc_expander&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── classical_version&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   ├── env&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   │   ├── __init__.py&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   │   └── rvc_expander_wrapper.py&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   ├── __init__.py&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   └── test_rvc_expander.py&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── __init__.py&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── README.md&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;└── toffee_version&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ├── agent&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    │   └── __init__.py&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ├── bundle&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    │   └── __init__.py&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ├── env&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    │   ├── __init__.py&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    │   └── ref_rvc_expand.py&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ├── __init__.py&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    └── &lt;span style=&#34;color:#204a87&#34;&gt;test&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ├── __init__.py&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ├── rvc_expander_fixture.py&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        └── test_rvc.py&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里&lt;code&gt;rvc_expander&lt;/code&gt;目录下有&lt;code&gt;classical_version&lt;/code&gt;传统版本和&lt;code&gt;toffee_version&lt;/code&gt;使用toffee的版本。&#xA;传统版本就是使用&lt;code&gt;pytest&lt;/code&gt;框架来进行测试，&lt;code&gt;toffee&lt;/code&gt;只使用了其&lt;code&gt;Bundle&lt;/code&gt;;而在toffee版本中，我们会使用更多&lt;code&gt;toffee&lt;/code&gt;的特性。      &lt;br&gt;&#xA;一般来说，&lt;strong&gt;使用传统版本就已经可以覆盖绝大多数情况了&lt;/strong&gt;，只有在传统版本不能满足需求时，才需要使用&lt;code&gt;toffee&lt;/code&gt;版本。&lt;br&gt;&#xA;编写测试环境的时候，&lt;strong&gt;两个版本选择一个就行&lt;/strong&gt;。&lt;br&gt;&#xA;模块（例如&lt;code&gt;rvc_expander&lt;/code&gt;）中的代码目录结构由贡献者自行决定（我们写的时候并&lt;strong&gt;不需要再建一级&lt;code&gt;classical_version&lt;/code&gt;或&lt;code&gt;toffee_version&lt;/code&gt;目录&lt;/strong&gt;），但需要满足 python 规范，且逻辑和命名合理。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bitmap接口时序图</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/modules/03_bm_timing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/modules/03_bm_timing/</guid>
      <description>&lt;h2 id=&#34;bitmap接口时序图&#34;&gt;Bitmap接口时序图&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../module03_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;信号&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_req_ready&lt;/td&gt;&#xA;          &lt;td&gt;8个fsm中有至少一个idle时为高，可以视为常态高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_req_valid&lt;/td&gt;&#xA;          &lt;td&gt;新请求进入时高，平时为低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_resp_ready&lt;/td&gt;&#xA;          &lt;td&gt;当请求源（ptw hptw llptw）发送请求，等待返回时会拉高，平时无请求时为低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_resp_valid&lt;/td&gt;&#xA;          &lt;td&gt;当返回查询结果时拉高，平时为低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_mem_req_ready&lt;/td&gt;&#xA;          &lt;td&gt;有其它mem请求时（ptw llptw hptw）为低，平时为高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_mem_req_valid&lt;/td&gt;&#xA;          &lt;td&gt;cache miss时发起mem请求拉高，平时为低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_mem_resp_valid&lt;/td&gt;&#xA;          &lt;td&gt;mem 返回结果拉高，平时为低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_cache_req_valid&lt;/td&gt;&#xA;          &lt;td&gt;bimap fsm 发起 cache 请求拉高，平时为低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_cache_req_ready&lt;/td&gt;&#xA;          &lt;td&gt;常态高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_cache_resp_valid&lt;/td&gt;&#xA;          &lt;td&gt;io_cache_req_valid下一clk 拉高平时低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;io_cache_resp_ready&lt;/td&gt;&#xA;          &lt;td&gt;io_cache_req_valid 下一clk 拉高平时低&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>Shield-Bitmap 地址翻译</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/feature/02_bm_mmu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/feature/02_bm_mmu/</guid>
      <description>&lt;h1 id=&#34;虚拟化两阶段地址翻译流程&#34;&gt;虚拟化两阶段地址翻译流程&lt;/h1&gt;&#xA;&lt;p&gt;bitmap和MMU-L2TLB耦合，会在虚拟化两阶段地址走表翻译完成后才进行隔离检查。如果bitmap检查没有通过，就向MMU-L1TLB 发送af。因此对L1TLB以及其上面的模块来说，bitmap是透明的。所以，在进一步介绍前，需要先了解MMU处理虚拟化两阶段地址的流程。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;两阶段翻译&lt;/strong&gt;：Guest Virtual Address (GVA) → Guest Physical Address (GPA) → Host Physical Address (HPA)&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;关键寄存器&lt;/strong&gt; ：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;hgatp&lt;/strong&gt; ：控制G-stage（客户机阶段）页表根地址&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;vsatp&lt;/strong&gt; ：控制VS-stage（虚拟化监督模式阶段）页表根地址&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;1. VAPT (Virtual Address Protection and Translation)&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt; ：管理客户机虚拟地址（GVA）到客户机物理地址（GPA）的第一阶段翻译（VS-stage）。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&lt;strong&gt;字段名&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;位宽&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;MODE&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;页表模式：&lt;br/&gt; &lt;ul&gt;&lt;li&gt;&lt;code&gt;0&lt;/code&gt;: 关闭翻译&lt;/li&gt; &lt;li&gt;&lt;code&gt;1&lt;/code&gt;: Sv32&lt;/li&gt; &lt;li&gt;&lt;code&gt;8&lt;/code&gt;: Sv39&lt;/li&gt; &lt;li&gt;&lt;code&gt;9&lt;/code&gt;: Sv48&lt;/li&gt; &lt;li&gt;&lt;code&gt;10&lt;/code&gt;: Sv57&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;ASID&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;16&lt;/td&gt;&#xA;          &lt;td&gt;地址空间标识符（Address Space ID），隔离不同客户机的地址空间&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;PPN&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;44&lt;/td&gt;&#xA;          &lt;td&gt;物理页号（Physical Page Number），指向VS-stage页表的根页表地址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;RESERVED&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;保留位，必须写0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;G&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;全局映射标志（Global bit），若为1则忽略ASID匹配&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;2. SVAPT (Supervisor Virtual Address Protection and Translation)&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>添加测试用例</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/03_add_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/03_add_test/</guid>
      <description>&lt;h2 id=&#34;命名要求&#34;&gt;命名要求&lt;/h2&gt;&#xA;&lt;p&gt;所有测试用例文件请以&lt;code&gt;test_*.py&lt;/code&gt;的方式进行命名，&lt;code&gt;*&lt;/code&gt;用测试目标替换（例如&lt;code&gt;test_rvc_expander.py&lt;/code&gt;）。所有测试用例也需要以&lt;code&gt;test_&lt;/code&gt;前缀开头。用例名称需要具有明确意义。&lt;/p&gt;&#xA;&lt;p&gt;命名举例如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;test_a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;():&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 不合理，无法通过a判断测试目标&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;pass&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;test_rvc_expand_16bit_full&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;():&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 合理，可以通过用例名称大体知道测试内容&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;pass&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;使用-assert&#34;&gt;使用 Assert&lt;/h2&gt;&#xA;&lt;p&gt;在每个测试用例中，都需要通过&lt;code&gt;assert&lt;/code&gt;来判断本测试是否通过。&#xA;&lt;code&gt;pytest&lt;/code&gt;统计的是&lt;code&gt;assert&lt;/code&gt;语句的结果，因此&lt;code&gt;assert&lt;/code&gt;语句需要保证能够通过。&lt;/p&gt;&#xA;&lt;p&gt;以下内容位于&lt;code&gt;ut_frontend/ifu/rvc_expander/classical_version/test_rvc_expander.py&lt;/code&gt;中：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rvc_expand&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;rvc_expander&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ref_insts&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;is_32bit&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;False&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;fsIsOff&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;False&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&amp;#34;&amp;#34;compare the RVC expand result with the reference&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;    Args:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;        rvc_expander (warpper): the fixture of the RVC expander&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;        ref_insts (list[int]]): the reference instruction list&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;find_error&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;insn&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ref_insts&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000&#34;&gt;insn_disasm&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;disasmbly&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;insn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;instr_ex&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rvc_expander&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;expand&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;insn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;fsIsOff&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;is_32bit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;assert&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;insn&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;RVC expand error, 32bit instruction need to be the same&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;insn_disasm&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;unknown&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;and&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;instr_ex&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#000&#34;&gt;debug&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;find bad inst:&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;insn&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;, ref: 1, dut: 0&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#000&#34;&gt;find_error&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;elif&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;insn_disasm&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;unknown&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;and&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;instr_ex&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;instr_filter&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;insn_disasm&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#000&#34;&gt;debug&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;find bad inst:&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;insn&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;,disasm:&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;insn_disasm&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;, ref: 0, dut: 1&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#000&#34;&gt;find_error&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;assert&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;find_error&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;RVC expand error (&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt; errros)&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;find_error&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;编写注释&#34;&gt;编写注释&lt;/h2&gt;&#xA;&lt;p&gt;每个测试用例都需要添加必要的说明和注释，需要满足&lt;a href=&#34;https://peps.python.org/pep-0257/&#34;&gt;Python 注释规范&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>香山bitmap 应用场景</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/basic/03_bm_scenario/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/basic/03_bm_scenario/</guid>
      <description>&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-机密虚拟机&#34;&gt;1. 机密虚拟机&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../basic03_1.png&#34; alt=&#34;应用场景-机密虚拟机&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Shield-XS用于普通虚拟机和机密虚拟机的隔离。在机密虚拟机（Confidential VM， CVM）环境中，bitmap 用于标记和隔离安全内存区域。&lt;/p&gt;&#xA;&lt;p&gt;普通虚拟机在访问内存时，硬件通过 bitmap 检查机制确保其只能访问被授权的内存区域，从而实现虚拟机之间的内存隔离。&lt;/p&gt;&#xA;&lt;p&gt;注：机密虚拟机之间的隔离通过MMU 完成，不需要经过Bitmap 的检查机制。&lt;/p&gt;&#xA;&lt;p&gt;CVM Bitmap 的资源的标记和分配由C-SDSM (Confidential Supervisor Domain Security Manager) 完成，Hypervisor 和 CVM 通过TEECall 和 TEEResume 进行安全世界的交互。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../basic03_2.png&#34; alt=&#34;安全世界接口&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;TEECall&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从普通世界（Normal World）切换到安全世界（TEE），进入敏感工作负载执行流程。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;TEEResume&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从 TEE 返回普通世界，恢复 Normal Workloads 的执行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-安全增强容器&#34;&gt;2. 安全增强容器&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../basic03_3.png&#34; alt=&#34;应用场景-容器&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;上图显示了bitmap在容器中的应用场景。安全容器和普通容器都位于可信计算基的保护范围内。在安全容器中运行的应用程序可能包含敏感数据或关键业务逻辑。为了防止这些数据被普通容器或恶意软件访问，采用通过 &lt;strong&gt;bitmap 机制&lt;/strong&gt;进行隔离。&lt;/p&gt;&#xA;&lt;p&gt;Bitmap 数据结构用于标记哪些物理页属于安全容器的存储空间，通过将对应该容器内存区域的位图数据写为1，确保普通容器无法访问这些存储空间。只有安全容器内的应用程可以访问这些被标记为安全的内存页。&lt;/p&gt;&#xA;&lt;p&gt;普通容器中的应用程序可能来自不可信的来源。通过 bitmap 机制，普通容器的内存访问被限制在非安全内存区域。任何试图访问安全内存的请求都会被硬件拦截，并触发Access Fault。&lt;/p&gt;&#xA;&lt;p&gt;在上述场景的具体的实施细节中，&lt;strong&gt;&lt;font style=&#34;color:#ee0000;&#34;&gt;软件模块负责Bitmap管理和配置 ， 硬件机制负责Bitmap检查和同步。&lt;font&gt;&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>FIFO文档案例</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/01_fifo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/01_fifo/</guid>
      <description>&lt;p&gt;以下以FIFO为例，展示了一个简单的文档案例&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;`timescale&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ns&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ps&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;FIFO&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//data_width = 8  data depth =8&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;input&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;clk&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;input&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rst_n&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;input&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;wr_en&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;          &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//写使能&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;input&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rd_en&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;          &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//读使能&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;input&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;wdata&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;     &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//写入数据输入&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;output&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;rdata&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//读取数据输出&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;output&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;empty&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;         &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//读空标志信号&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;output&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;full&lt;/span&gt;           &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//写满标志信号&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;reg&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rdata_reg&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;&amp;#39;d0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;assign&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rdata&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rdata_reg&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;reg&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;];&lt;/span&gt;     &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//数据存储单元(8bit数据8个)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;reg&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;wr_ptr&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;&amp;#39;d0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;  &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//写指针&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;reg&lt;/span&gt;  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rd_ptr&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;&amp;#39;d0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;  &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//读指针&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;wire&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;wr_addr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//写地址(写指针的低3位)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;wire&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rd_addr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//读地址(读指针的低3位)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;assign&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;wr_addr&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;wr_ptr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;];&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;assign&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rd_addr&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rd_ptr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;];&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;always&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;@(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;posedge&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;clk&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;or&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;negedge&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rst_n&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;begin&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//写数据&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;rst_n&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;wr_ptr&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;&amp;#39;d0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;wr_en&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;full&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;begin&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;wr_addr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;  &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;wdata&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;wr_ptr&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;wr_ptr&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;&amp;#39;d1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;end&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;end&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;always&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;@(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;posedge&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;clk&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;or&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;negedge&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rst_n&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;begin&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//读数据&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;rst_n&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;rd_ptr&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;&amp;#39;d0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;rd_en&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;empty&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;begin&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;rdata_reg&lt;/span&gt;  &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;rd_addr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;];&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;rd_ptr&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rd_ptr&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;&amp;#39;d1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;end&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;end&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;assign&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;empty&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;wr_ptr&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rd_ptr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//读空&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;assign&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;full&lt;/span&gt;  &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;wr_ptr&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;~&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;rd_ptr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;],&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;rd_ptr&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]});&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;//写满&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;endmodule&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;fifo-模块验证文档&#34;&gt;FIFO 模块验证文档&lt;/h1&gt;&#xA;&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;本文档描述FIFO的功能，并根据功能给出测试点参考，方便测试的参与者理解测试需求，编写相关测试用例。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;缩写&lt;/th&gt;&#xA;          &lt;th&gt;全称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;FIFO&lt;/td&gt;&#xA;          &lt;td&gt;First In First Out&lt;/td&gt;&#xA;          &lt;td&gt;先进先出的数据缓冲队列&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;功能说明&#34;&gt;功能说明&lt;/h2&gt;&#xA;&lt;p&gt;本次需要验证的是FIFO，一种常见的硬件缓冲模块，在硬件电路中临时存储数据，并按照数据到达的顺序进行处理。&lt;/p&gt;&#xA;&lt;p&gt;本次需要验证的FIFO每次可写可读8位数据，容量为8。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-读fifo操作&#34;&gt;1. 读FIFO操作&lt;/h3&gt;&#xA;&lt;h4 id=&#34;11-常规读取&#34;&gt;1.1. 常规读取&lt;/h4&gt;&#xA;&lt;p&gt;&lt;strong&gt;功能描述&lt;/strong&gt;：当rd_en=1且empty=0时，在时钟上升沿输出rdata&lt;/p&gt;</description>
    </item>
    <item>
      <title>Shield-Bitmap 地址翻译2</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/feature/03_bm_mmu_with_bm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/feature/03_bm_mmu_with_bm/</guid>
      <description>&lt;h1 id=&#34;加入了shield-xs安全检查后的内存地址转换流程&#34;&gt;加入了Shield-XS安全检查后的内存地址转换流程&lt;/h1&gt;&#xA;&lt;p&gt;如前文所述， bitmap和MMU耦合。现在将介绍增加了bitmap后的MMU地址翻译流程。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../feature03_1.jpeg&#34; alt=&#34; &#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;从 &lt;strong&gt;客户虚拟地址&lt;/strong&gt; 到 &lt;strong&gt;主机物理地址&lt;/strong&gt; 的转换过程，同时涉及 &lt;strong&gt;安全属性检查&lt;/strong&gt; 和 Shield-Bitmap&lt;strong&gt;高速缓存访问&lt;/strong&gt;。以下是详细步骤：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;客户虚拟地址（Guest Virtual Address）&lt;/strong&gt;: 流程开始于计算单元（如CPU）使用客户虚拟地址发出内存访问请求。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;访问一级快表（L1TLB Lookup）&lt;/strong&gt;: 首先查询一级快表（&lt;strong&gt;L1TLB&lt;/strong&gt;），检查是否已缓存该地址的映射。只有经历过bitmap检查才会出现在L1TLB Cache中。因此和L2TLB Cache不同，L1TLB Cache 不会存储bitmap检查位。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;一级快表缓存命中？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;是&lt;/strong&gt; → 直接从L1TLB Cache获取主机物理地址（Host Physical Address）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;否&lt;/strong&gt; → 进入下一级查询（访问二级快表）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;访问二级快表（L2TLB Lookup）&lt;/strong&gt;: 如果一级快表未命中，继续查询二级快表（L2TLB），检查二级快表是否有对应的映射。L2TLB Cache 存储安全允许位（cf）表示 是否经过bitmap 检查。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;二级快表缓存命中？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;cf 和 L2TLB 页表项均命中&lt;/strong&gt; → 获取主机物理地址，并回填一级快表（更新L1TLB）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;L2TLB 页表项命中，bitmap cf 未设&lt;/strong&gt;→ 发送请求至bitmap，进行权限检查。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;否&lt;/strong&gt; → 触发 &lt;strong&gt;页表遍历（Page Table Walker）&lt;/strong&gt;，从内存中加载页表映射关系，随后进行bitmap检查。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;进行页表遍历&lt;/strong&gt;：从内存中加载页表映射关系&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;主机虚拟地址 → 主机物理地址转换&lt;/strong&gt;：通过页表遍历获取主机物理地址（Host Physical Address）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;安全性检查允许访问（Security Check）&lt;/strong&gt;： 对物理地址进行 &lt;strong&gt;安全属性检查&lt;/strong&gt;。如果检查失败，可能触发访问错误（Access Fault）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>代码覆盖率</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</guid>
      <description>&lt;p&gt;代码覆盖率是一项评价指标，它衡量了被测代码中哪些部分被执行了，哪些部分没有被执行。通过统计代码覆盖率，可以评估测试的有效性和覆盖程度。&lt;/p&gt;&#xA;&lt;p&gt;代码覆盖率包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;行覆盖率(line coverage): 被测代码中被执行的行数，最简单的指标，一般期望达到 100%。&lt;/li&gt;&#xA;&lt;li&gt;条件覆盖率(branch coverage): 每一个控制结构的每个分支是否均被执行。例如，给定一个 if 语句，其 true 和 false 分支是否均被执行？&lt;/li&gt;&#xA;&lt;li&gt;有限状态机覆盖率(fsm coverage): 状态机所有状态是否都达到过。&lt;/li&gt;&#xA;&lt;li&gt;翻转覆盖率(toggle coverage): 统计被测代码中被执行的翻转语句，检查电路的每个节点是否都有 0 -&amp;gt; 1 和 1 -&amp;gt; 0 的跳变。&lt;/li&gt;&#xA;&lt;li&gt;路径覆盖率(path coverage): 检查路径的覆盖情况。在 always 语句块和 initial 语句块中，有时会使用 if &amp;hellip; else 和 case 语句，在电路结构上便会产生一系列的数据路径。。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;*我们主要使用的模拟器是 Verilator,优先考虑&lt;strong&gt;行覆盖率&lt;/strong&gt;。Verilator 支持覆盖率统计，因此我们在构建 DUT 时，如果要开启覆盖率统计，需要在编译选项中添加&lt;code&gt;-c&lt;/code&gt;参数。&lt;/p&gt;&#xA;&lt;h2 id=&#34;本项目中相关涉及位置&#34;&gt;本项目中相关涉及位置&lt;/h2&gt;&#xA;&lt;p&gt;开启覆盖率需要在编译时（使用 picker 命令时）加上“-c”参数（参考 picker 的&lt;a href=&#34;https://github.com/XS-MLVP/picker/blob/master/README.zh.md#%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A&#34;&gt;参数解释&lt;/a&gt;），同时在文件中设置启用行覆盖率，这样在使用 toffee 测试时，才能够生成覆盖率统计文件。&lt;/p&gt;&#xA;&lt;p&gt;结合上面的描述，在本项目中也就是编译，编写和启用行覆盖率函数和测试的时候会涉及到代码覆盖率：&lt;/p&gt;&#xA;&lt;h3 id=&#34;添加编译脚本部分&#34;&gt;添加编译脚本部分&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/01_build_script/#%e7%bc%96%e5%86%99-buildcfg---bool-%e5%87%bd%e6%95%b0&#34;&gt;编写编译脚本&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 省略前面&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;os&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;path&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;exists&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;get_root_dir&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;dut/RVCExpander&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000&#34;&gt;info&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Exporting RVCExpander.sv&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#000&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;exe_cmd&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;picker export --cp_lib false &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;get_rtl_dir&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;rtl/RVCExpander.sv&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cfg&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cfg&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                                              &lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt; --lang python --tdir &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;get_root_dir&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;dut&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;/ -w rvc.fst -c&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;assert&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Failed to export RVCExpander.sv: &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 省略后面&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在&lt;code&gt;s, out, err=...&lt;/code&gt;这一行，我们使用 picker 命令，并且开启代码了覆盖率(命令最后的&amp;quot;-c&amp;quot;参数)。&lt;/p&gt;</description>
    </item>
    <item>
      <title>开销评估</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/modules/04_bm_cost/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/02_bitmap/modules/04_bm_cost/</guid>
      <description>&lt;h2 id=&#34;开销评估&#34;&gt;开销评估&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;1. 基本配置&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;类别&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;配置项&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;参数**&lt;/strong&gt;/*&lt;strong&gt;*设置&lt;/strong&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Shield-Bit 配置&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;有效 Shield-XS 隔离模型&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;-&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;设置 Shield-Bitmap&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;_&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Shield-Bitmap缓存大小&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;128 × 8 Bytes&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;KunminghuV2 配置&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;TileLink Prototype&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;-&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;缓存层级配置&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;L1 指令/数据缓存大小&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;64KB&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;L1 指令/数据 TLB&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;48-全关联（Full Association）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;L2 缓存大小&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;1MB&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;L3 缓存大小&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;16MB&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;&lt;strong&gt;2. SPEC2006 性能数据&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;SPECInt2006 Simpoint est.@&lt;strong&gt;3GHz&lt;/strong&gt; &lt;strong&gt;GEOMEAN 44.62 &lt;strong&gt;-&amp;gt;&lt;/strong&gt; 44.29 (0.72% )&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../module04_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;图 9.1 SPEC2006 性能开销&lt;/p&gt;&#xA;&lt;p&gt;性能开销与DTLB Miss-rate 呈正比。有效的减少 DTLB 和 Shield-bitmap Cache 的miss-rate, 可以进一步提升性能。例如将缓存从 16 项扩展到 128 项，可使 GemsFDTD 的性能开销从 6.51% 降低至 2.36%。&lt;/p&gt;</description>
    </item>
    <item>
      <title>功能覆盖率</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</guid>
      <description>&lt;p&gt;功能覆盖率（Functional Coverage）是一种&lt;strong&gt;用户定义&lt;/strong&gt;的度量标准，用于度量验证中已执行的设计规范的比例。功能覆盖率关注的是设计的功能和特性是否被测试用例覆盖到了。&lt;/p&gt;&#xA;&lt;p&gt;反标是指将功能点与测试用例对应起来。这样，在统计时，就能看到每个功能点对应了哪些测试用例，从而方便查看哪些功能点用的测试用例多，哪些功能点用的测试用例少，有利于后期的测试用例优化。&lt;/p&gt;&#xA;&lt;h2 id=&#34;本项目中相关涉及位置&#34;&gt;本项目中相关涉及位置&lt;/h2&gt;&#xA;&lt;p&gt;功能覆盖率需要我们先定义了才能统计，主要是在构建测试环境的时候涉及。&lt;/p&gt;&#xA;&lt;p&gt;在&lt;a href=&#34;https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/02_build_env/&#34;&gt;构建测试环境&lt;/a&gt;中：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/02_build_env/#2-%e5%ae%9a%e4%b9%89%e5%8a%9f%e8%83%bd%e8%a6%86%e7%9b%96%e7%8e%87&#34;&gt;定义功能覆盖率&lt;/a&gt;： 创建了功能覆盖率组,添加观察点和反标&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/02_build_env/#3-%e5%ae%9a%e4%b9%89%e5%bf%85%e8%a6%81fixture&#34;&gt;定义必要 fixture&lt;/a&gt;： 把统计结果传递给 toffee-report&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/02_build_env/#4-%e7%bb%9f%e8%ae%a1%e8%a6%86%e7%9b%96%e7%8e%87&#34;&gt;统计覆盖率&lt;/a&gt;： 添加观察点和反标&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;其他：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在 Test case 中使用，可以在每个测试用例里也编写一个功能点。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;功能覆盖率使用流程&#34;&gt;功能覆盖率使用流程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;指定-group-名称&#34;&gt;指定 Group 名称&lt;/h3&gt;&#xA;&lt;p&gt;测试报告通过 Group 名字和 DUT 名字进行匹配，利用 comm.UT_FCOV 获取 DUT 前缀，例如在 Python 模块&lt;code&gt;ut_frontend/ifu/rvc_expander/classical_version/env/rvc_expander_wrapper.py&lt;/code&gt;中进行如下调用：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;UT_FCOV&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 本模块名为：ut_frontend.ifu.rvc_expander.classical_version.env.rvc_expander_wrapper&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 通过../../../去掉了classical_version和上级模块env，rvc_expander_wrapper&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# UT_FCOV会默认去掉前缀 ut_&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;g&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;fc&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;CovGroup&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;UT_FCOV&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;../../../CLASSIC&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# name = UT_FCOV(&amp;#34;../../../CLASSIC&amp;#34;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;name 的值为&lt;code&gt;frontend.ifu.rvc_expander.CLASSIC&lt;/code&gt;，在最后统计结果时，会按照最长前缀匹配到目标 UT（即匹配到：frontend.ifu.rvc_expander 模块）&lt;/p&gt;&#xA;&lt;h3 id=&#34;创建覆盖率组&#34;&gt;创建覆盖率组&lt;/h3&gt;&#xA;&lt;p&gt;使用&lt;code&gt;toffee&lt;/code&gt;的&lt;code&gt;funcov&lt;/code&gt;可以创建覆盖率组。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;toffee.funcov&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;fc&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 使用上面指定的GROUP名字&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;g&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;fc&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;CovGroup&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这两步也可以合成一句&lt;code&gt;g = fc.CovGroup(UT_FCOV(&amp;quot;../../../CLASSIC&amp;quot;))&lt;/code&gt;。&#xA;创建的g对象就表示了一个功能覆盖率组，可以使用其来提供观察点和反标。&lt;/p&gt;&#xA;&lt;h3 id=&#34;添加观察点和反标&#34;&gt;添加观察点和反标&lt;/h3&gt;&#xA;&lt;p&gt;在每个测试用例内部，可以使用&lt;code&gt;add_watch_point&lt;/code&gt;（&lt;code&gt;add_cover_point&lt;/code&gt;是其别名，二者完全一致）来添加观察点和&lt;code&gt;mark_function&lt;/code&gt;来添加反标。&#xA;观察点是，当对应的信号触发了我们在观察点内部定义的要求后，这个观察点的名字（也就是功能点）就会被统计到功能覆盖率中。&#xA;反标是，将功能点和测试用例进行关联，这样在统计时，就能看到每个功能点对应了哪些测试用例。&lt;/p&gt;&#xA;&lt;p&gt;对于观察点的位置，需要根据实际情况来定，一般来说，在测试用例外直接添加观察点是没有问题的。&#xA;不过有时候我们可以更加的灵活。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在测试用例之外（&lt;code&gt;decode_wrapper.py&lt;/code&gt;中）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;init_rvc_expander_funcov&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;expander&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;g&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;fc&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;CovGroup&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Add watch points to the RVCExpander module to collect function coverage information&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 1. Add point RVC_EXPAND_RET to check expander return value:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#    - bin ERROR. The instruction is not illegal&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#    - bin SUCCE. The instruction is not expanded&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;g&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;add_watch_point&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;expander&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;ERROR&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;lambda&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;stat&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()[&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;ilegal&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;False&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;SUCCE&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;lambda&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;stat&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()[&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;ilegal&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;False&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                          &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;RVC_EXPAND_RET&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 5. Reverse mark function coverage to the check point&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;_M&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;):&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# get the module name&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;module_name_with&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;../../test_rv_decode&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#  - mark RVC_EXPAND_RET&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;g&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;mark_function&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;RVC_EXPAND_RET&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;_M&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;([&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;test_rvc_expand_16bit_full&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                              &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;test_rvc_expand_32bit_full&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                              &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;test_rvc_expand_32bit_randomN&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]),&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;bin_name&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;ERROR&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;SUCCE&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;])&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# The End                                                                              &lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;None&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个例子的第一个&lt;code&gt;g.add_watch_point&lt;/code&gt;是放在测试用例之外的，因为它和现有的测试用例没有直接关系，放在测试用例之外反而更加方便。添加观察点之后，只要&lt;code&gt;add_watch_point&lt;/code&gt;方法中的&lt;code&gt;bins&lt;/code&gt;条件触发了，我们的&lt;code&gt;toffee-test&lt;/code&gt;框架就能够收集到对应的功能点。&lt;/p&gt;</description>
    </item>
    <item>
      <title>果壳Cache文档案例</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/02_nutshell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/00_standard/02_nutshell/</guid>
      <description>&lt;p&gt;本文档将以&lt;a href=&#34;https://github.com/OSCPU/NutShell/blob/fc12171d929e7e589fab9f794ab63ce12e6c594e/src/main/scala/nutcore/mem/Cache.scala&#34;&gt;果壳L1Cache&lt;/a&gt;作为案例，展示一个具有相当复杂度的模块的验证说明文档例子（请一定同提交的验证报告区分开来）。&lt;/p&gt;&#xA;&lt;h1 id=&#34;果壳l1cache验证文档&#34;&gt;果壳L1Cache验证文档&lt;/h1&gt;&#xA;&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;本文档针对NutShell L1Cache的验证需求撰写，通过对其功能进行描述并依据功能给出参考测试点，从而帮助验证人员编制测试用例。&lt;/p&gt;&#xA;&lt;p&gt;果壳（NutShell）是一款由5位中国科学院大学本科生设计的基于RISC-V RV64开放指令集的顺序单发射处理器(&lt;a href=&#34;https://github.com/OSCPU/NutShell&#34;&gt;NutShell·Github&lt;/a&gt;), 隶属于国科大与计算所“一生一芯”项目。而果壳Cache（NutShell Cache）是其缓存模块，采用可定制化设计（L1 Cache和L2 Cache采用相同的模板生成，只需要调整参数），具体来说，L1 Cache（指令Cache和数据Cache）大小为32KB，L2 Cache大小为128KB, 在整体结构上，果壳Cache采用三级流水的结构。&lt;/p&gt;&#xA;&lt;p&gt;本次验证的目标是L1 Cache，即一级缓存。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;MMIO（Memory-Mapped Input/Output）&lt;/td&gt;&#xA;          &lt;td&gt;内存映射IO&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;写回&lt;/td&gt;&#xA;          &lt;td&gt;Cache需要进行替换时，会将脏替换块写回内存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;关键字优先方案&lt;/td&gt;&#xA;          &lt;td&gt;缺失发生时，系统会优先获取CPU所需要的当前指令或数据所对应的字&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;前置知识&#34;&gt;前置知识&lt;/h2&gt;&#xA;&lt;h3 id=&#34;cache的层次结构&#34;&gt;Cache的层次结构&lt;/h3&gt;&#xA;&lt;p&gt;Cache有三种主要的组织方式：直接映射（Direct-Mapped）Cache、组相连（Set-Associative）Cache和全相连（Fully-Associative）Cache。对于物理内存中的一个数据，如果在Cache中只有一个位置可以存放它，这就是直接映射Cache；如果有多个位置可以存放这个数据，这就是组相连Cache；如果Cache中的任何位置都可以存放这个数据，这就是全相连Cache。&lt;/p&gt;&#xA;&lt;p&gt;直接映射Cache和全相连Cache实际上是组相连Cache的两种特殊情况。现代处理器中的Cache通常属于这三种方式中的一种。例如，翻译后备缓冲区（TLB）和Victim Cache多采用全相连结构，而普通的指令缓存（I-Cache）和数据缓存（D-Cache）则采用组相连结构。当处理器需要执行一个指令时，它会首先查找该指令是否在I-Cache中。如果在，则直接从I-Cache中读取指令并执行；如果不在，则需要从内存中读取指令到I-Cache中，再执行。与I-Cache类似，当处理器需要读取或写入数据时，会首先查找D-Cache。如果数据在D-Cache中，则直接读取或写入；如果不在，则需要从内存中加载数据到D-Cache中。与I-Cache不同的是，D-Cache需要考虑数据的一致性和写回策略。为了保证数据的一致性，当数据在D-Cache中被修改后，需要同步更新到内存中。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;composition.png&#34; alt=&#34;composition&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;cache的写入&#34;&gt;Cache的写入&lt;/h3&gt;&#xA;&lt;p&gt;在执行写数据时，如果只是向D-Cache中写入数据而不改变其下级存储器中的数据，就会导致D-Cache和下级存储器对于同一地址的数据不一致（non-consistent）。为了保持一致性，一般Cache在写命中状态下采用两种写入方式：&#xA;（1）写通（Write Through）：数据写入D-Cache的同时也写入其下级存储器。然而，由于下级存储器的访问时间较长，而存储指令的频率较高，频繁地向这种较慢的存储器中写入数据会降低处理器的执行效率。&#xA;（2）写回（Write Back）：数据写入D-Cache后，只是在Cache line上做一个标记，并不立即将数据写入更下级的存储器。只有当Cache中这个被标记的line要被替换时，才将其写入下级存储器。这种方式能够减少向较慢存储器写入数据的频率，从而获得更好的性能。然而，这种方式会导致D-Cache和下级存储器中许多地址的数据不一致，给存储器的一致性管理带来一定的负担。&lt;/p&gt;&#xA;&lt;p&gt;D-Cache处理写缺失一般有两种策略：&lt;/p&gt;&#xA;&lt;p&gt;（1）&lt;strong&gt;非写分配（Non-Write Allocate）&lt;/strong&gt;：直接将数据写入下级存储器，而不将其写入D-Cache。这意味着当发生写缺失时，数据会直接写入到下级存储器，而不会经过D-Cache。&lt;/p&gt;&#xA;&lt;p&gt;（2）&lt;strong&gt;写分配（Write Allocate）&lt;/strong&gt;：在发生写缺失时，会先将相应地址的整个数据块从下级存储器中读取到D-Cache中，然后再将要写入的数据合并到这个数据块中，最终将整个数据块写回到D-Cache中。这样做的好处是可以在D-Cache中进行更多的操作，但同时也增加了对内存的访问次数和延迟。&#xA;写通（Write Through）和非写分配（Non-Write Allocate）将数据直接写入下级存储器，而写回（Write Back）和写分配（Write Allocate）则会将数据写入到D-Cache中。通常情况下，D-Cache的写策略搭配为写通+非写分配或写回+写分配。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;写通示意图&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div style=&#34;text-align:center&#34;&gt;&#xA;&lt;img src=&#34;Write-through_with_no-write-allocation.png&#34; alt=&#34;write-through&#34; width=&#34;400&#34; /&gt;&#xA;&lt;p&gt;&lt;b&gt;写通示意图&lt;/b&gt;&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;div style=&#34;text-align:center&#34;&gt;&#xA;&lt;img src=&#34;Write-back_with_write-allocation.png&#34; alt=&#34;write-back&#34; width=&#34;400&#34; /&gt;&#xA;&lt;p&gt;&lt;b&gt;写回示意图&lt;/b&gt;&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 id=&#34;替换策略&#34;&gt;替换策略&lt;/h3&gt;&#xA;&lt;p&gt;读写D-Cache发生缺失时，需要从对应的Cache Set中找到一个cache行，来存放从下级存储器中读出的数据，如果此时这个Cache Set内的所有Cache行都已经被占用了，那么就需要替换掉其中一个，如何从这些有效的Cache行找到一个并替换它，这就是替换策略，本节介绍几种最常用的替换策略。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;近期最少使用法&lt;/strong&gt;会选择最近被使用次数最少的Cache行，因此这个算法需要追踪每个Cache行的使用情况，这需要为每个Cache行都设置一个年龄（age）部分，每当一个Cache行被访问时，它对应的年龄部分就会增加，或者减少其他Cache行的年龄值，这样当进行替换时，年龄值最小的那个Cache行就是被使用次数最少的了，会选择它进行替换。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;随机替换算法&lt;/strong&gt;硬件实现简单，这种方法发生缺失的频率会更高一些，但是随着Cache容量的增大，这个差距是越来越小的。在实际的设计中，很难实现严格的随机，一般采用一种称为时钟算法（clock algorithm）的方法实现近似的随机，它的工作原理本质上是一个时钟计数器，计数器的宽度由Cache的路的个数决定，当要替换时，就根据这个计数器选择相应的行进行替换。这种方法硬件复杂度较低，也不会损失较多的性能，因此是一种折中的方法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;整体框图和流水级&#34;&gt;整体框图和流水级&lt;/h2&gt;&#xA;&lt;p&gt;以下是L1Cache的整体框图和流水级示意：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;Cache.png&#34; alt=&#34;Cache&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;子模块列表&#34;&gt;子模块列表&lt;/h2&gt;&#xA;&lt;p&gt;以下是NutShell L1Cache的一些子模块：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;子模块&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;s1&lt;/td&gt;&#xA;          &lt;td&gt;缓存阶段1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;s2&lt;/td&gt;&#xA;          &lt;td&gt;缓存阶段2&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;s3&lt;/td&gt;&#xA;          &lt;td&gt;缓存阶段3&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;metaArray&lt;/td&gt;&#xA;          &lt;td&gt;以数组形式存储元数据&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;dataArray&lt;/td&gt;&#xA;          &lt;td&gt;以数组形式存储缓存数据&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;arb&lt;/td&gt;&#xA;          &lt;td&gt;总线仲裁器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;上下游通信总线采用SimpleBus总线，包含了req和resp两个通路，其中req通路的cmd信号表明请求的操作类型，可以通过检查该信号获得访问类型。SimpleBus总线共有七种操作类型，由于NutShell文档未涉及probe和prefetch操作，在验证中只出现五种操作：read、write、readBurst、writeBurst、writeLast，前两种为字读写，后三种为Burst读写，即一次可以操作多个字。&lt;/p&gt;</description>
    </item>
    <item>
      <title>FTQ顶层</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/01_topio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/01_topio/</guid>
      <description>&lt;h1 id=&#34;简述&#34;&gt;简述&lt;/h1&gt;&#xA;&lt;p&gt;在FTQ概述中，我们已经知道了，FTQ的作用就是多个模块交互的中转站，大致了解了它接受其他模块的哪些信息，它如何接受并存储这些信息在FTQ中，并如何把这些存储信息传递给需要的模块。&#xA;下面我们来具体了解一下FTQ与其他模块的交互接口，我们会对这种交互有一个更具体的认识。&lt;/p&gt;&#xA;&lt;h1 id=&#34;io一览&#34;&gt;IO一览&lt;/h1&gt;&#xA;&lt;h2 id=&#34;模块间io&#34;&gt;模块间IO&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;fromBpu：接受BPU预测结果的接口（BpuToFtqIO）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;fromIfu：接受IFU预译码写回的接口（IfuToFtqIO）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;fromBackend：接受后端执行结果和commit信号的接口（CtrlToFtqIO）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;toBpu：向BPU发送训练信息和重定向信息的接口（FtqToBpuIO）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;toIfu：向IFU发送取值目标和重定向信息的接口（FtqToIfuIO）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;toICache：向ICache发送取值目标的接口（FtqToICacheIO）&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;toBackend：向后端发送取值目标的接口（FtqToCtrlIO）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;toPrefetch：向Prefetch发送取值目标的接口（FtqToPrefetchIO）&lt;/li&gt;&#xA;&lt;li&gt;mmio&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;&#xA;&lt;p&gt;上述是主要的IO接口，此外，还有一些用于性能统计的IO接口，比如对BPU预测正确和错误结果次数进行统计，并进行转发的IO, 还有转发BPU各预测器预测信息的IO。&lt;/p&gt;&#xA;&lt;h1 id=&#34;bputoftqio&#34;&gt;&lt;a href=&#34;https://open-verify.cc/xs-bpu/docs/ports/02_global_ports/&#34;&gt;BpuToFtqIO&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;ifutoftqio&#34;&gt;IfuToFtqIO&lt;/h1&gt;&#xA;&lt;p&gt;我们知道从IFU，我们会得到预译码信息和重定向信息，而后者其实也是从预译码信息中生成。所以从IFU到FTQ的接口主要就是用来传递预译码信息的&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pdWb：IFU向FTQ写回某个FTQ项的预译码信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;strong&gt;PredecodeWritebackBundle&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pc：一个分支预测块覆盖的预测范围内的所有pc&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Vec(PredictWidth, UInt(VAddrBits.W))&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;pd：预测范围内所有指令的预译码信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Vec(PredictWidth, new PreDecodeInfo)&lt;/li&gt;&#xA;&lt;li&gt;PreDecodeInfo：每条指令的预译码信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：PreDecodeInfo&lt;/li&gt;&#xA;&lt;li&gt;信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;valid：预译码有效信号&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Bool&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;isRVC：是RVC指令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Bool&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;brType：跳转指令类型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：UInt(2.W)&lt;/li&gt;&#xA;&lt;li&gt;说明：根据brType的值判断跳转指令类型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;b01：对应分支指令&lt;/li&gt;&#xA;&lt;li&gt;b10：对应jal&lt;/li&gt;&#xA;&lt;li&gt;b11：对应jalr&lt;/li&gt;&#xA;&lt;li&gt;b00：对应非控制流指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;isCall：是Call指令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Bool&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;isRet：是Ret指令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Bool&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ftqIdx：FTQ项的索引，标记写回到哪个FTQ项&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：FtqPtr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ftqOffset：由BPU预测结果得到的，在该指令块中指令控制流指令的位置（指令控制流指令就是实际发生跳转的指令）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：UInt(log2Ceil(PredictWidth).W)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;misOffset：预译码发现发生预测错误的指令在指令块中的位置&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：ValidUndirectioned(UInt(log2Ceil(PredictWidth).W))&lt;/li&gt;&#xA;&lt;li&gt;说明：它的valid信号拉高表示该信号有效，也就说明存在预测错误，会引发重定向&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;cfiOffset：由预译码结果得到的，在该指令块中指令控制流指令的位置（指令控制流指令就是实际发生跳转的指令）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：ValidUndirectioned(UInt(log2Ceil(PredictWidth).W))&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;target：该指令块的目标地址&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：UInt(VAddrBits.W)&lt;/li&gt;&#xA;&lt;li&gt;说明：所谓目标地址，即在指令块中有控制流指令时，控制流指令的地址，在没有控制流指令时，指令块顺序执行，该指令块最后一条指令的下一条指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;jalTarget：jal指令的跳转地址&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：UInt(VAddrBits.W)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;instrRange：有效指令范围&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Vec(PredictWidth, Bool())&lt;/li&gt;&#xA;&lt;li&gt;说明：表示该条指令是不是在这个预测块的有效指令范围内（第一条有效跳转指令之前的指令）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;ctrltoftqio&#34;&gt;CtrlToFtqIO&lt;/h1&gt;&#xA;&lt;p&gt;后端控制块向FTQ发送指令提交信息，后端执行结果的接口。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;rob_commits：一个提交宽度内的RobCommitInfo信息。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Vec(CommitWidth, Valid(new RobCommitInfo))&lt;/li&gt;&#xA;&lt;li&gt;详情链接：RobCommitInfo&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;redirect：后端提供重定向信息的接口。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Valid(new Redirect)&lt;/li&gt;&#xA;&lt;li&gt;详情链接：Redirect&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ftqIdxAhead：提前重定向的FTQ指针，将要重定向的FTQ项的指针提前发送&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型： Vec(BackendRedirectNum, Valid(new FtqPtr))&lt;/li&gt;&#xA;&lt;li&gt;说明：虽然有三个接口，但实际上只用到了第一个接口，后面两个弃用了&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ftqIdxSelOH：独热码，本来是依靠该信号从提前重定向ftqIdxAhead中选择一个，但现在只有一个接口了，独热码也只有一位了。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Valid(UInt((BackendRedirectNum).W))&lt;/li&gt;&#xA;&lt;li&gt;说明：为了实现提前一拍读出在ftq中存储的重定向数据，减少redirect损失，后端会向ftq提前一拍（相对正式的后端redirect信号）传送ftqIdxAhead信号和ftqIdxSelOH信号。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;ftqtobpuio&#34;&gt;&lt;a href=&#34;https://open-verify.cc/xs-bpu/docs/ports/02_global_ports/&#34;&gt;FtqToBpuIO&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;ftqtoicacheio&#34;&gt;FtqToICacheIO&lt;/h1&gt;&#xA;&lt;p&gt;FTQ向IFU发送取值目标，ICache是指令缓存，如果取值目标在ICache中命中，由ICache将指令发给IFU&lt;/p&gt;</description>
    </item>
    <item>
      <title>FTQ子队列</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/02_subqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/02_subqueue/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;请注意：从本篇开始，就涉及待验证的功能点和测试点了&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;在之前的介绍中，我们采用FTQ项这个术语描述描述FTQ队列中的每一个元素，实际上，这只是一种便于抽象的说法。&lt;/p&gt;&#xA;&lt;p&gt;实际上的FTQ队列，是由好多个子队列共同构成的，一些子队列维护一类信息，另一些子队列维护另一类信息，相同ftqIdx索引的子队列信息共同构成一个完整的FTQ项。&lt;/p&gt;&#xA;&lt;p&gt;为什么要把它们分开成多个子队列呢？因为某些模块只需要FTQ项中的某一些信息，比如IFU想要取值目标，它只需要专门存储取值目标的子队列提供的信息就行了。另外，在我们更改FTQ项的内容时，也只需要写入需要更新的子队列，比如IFU预译码写回时，只需要写回专门存储预译码信息的队列了。&lt;/p&gt;&#xA;&lt;p&gt;下面来介绍一些FTQ的主要子队列，以及它们内部存储的数据结构。此外，FTQ还有一些存储中间状态的更小的队列&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;a href=&#34;https://open-verify.cc/xs-bpu/docs/ports/00_ftb/&#34;&gt;FTB项&lt;/a&gt;&lt;/td&gt;&#xA;          &lt;td&gt;分支预测结果的基本组成项，包含对预测块中分支指令和跳转指令的预测&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;取指目标&lt;/td&gt;&#xA;          &lt;td&gt;一个预测块内包含的所有指令PC，当然，它不是直接发送所有PC，而是发送部分信号，接收方可由该信号推出所有PC&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;子模块列表&#34;&gt;子模块列表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;子模块&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ftq_redirect_mem&lt;br&gt;&lt;/td&gt;&#xA;          &lt;td&gt;重定向存储子队列，存储来自分支预测结果的重定向信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ftq_pd_mem&lt;/td&gt;&#xA;          &lt;td&gt;预译码存储子队列，存储来自IFU的对指令块的预译码信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ftb_entry_mem&lt;/td&gt;&#xA;          &lt;td&gt;FTB项存储子队列，存储自分支预测结果中的ftb项&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ftq_pc_mem&lt;/td&gt;&#xA;          &lt;td&gt;取指目标子队列，存储来自分支预测结果的取指目标&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-ftq_redirect_mem存储重定向信息&#34;&gt;1. ftq_redirect_mem存储重定向信息&lt;/h3&gt;&#xA;&lt;p&gt;ftq_redirect_mem是香山ftq的一个子队列。它记录了重定向需要的一些信息，帮助重定向回正确状态，这些信息来自于BPU分支预测中的RAS预测器，以及顶层的分支历史指针，如果想要了解，可以参考BPU的RAS子文档了解如何通过这些信息回溯到之前的状态。&lt;/p&gt;&#xA;&lt;p&gt;它是一个寄存器堆，由64（FtqSize）个表项（Ftq_Redirect_SRAMEntry）构成。支持同步读写操作。有3个读端口和1个写端口，每个读端口负责与不同的模块交互。&lt;/p&gt;&#xA;&lt;h4 id=&#34;11-ftq_redirect_mem读操作&#34;&gt;1.1 ftq_redirect_mem读操作&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读操作：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;输入：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要使能ren，这是一个向量，可指定任意读端口可读&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对应接口：ren&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;从任意读端口中输入要读取的元素在ftq_redirect_mem中的地址，这是一个从0到ftqsize-1的索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对应接口：raddr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;输出：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从发起输入的读端口对应的读出端口中读出Ftq_Redirect_SRAMEntry。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对应接口：rdata&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;12-ftq_redirect_mem写操作&#34;&gt;1.2 ftq_redirect_mem写操作&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;写操作&#xA;&lt;ul&gt;&#xA;&lt;li&gt;输入：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要使能wen，可指定写端口可写&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对应接口：wen&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;向写端口中输入要写入的元素在ftq_redirect_mem中的地址，这是一个从0到ftqsize-1的索引&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对应接口：waddr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;向wdata中写入Ftq_Redirect_SRAMEntry&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对应接口：wdata&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;多端口读：可以从多个读端口读取结果&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;em&gt;每个子队列的读写基本都是类似的，后面不再赘述&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;ftq_redirect_sramentry&#34;&gt;Ftq_Redirect_SRAMEntry&lt;/h3&gt;&#xA;&lt;p&gt;ftq_redirect_mem存储的表项。继承自SpeculativeInfo，存储RAS预测器相关重定向信息，根据这些信息回溯到之前的状态&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;sc_disagree：统计分支指令在sc预测器中预测是否发生错误&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：Some(Vec(numBr, Bool()))&lt;/li&gt;&#xA;&lt;li&gt;说明：Option 类型，表明这个值可能不存在，在非FPGA平台才有，否则为none&lt;/li&gt;&#xA;&lt;li&gt;信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SpeculativeInfo：推测信息，帮助BPU在发生重定向的时候回归正常的状态&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口列表:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;histPtr：重定向请求需要恢复的全局历史指针，可参见BPU顶层文档了解详情&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：CGHPtr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;说明：以下都属于RAS重定向信息,可参见BPU文档了解如何利用这些信息进行重定向&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ssp：重定向请求指令对应的 RAS 推测栈栈顶在提交栈位置的指针&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：UInt(log2Up(RasSize).W)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;sctr：重定向请求指令对应的 RAS 推测栈栈顶递归计数 Counter&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：RasCtrSize.W&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;TOSW：重定向请求指令对应的 RAS 推测栈（队列）写指针&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：RASPtr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;TOSR：重定向请求指令对应的 RAS 推测栈（队列）读指针&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：RASPtr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;NOS：重定向请求指令对应的 RAS 推测栈（队列）读指针&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：RASPtr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;topAddr：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：UInt(VAddrBits.W)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;功能名称&lt;/th&gt;&#xA;          &lt;th&gt;测试点名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;          &lt;td&gt;FTQ_REDIRECT_MEM&lt;/td&gt;&#xA;          &lt;td&gt;WRITE&lt;/td&gt;&#xA;          &lt;td&gt;向单端口输入wen，waddr决定是否写入以及写入地址，写入wdata&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.2&lt;/td&gt;&#xA;          &lt;td&gt;FTQ_REDIRECT_MEM&lt;/td&gt;&#xA;          &lt;td&gt;READ&lt;/td&gt;&#xA;          &lt;td&gt;向多端口中输入ren，raddr决定是否读以及读取地址，从rdata读取&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;2-ftq_pd_mem存储预译码信息&#34;&gt;2. ftq_pd_mem存储预译码信息&lt;/h3&gt;&#xA;&lt;p&gt;由64（FtqSize）个表项（Ftq_pd_Entry）构成。支持同步读写操作。有2个读端口和1个写端口。具有读写使能信号。&lt;/p&gt;</description>
    </item>
    <item>
      <title>FTQ接收BPU分支预测结果</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/03_enqfrombpu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/03_enqfrombpu/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;BPU会将分支预测结果和meta数据发给FTQ。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从分支预测结果中，我们可以提取出分支预测块对应的取值目标，比如，一个不跨缓存行且所有指令均为RVC指令的分支预测块对应的取值目标，是从分支预测块起始地址开始的以2B为间隔的连续16条指令。&lt;/li&gt;&#xA;&lt;li&gt;meta信息则存储了各个预测器相关的预测信息，由于BPU预测有三个流水级，每个流水级都有相应的预测器，所以只有到s3阶段才有可能收集到所有预测器的预测信息，直到此时FTQ才接受到完整的meta，这些信息会在该分支预测块的全部指令被后端提交时交给BPU进行训练&lt;/li&gt;&#xA;&lt;li&gt;FTBEntry：严格来说，它其实也是meta的一部分，但是因为更新的时候ftb_entry需要在原来的基础上继续修改，为了不重新读一遍ftb，另外给它存储一个副本。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BPU (Branch Prediction Unit)&lt;/td&gt;&#xA;          &lt;td&gt;分支预测单元&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;FTQ (Fetch Target Queue)&lt;/td&gt;&#xA;          &lt;td&gt;采集目标队列&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;IFU (Instruction Fetch Unit)&lt;/td&gt;&#xA;          &lt;td&gt;指令采集单元&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;RAS (Return Address Stack)&lt;/td&gt;&#xA;          &lt;td&gt;返回地址堆&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;FTQ Entry&lt;/td&gt;&#xA;          &lt;td&gt;FTQ队列中的单个表项&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-新的预测块进队条件&#34;&gt;1. 新的预测块进队条件&lt;/h3&gt;&#xA;&lt;h4 id=&#34;11-成功接收数据&#34;&gt;&lt;strong&gt;1.1 成功接收数据&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;h5 id=&#34;111-ftq准备好接收信号&#34;&gt;1.1.1 FTQ准备好接收信号&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FTQ准备好接收信号：&#xA;     当FTQ队列中元素小于FtqSize或者可以提交指令块（canCommit拉高，说明可以提交指令块，在后面的文档: FTQ向BPU发送更新信息中介绍怎么判断是否可以提交指令块）的时候，来自BPU的新的指令预测块可以进入FTQ队列，队列准备好接收新的预测块，fromBpu的resp接口ready信号拉高。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;112-bpu准备好要发送的信号&#34;&gt;1.1.2 BPU准备好要发送的信号&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;BPU准备好要发送的信号：&#xA;     当BPU发往FTQ的接口vaid信号拉高，表示发送信号准备好&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;满足以上两个条件时,fromBpu的resp接口fire，表示接口数据被成功发送到FTQ中。&lt;/p&gt;&#xA;&lt;h4 id=&#34;12-允许bpu入队allowbpuin&#34;&gt;&lt;strong&gt;1.2 允许BPU入队allowBpuIn&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重定向发生时，会回滚到之前的状态，新发送的BPU预测信息自然就不需要了。&lt;strong&gt;允许BPU入队&lt;/strong&gt;时不能发生重定向&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;121-后端重定向发生&#34;&gt;1.2.1 后端重定向发生&lt;/h5&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;后端重定向发生：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标志：接收后端写回信息的接口fromBackend的重定向接口redirect有效，则该周期不允许入队，如果没有发生真实提前重定向realAhdValid(参见FTQ接收后端重定向一文)，则下一个周期也不允许入队。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h5 id=&#34;122-ifu重定向发生&#34;&gt;1.2.2 IFU重定向发生&lt;/h5&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;IFU重定向发生：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标志：IFU重定向信息生成的两个周期，均不许入队（参见FTQ接收IFU重定向一文了解IFU重定向信息的生成）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;只要避免上述两种重定向出现的情况，就可以允许BPU入队,即可以把发送到FTQ的数据，写入FTQ项&lt;/p&gt;&#xA;&lt;h4 id=&#34;13-以bpu预测结果重定向的方式入队&#34;&gt;1.3 以BPU预测结果重定向的方式入队&lt;/h4&gt;&#xA;&lt;p&gt;上述的BPU入队方式是一个全新的预测块进队，即BPU分支预测的s1阶段结果入队，此时未发生预测结果重定向。&lt;/p&gt;&#xA;&lt;p&gt;当BPU发生预测结果重定向时，只要&lt;strong&gt;允许BPU入队allowBpuIn&lt;/strong&gt;，也可以看作预测结果入队，不过这种入队是覆写队列中已有的FTQ项，没有写入新的指令块。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;BPU预测结果发生重定向的具体标志：fromBpu的resp接口的s2（s2阶段的预测信息）有效，且s2的hasRedirect拉高，表示在s2阶段发生了重定向，s3阶段重定向是一样的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;综合两种形式的BPU入队，这里称之为广义BPU入队方便区分，记为bpu_in_fire，该信号拉高，表明发生广义BPU入队。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-写入ftq项&#34;&gt;2. 写入FTQ项&lt;/h3&gt;&#xA;&lt;p&gt;之前已经说明过了，FTQ项只是一个抽象的概念，FTQ有很多个子队列组成，它们的项共同构成一个FTQ项，所以，向FTQ中写入FTQ项，实际上就是就是把BPU的预测信息写到对应的FTQ子队列中。&lt;/p&gt;&#xA;&lt;p&gt;FTQ主要获取以下信息作为bpu_in_resp&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;bpu_in_resp：BPU交给FTQ的resp详见BPU文档，resp中含有s1,s2,s3三个阶段的指令预测信息，bpu_in_resp将获取其中某一阶段预测信息selectedResp作为其值。未发生重定向时，使用s1作为预测结果，s2或者s3发生重定向信息时，优先s3的预测信息作为selectedResp。某阶段发生重定向的标志与上文讲述的一样一样。&#xA;从selectedResp（bpu_in_resp）中，我们还可以获取以下目标信息帮助我们写入子队列：ftq_idx，帮助我们索引写入子队列的地址&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;21-写入ftq子队列&#34;&gt;2.1 写入FTQ子队列：&lt;/h4&gt;&#xA;&lt;h5 id=&#34;211-写入ftq_pc_mem&#34;&gt;2.1.1 写入ftq_pc_mem&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftq_pc_mem: 来自BPU的selectedResp预测信息被写入ftq_pc_mem, 该存储结构有ftqsize个表项，对应队列中的所有ftq表项，每个存储元素可以推出对应的ftq表项中每条指令的pc地址&#xA;接收信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;wen：接收bpu_in_fire作为写使能信号&lt;/li&gt;&#xA;&lt;li&gt;waddr：接收selectedResp的ftq_idx&lt;/li&gt;&#xA;&lt;li&gt;wdata：selectedResp的相应信号&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;212-写入ftq_redirect_mem&#34;&gt;2.1.2 写入ftq_redirect_mem&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftq_redirect_mem: 在BPU的s3（也就是最终阶段）接收信息，因为重定向信息只有在s3阶段才能得到。里面存储了RAS重定向相关的信息帮助BPU进行重定向。&#xA;接收信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;wen：从BPU（fromBpu）回应（resp）的lastStage有效信号&lt;/li&gt;&#xA;&lt;li&gt;waddr：从BPU回应的lastStage的ftq_idx.value&lt;/li&gt;&#xA;&lt;li&gt;wdata：从BPU回应的last_stage_spec_info&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;213-写入ftq_meta_1r_sram&#34;&gt;2.1.3 写入ftq_meta_1r_sram&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftq_meta_1r_sram：在 BPU的s3阶段接收信息，同样是因为对于一个指令预测块，只有在其s3阶段才能获取完整的mata信息，同样被接收的还有最后阶段ftqentry信息&#xA;接收信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;wen：从BPU（fromBpu）回应（resp）的lastStage有效信号&lt;/li&gt;&#xA;&lt;li&gt;waddr：从BPU回应的lastStage的ftq_idx的value&lt;/li&gt;&#xA;&lt;li&gt;wdata：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;meta：从BPU回应的last_stage_meta&lt;/li&gt;&#xA;&lt;li&gt;ftb_entry：从BPU回应的last_stage_ftb_entry&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;214-写入ftb_entry_mem&#34;&gt;2.1.4 写入ftb_entry_mem&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftb_entry_mem：虽然ftq_meta_1r_sram中存储有最后阶段ftbentry，但此处出于更高效率读取专门把它存在ftb_entry_mem中。&#xA;接收信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;wen：从BPU（fromBpu）回应（resp）的lastStage有效信号&lt;/li&gt;&#xA;&lt;li&gt;waddr：从BPU回应的lastStage的ftq_idx的value字段&lt;/li&gt;&#xA;&lt;li&gt;wdata：从BPU回应的last_stage_ftb_entry&#xA;从中可以看到，FTQ虽然名字上听起来是一个队列，&lt;strong&gt;实际上内部却是由数个队列组成&lt;/strong&gt;，他们共同构成了FTQ这个大队列&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;22-写入状态队列&#34;&gt;2.2 写入状态队列&lt;/h4&gt;&#xA;&lt;p&gt;上述存储结构是FTQ中比较核心的存储结构，实际上，还有一些子队列用来存储一些状态信息，也同样都是存储ftqsize个（64）元素，需要被写入，写入时机是在发生bpu_in_fire的下一个周期，或者再下一个周期 。主要有以下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>FTQ向IFU发送取指目标</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/04_toifu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/04_toifu/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;IFU需要取FTQ中的项进行取指令操作，同时也会简单地对指令进行解析，并写回错误的指令&#xA;FTQ发送给IFU的信号同时也需发送给ICache一份，ICache是指令缓存，帮助快速读取指令。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ifuPtr：该寄存器信号指示了当前FTQ中需要读取的项的指针。直接发送给io.toIfu.req接口的ftqIdx。&lt;/li&gt;&#xA;&lt;li&gt;entry_is_to_send：entry_fetch_status存储每个FTQ项的发送状态，初始化并默认为当前ifuptr指向的项对应的发送状态，后续可能因为旁路逻辑等改变&lt;/li&gt;&#xA;&lt;li&gt;entry_ftq_offset: 从cfiIndex_vec中初始化并默认为当前ifuptr指向项的跳转指令在预测块中的偏移，后续可能因为旁路逻辑等改变&lt;/li&gt;&#xA;&lt;li&gt;entry_next：本次取指结束后下一次取值的开始地址&lt;/li&gt;&#xA;&lt;li&gt;pc_mem_ifu_ptr_rdata：获取ifuptr指向FTQ项的取指信息（从ftq_pc_mem的读取接口ifuPtr_rdata中获取）&lt;/li&gt;&#xA;&lt;li&gt;pc_mem_ifu_plus1_rdata：获取ifuptr+1指向FTQ项的pc相关信息（从ftq_pc_mem的读取接口ifuPtrPlus1_rdata中）&lt;/li&gt;&#xA;&lt;li&gt;copied_ifu_plus1_to_send：多个相同的复制信号，entry_fetch_status中指向ifuPtrPlus1的项是f_to_send状态或者上一周期bpu_in_fire,同时旁路bpu指针bpu_in_bypass_ptr等于ifuptr+1时，信号copied_ifu_plus1_to_send在一周期后拉高&lt;/li&gt;&#xA;&lt;li&gt;copied_ifu_ptr_to_send：同理，只是把ifuptr+1改成了ifuptr&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-获取取指目标信息&#34;&gt;1. 获取取指目标信息&lt;/h3&gt;&#xA;&lt;p&gt;获取取指目标有两个来源，一个是BPU写入信息时，直接将取指目标旁路出来，一种则是从存储取指目标的队列ftq_pc_mem中读取。使用前一种方式的前提，是刚好ifuPtr指向的读取项刚好就是旁路指针信号bpu_in_resp_ptr（BPU入队时写入项的ftqIdx）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;旁路逻辑：pc信号在被写入存储子队列时就被旁路一份，写入信号ftq_pc_mem.io.wdata在bpu_in_fire信号拉高时被旁路到旁路信号寄存器bpu_in_bypass_buf中。同时被旁路的还有指针信号bpu_in_resp_ptr，在同样的条件下被旁路到寄存器bpu_in_bypass_ptr中&lt;/li&gt;&#xA;&lt;li&gt;读取ftq_pc_mem: 存储pc相关的取指目标，该存储队列有多个读接口，对所有ftqptr的写入信号（比如ifuPtr_write, ifuPtrPlus1_write等）被直接连接到存储队列的读取接口，这样，在ftqPtr寄存器正式被更新时，就可以同时直接从对应的读取接口中返回对应指针的读取结果，比如ftq_pc_mem.io.ifuPtr_rdata&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;11-准备发往icache的取指目标&#34;&gt;1.1 准备发往ICache的取指目标&lt;/h4&gt;&#xA;&lt;p&gt;有以下三种情况，分别对应&lt;strong&gt;测试点1.1.1，1.1.2，1.1.3&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;旁路生效，即旁路bpu指针等于ifuptr，且上一周期bpu输入有效结果（last_cycle_bpu_in表示上一周期bpu_in_fire）有效（也就相当于该旁路指针是有效的），此时，直接向toICache接口输入旁路pc信息bpu_in_bypass_buf&lt;/li&gt;&#xA;&lt;li&gt;不满足情况1，但是上一周期发生ifu_fire（即FTQ发往IFU的接口发生fire），成功传输信号，此toICache中被写入pc存储子队列ftq_pc_mem中ifuptr+1对应项的结果，这是因为此时发生了ifu_fire，新的ifuptr还未来得及更新（即加1），所以直接从后一项中获取新的发送数据&lt;/li&gt;&#xA;&lt;li&gt;前两种情况都不满足，此时toICache接口中被写入pc存储队列中ifuptr对应项的结果&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;12-提前一周期准备发往prefetch的取指目标&#34;&gt;1.2 提前一周期准备发往Prefetch的取指目标&lt;/h4&gt;&#xA;&lt;p&gt;有以下三种情况，分别对应&lt;strong&gt;测试点1.2.1，1.2.2，1.2.3&lt;/strong&gt;&#xA;同样有三种情况：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;bpu有信号写入（bpu_in_fire），同时bpu_in_resp_ptr等于pfptr的写入信号pfptr_write, （此时pfptr_write还没有正式被写入pfptr中），读取bpu向pc存储队列的写入信号wdata，下一周期写入ToPrefetch&#xA;     &lt;em&gt;xxxptr_write：是相应FTQptr寄存器的write信号，连接到寄存器的写端口，寄存器在时钟上升沿成功写入write信号&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;不满足情况1，且由bpu到prefetch的接口发生fire，即bpu向预取单元成功发送信号，pc存储单元的pfPtrPlus1_rdata下一周期写入ToPrefetch接口，选择指针加1对应项的原因与toICache类似。&lt;/li&gt;&#xA;&lt;li&gt;不满足以上两种情况：pc存储单元的pfPtr_rdata在下一周期被写入ToPrefetch接口&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;13-设置下一个发送的指令块的起始地址&#34;&gt;1.3 设置下一个发送的指令块的起始地址&lt;/h4&gt;&#xA;&lt;p&gt;有以下三种情况，分别对应&lt;strong&gt;测试点1.3.1，1.3.2，1.3.3&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;target（entry_next_addr）旁路逻辑：&lt;/strong&gt;&#xA;有三种情况：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;上一周期bpu写入信号，且旁路指针等于ifuptr：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;toIfu：写入旁路pc信息bpu_in_bypass_buf&lt;/li&gt;&#xA;&lt;li&gt;entry_is_to_send ：拉高&lt;/li&gt;&#xA;&lt;li&gt;entry_next_addr ：bpu预测结果中跳转地址last_cycle_bpu_target&lt;/li&gt;&#xA;&lt;li&gt;entry_ftq_offset ：bpu预测结果中跳转指令在预测块中的偏移last_cycle_cfiIndex&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;不满足情况1，bpu到ifu的接口发生fire，信号成功写入&#xA;&lt;ul&gt;&#xA;&lt;li&gt;toIfu：写入pc存储队列的读出信号ifuPtrPlus1_rdata，这同样是因为ifuptr还没来得及更改，所以直接使用ifuptr+1对应项的rdata&lt;/li&gt;&#xA;&lt;li&gt;entry_is_to_send ：发送状态队列中ifuPtrPlus1对应项为f_to_send或者在上一周期bpu有写入时旁路bpu指针等于ifuptr加1，entry_is_to_send拉高。&lt;/li&gt;&#xA;&lt;li&gt;entry_next_addr ：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果上一周期bpu有写入且bpu旁路指针等于ifuptr+1，写入bpu旁路pc信号的startAddr字段，而这个项的pc信息还没有写入，正在pc旁路信号中，这是因为ifuptr+1对应下一个指令预测块，它的起始地址实际上就是ifuptr对应指令的预测块的跳转目标。&lt;/li&gt;&#xA;&lt;li&gt;如果不满足该条件，&#xA;&lt;ol&gt;&#xA;&lt;li&gt;ifuptr等于newest_entry_ptr: 使用newest_entry_target作为entry_next_addr，newest_entry_ptr，newest_entry_target这几个内部信号，表明我们当前队列中最新的有效的FTQ项。如之前所说，BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，在相应的文档中，对其生成方式做具体的描述。&lt;/li&gt;&#xA;&lt;li&gt;不满足条件1：使用pc存储队列的ifuPtrPlus2_rdata.startAddr&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;不满足情况1，2：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;toIfu：写入pc存储队列的读出信号ifuPtr_rdata&lt;/li&gt;&#xA;&lt;li&gt;entry_is_to_send ：发送状态队列中ifuPtr对应项为f_to_send或者在上一周期bpu有写入时旁路bpu指针等于ifuptr&lt;/li&gt;&#xA;&lt;li&gt;entry_next_addr ：&lt;/li&gt;&#xA;&lt;li&gt;如果上一周期bpu有写入且bpu旁路指针等于ifuptr+1，写入bpu旁路pc信号的startAddr字段。&lt;/li&gt;&#xA;&lt;li&gt;如果不满足该条件，&#xA;         1. ifuptr等于newest_entry_ptr: 使用newest_entry_target作为entry_next_addr。&#xA;         2. 不满足上面的条件1：使用pc存储队列的ifuPtrPlus1_rdata.startAddr，为什么条件2和条件3，一个使用ifuPtrPlus2_rdata.startAddr作为entry_next_addr ，一个使用ifuPtrPlus1_rdata.startAddr作为，这也是出于时序的考虑：&#xA;因为要获得实际上的ifuptr+1对应项的start值作为结果，而因为第一处那里因为ifuptr还没来得及更新（加1）同步到当前实际的ifuptr，所以要加2来达到实际上的ifuptr+1对应的值，而第二处的ifuptr已经更新了，所以只用加1就行了。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-发送取指信息&#34;&gt;2. 发送取指信息&lt;/h3&gt;&#xA;&lt;h4 id=&#34;21-发送取指目标&#34;&gt;2.1 发送取指目标&lt;/h4&gt;&#xA;&lt;h5 id=&#34;211-发送给ifu&#34;&gt;2.1.1 发送给IFU&lt;/h5&gt;&#xA;&lt;p&gt;&lt;strong&gt;toIfu接口的req接口：&lt;/strong&gt;&#xA;FTQ通过该接口向IFU发送取指信号：&lt;/p&gt;</description>
    </item>
    <item>
      <title>IFU向FTQ写回预译码信息</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/05_wbfromifu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/05_wbfromifu/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;IFU获取来自BPU的预测信息之后，会执行预译码，并将FTQ项写回FTQ中去。我们会比对FTQ中原BPU预测项和预译码的结果，判断是否有预测错误&lt;/p&gt;&#xA;&lt;h3 id=&#34;基本流程&#34;&gt;基本流程&lt;/h3&gt;&#xA;&lt;p&gt;预译码写回ftq_pd_mem：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FTQ从pdWb接口中获取IFU的写回信息，FTQ首先将预译码写回信息写回到ftq_pd_mem,&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;更新提交状态队列commitStateQueue：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;然后根据写回信息中指令的有效情况更新提交状态队列commitStateQueue。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;比对错误：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同时，从ftb_entry_mem读出ifu_Wb_idx所指的FTB项，将该FTB项的预测结果与预译码写回结果进行对比，看两者对分支的预测结果是否有所不同。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;综合错误：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;之后就综合根据预译码信息可能得到的错误：有前面说的比对BPU的预测结果和预译码结果得到的错误，也有直接根据预译码得到的错误预测信息。根据错误预测结果更新命中状态队列。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;更新写回指针&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最后，如果IFU成功写回，ifu_Wb_idx更新加1。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;预译码&lt;/td&gt;&#xA;          &lt;td&gt;IFU会对取指目标进预译码，之后写回FTQ&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ifuWbPtr&lt;/td&gt;&#xA;          &lt;td&gt;IFU写回指针，知识IFU预译码要写入FTQ的位置&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-预译码写回ftq_pd_mem&#34;&gt;1. 预译码写回ftq_pd_mem&lt;/h3&gt;&#xA;&lt;p&gt;写回有效：预译码信息pdWb有效时，写有效&#xA;写回地址：pdWb的ftqIdx的value&#xA;写回值：解析整个pdWb的结果&lt;/p&gt;&#xA;&lt;h3 id=&#34;2-更新提交状态队列&#34;&gt;2. 更新提交状态队列&lt;/h3&gt;&#xA;&lt;p&gt;当预译码信息pdWb有效时，相当于写回有效，此时，根据预译码信息中每条指令的有效情况和该指令是否在有效范围内，判断指令的提交状态是否可以修改，若可以修改，则将提交状态队列，写回项中的指令状态修改&lt;/p&gt;&#xA;&lt;h4 id=&#34;详细信号表示&#34;&gt;详细信号表示&lt;/h4&gt;&#xA;&lt;p&gt;pdWb有效时，ifu_wb_valid拉高。&#xA;此时，对于预译码信息中每一条指令的预译码结果pd做判断：&#xA;如果预译码结果valid，且指令在有效范围内（根据insrtRange的bool数组指示），则提交状态队列commitStateQueue中，写回项中的指令状态修改为c_toCommit，表示可以提交，这是因为只有在FTQ项被预译码写回后，才能根据后端提交信息提交该FTQ项，之后会把预译码信息一并发往更新通道。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-比对预测结果与预译码结果&#34;&gt;3. 比对预测结果与预译码结果&lt;/h3&gt;&#xA;&lt;p&gt;从ftb存储队列ftb_entry_mem中的读取ifu写回指针ifuwbptr的对应项：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pdWb有效的时候，读有效，读取地址为预译码信息中指示的ftqIdx。&#xA;当命中状态队列指示待比对项ftb命中，且回写有效时，读取出FTB存储队列中对应的项，与预译码信息进行比对，当BPU预测的FTB项指示指令是有效分支指令，而预译码信息中则指示不是有效分支指令时，发生分支预测错误，当BPU预测的FTB项指示指令是有效jmp指令，而预译码信息中则指示不是有效jmp指令时，发生跳转预测错误&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;详细信号表示-1&#34;&gt;详细信号表示：&lt;/h4&gt;&#xA;&lt;p&gt;ifu_wb_valid回写有效时，ftb_entry_mem回写指针对应读使能端口ren有效，读取地址为ifu_wb_idx预测译码信息中指示的ftqIdx的value值。&#xA;回写项命中且回写有效，hit_pd_valid信号有效，此时，读取ftb存储队列中的FTB项，读出brSlots与tailSlot，并进行比对：&lt;/p&gt;&#xA;&lt;h4 id=&#34;31-判断是否有分支预测错误br_false_hit&#34;&gt;3.1 判断是否有分支预测错误br_false_hit&lt;/h4&gt;&#xA;&lt;h5 id=&#34;测试点311和312对应以下两种条件导致的br_false_hit&#34;&gt;测试点3.1.1和3.1.2对应以下两种条件导致的br_false_hit&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;判断是否有分支预测错误br_false_hit：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;brSlots的任意一项有效，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高表明是分支指令，&lt;/li&gt;&#xA;&lt;li&gt;taiSlot有效且sharing字段拉高表明该slot为分支slot，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高表明是分支指令&#xA;满足任意条件可判断发生分支预测错误br_false_hit，该信号拉高&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;32-判断是否发生jmp预测错误jal_false_hit&#34;&gt;3.2 判断是否发生jmp预测错误jal_false_hit&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;判断是否发生jmp预测错误jal_false_hit：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;预测结果中必须指明指令预测有效，且其中isJal拉高表面是jal指令或者指明是isjalr指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;4-预译码错误&#34;&gt;4. 预译码错误&lt;/h3&gt;&#xA;&lt;p&gt;直接从预测结果中获取错误预测相关信息，如果回写项ftb命中且missoffset字段有效表明有错误预测的指令，hit_pd_mispred信号拉高，表示预译码结果中直接指明有预测错误的指令。&lt;/p&gt;&#xA;&lt;h3 id=&#34;5-综合错误&#34;&gt;5. 综合错误&lt;/h3&gt;&#xA;&lt;p&gt;综合比对预测结果与预译码结果得到的错误信息，与预译码错误直接获得的预测错误，任意一种发生时has_false_hit拉高表示有预测错误，此时，命中状态队列entry_hit_status中写回项的状态置为h_false_hit&lt;/p&gt;&#xA;&lt;h3 id=&#34;6-更新写回指针&#34;&gt;6. 更新写回指针&lt;/h3&gt;&#xA;&lt;p&gt;ifu_wb_valid拉高，表示写回有效，将ifuWbPtr更新为原值加1。&lt;/p&gt;&#xA;&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;顶层IO&lt;/th&gt;&#xA;          &lt;th&gt;子接口&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;fromIfu&lt;/td&gt;&#xA;          &lt;td&gt;pdWb&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;测试点总表&#34;&gt;测试点总表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;功能名称&lt;/th&gt;&#xA;          &lt;th&gt;测试点名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;WB_PD&lt;/td&gt;&#xA;          &lt;td&gt;WB_PD&lt;/td&gt;&#xA;          &lt;td&gt;向ftq_pd_mem中写回预译码信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;UPDATE_COMMITSTATE&lt;/td&gt;&#xA;          &lt;td&gt;UPDATE_COMMITSTATE&lt;/td&gt;&#xA;          &lt;td&gt;当预译码信息pdWb有效时，根据预译码信息中每条指令的有效情况和该指令是否在有效范围内，判断指令的提交状态是否可以修改，若可以修改，则将提交状态队列，写回项中的指令状态修改&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.1.1&lt;/td&gt;&#xA;          &lt;td&gt;BR_FALSE_HIT&lt;/td&gt;&#xA;          &lt;td&gt;COND1&lt;/td&gt;&#xA;          &lt;td&gt;brSlots的任意一项有效，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.1.2&lt;/td&gt;&#xA;          &lt;td&gt;BR_FALSE_HIT&lt;/td&gt;&#xA;          &lt;td&gt;COND2&lt;/td&gt;&#xA;          &lt;td&gt;taiSlot有效且sharing字段拉高表明该slot为分支slot，同时在预译码信息中不满足这一项对应的pd有效且isBr字段拉高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.2&lt;/td&gt;&#xA;          &lt;td&gt;JAL_FALSE_HIT&lt;/td&gt;&#xA;          &lt;td&gt;JAL_FALSE_HIT&lt;/td&gt;&#xA;          &lt;td&gt;指令预测有效，且其中isJal拉高或者指明是isjalr指令&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;          &lt;td&gt;PD_MISS&lt;/td&gt;&#xA;          &lt;td&gt;PD_MISS&lt;/td&gt;&#xA;          &lt;td&gt;如果回写项ftb命中且missoffset字段有效表明有错误预测的指令，hit_pd_mispred信号拉高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;5&lt;/td&gt;&#xA;          &lt;td&gt;FALSE_HIT&lt;/td&gt;&#xA;          &lt;td&gt;FALSE_HIT&lt;/td&gt;&#xA;          &lt;td&gt;综合比对预测结果与预译码结果得到的错误信息，与预译码错误直接获得的预测错误，任意一种发生时has_false_hit拉高表示有预测错误，此时，命中状态队列entry_hit_status中写回项的状态置为h_false_hit&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;6&lt;/td&gt;&#xA;          &lt;td&gt;UPDATE_IFU_WB_PTR&lt;/td&gt;&#xA;          &lt;td&gt;UPDATE_IFU_WB_PTR&lt;/td&gt;&#xA;          &lt;td&gt;ifu_wb_valid拉高，将ifuWbPtr更新为原值加1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>FTQ接收后端重定向</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/06_-redirectfrombackend/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/06_-redirectfrombackend/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;FTQ重定向信息有两个来源，分别是IFU 和 后端。两者的 重定向接口大致相似，但重定向的过程有一定区别。&lt;/p&gt;&#xA;&lt;p&gt;对于重定向，后端有提前重定向机制，为了实现提前一拍读出在ftq中存储的重定向数据，减少redirect损失，后端会向ftq提前一拍（相对正式的后端redirect信号）传送ftqIdxAhead信号和ftqIdxSelOH信号。ftqIdxSelOH信号出现的原因，是早期版本要读多个ftqIdxAhead信号，以独热码的形式选其中一路作为最终确认的提前索引值，但现在只需要从一个端口获取ftqIdx信号了，ftqIdxAhead只能确认这一个端口了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;sc_disagree&lt;/td&gt;&#xA;          &lt;td&gt;统计SC预测错误用的性能计数器中需要用到的值，SC预测器是BPU子预测器TAGE-SC预测器的一个部分&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-接收后端重定向信号&#34;&gt;1. 接收后端重定向信号&lt;/h3&gt;&#xA;&lt;h3 id=&#34;时序&#34;&gt;时序&lt;/h3&gt;&#xA;&lt;h4 id=&#34;11-提前重定向&#34;&gt;1.1 提前重定向&lt;/h4&gt;&#xA;&lt;p&gt;第一个周期：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;后端重定向写回时，首先会从后端到FTQ的IO接口（CtrltoFtqIO）中，看ftqIdx是不是有效信号，且此时后端正式重定向信号redirect无效(因为提前重定向会比正式重定向提前一拍，所以此时正式重定向无效)，这时，提前重定向信号aheadValid有效, 将使用提前获取的重定向ftqIdx，&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;12-真实提前重定向&#34;&gt;1.2 真实提前重定向&lt;/h4&gt;&#xA;&lt;p&gt;第二个周期：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果此时后端正式重定向信号有效了，且ftqIdxSelOH拉高，说明在正式重定向阶段成功对ftqIdxAhead信号进行选中，同时上一周期重定向信号aheadValid是有效的，则真实提前重定向信号realAhdValid拉高，在此时读取&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;13-存储后端重定向信号&#34;&gt;1.3 存储后端重定向信号&lt;/h4&gt;&#xA;&lt;p&gt;第三个周期：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;该周期会把来自后端的重定向信息的存储一份在寄存器backendRedirectReg中，具体的来说，当上一个周期后端重定向有效时，将后端重定向bits字段（存储实际内容）被写入寄存器的bits字段。&lt;/li&gt;&#xA;&lt;li&gt;而实际决定信号是否有效的valid字段（决定该信号是否有效）则在上一周期真实提前重定向信号有效（表示确实使用了提前重定向的ftqIdx进行重定向）的情况下，被写入false，因为提前重定向发生时，我们直接使用当前的后端重定向信号交给FTQ就可以了。而不需要多保存一个周期。&lt;/li&gt;&#xA;&lt;li&gt;真实提前重定向信号无效时，则由上一周期后端正式重定向的有效值决定，只有信号有效时，我们才需要把它存下来，之后交给FTQ。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-选择重定向信号&#34;&gt;2. 选择重定向信号&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;信号抉择&lt;/strong&gt;：&#xA;是提前获取后端重定向信息还是延迟一个周期从寄存器内读取？&#xA;真实重定向有效时，直接将后端重定向信息传递给FTQ，否则，取重定向寄存器内的信号作为重定向信息传递给FTQ，相当于晚一个周期发送重定向信息。最后被选择的重定向信息作为&lt;strong&gt;后端重定向结果fromBackendRedirect&lt;/strong&gt;发送给FTQ&lt;/p&gt;&#xA;&lt;p&gt;接下来讲讲后端重定向在这三个周期到底通过ftqIdx到底读了哪些FTQ子队列中的信息，以及怎么使用它们。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-整合子队列信号&#34;&gt;3. 整合子队列信号&lt;/h3&gt;&#xA;&lt;h4 id=&#34;31-读取子队列&#34;&gt;3.1 读取子队列&lt;/h4&gt;&#xA;&lt;p&gt;接下来讲讲后端重定向在这三个周期到底通过ftqIdx到底读了哪些FTQ子队列中的信息，以及怎么使用它们。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;后端重定向读取的子队列：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftq_redirect_mem：FTQ会根据后端重定向提供的ftqIdx读出ftq_Redirect_SRAMEntry，借助它提供的信息重定向到之前的状态。&lt;/li&gt;&#xA;&lt;li&gt;ftq_entry_mem：读出重定向指令块对应的FTB项&lt;/li&gt;&#xA;&lt;li&gt;ftq_pd_mem：读出重定向指令块的预译码信息&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;311-发生提前重定向时读取子队列需要两个周期&#34;&gt;3.1.1 发生提前重定向时，读取子队列需要两个周期&lt;/h4&gt;&#xA;&lt;h4 id=&#34;312-未发生提前重定向时读取子队列需要三个周期&#34;&gt;3.1.2 未发生提前重定向时，读取子队列需要三个周期&lt;/h4&gt;&#xA;&lt;p&gt;&lt;strong&gt;读子队列时序：&lt;/strong&gt;&#xA;第一个周期：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提前重定向信号有效时，将子队列的读端口，读有效信号拉高，输入ftqIdxAhead的value字段作为读地址，发起读取请求。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;第二个周期：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;case1. 如果第一周期的提前重定向无效，而现在正式重定向有效，则在此时才拉高读有效信号，使用正式重定向接口的ftqIdx作为读取地址，发起读取请求。&lt;/li&gt;&#xA;&lt;li&gt;case2. 真实提前重定向有效了，此时因为前一个周期已经发起读取请求，此时可以直接从子队列的读端口读出了&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;第三个周期&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;真实提前重定向无效，但至少前一个周期正式重定向发起的读取请求能保证在当前周期从子队列中读出。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;32-将子队列信息整合到后端重定向信号&#34;&gt;3.2 将子队列信息整合到后端重定向信号&lt;/h4&gt;&#xA;&lt;p&gt;&lt;strong&gt;处理读取信息&lt;/strong&gt;&#xA;&lt;em&gt;FTQ会将从子队列中读出的信息整合到fromBackendRedirect中。&lt;/em&gt;&#xA;具体来说：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重定向redirect接口的CfiUpdateInfo接口直接接收ftq_Redirect_SRAMEntry中的同名信号。&lt;/li&gt;&#xA;&lt;li&gt;利用fromBackendRedirect中指示的ftqOffset读取指令块预译码信息中实际跳转指令的预译码信息，该ftqOffset为后端执行过后确定的控制流指令在指令块内的偏移。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;得到的预译码信息被直接连接到CfiUpdateInfo接口的pd接口中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;对于读出的指令块对应的FTB项，我们可以从中得知实际执行时得到的跳转指令，是否在FTB项被预测为跳转指令，或者是被预测为jmp指令，如果是，则cfiUpdateInfo的br_hit接口或者jr_hit接口被拉高，表示对应的分支预测结果正确了。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;具体来说：通过发送ftqOffset，ftb项以brIsSaved的方式判断是否br_hit，判断是否jr_hit的方式也是类似的（r_ftb_entry.isJalr &amp;amp;&amp;amp; r_ftb_entry.tailSlot.offset === r_ftqOffset）。&lt;/li&gt;&#xA;&lt;li&gt;在CfiUpdateInfo接口设置为br_hit的时候，还会根据这条发生跳转的分支指令是哪个槽从ftq_Redirect_SRAMEntry重定向接口的sc_disagree统计SC预测错误用的性能计数器中，获取对应值，最后整合到后端重定向接口中（如果没有br_hit，对应计数器的两个值都为0）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;顶层IO&lt;/th&gt;&#xA;          &lt;th&gt;功能&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;fromBackend&lt;/td&gt;&#xA;          &lt;td&gt;接收后端重定向信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;测试点总表&#34;&gt;测试点总表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;功能名称&lt;/th&gt;&#xA;          &lt;th&gt;测试点名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;          &lt;td&gt;RECERIVE_BACKEND_REDIRECT&lt;/td&gt;&#xA;          &lt;td&gt;REDIRECT_AHEAD&lt;/td&gt;&#xA;          &lt;td&gt;后端重定向写回时，首先会从后端到FTQ的IO接口（CtrltoFtqIO）中，看ftqIdx是不是有效信号，且此时后端正式重定向信号redirect无效，这时，提前重定向信号aheadValid有效&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.2&lt;/td&gt;&#xA;          &lt;td&gt;RECERIVE_BACKEND_REDIRECT&lt;/td&gt;&#xA;          &lt;td&gt;REAL_REDIRECT_AHEAD&lt;/td&gt;&#xA;          &lt;td&gt;如果此时后端正式重定向信号有效了，且ftqIdxSelOH拉高，同时上一周期重定向信号aheadValid是有效的，则真实提前重定向信号realAhdValid拉高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.3&lt;/td&gt;&#xA;          &lt;td&gt;RECERIVE_BACKEND_REDIRECT&lt;/td&gt;&#xA;          &lt;td&gt;STORE_REDIRECT&lt;/td&gt;&#xA;          &lt;td&gt;后端真实重定向无效时写入寄存器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;CHOOSE_AHEAD&lt;/td&gt;&#xA;          &lt;td&gt;CHOOSE_AHEAD&lt;/td&gt;&#xA;          &lt;td&gt;真实重定向有效时，直接将后端重定向信息传递给FTQ，否则，取重定向寄存器内的信号作为重定向信息传递给FTQ&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.1.1&lt;/td&gt;&#xA;          &lt;td&gt;READ_FTQ_SUBQUEUE&lt;/td&gt;&#xA;          &lt;td&gt;READ_AHEAD&lt;/td&gt;&#xA;          &lt;td&gt;发生提前重定向时，读取子队列需要两个周期&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.1.2&lt;/td&gt;&#xA;          &lt;td&gt;READ_FTQ_SUBQUEUE&lt;/td&gt;&#xA;          &lt;td&gt;READ_NO_AHEAD&lt;/td&gt;&#xA;          &lt;td&gt;未发生提前重定向时，读取子队列需要三个周期&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.2&lt;/td&gt;&#xA;          &lt;td&gt;ADD_SUBQUEUE_INFO&lt;/td&gt;&#xA;          &lt;td&gt;ADD_SUBQUEUE_INFO&lt;/td&gt;&#xA;          &lt;td&gt;将子队列信息整合到后端重定向信号&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>FTQ接收IFU重定向</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/07_redirectfromifu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/07_redirectfromifu/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;除了后端，IFU也会发送重定向相关消息，和后端不同，IFU的重定向信息来自于预译码写回信息。相同的是，它们都是通过BranchPredictionRedirect的接口传递重定向信息。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;RedirectLevel&lt;/td&gt;&#xA;          &lt;td&gt;重定向等级，重定向请求是否包括本位置，低表示在本位置后重定向，高表示在本位置重定向。它在之后决定了由重定向导致的冲刷信号是否会影响到发生重定向的指令&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-ifu重定向信号生成&#34;&gt;1. IFU重定向信号生成&lt;/h3&gt;&#xA;&lt;h4 id=&#34;流程&#34;&gt;流程&lt;/h4&gt;&#xA;&lt;p&gt;IFU重定向是通过这个BranchPredictionRedirect接口传递的，下面来讲述IFU重定向怎么生成IFU的BranchPredictionRedirect内相应信号的，这个过程需要两个周期&#xA;信号列表：&#xA;&lt;strong&gt;第一个周期&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;11-ifu-重定向触发条件&#34;&gt;1.1 IFU 重定向触发条件&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;valid：当预译码写回pdWb有效，且pdWb的missOffset字段有效表明存在预测错误的指令，同时后端冲刷信号backendFlush无效时，valid信号有效。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;12-ifu生成重定向信号&#34;&gt;1.2 IFU生成重定向信号&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftqIdx：接收pdWb指定的ftqIdx&lt;/li&gt;&#xA;&lt;li&gt;ftqOffset：接收pdWb的missOffset的bits字段&lt;/li&gt;&#xA;&lt;li&gt;level：RedirectLevel.flushAfter，将重定向等级设置为flushAfter&lt;/li&gt;&#xA;&lt;li&gt;BTBMissBubble：true&lt;/li&gt;&#xA;&lt;li&gt;debugIsMemVio：false&lt;/li&gt;&#xA;&lt;li&gt;debugIsCtrl：false&lt;/li&gt;&#xA;&lt;li&gt;cfiUpdate：&#xA;信号列表:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pc：pdWb中记录的指令块中所有指令pc中，missOffset对应的pc&lt;/li&gt;&#xA;&lt;li&gt;pd：pdWb中记录的指令块中所有指令的pd中，missOffset对应的pd&lt;/li&gt;&#xA;&lt;li&gt;predTaken：从cfiIndex_vec子队列中读取pdWb中ftqIdx索引的项是否valid，有效说明指令块内被预测为有控制流指令。&lt;/li&gt;&#xA;&lt;li&gt;target：pdWb中的target&lt;/li&gt;&#xA;&lt;li&gt;taken：pdWb中cfiOffset的valid字段，有效时表明预译码认为指令块中存在指令控制流指令&lt;/li&gt;&#xA;&lt;li&gt;isMisPred：pdWb中missOffset的valid字段，有效时表明预译码认为指令块中存在预测错误的指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;第二个周期：&lt;/strong&gt;&#xA;该周期进行的信号生成是在第一周期valid字段有效的情况下才继续的&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;cifUpdate：&#xA;信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重定向RAS相关信号：通过ftqIdx索引从 ftq_redirect_mem读出ftq_Redirect_SRAMEntry，把其中的所有信号直接传递给cfiUpdate的同名信号中。&lt;/li&gt;&#xA;&lt;li&gt;target：已在第一周期写入cfiUpdate的pd有效，且isRet字段拉高，指明发生预测错误的指令本是一条Ret指令，此时，将target设置为cfiUpdate的topAddr，帮助回到发生错误之前的状态。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-重定向结果生效&#34;&gt;2. 重定向结果生效&lt;/h3&gt;&#xA;&lt;p&gt;两个周期生成完整的重定向信息后，IFU重定向信息才有效，有可能被FTQ采取，完整的&lt;strong&gt;IFU重定向结果记为ifuRedirectToBpu&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-ifu-冲刷信号-ifuflush&#34;&gt;3. IFU 冲刷信号 (&lt;code&gt;ifuFlush&lt;/code&gt;)&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;指令流控制信号&lt;/strong&gt;：&#xA;ifuFlush：来自IFU的冲刷信号，主要是由IFU重定向造成的，生成IFU重定向信息的两个周期内，该信号都拉高&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标志：IFU重定向信息产生接口BranchPredictionRedirect中valid有效，表示开始生成重定向信息，该周期以及下一个周期，ifuFlush拉高&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;顶层IO&lt;/th&gt;&#xA;          &lt;th&gt;作用&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;fromIFU&lt;/td&gt;&#xA;          &lt;td&gt;接收来自IFU的预译码信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;接口时序&#34;&gt;接口时序&lt;/h2&gt;&#xA;&lt;h2 id=&#34;测试点总表&#34;&gt;测试点总表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;功能名称&lt;/th&gt;&#xA;          &lt;th&gt;测试点名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;          &lt;td&gt;IFU_REDIRECT&lt;/td&gt;&#xA;          &lt;td&gt;IFU_REDIRECT_GRN_VALID&lt;/td&gt;&#xA;          &lt;td&gt;当预译码写回pdWb有效，且pdWb的missOffset字段有效表明存在预测错误的指令，同时后端冲刷信号backendFlush无效时，valid信号有效&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.2&lt;/td&gt;&#xA;          &lt;td&gt;IFU_REDIRECT&lt;/td&gt;&#xA;          &lt;td&gt;IFU_REDIRECT_GEN&lt;/td&gt;&#xA;          &lt;td&gt;允许生成IFU重定向时，在两周期内生成具体信号&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;IFU_REDIRECT_TO_BPU&lt;/td&gt;&#xA;          &lt;td&gt;IFU_REDIRECT_TO_BPU&lt;/td&gt;&#xA;          &lt;td&gt;IFU重定向生成后，IFU重定向结果生效&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3&lt;/td&gt;&#xA;          &lt;td&gt;IFU_FLUSH&lt;/td&gt;&#xA;          &lt;td&gt;IFU_FLUSH&lt;/td&gt;&#xA;          &lt;td&gt;生成IFU重定向信息的两个周期内，ifuFlush信号都拉高&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/mrs-testpoints&gt;</description>
    </item>
    <item>
      <title>FTQ向后端发送取指目标</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/08_tobackend/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/08_tobackend/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;pc取值目标会发给后端pc mem让他自己进行存储，之后从自己的pc mem取指，此外，最新的FTQ项和对应的跳转目标也会发给后端。&lt;/p&gt;&#xA;&lt;p&gt;怎样算是一个最新的FTQ项，BPU最新发送的预测块可以是最新的FTQ项，其次，重定向发生时，需要回滚到发生错误预测之前的状态，从指定的FTQ项开始重新开始预测，预译码等等，这也可以是被更新的最新的FTQ项。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;暂无&lt;/td&gt;&#xA;          &lt;td&gt;暂无&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h4 id=&#34;流程&#34;&gt;流程&lt;/h4&gt;&#xA;&lt;h4 id=&#34;1发送取值目标到pc-mem&#34;&gt;1.发送取值目标到pc mem&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;发送时机：bpu_in_fire，即BPU向前端发送有效预测信息，或者重定向信息的时候。以此为基础之后的第二个周期，进行发送，通过将toBackend接口的pc_mem_wen设置为true的方式指明开始发送&lt;/li&gt;&#xA;&lt;li&gt;接口信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;pc_mem_wen：设置为true&lt;/li&gt;&#xA;&lt;li&gt;pc_mem_waddr：接收bpu_in_fire那个周期BPU发送的ftqIdx&lt;/li&gt;&#xA;&lt;li&gt;pc_mem_wdata：接收bpu_in_fire那个周期，FTQ读取的ftq_pc_mem中的取指目标&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;2更新最新的ftq项&#34;&gt;2.更新最新的FTQ项&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;发送时机：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最新的FTQ项可能是由BPU写入最新预测信息造成的，&lt;strong&gt;发送取值目标到pc mem&lt;/strong&gt;也是因为BPU写入最新预测信息才写入的，如果是这种情况造成的，更新FTQ项和写入pc mem的时机是一致的。&lt;/li&gt;&#xA;&lt;li&gt;此外发生重定向时，也会进行状态回滚更新FTQ项，标志是后端接口fromBackend的重定向redirect信号有效，或者写入BPU的接口toBPU的redirctFromIFU拉高说明当前有来自IFU的重定向&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;em&gt;（注释（可忽略）IFU重定向信号生成有两个周期，可以认为第一个周期预译码信息中missoffset有效说明IFU重定向发生，也可以认为第二个周期redirctFromIFU拉高说明重定向发生，此处取后者）。&lt;/em&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;同样是向toBackend中写入&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;接口信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;newest_entry_en：前面说的发送时机到来时，再延迟一个周期达到真正的写入时机，这时才拉高信号&lt;/li&gt;&#xA;&lt;li&gt;newest_entry_ptr：发送时机到来时的newest_entry_ptr，在真正的写入时机写入&lt;/li&gt;&#xA;&lt;li&gt;newest_entry_target：发送时机到来时的newest_entry_target&#xA;newest_entry_ptr，newest_entry_target这几个都是同名的内部信号，如之前所说，BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，在相应的文档中，对其生成方式做具体的描述。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;顶层IO&lt;/th&gt;&#xA;          &lt;th&gt;作用&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;toBackend&lt;/td&gt;&#xA;          &lt;td&gt;发送取指令目标，让后端进行储存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;测试点总表&#34;&gt;测试点总表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;功能名称&lt;/th&gt;&#xA;          &lt;th&gt;测试点名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;          &lt;td&gt;SEND_PC_TO_BACKEND&lt;/td&gt;&#xA;          &lt;td&gt;SEND_PC&lt;/td&gt;&#xA;          &lt;td&gt;发送取值目标到pc mem&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;          &lt;td&gt;SEND_PC_TO_BACKEND&lt;/td&gt;&#xA;          &lt;td&gt;UPDATE_NEWEST&lt;/td&gt;&#xA;          &lt;td&gt;更新最新的FTQ项&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/mrs-testpoints&gt;</description>
    </item>
    <item>
      <title>执行单元修改FTQ状态队列</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/09_wbfromexu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/09_wbfromexu/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;后端的写回信息，包括重定向信息和更新信息，实际上都是执行之后，由实际执行单元根据结果发回的&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;cfiIndex_vec&lt;/td&gt;&#xA;          &lt;td&gt;控制流指令索引队列，记录每个指令块中控制流指令的索引&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;update_target&lt;/td&gt;&#xA;          &lt;td&gt;更新目标队列，记录每个指令块的跳转目标&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;FTQ最新项&lt;/td&gt;&#xA;          &lt;td&gt;BPU新的写入，重定向等等都会对最新FTQ项进行新的安排，表明我们当前关注的最新FTQ项。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-由后端的写回信号修改ftq状态&#34;&gt;1. 由后端的写回信号修改FTQ状态&lt;/h3&gt;&#xA;&lt;h4 id=&#34;11-修改ftq状态队列&#34;&gt;1.1 修改FTQ状态队列&lt;/h4&gt;&#xA;&lt;p&gt;从后端写回FTQ接口fromBackend中的redirect接口中，我们可以读出valid，ftqPtr，ftqOffset（后端实际执行时确认的控制流指令的偏移），taken，mispred字段，依靠它们来判断，如何修改FTQ的状态队列和相关的变量&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;后端执行单元写回时被修改的队列&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;h4 id=&#34;111-修改cfiindex_vec&#34;&gt;1.1.1 修改cfiIndex_vec&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;cfiIndex_vec：&#xA;修改方式：执行写回修改队列中ftqPtr那一项&#xA;&lt;ul&gt;&#xA;&lt;li&gt;valid：fromBackend中的redirect接口中，valid有效，taken有效，且ftqOffset小于或者等于cfiIndex_vec中ftqPtr那一项指定的偏移：这说明重定向发生，实际执行结果判断ftqPtr索引的指令块确实会发生跳转，且实际执行跳转的指令在被预测为发生跳转的指令之前或等于它。所以这时指令块是会发生跳转的，控制流索引队列的ftqPtr项valid&lt;/li&gt;&#xA;&lt;li&gt;bits：fromBackend中的redirect接口中，valid有效，taken有效，且ftqOffset小于cfiIndex_vec中ftqPtr那一项指定的偏移，偏移量被更新为更小值ftqOffset。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;112-修改update_target&#34;&gt;1.1.2 修改update_target&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;update_target：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftqPtr索引项的跳转目标修改为fromBackend的redirect接口中的cifUpdate中指定的target&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;113-修改mispredict_vec&#34;&gt;1.1.3 修改mispredict_vec&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;mispredict_vec：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果该重定向指令是来自后端的重定向指令， ftqPtr索引项的ftqOffset偏移指令被设置为fromBackend的redirect接口中的cifUpdate中指定的isMisPred&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;12-修改ftq最新项&#34;&gt;1.2 修改FTQ最新项&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;newest_entry_target：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;被修改为重定向接口中cfiUpdate指定的target&lt;/li&gt;&#xA;&lt;li&gt;辅助信号newest_entry_target_modified被指定为true&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;newest_entry_ptr：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;修改为重定向接口指定的ftqIdx&lt;/li&gt;&#xA;&lt;li&gt;辅助信号newest_entry_ptr_modified被指定为true&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-由ifu的写回信号修改ftq状态&#34;&gt;2. 由IFU的写回信号修改FTQ状态&lt;/h3&gt;&#xA;&lt;p&gt;IFU既然也能和后端一样生成重定向信息，那么他也能在产生重定向信息的时候修改这些状态队列和FTQ最新项，区别：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;但是，由于IFU没有真的执行，所以它的预译码结果并不能作为决定指令块是不是真的被错误预测了，所以它不能修改mispredict_vec的状态&lt;/li&gt;&#xA;&lt;li&gt;其次，后端重定向优先级永远高于IFU重定向，两者同时发生时只采用后端重定向。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;所以这个部分也有以下测试点：&lt;/p&gt;&#xA;&lt;h4 id=&#34;211-修改cfiindex_vec&#34;&gt;2.1.1 修改cfiIndex_vec&lt;/h4&gt;&#xA;&lt;h4 id=&#34;212-修改update_target&#34;&gt;2.1.2 修改update_target&lt;/h4&gt;&#xA;&lt;h4 id=&#34;22-修改ftq最新项&#34;&gt;2.2 修改FTQ最新项&lt;/h4&gt;&#xA;&lt;h2 id=&#34;常量说明&#34;&gt;常量说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;常量名&lt;/th&gt;&#xA;          &lt;th&gt;常量值&lt;/th&gt;&#xA;          &lt;th&gt;解释&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;常量1&lt;/td&gt;&#xA;          &lt;td&gt;64&lt;/td&gt;&#xA;          &lt;td&gt;常量1解释&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;常量2&lt;/td&gt;&#xA;          &lt;td&gt;8&lt;/td&gt;&#xA;          &lt;td&gt;常量2解释&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;常量3&lt;/td&gt;&#xA;          &lt;td&gt;16&lt;/td&gt;&#xA;          &lt;td&gt;常量3解释&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;顶层IO&lt;/th&gt;&#xA;          &lt;th&gt;子接口&lt;/th&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;fromBackend&lt;/td&gt;&#xA;          &lt;td&gt;redirect&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;测试点总表&#34;&gt;测试点总表&lt;/h2&gt;&#xA;&lt;p&gt;实际使用下面的表格时，请用有意义的英文大写的功能名称和测试点名称替换下面表格中的名称&lt;/p&gt;</description>
    </item>
    <item>
      <title>冲刷指针和状态队列</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/10_flushptrandstatequeue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/10_flushptrandstatequeue/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;之前讲了，后端和IFU重定向写回会修改一些状态队列。此外，FtqPtr也是一种比较重要的维护信息。由后端或者IFU引起的重定向，需要恢复各种类型用来索引FTQ项的FtqPtr。而当重定向是由后端发起的时候，还要修改提交状态队列，说明指令已经被执行。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;FTQ指针&lt;/td&gt;&#xA;          &lt;td&gt;用来索引FTQ项，有不同类型的FTQ指针，比如bpuPtr，ifuPtr&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;flush&lt;/td&gt;&#xA;          &lt;td&gt;冲刷，发生时需要重置FTQ指针，以及重置其他状态&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;融合指令&lt;/td&gt;&#xA;          &lt;td&gt;一条指令可以和其他指令融合，形成融合指令&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-冲刷ftq指针及提交状态队列&#34;&gt;1. 冲刷FTQ指针及提交状态队列&lt;/h3&gt;&#xA;&lt;h4 id=&#34;流程&#34;&gt;流程&lt;/h4&gt;&#xA;&lt;p&gt;后端和IFU的重定向信号都会冲刷指针，更具体的来说：&lt;/p&gt;&#xA;&lt;h4 id=&#34;11-冲刷条件&#34;&gt;1.1 冲刷条件&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;后端写回接口fromBackend有效，或者IFU重定向有效：（当预译码写回pdWb有效，且pdWb的missOffset字段有效表明存在预测错误的指令，同时后端冲刷信号backendFlush无效）。（参考：从IFU重定向的第一个周期，重定向valid值有效条件）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;12-冲刷指针&#34;&gt;1.2 冲刷指针&lt;/h4&gt;&#xA;&lt;p&gt;第一个周期：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;冲刷指针：确认后端和IFU的重定向信号可能冲刷指针时，从两个重定向来源的redirect接口读出重定向信息，包括ftqIdx，ftqOffset，重定向等级RedirectLevel。有两个来源时，优先后端的重定向信息。&#xA;冲刷指针列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;bpuPtr：ftqIdx+1&lt;/li&gt;&#xA;&lt;li&gt;ifuPtr：ftqIdx+1&lt;/li&gt;&#xA;&lt;li&gt;ifuWbPtr：ftqIdx+1&lt;/li&gt;&#xA;&lt;li&gt;pfPtr：ftqIdx+1&#xA;&lt;em&gt;注：只是在当前周期向指针寄存器写入更新信息，实际生效是在下一个周期。&lt;/em&gt;&#xA;这样一来，所有类型指针当前指向的都是发生重定向的指令块的下一项了，我们从这一项开始重新进行分支预测，预译码，等等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;13-冲刷提交状态队列&#34;&gt;1.3 冲刷提交状态队列&lt;/h4&gt;&#xA;&lt;p&gt;第二个周期：&#xA;如果上一个周期的重定向来源是后端，FTQ会进一步更改提交状态队列&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提交状态队列中，对于重定向的指令块（通过ftqIdx索引），位于ftqOffset后面的指令的状态被设置为c_empty&lt;/li&gt;&#xA;&lt;li&gt;对于正好处于ftqOffset的指令，判断RedirectLevel，低表示在本位置后flush，高表示在本位置flush，所以level为高时，对于的指令提交状态被设置为flush。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-转发到顶层io&#34;&gt;2 转发到顶层IO&lt;/h3&gt;&#xA;&lt;p&gt;实际上，在发生重定向的时候，还涉及一些将重定向信息通过FTQ顶层IO接口转发给其他模块的操作，比如ICache需要flush信号取进行冲刷，IFU也需要后端的重定向信号对它进行重定向，具体来说：&#xA;在&lt;strong&gt;流程&lt;/strong&gt;的第一个周期：&lt;/p&gt;&#xA;&lt;h4 id=&#34;21-flush转发到icacheflush&#34;&gt;2.1 flush转发到icacheFlush&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;flush信号顶层IO转发（icacheFlush）：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;确认后端和IFU的重定向信号可能冲刷指针时，拉高FTQ顶层IO接口中的icacheFlush信号，把重定向产生的flush信号转发给ICache&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;22-重定向信号转发到ifu&#34;&gt;2.2 重定向信号转发到IFU&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重定向信号顶层IO转发（toIFU）：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;redirect：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;bits：接收来自后端的重定向信号&lt;/li&gt;&#xA;&lt;li&gt;valid：后端的重定向信号有效时有效，保持有效，直到下个周期依然有效&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;3-重排序缓冲区提交&#34;&gt;3 重排序缓冲区提交&lt;/h3&gt;&#xA;&lt;p&gt;其实，除了后端重定向会更新提交状态队列，最直接的更新提交状态队列的方式是通过FTQ顶层IO中frombackend里提供的提交信息，rob_commits告知我们哪些指令需要被提交。&lt;/p&gt;&#xA;&lt;p&gt;rob_commits的valid字段有效，可以根据其中信息对指令进行提交，修改状态队列。对于被执行的指令，是如何提交的，如何对应地修改提交状态队列，有两种情况：&lt;/p&gt;&#xA;&lt;h4 id=&#34;31-提交普通指令&#34;&gt;3.1 提交普通指令&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于普通指令，根据rob_commits的ftqIdx和ftqOffset索引提交状态队列中的某条指令，将对应的提交状态设置为c_commited&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;32-提交融合指令&#34;&gt;3.2 提交融合指令&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于融合指令，根据提交类型commitType对被索引的指令和另一与之融合的指令进行提交，将对应的提交状态设置为c_commited&#xA;&lt;ol&gt;&#xA;&lt;li&gt;commitType = 4：同时把被索引指令的下一条指令设为c_commited&lt;/li&gt;&#xA;&lt;li&gt;commitType = 5：同时把被索引指令的之后的第二条指令设为c_commited&lt;/li&gt;&#xA;&lt;li&gt;commitType = 6：同时把被指令块的下一个指令块的第0条指令设为c_commited&lt;/li&gt;&#xA;&lt;li&gt;commitType = 7：同时把被指令块的下一个指令块的第1条指令设为c_commited&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;顶层IO&lt;/th&gt;&#xA;          &lt;th&gt;作用&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;fromBackend&lt;/td&gt;&#xA;          &lt;td&gt;接收后端重定向和指令提交&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;fromIfu&lt;/td&gt;&#xA;          &lt;td&gt;接收IFU重定向&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;icacheFlush&lt;/td&gt;&#xA;          &lt;td&gt;将flush信号转发到icache&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;toIFU&lt;/td&gt;&#xA;          &lt;td&gt;将后端重定向转发到IFU&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;测试点总表&#34;&gt;测试点总表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;功能名称&lt;/th&gt;&#xA;          &lt;th&gt;测试点名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;          &lt;td&gt;FLUSH_FTQPTR_AND_COMMITSTATE&lt;/td&gt;&#xA;          &lt;td&gt;FLUSH_COND&lt;/td&gt;&#xA;          &lt;td&gt;后端写回接口fromBackend有效，或者IFU重定向有效时，进行冲刷&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.2&lt;/td&gt;&#xA;          &lt;td&gt;FLUSH_FTQPTR_AND_COMMITSTATE&lt;/td&gt;&#xA;          &lt;td&gt;FLUSH_FTQ_PTR&lt;/td&gt;&#xA;          &lt;td&gt;优先采用后端重定向信息冲刷FTQ指针&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.3&lt;/td&gt;&#xA;          &lt;td&gt;FLUSH_FTQPTR_AND_COMMITSTATE&lt;/td&gt;&#xA;          &lt;td&gt;FLUSH_COMMIT_STATE&lt;/td&gt;&#xA;          &lt;td&gt;发生后端重定向时，进一步修改提交状态队列&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.1&lt;/td&gt;&#xA;          &lt;td&gt;TRANSFER_TO_TOP&lt;/td&gt;&#xA;          &lt;td&gt;FLUSH&lt;/td&gt;&#xA;          &lt;td&gt;后端和IFU的重定向信号可能冲刷指针，拉高FTQ顶层IO接口中的icacheFlush信号&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.2&lt;/td&gt;&#xA;          &lt;td&gt;TRANSFER_TO_TOP&lt;/td&gt;&#xA;          &lt;td&gt;IFU&lt;/td&gt;&#xA;          &lt;td&gt;将重定向信号转发到IFU&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.1&lt;/td&gt;&#xA;          &lt;td&gt;COMMIT_BY_ROB&lt;/td&gt;&#xA;          &lt;td&gt;NORMAL&lt;/td&gt;&#xA;          &lt;td&gt;对于普通指令，根据rob_commits的ftqIdx和ftqOffset索引提交状态队列中的某条指令，将对应的提交状态设置为c_commited&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3.2&lt;/td&gt;&#xA;          &lt;td&gt;COMMIT_BY_ROB&lt;/td&gt;&#xA;          &lt;td&gt;FUSION&lt;/td&gt;&#xA;          &lt;td&gt;对于融合指令，根据提交类型commitType对被索引的指令和另一与之融合的指令进行提交，将对应的提交状态设置为c_commited&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>FTQ向BPU发送更新与重定向信息</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/11_tobpu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/03_ftq/11_tobpu/</guid>
      <description>&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;FTQ将已提交指令的更新信息发往BPU进行训练，同时转发重定向信息。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;暂无&lt;/td&gt;&#xA;          &lt;td&gt;暂无&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-转发重定向&#34;&gt;1. 转发重定向&lt;/h3&gt;&#xA;&lt;p&gt;向toBPU接口进行转发：&lt;/p&gt;&#xA;&lt;h4 id=&#34;11-ifu重定向结果有效&#34;&gt;1.1 IFU重定向结果有效&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;redirctFromIFU：IFU重定向结果有效时，拉高该信号（注意：IFU重定向有效的时机有两种说法，因为IFU重定向结果生成需要两个周期，此处取后者，即，IFU重定向生成过程的第二个周期有效，也是IFU生成完整重定向结果的周期）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;12-选择后端重定向或者ifu重定向&#34;&gt;1.2 选择后端重定向或者IFU重定向&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;redirect：如果后端重定向结果fromBackendRedirect有效，选用fromBackendRedirect，否则选用IFU重定向结果ifuRedirectToBpu&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-bpu更新暂停&#34;&gt;2 BPU更新暂停&lt;/h3&gt;&#xA;&lt;p&gt;BPU的更新需要两个周期，故需要三种状态去表明我们当前的更新状态：更新的第一个周期，第二个周期，更新完成。&#xA;当发生更新的时候，会暂停FTQ对指令块的提交以及发送更新信息。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-提交指令块&#34;&gt;3 提交指令块&lt;/h3&gt;&#xA;&lt;p&gt;FTQ需要对当前comPtr指向的当前提交指令块，进行判断是否能够提交。&#xA;这个过程比较复杂。&#xA;由于 香山V2版本 的后端会在 ROB 中重新压缩 FTQ entry，因此并不能保证提交一个 entry 中的每条指令，甚至不能保证每一个 entry 都有指令提交。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;判断一个 entry 是否被提交有如下几种可能&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;robCommPtr 在 commPtr 之后（ptr更大）。也就是说，后端已经开始提交之后 entry 的指令，在 robCommPtr 指向的 entry 之前的 entry 一定都已经提交完成&lt;/li&gt;&#xA;&lt;li&gt;commitStateQueue 中的某个指令块内最后一条有效范围内指令被提交。FTQ项中该指令被提交意味着这FTQ项内的指令已经全部被提交&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在此以外，还必须要考虑到，后端存在 flush itself 的 redirect 请求，这意味着这条指令自身也需要重新执行，这包括异常、load replay 等情况。在这种情况下，这一FTQ项不应当被提交以更新 BPU，否则会导致 BPU 准确率显著下降。&lt;/p&gt;&#xA;&lt;h4 id=&#34;31-cancommit&#34;&gt;3.1 canCommit&lt;/h4&gt;&#xA;&lt;p&gt;具体来看，判断commPtr指向的指令块能否提交，如果可以提交记为canCommit。&lt;/p&gt;&#xA;&lt;p&gt;canCommit的设置条件如下：&lt;/p&gt;&#xA;&lt;h4 id=&#34;311-cond1&#34;&gt;3.1.1 COND1&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当commPtr不等于ifuWbPtr，且没有因为BPU更新而暂停，同时robCommPtr在commPtr之后。之所以要求commPtr不等于ifuWbPtr是因为，前面说过了必须先预译码写回FTQ项才能提交&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;312-cond2&#34;&gt;3.1.2 COND2&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;commitStateQueue 中commPtr对应指令块有指令处于c_toCommit 或c_committed状态。且指令块中最后一条处于c_toCommit 或c_committed状态的指令是c_committed的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这两种情况下，canCommit拉高，说明可以提交该指令块&lt;/p&gt;</description>
    </item>
    <item>
      <title>CtrlUnit</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/05_ctrlunit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/05_ctrlunit/</guid>
      <description>&lt;div class=&#34;icache-ctx&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;ctrlunit&#34;&gt;CtrlUnit&lt;/h2&gt;&#xA;&lt;p&gt;目前 CtrlUnit 主要负责 ECC 校验使能/错误注入等功能。&#xA;RegField 案例类和伴生对象的作用，RegReadFn 和 RegWriteFn 案例类和伴生对象的作用。&lt;/p&gt;&#xA;&lt;p&gt;通过两个控制寄存器 CSR：eccctrl 和 ecciaddr，来实现错误注入。&#xA;在 eccctrlBundle 中，定义 eccctrl 的 ierror、istatus、itarget、inject、enable 域的初始值。&#xA;在 ecciaddrBundle 中，定义 ecciaddr 的 paddr 域的初始值。&lt;/p&gt;&#xA;&lt;h3 id=&#34;mmio-mapped-csr&#34;&gt;mmio-mapped CSR&lt;/h3&gt;&#xA;&lt;p&gt;CtrlUnit 内实现了一组 mmio-mapped CSR，连接在 tilelink 总线上，地址可由参数 &lt;code&gt;cacheCtrlAddressOpt&lt;/code&gt; 配置，默认地址为&lt;code&gt;0x38022080&lt;/code&gt;。总大小为 128B。&lt;/p&gt;&#xA;&lt;p&gt;当参数 &lt;code&gt;cacheCtrlAddressOpt&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; 时，CtrlUnit &lt;strong&gt;不会实例化&lt;/strong&gt;。此时 ECC 校验使能&lt;strong&gt;默认开启&lt;/strong&gt;，软件不可控制关闭；软件不可控制错误注入。&lt;/p&gt;&#xA;&lt;p&gt;目前实现的 CSR 如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              64     10        7         4         2        1        0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x00 eccctrl   | WARL | ierror | istatus | itarget | inject | enable |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              64 PAddrBits-1               0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;0x08 ecciaddr  | WARL |       paddr        |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;CSR&lt;/th&gt;&#xA;          &lt;th&gt;field&lt;/th&gt;&#xA;          &lt;th&gt;desp&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;eccctrl&lt;/td&gt;&#xA;          &lt;td&gt;enable&lt;/td&gt;&#xA;          &lt;td&gt;ECC 错误校验使能，原 sfetchctl(0) 。 &lt;br&gt;注：即使不使能，在 icache 重填时仍会计算 parity，可能会有额外功耗；但如果不计算，则在未使能转换成使能时需要冲刷 icache（否则读出的 parity 有 50%概率是错的）。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;eccctrl&lt;/td&gt;&#xA;          &lt;td&gt;inject&lt;/td&gt;&#xA;          &lt;td&gt;ECC 错误注入使能，写 1 即使能，读恒 0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;eccctrl&lt;/td&gt;&#xA;          &lt;td&gt;itarget&lt;/td&gt;&#xA;          &lt;td&gt;ECC 错误注入目标 &lt;br&gt;0: metaArray&lt;br&gt;1: rsvd&lt;br&gt;2: dataArray&lt;br&gt;3: rsvd&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;eccctrl&lt;/td&gt;&#xA;          &lt;td&gt;istatus&lt;/td&gt;&#xA;          &lt;td&gt;ECC 错误注入状态（read-only）&lt;br&gt;0: idle：注入控制器闲置&lt;br&gt;1: working：收到注入请求，注入中&lt;br&gt;2: injected：注入完成，等待触发&lt;br&gt;3: rsvd&lt;br&gt;4: rsvd&lt;br&gt;5: rsvd&lt;br&gt;6: rsvd&lt;br&gt;7: error：注入出错&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;eccctrl&lt;/td&gt;&#xA;          &lt;td&gt;ierror&lt;/td&gt;&#xA;          &lt;td&gt;ECC 错误原因（read-only）&lt;br&gt;0: ECC 未使能 (i.e. !eccctrl.enable) &lt;br&gt;1: inject 目标 SRAM 无效 (i.e. eccctrl.itarget==rsvd) &lt;br&gt;2: inject 目标地址 (i.e. ecciaddr.paddr) 不在 ICache 中&lt;br&gt;3: rsvd &lt;br&gt;4: rsvd &lt;br&gt;5: rsvd &lt;br&gt;6: rsvd &lt;br&gt;7: rsvd&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ecciaddr&lt;/td&gt;&#xA;          &lt;td&gt;paddr&lt;/td&gt;&#xA;          &lt;td&gt;ECC 错误注入物理地址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;RERI standard&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;RERI 手册还要求了错误计数等寄存器，用于软件获取 RAS controller 状态，参考手册，可能需要与 dcache、L2cache 统一在后端实现，icache 像现在给 BEU 送 error 一样送给后端。&lt;br&gt;即：暂时不需要在 icache 实现，但要把错误计数等机制所需的接口准备出来&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;错误校验使能&#34;&gt;错误校验使能&lt;/h3&gt;&#xA;&lt;p&gt;CtrlUnit 的 &lt;code&gt;eccctrl.enable&lt;/code&gt; 位直接连接到 MainPipe，控制 ECC 校验使能。当该位为 0 时，ICache 不会进行 ECC 校验。但仍会在重填时计算校验码并存储，这可能会有少量的额外功耗；如果不计算，则在未使能转换成使能时需要冲刷 ICache（否则读出的 parity code 可能是错的）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>F3PreDecoder</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/02_f3predecoder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/02_f3predecoder/</guid>
      <description>&lt;div class=&#34;ifu-ctx&#34;&gt;&#xA;&lt;h1 id=&#34;子模块f3predecoder模块简介&#34;&gt;子模块：F3PreDecoder模块简介&lt;/h1&gt;&#xA;&lt;p&gt;这个模块是从PreDecoder中时序优化出来的，负责判定CFI指令的类型&lt;/p&gt;&#xA;&lt;h2 id=&#34;f3predecoder功能介绍&#34;&gt;F3PreDecoder功能介绍&lt;/h2&gt;&#xA;&lt;h3 id=&#34;cfi指令类型判定&#34;&gt;CFI指令类型判定&lt;/h3&gt;&#xA;&lt;p&gt;要想确定CFI指令类型，只需要分别尝试匹配JAL、JALR、BR和他们的RVC版本即可，注意，RVC的EBREAK&#xA;不应该被视为CFI指令。在匹配的过程中，自然CFI指令的类型就被甄别出来了。在这一步中，我们将所有指令分到如下四类brType中：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;CFI指令类型&lt;/th&gt;&#xA;          &lt;th&gt;brType类型编码&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;非CFI&lt;/td&gt;&#xA;          &lt;td&gt;00&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;branch指令&lt;/td&gt;&#xA;          &lt;td&gt;01&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;jal指令&lt;/td&gt;&#xA;          &lt;td&gt;10&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;jalr指令&lt;/td&gt;&#xA;          &lt;td&gt;11&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;retcall判定&#34;&gt;ret、call判定&lt;/h3&gt;&#xA;&lt;p&gt;然后，我们需要判断是否为call或者ret，这可以通过rd和rs的取值来考察，具体来说，RISCV的RVI指令中，提供了对rd和rs取值的约定，&#xA;当二者取到link寄存器的序号（x1为标准的返回地址寄存器，x5为备用的link寄存器），分别对应着压栈和弹栈。详细的对应情况如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;linkjal.png&#34; alt=&#34;links&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;f3predecoder接口说明&#34;&gt;F3Predecoder接口说明&lt;/h2&gt;&#xA;&lt;p&gt;in_instr: 传递 16 x 4B的拼接指令码&lt;/p&gt;&#xA;&lt;p&gt;out_pd：每条指令的预译码信息，在F3Predecoder分析得到的是brType、isCall和isRet&lt;/p&gt;&#xA;&lt;h2 id=&#34;f3predecoder子模块测试点和功能点&#34;&gt;F3PreDecoder子模块测试点和功能点&lt;/h2&gt;&#xA;&lt;h3 id=&#34;功能点1-cfi指令类型判定&#34;&gt;功能点1 CFI指令类型判定&lt;/h3&gt;&#xA;&lt;p&gt;要想确定CFI指令类型，只需要分别尝试匹配JAL、JALR、BR和他们的RVC版本即可，注意，RVC的EBREAK&#xA;不应该被视为CFI指令。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;          &lt;td&gt;非CFI判定&lt;/td&gt;&#xA;          &lt;td&gt;对传入的非CFI指令（包括RVC.EBREAK），应该判定为类型0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.2&lt;/td&gt;&#xA;          &lt;td&gt;BR判定&lt;/td&gt;&#xA;          &lt;td&gt;对传入的BR指令，应该判定为类型1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.3&lt;/td&gt;&#xA;          &lt;td&gt;JAL判定&lt;/td&gt;&#xA;          &lt;td&gt;对传入的JAL指令，应该判定为类型2&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.4&lt;/td&gt;&#xA;          &lt;td&gt;JALR判定&lt;/td&gt;&#xA;          &lt;td&gt;对传入的JALR指令，应该判定为类型3&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;功能点2-retcall判定&#34;&gt;功能点2 ret、call判定&lt;/h3&gt;&#xA;&lt;p&gt;然后，需要判断是否为call或者ret，这可以通过rd和rs的取值来考察。当然，首先必须得满足无条件跳转指令。&lt;/p&gt;&#xA;&lt;p&gt;对于类型2，只有不为RVC指令且目的寄存器rd为link寄存器（x1或x5）时，才为Call。&lt;/p&gt;&#xA;&lt;p&gt;对于类型3，在RVI指令下，当rd为link寄存器时，必为Call。当rs为link寄存器且rd不为时，必为Ret。&#xA;在RVC指令下，对C.JALR指令，为call，对C.JR指令，当rs1为link时，为Ret&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.1&lt;/td&gt;&#xA;          &lt;td&gt;非CFI和BR不判定&lt;/td&gt;&#xA;          &lt;td&gt;对传入的非CFI和BR指令，都不应判定为call或者ret&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.2.1.1&lt;/td&gt;&#xA;          &lt;td&gt;RVI.JAL判定call&lt;/td&gt;&#xA;          &lt;td&gt;对传入的RVI.JAL指令，当rd设置为1或5，应当判定该指令为call&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.2.1.2&lt;/td&gt;&#xA;          &lt;td&gt;RVI.JAL例外&lt;/td&gt;&#xA;          &lt;td&gt;对传入的RVI.JAL指令，当rd设置为1和5之外的值，不应当判定该指令为call或ret&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.2.2&lt;/td&gt;&#xA;          &lt;td&gt;RVC.JAL不判定&lt;/td&gt;&#xA;          &lt;td&gt;对传入的RVC.JAL指令，无论什么情况都不能判定为call或ret&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.3.1.1&lt;/td&gt;&#xA;          &lt;td&gt;RVI.JALR和rd为link&lt;/td&gt;&#xA;          &lt;td&gt;传入RVI.JALR指令，并且rd为1或5，无论其他取值，都应判定为call&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.3.1.2&lt;/td&gt;&#xA;          &lt;td&gt;RVI.JALR且仅rs为link&lt;/td&gt;&#xA;          &lt;td&gt;传入RVI.JALR指令，rd不为1和5，rs为1或5，应判定为ret&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.3.1.3&lt;/td&gt;&#xA;          &lt;td&gt;RVI.JALR无link&lt;/td&gt;&#xA;          &lt;td&gt;对传入的JALR指令，若rd和rs均不为link，则不应判定为ret和cal&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.3.2.1&lt;/td&gt;&#xA;          &lt;td&gt;RVC.JALR为Ret&lt;/td&gt;&#xA;          &lt;td&gt;传入RVC.JALR指令，必定为call&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.3.2.2.1&lt;/td&gt;&#xA;          &lt;td&gt;RVC.JR且rs为link&lt;/td&gt;&#xA;          &lt;td&gt;传入RVC.JR指令，rs为1或5，应判定为ret&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.3.2.2.2&lt;/td&gt;&#xA;          &lt;td&gt;RVC.JR且rs不为link&lt;/td&gt;&#xA;          &lt;td&gt;传入RVC.JR指令，rs不为1或5，不应判定为ret&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;测试点汇总&#34;&gt;测试点汇总&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;功能&lt;/th&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;          &lt;td&gt;CFI指令类型判定&lt;/td&gt;&#xA;          &lt;td&gt;非CFI判定&lt;/td&gt;&#xA;          &lt;td&gt;对传入的非CFI指令（包括RVC.EBREAK），应该判定为类型0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.2&lt;/td&gt;&#xA;          &lt;td&gt;CFI指令类型判定&lt;/td&gt;&#xA;          &lt;td&gt;BR判定&lt;/td&gt;&#xA;          &lt;td&gt;对传入的BR指令，应该判定为类型1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.3&lt;/td&gt;&#xA;          &lt;td&gt;CFI指令类型判定&lt;/td&gt;&#xA;          &lt;td&gt;JAL判定&lt;/td&gt;&#xA;          &lt;td&gt;对传入的JAL指令，应该判定为类型2&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.4&lt;/td&gt;&#xA;          &lt;td&gt;CFI指令类型判定&lt;/td&gt;&#xA;          &lt;td&gt;JALR判定&lt;/td&gt;&#xA;          &lt;td&gt;对传入的JALR指令，应该判定为类型3&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.1&lt;/td&gt;&#xA;          &lt;td&gt;ret、call判定&lt;/td&gt;&#xA;          &lt;td&gt;非CFI和BR不判定&lt;/td&gt;&#xA;          &lt;td&gt;对传入的非CFI和BR指令，都不应判定为call或者ret&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.2.1.1&lt;/td&gt;&#xA;          &lt;td&gt;ret、call判定&lt;/td&gt;&#xA;          &lt;td&gt;RVI.JAL判定call&lt;/td&gt;&#xA;          &lt;td&gt;对传入的RVC.JAL指令，当rd设置为1或5，应当判定该指令为call&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.2.1.2&lt;/td&gt;&#xA;          &lt;td&gt;ret、call判定&lt;/td&gt;&#xA;          &lt;td&gt;RVI.JAL例外&lt;/td&gt;&#xA;          &lt;td&gt;对传入的RVC.JAL指令，当rd设置为1和5之外的值，不应当判定该指令为call或ret&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.2.2&lt;/td&gt;&#xA;          &lt;td&gt;ret、call判定&lt;/td&gt;&#xA;          &lt;td&gt;RVC.JAL不判定&lt;/td&gt;&#xA;          &lt;td&gt;对传入的RVI.JAL指令，无论什么情况都不能判定为call或ret&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.3.1.1&lt;/td&gt;&#xA;          &lt;td&gt;ret、call判定&lt;/td&gt;&#xA;          &lt;td&gt;RVI.JALR和rd为link&lt;/td&gt;&#xA;          &lt;td&gt;传入RVI.JALR指令，并且rd为1或5，无论其他取值，都应判定为call&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.3.1.2&lt;/td&gt;&#xA;          &lt;td&gt;ret、call判定&lt;/td&gt;&#xA;          &lt;td&gt;RVI.JALR且仅rs为link&lt;/td&gt;&#xA;          &lt;td&gt;传入RVI.JALR指令，rd不为1和5，rs为1或5，应判定为ret&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.3.1.3&lt;/td&gt;&#xA;          &lt;td&gt;ret、call判定&lt;/td&gt;&#xA;          &lt;td&gt;RVI.JALR无link&lt;/td&gt;&#xA;          &lt;td&gt;对传入的JALR指令，若rd和rs均不为link，则不应判定为ret和cal&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.3.2.1&lt;/td&gt;&#xA;          &lt;td&gt;ret、call判定&lt;/td&gt;&#xA;          &lt;td&gt;RVC.JALR为Ret&lt;/td&gt;&#xA;          &lt;td&gt;传入RVC.JALR指令，必定为call&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.3.2.2.1&lt;/td&gt;&#xA;          &lt;td&gt;ret、call判定&lt;/td&gt;&#xA;          &lt;td&gt;RVC.JR且rs为link&lt;/td&gt;&#xA;          &lt;td&gt;传入RVC.JR指令，rs为1或5，应判定为ret&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.3.2.2.2&lt;/td&gt;&#xA;          &lt;td&gt;ret、call判定&lt;/td&gt;&#xA;          &lt;td&gt;RVC.JR且rs不为link&lt;/td&gt;&#xA;          &lt;td&gt;传入RVC.JR指令，rs不为1或5，不应判定为ret&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>FrontendTrigger</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/05_frontend_trigger/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/05_frontend_trigger/</guid>
      <description>&lt;div class=&#34;ifu-ctx&#34;&gt;&#xA;&lt;h1 id=&#34;frontendtrigger子模块&#34;&gt;FrontendTrigger子模块&lt;/h1&gt;&#xA;&lt;p&gt;该子模块的主要作用是在前端设置硬件断点和检查。&lt;/p&gt;&#xA;&lt;p&gt;该模块的输入pc有一个隐含条件，那就是这个pc是通过ftq传递的startAddr计算出来的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;frontendtrigger功能介绍&#34;&gt;FrontendTrigger功能介绍&lt;/h2&gt;&#xA;&lt;h3 id=&#34;断点设置和断点检查&#34;&gt;断点设置和断点检查&lt;/h3&gt;&#xA;&lt;p&gt;在IFU的FrontendTrigger模块里共4个Trigger，编号为0,1,2,3，每个Trigger的配置信息（断点类型、匹配地址等）保存在tdata寄存器中。&lt;/p&gt;&#xA;&lt;p&gt;当软件向CSR寄存器&lt;code&gt;tselect&lt;/code&gt;、&lt;code&gt;tdata1/2&lt;/code&gt;写入特定的值时，CSR会向IFU发送tUpdate请求，更新FrontendTrigger内的&lt;code&gt;tdata&lt;/code&gt;寄存器中的配置信息。&#xA;目前前端的Trigger仅可以配置成PC断点&lt;code&gt;mcontrol.tdata1&lt;/code&gt;寄存器的select位为0；当select=1时，该Trigger将永远不会命中，且不会产生异常）。&lt;/p&gt;&#xA;&lt;p&gt;在取指时，IFU的F3流水级会向FrontendTrigger模块发起查询并在同一周期得到结果。后者会对取指块内每一条指令在每一个Trigger上做检查，&#xA;当指令的PC和&lt;code&gt;tdata2&lt;/code&gt;寄存器内容的关系满足&lt;code&gt;mcontrol.match&lt;/code&gt;位所指示的关系（香山支持match位为0、2、3，对应等于、大于等于、小于）时，&#xA;该指令会被标记为Trigger命中，随着执行在后端产生断点异常，进入M-Mode或调试模式。&lt;/p&gt;&#xA;&lt;h3 id=&#34;链式断点&#34;&gt;链式断点&lt;/h3&gt;&#xA;&lt;p&gt;根据RISCV的debug spec，香山实现的是mcontrol6。&lt;/p&gt;&#xA;&lt;p&gt;当它们对应的Chain位被置时，只有当该Trigger和编号在它后面一位的Trigger同时命中，&lt;del&gt;且timing配置相同时&lt;/del&gt;（在最新的手册中，这一要求已被删除），处理器才会产生异常。&lt;/p&gt;&#xA;&lt;p&gt;在过去（riscv-debug-spec-draft，对应 XiangShan 2024.10.05 合入的 &lt;a href=&#34;https://github.com/OpenXiangShan/XiangShan/pull/3693&#34;&gt;PR#3693&lt;/a&gt; 前）的版本中，Chain 还需要满足两个 Trigger 的 &lt;code&gt;mcontrol.timing&lt;/code&gt; 是相同的。而在新版（riscv-debug-spec-v1.0.0）中，&lt;code&gt;mcontrol.timing&lt;/code&gt; 被移除。目前 XiangShan 的 scala 实现仍保留了这一位，但其值永远为 0 且不可写入，编译生成的 verilog 代码中没有这一位。&lt;/p&gt;&#xA;&lt;h2 id=&#34;frontendtrigger-接口说明&#34;&gt;FrontendTrigger 接口说明&lt;/h2&gt;&#xA;&lt;p&gt;设计上并没有提供一个或一组对外的接口来查询某个断点的状态，因此，要在测试中检查断点状态，要么需要检查内部信号的情况（仓库中提供的构建脚本已经暴露了所有内部信号），要么通过具体执行过程中，断点的触发情况来判定。&lt;/p&gt;&#xA;&lt;h3 id=&#34;输入接口&#34;&gt;输入接口&lt;/h3&gt;&#xA;&lt;p&gt;主要分为控制接口和执行信息（目前执行信息只有pc）&lt;/p&gt;&#xA;&lt;h4 id=&#34;控制接口-io_frontendtrigger&#34;&gt;控制接口 io_frontendTrigger&lt;/h4&gt;&#xA;&lt;p&gt;本接口存储了frontendTrigger的控制信息，包含以下信号/信号组：&lt;/p&gt;&#xA;&lt;h5 id=&#34;debugmode&#34;&gt;debugMode&lt;/h5&gt;&#xA;&lt;p&gt;当前是否处于debug模式下&lt;/p&gt;&#xA;&lt;h5 id=&#34;tenablevec&#34;&gt;tEnableVec&lt;/h5&gt;&#xA;&lt;p&gt;对FrontendTrigger的每个断点，指示其是否有效。&lt;/p&gt;&#xA;&lt;h5 id=&#34;tupdate&#34;&gt;tUpdate&lt;/h5&gt;&#xA;&lt;p&gt;更新断点的控制信息，包含以下信号/信号组：&lt;/p&gt;&#xA;&lt;p&gt;valid：此次更新是否有效/是否更新。&lt;/p&gt;&#xA;&lt;p&gt;bits_addr：此次更新的是哪个断点（0~3）&lt;/p&gt;&#xA;&lt;p&gt;bits_tdata_action：断点触发条件达成后的行为&lt;/p&gt;&#xA;&lt;p&gt;bits_tdata_chain：断点是否链式传导&lt;/p&gt;&#xA;&lt;p&gt;bits_tdata_matchType：断点匹配类型（等于、大于、小于三种）&lt;/p&gt;&#xA;&lt;p&gt;bits_tdata_select：目前为止，select为0时为pc断点&lt;/p&gt;&#xA;&lt;p&gt;bits_tdata_tdata2：用于和PC比较的基准值&lt;/p&gt;&#xA;&lt;h5 id=&#34;triggercanraisebpexp&#34;&gt;triggerCanRaiseBpExp&lt;/h5&gt;&#xA;&lt;p&gt;trigger是否可以引起异常&lt;/p&gt;&#xA;&lt;h4 id=&#34;pc&#34;&gt;pc&lt;/h4&gt;&#xA;&lt;p&gt;pc有一个隐含条件，就是16条指令的pc必定是连续的&lt;/p&gt;&#xA;&lt;h3 id=&#34;输出接口&#34;&gt;输出接口&lt;/h3&gt;&#xA;&lt;p&gt;triggered：16条指令的断点触发情况。&lt;/p&gt;&#xA;&lt;h2 id=&#34;frontendtrigger-测试点和功能点&#34;&gt;FrontEndTrigger 测试点和功能点&lt;/h2&gt;&#xA;&lt;h3 id=&#34;功能点1-设置断点和断点检查&#34;&gt;功能点1 设置断点和断点检查&lt;/h3&gt;&#xA;&lt;p&gt;FrontEndTrigger目前仅支持设置PC断点，这通过设置断点的tdata1寄存器的select位为0实现。&#xA;同时，tdata2寄存器的mcontrol位负责设置指令PC和tdata2寄存器的地址需要满足的关系，&#xA;关系满足时，该指令会被标记为trigger命中。&lt;/p&gt;&#xA;&lt;p&gt;所以，基于以上功能描述，我们需要测试：&lt;/p&gt;&#xA;&lt;p&gt;select位为1时，断点是否永远不会触发。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ICache</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/06_icache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/06_icache/</guid>
      <description>&lt;div class=&#34;icache-ctx&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;icache&#34;&gt;ICache&lt;/h2&gt;&#xA;&lt;p&gt;各种组合数据的宽度以 system verilog/verilog 中的为准。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IPrefetchPipe 接收来自 FTQ 的预取请求，然后向 MetaArray 和 ITLB 发送请求，再从 ITLB 的响应得到 paddr，之后与 MetaArray 返回的 tag 进行比较得到命中信息，把命中信息、MetaArray ECC 校验信息和 ITLB 信息一并写入 WayLookup，同时进行 PMP 检查。未命中就将信息发送给 MissUnit 处理，MissUnit 通过 TileLink 总线向 L2Cache 发起请求，获取数据后返回给 MetaArray 和 IPrefetchPipe。之后会判断是否 Miss，如果 Miss 则把预取请求发送到 MissUnit，它会通过 TileLink 向 L2 做预取指。&lt;/li&gt;&#xA;&lt;li&gt;MainPipe 接收来自 FTQ 的取指请求，然后从 WayLookup 获取路命中信息和 ITLB 查询结果，再访问 DataArray。命中后向 replacer 发送 touch 请求，replacer 采用 PLRU 替换策略,接收到 MainPipe 的命中更新，向 MissUnit 提供写入的 waymask。同时进行 PMP 检查，接收 DataArry 返回的数据。对 DataArray 做 ECC 校验，根据 DataArry 和 MetaArry 的校验结果（MetaArray 的校验结果来自 Waylookup）判断是否将错误报告给总线（beu）。之后，如果 DataArry 没有命中，将信息发往 MissUnit 处理。MissUnit 通过 TileLink 总线向 L2Cache 发起请求，获取数据后返回给 DataArray 和 MainPipe。之后就可以将数据返回给 IFU。&lt;/li&gt;&#xA;&lt;li&gt;MetaArray 存储缓存行的标签（Tag）和 ECC 校验码&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用双 Bank SRAM 结构，支持双线访问（Double-Line），每个 Bank 存储部分元数据。&lt;/li&gt;&#xA;&lt;li&gt;标签包含物理地址的高位，用于地址匹配。&lt;/li&gt;&#xA;&lt;li&gt;支持标签 ECC 校验，检测和纠正存储错误。&lt;/li&gt;&#xA;&lt;li&gt;valid_array 记录每个 Way 的有效状态，Flush 操作会清零&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;DataArray 存储实际的指令数据块。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据按 Bank 划分为八个，每个 Bank 宽度为 64 位，支持多 Bank 并行访问。&lt;/li&gt;&#xA;&lt;li&gt;数据 ECC 校验，分段生成校验码，增强错误检测能力。&lt;/li&gt;&#xA;&lt;li&gt;支持双线访问，根据地址偏移选择 Bank，单周期可读取 32 字节数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;冲刷信号有三种：ftqPrefetch.flushFromBpu，itlbFlushPipe，模块外部的 fencei 和 flush 信号。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ftqPrefetch.flushFromBpu：通过 FTQ 来自的 BPU 刷新信号，用于控制预取请求的冲刷。&lt;/li&gt;&#xA;&lt;li&gt;itlbFlushPipe：ITLB 的冲刷信号，itlb 在收到该信号时会冲刷 gpf 缓存。&lt;/li&gt;&#xA;&lt;li&gt;fencei:刷新 MetaArray，清除所有路的 valid_array 清零；missUnit 中所有 MSHR 置无效。&lt;/li&gt;&#xA;&lt;li&gt;flush:mainPipe 和 prefetchPipe 所有流水级直接置无效，wayLookup 读写指针复位，gpf_entry 直接置无效,missUnit 中所有 MSHR 置无效。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;replacer&#34;&gt;Replacer&lt;/h3&gt;&#xA;&lt;p&gt;采用 PLRU 更新算法，考虑到每次取指可能访问连续的 doubleline，对于奇地址和偶地址设置两个 replacer，在进行 touch 和 victim 时根据地址的奇偶分别更新 replacer。&lt;/p&gt;</description>
    </item>
    <item>
      <title>IO接口说明</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/04_io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/04_io/</guid>
      <description>&lt;h1 id=&#34;香山实例化-tlbsv-接口说明itlb&#34;&gt;香山实例化 TLB.sv 接口说明（ITLB）&lt;/h1&gt;&#xA;&lt;h2 id=&#34;基本控制信号&#34;&gt;基本控制信号&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;clock&lt;/code&gt;: 时钟信号，驱动 &lt;code&gt;TLB&lt;/code&gt; 的时序逻辑。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;reset&lt;/code&gt;: 复位信号，用于重置 &lt;code&gt;TLB&lt;/code&gt; 的状态。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;刷新sfence接口信号&#34;&gt;刷新（SFENCE）接口信号&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;io_sfence_valid&lt;/code&gt;: &lt;code&gt;SFENCE&lt;/code&gt; 操作的有效性标志。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_sfence_bits_rs1&lt;/code&gt;: &lt;code&gt;SFENCE&lt;/code&gt; 操作是否使用寄存器 &lt;code&gt;rs1&lt;/code&gt; 的值。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_sfence_bits_rs2&lt;/code&gt;: &lt;code&gt;SFENCE&lt;/code&gt; 操作是否使用寄存器 &lt;code&gt;rs2&lt;/code&gt; 的值。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_sfence_bits_addr&lt;/code&gt;: &lt;code&gt;SFENCE&lt;/code&gt; 操作指定的地址，用于选择性刷新特定地址的 &lt;code&gt;TLB&lt;/code&gt; 条目。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_sfence_bits_id&lt;/code&gt;: 刷新操作指定的 &lt;code&gt;asid/vmid&lt;/code&gt;，用于选择性刷新特定地址空间的 &lt;code&gt;TLB&lt;/code&gt; 条目。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_sfence_bits_flushPipe&lt;/code&gt;: 刷新整个管道。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_sfence_bits_hv&lt;/code&gt;: 指示指令是否为 &lt;code&gt;HFENCE.VVMA&lt;/code&gt;，即是否刷新虚拟化下由 &lt;code&gt;vsatp&lt;/code&gt; 寄存器控制的条目。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_sfence_bits_hg&lt;/code&gt;: 指示指令是否为 &lt;code&gt;HFENCE.GVMA&lt;/code&gt;，即是否刷新由 &lt;code&gt;hgatp&lt;/code&gt; 寄存器控制的条目。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;控制与状态寄存器csr接口信号&#34;&gt;控制与状态寄存器（CSR）接口信号&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;io_csr_satp_mode&lt;/code&gt;: &lt;code&gt;SATP&lt;/code&gt; 寄存器的模式字段（如裸模式、&lt;code&gt;Sv32&lt;/code&gt;、&lt;code&gt;Sv39&lt;/code&gt; 等）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_csr_satp_asid&lt;/code&gt;: 当前 &lt;code&gt;SATP&lt;/code&gt; 寄存器的 &lt;code&gt;ASID&lt;/code&gt;（地址空间标识符）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_csr_satp_changed&lt;/code&gt;: 指示 &lt;code&gt;SATP&lt;/code&gt; 寄存器的值是否已更改。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_csr_vsatp_mode&lt;/code&gt;: &lt;code&gt;VSATP&lt;/code&gt; 寄存器的模式字段。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_csr_vsatp_asid&lt;/code&gt;: &lt;code&gt;VSATP&lt;/code&gt; 寄存器的 &lt;code&gt;ASID&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_csr_vsatp_changed&lt;/code&gt;: 指示 &lt;code&gt;VSATP&lt;/code&gt; 寄存器的值是否已更改。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_csr_hgatp_mode&lt;/code&gt;: &lt;code&gt;HGATP&lt;/code&gt; 寄存器的模式字段。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_csr_hgatp_vmid&lt;/code&gt;: &lt;code&gt;HGATP&lt;/code&gt; 寄存器的 &lt;code&gt;VMID&lt;/code&gt;（虚拟机标识符）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_csr_hgatp_changed&lt;/code&gt;: 指示 &lt;code&gt;HGATP&lt;/code&gt; 寄存器的值是否已更改。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_csr_priv_virt&lt;/code&gt;: 指示是否在虚拟模式下运行。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_csr_priv_imode&lt;/code&gt;: 指令模式的特权级（如用户态、内核态等）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;请求者requestor接口信号&#34;&gt;请求者（Requestor）接口信号&lt;/h2&gt;&#xA;&lt;h3 id=&#34;requestor-0-信号&#34;&gt;Requestor 0 信号&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_0_req_valid&lt;/code&gt;: &lt;code&gt;requestor0&lt;/code&gt; 的请求有效信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_0_req_bits_vaddr&lt;/code&gt;: &lt;code&gt;requestor0&lt;/code&gt; 的请求虚拟地址。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_0_resp_bits_paddr_0&lt;/code&gt;: &lt;code&gt;requestor0&lt;/code&gt; 的物理地址响应信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_0_resp_bits_gpaddr_0&lt;/code&gt;: &lt;code&gt;requestor0&lt;/code&gt; 的物理地址转换为 &lt;code&gt;GPA&lt;/code&gt;（&lt;code&gt;Guest Physical Address&lt;/code&gt;）的响应信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_0_resp_bits_miss&lt;/code&gt;: &lt;code&gt;requestor0&lt;/code&gt; 请求的地址未命中的信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_0_resp_bits_excp_0_gpf_instr&lt;/code&gt;: &lt;code&gt;requestor0&lt;/code&gt; 出现 &lt;code&gt;General Protection Fault&lt;/code&gt; (&lt;code&gt;GPF&lt;/code&gt;) 异常的信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_0_resp_bits_excp_0_pf_instr&lt;/code&gt;: &lt;code&gt;requestor0&lt;/code&gt; 出现 &lt;code&gt;Page Fault&lt;/code&gt; (&lt;code&gt;PF&lt;/code&gt;) 异常的信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_0_resp_bits_excp_0_af_instr&lt;/code&gt;: &lt;code&gt;requestor0&lt;/code&gt; 出现 &lt;code&gt;Access Fault&lt;/code&gt; (&lt;code&gt;AF&lt;/code&gt;) 异常的信号。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;requestor-1-信号&#34;&gt;Requestor 1 信号&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_1_req_valid&lt;/code&gt;: &lt;code&gt;requestor1&lt;/code&gt; 的请求有效信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_1_req_bits_vaddr&lt;/code&gt;: &lt;code&gt;requestor1&lt;/code&gt; 的请求虚拟地址。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_1_resp_bits_paddr_0&lt;/code&gt;: &lt;code&gt;requestor1&lt;/code&gt; 的物理地址响应信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_1_resp_bits_gpaddr_0&lt;/code&gt;: &lt;code&gt;requestor1&lt;/code&gt; 的 &lt;code&gt;GPA&lt;/code&gt; 响应信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_1_resp_bits_miss&lt;/code&gt;: &lt;code&gt;requestor1&lt;/code&gt; 的未命中信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_1_resp_bits_excp_0_gpf_instr&lt;/code&gt;: &lt;code&gt;requestor1&lt;/code&gt; 出现 &lt;code&gt;GPF&lt;/code&gt; 异常的信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_1_resp_bits_excp_0_pf_instr&lt;/code&gt;: &lt;code&gt;requestor1&lt;/code&gt; 出现 &lt;code&gt;PF&lt;/code&gt; 异常的信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_1_resp_bits_excp_0_af_instr&lt;/code&gt;: &lt;code&gt;requestor1&lt;/code&gt; 出现 &lt;code&gt;AF&lt;/code&gt; 异常的信号。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;requestor-2-信号&#34;&gt;Requestor 2 信号&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_2_req_ready&lt;/code&gt;: &lt;code&gt;requestor2&lt;/code&gt; 的请求就绪信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_2_req_valid&lt;/code&gt;: &lt;code&gt;requestor2&lt;/code&gt; 的请求有效信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_2_req_bits_vaddr&lt;/code&gt;: &lt;code&gt;requestor2&lt;/code&gt; 的请求虚拟地址。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_2_resp_ready&lt;/code&gt;: &lt;code&gt;requestor2&lt;/code&gt; 的响应就绪信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_2_resp_valid&lt;/code&gt;: &lt;code&gt;requestor2&lt;/code&gt; 的响应有效信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_2_resp_bits_paddr_0&lt;/code&gt;: &lt;code&gt;requestor2&lt;/code&gt; 的物理地址响应信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_2_resp_bits_gpaddr_0&lt;/code&gt;: &lt;code&gt;requestor2&lt;/code&gt; 的 &lt;code&gt;GPA&lt;/code&gt; 响应信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_2_resp_bits_excp_0_gpf_instr&lt;/code&gt;: &lt;code&gt;requestor2&lt;/code&gt; 出现 &lt;code&gt;GPF&lt;/code&gt; 异常的信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_2_resp_bits_excp_0_pf_instr&lt;/code&gt;: &lt;code&gt;requestor2&lt;/code&gt; 出现 &lt;code&gt;PF&lt;/code&gt; 异常的信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_requestor_2_resp_bits_excp_0_af_instr&lt;/code&gt;: &lt;code&gt;requestor2&lt;/code&gt; 出现 &lt;code&gt;AF&lt;/code&gt; 异常的信号。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;刷新管道flush-pipe信号&#34;&gt;刷新管道（Flush Pipe）信号&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;io_flushPipe_0&lt;/code&gt;: 刷新管道 &lt;code&gt;0&lt;/code&gt; 的信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_flushPipe_1&lt;/code&gt;: 刷新管道 &lt;code&gt;1&lt;/code&gt; 的信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_flushPipe_2&lt;/code&gt;: 刷新管道 &lt;code&gt;2&lt;/code&gt; 的信号。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;页表遍历page-table-walker-ptw接口信号&#34;&gt;页表遍历（Page Table Walker, PTW）接口信号&lt;/h2&gt;&#xA;&lt;h3 id=&#34;ptw-请求信号&#34;&gt;PTW 请求信号&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_req_0_valid&lt;/code&gt;: &lt;code&gt;PTW req0&lt;/code&gt; 有效信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_req_0_bits_vpn&lt;/code&gt;: &lt;code&gt;PTW req0&lt;/code&gt; 的虚拟页号（&lt;code&gt;VPN&lt;/code&gt;）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_req_0_bits_s2xlate&lt;/code&gt;: 指示 &lt;code&gt;PTW req0&lt;/code&gt; 的转换模式。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_req_0_bits_getGpa&lt;/code&gt;: &lt;code&gt;PTW req0&lt;/code&gt; 的获取 &lt;code&gt;GPA&lt;/code&gt; 信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_req_1_valid&lt;/code&gt;: &lt;code&gt;PTW req1&lt;/code&gt; 有效信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_req_1_bits_vpn&lt;/code&gt;: &lt;code&gt;PTW req1&lt;/code&gt; 的虚拟页号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_req_1_bits_s2xlate&lt;/code&gt;: 指示 &lt;code&gt;PTW req1&lt;/code&gt; 的转换模式。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_req_1_bits_getGpa&lt;/code&gt;: &lt;code&gt;PTW req1&lt;/code&gt; 的获取 &lt;code&gt;GPA&lt;/code&gt; 信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_req_2_ready&lt;/code&gt;: &lt;code&gt;PTW req2&lt;/code&gt; 就绪信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_req_2_valid&lt;/code&gt;: &lt;code&gt;PTW req2&lt;/code&gt; 有效信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_req_2_bits_vpn&lt;/code&gt;: &lt;code&gt;PTW req2&lt;/code&gt; 的虚拟页号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_req_2_bits_s2xlate&lt;/code&gt;: 指示 &lt;code&gt;PTW req2&lt;/code&gt; 的转换模式。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_req_2_bits_getGpa&lt;/code&gt;: &lt;code&gt;PTW req2&lt;/code&gt; 的获取 &lt;code&gt;GPA&lt;/code&gt; 信号。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;ptw-响应信号&#34;&gt;PTW 响应信号&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_valid&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 有效信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s2xlate&lt;/code&gt;: 指示 &lt;code&gt;PTW resp&lt;/code&gt; 的地址转换类型。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_entry_tag&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目标签。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_entry_asid&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目 &lt;code&gt;ASID&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_entry_vmid&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目 &lt;code&gt;VMID&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_entry_perm_d&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目可写位。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_entry_perm_a&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目已访问位。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_entry_perm_g&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目全局位。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_entry_perm_u&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目用户模式位。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_entry_perm_x&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目可执行位。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_entry_perm_w&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目可写位。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_entry_perm_r&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目可读位。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_entry_level&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目级别。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_entry_ppn&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目物理页号（&lt;code&gt;PPN&lt;/code&gt;）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_addr_low&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目地址低位。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_ppn_low_*&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目 &lt;code&gt;PPN&lt;/code&gt; 低位。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_valididx_*&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目有效索引。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_pteidx_*&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目 &lt;code&gt;PTE&lt;/code&gt; 索引。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_pf&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目出现 &lt;code&gt;PF&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s1_af&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第一阶段页表条目出现 &lt;code&gt;AF&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s2_entry_tag&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第二阶段页表条目标签。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s2_entry_vmid&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第二阶段页表条目 &lt;code&gt;VMID&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s2_entry_ppn&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第二阶段页表条目 &lt;code&gt;PPN&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s2_entry_perm_*&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第二阶段页表条目的权限位。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s2_entry_level&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第二阶段页表条目级别。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s2_gpf&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第二阶段页表条目 &lt;code&gt;GPF&lt;/code&gt; 信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_s2_gaf&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的第二阶段页表条目 &lt;code&gt;GAF&lt;/code&gt; 信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;io_ptw_resp_bits_getGpa&lt;/code&gt;: &lt;code&gt;PTW resp&lt;/code&gt; 的获取 &lt;code&gt;GPA&lt;/code&gt; 信号。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>IPrefetchPipe</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/01_iprefetchpipe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/01_iprefetchpipe/</guid>
      <description>&lt;div class=&#34;icache-ctx&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;iprefetchpipe&#34;&gt;IPrefetchPipe&lt;/h2&gt;&#xA;&lt;p&gt;IPrefetchPipe 为预取的流水线，三级流水设计，负责预取请求的过滤。&lt;/p&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../iprefetchpipe_structure.png&#34;&#xA;         alt=&#34;IPrefetchPipe模块结构示意图&#34;&#xA;         style=&#34;zoom:40%&#34;/&gt;&#xA;    &lt;br&gt;&#x9;&#x9;&#xA;    IPrefetchPipe结构示意图&#x9;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;br&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;接收预取请求（s0 阶段）：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从 FTQ 或后端接收预取请求。&lt;/li&gt;&#xA;&lt;li&gt;发送读请求到 ITLB 和 MetaArray 缓存元数据模块。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;地址转换和缓存检查（s1 阶段）：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接收 ITLB 的地址转换结果，处理可能的缺失和重发。&lt;/li&gt;&#xA;&lt;li&gt;从缓存元数据中读取标签和有效位，检查是否命中。&lt;/li&gt;&#xA;&lt;li&gt;进行 PMP 权限检查，合并异常信息。&lt;/li&gt;&#xA;&lt;li&gt;根据情况决定是否发送请求到 WayLookup 模块。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;未命中请求处理（s2 阶段）：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;检查与 missUnit 的交互，更新命中状态。&lt;/li&gt;&#xA;&lt;li&gt;对于无异常的未命中请求，向 missUnit 发送请求以获取数据。&lt;/li&gt;&#xA;&lt;li&gt;控制流水线的推进和刷新，处理可能的阻塞和异常。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;s0-流水级&#34;&gt;S0 流水级&lt;/h3&gt;&#xA;&lt;p&gt;在 S0 流水级，接收来自 FTQ 的预取请求，向 MetaArray 和 ITLB 发送请求。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接收预取请求：从 FTQ 或后端接收预取请求，提取预取请求的虚拟地址、FTQ 索引、是否为软件预取、是否跨缓存行信、虚拟组索引（s0_req_vSetIdx）和后端的异常信息。&lt;/li&gt;&#xA;&lt;li&gt;发送请求到 ITLB：将虚拟地址发送到 ITLB 进行地址转换。&lt;/li&gt;&#xA;&lt;li&gt;发送请求到缓存元数据（Meta SRAM）：将请求发送到缓存的元数据存储器，以便在后续阶段读取缓存标签和有效位。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;s1-流水级&#34;&gt;S1 流水级&lt;/h3&gt;&#xA;&lt;p&gt;软件预取 enqway 持续一拍&amp;hellip;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接收 ITLB 的响应：从 ITLB 接收地址转换的结果，包括物理地址 paddr、异常类型(&lt;code&gt;af&lt;/code&gt;/&lt;code&gt;pf&lt;/code&gt;)和特殊情况(&lt;code&gt;pbmt.nc&lt;/code&gt;/&lt;code&gt;pbmt.io&lt;/code&gt;)。&lt;/li&gt;&#xA;&lt;li&gt;接收缓存元数据的响应并检查缓存命中：从缓存元数据存储器 MetaArray 读取缓存标签 &lt;code&gt;tag&lt;/code&gt; 和有效位，检查预取地址是否在缓存中已存在，命中结果存入 &lt;code&gt;waymask&lt;/code&gt; 中。&lt;/li&gt;&#xA;&lt;li&gt;权限检查：使用 PMP 对物理地址进行权限检查，确保预取操作的合法性。&lt;/li&gt;&#xA;&lt;li&gt;异常处理和合并：合并来自后端、ITLB、PMP 的异常信息，准备在后续阶段处理。&lt;/li&gt;&#xA;&lt;li&gt;发送请求到 WayLookup 模块：当条件满足时，将元数据（命中信息 &lt;code&gt;waymask&lt;/code&gt;、ITLB 信息 &lt;code&gt;paddr&lt;/code&gt;/&lt;code&gt;af&lt;/code&gt;/&lt;code&gt;pf&lt;/code&gt;）发送到 WayLookup 模块，以便进行后续的缓存访问。&lt;/li&gt;&#xA;&lt;li&gt;状态机转换：根据当前状态和条件，更新下一个状态。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;状态机初始状态为 &lt;code&gt;idle&lt;/code&gt;，当 S1 流水级进入新的请求时，首先判断 ITLB 是否缺失，如果缺失，就进入 &lt;code&gt;itlbResend&lt;/code&gt;；如果 ITLB 命中但命中信息未入队 WayLookup，就进入 &lt;code&gt;enqWay&lt;/code&gt;；如果 ITLB 命中且 WayLookup 入队但 S2 请求未处理完，就进入 &lt;code&gt;enterS2&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;在 &lt;code&gt;itlbResend&lt;/code&gt; 状态，重发 ITLB 请求，此时占用 ITLB 端口，直至请求回填完成，在回填完成的当拍向 MetaArray 再次发送读请求，回填期间可能发生新的写入，如果 MetaArray 繁忙（正在被写入），就进入&lt;code&gt;metaResend&lt;/code&gt;，否则进入 &lt;code&gt;enqWay&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;在 &lt;code&gt;metaResend&lt;/code&gt; 状态，重发 MetaArray 读请求，发送成功后进入 &lt;code&gt;enqWay&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;在 &lt;code&gt;enqWay&lt;/code&gt; 状态，尝试将元数据入队 WayLookup，如果 WayLookup 队列已满，就阻塞至 WayLookup 入队成功，另外在 MSHR 发生新的写入时禁止入队，主要是为了防止写入的信息与命中信息所冲突，需要对命中信息进行更新。当成功入队 WayLookup 或者是软件预取时，如果 S2 空闲，就直接进入 &lt;code&gt;idle&lt;/code&gt;，否则进入 &lt;code&gt;enterS2&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;在 &lt;code&gt;enterS2&lt;/code&gt; 状态，尝试将请求流入下一流水级，流入后进入 &lt;code&gt;idle&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&lt;!--块级封装--&gt;&#xA;    &lt;center&gt;&#x9;&lt;!--将图片和文字居中--&gt;&#xA;    &lt;img src=&#34;../iprefetchpipe_fsm.png&#34;&#xA;         alt=&#34;IPrefetchPipe状态机&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#x9;&#x9;&lt;!--换行--&gt;&#xA;    IPrefetchPipe S1状态机&#x9;&lt;!--标题--&gt;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;s2-流水级&#34;&gt;S2 流水级&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;监控 missUnit 的请求：更新 MSHR 的匹配状态。综合该请求的命中结果、ITLB 异常、PMP 异常、meta 损坏，判断是否需要预取，只有不存在异常时才进行预取。&lt;/li&gt;&#xA;&lt;li&gt;发送请求到 missUnit：因为同一个预测块可能对应两个 cacheline，所以通过 Arbiter 依次将请求发送至 MissUnit。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;命中信息的更新&#34;&gt;命中信息的更新&lt;/h3&gt;&#xA;&lt;p&gt;在 S1 流水级中得到命中信息后，距离命中信息真正在 MainPipe 中被使用要经过两个阶段，分别是在 IPrefetchPipe 中等待入队 WayLookup 阶段和在 WayLookup 中等待出队阶段，在等待期间可能会发生 MSHR 对 Meta/DataArray 的更新，因此需要对 MSHR 的响应进行监听，分为两种情况：&lt;/p&gt;</description>
    </item>
    <item>
      <title>LoadQueueRAR</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/01_loadqueuerar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/01_loadqueuerar/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文档参考&lt;a href=&#34;https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ&#34;&gt;香山LSQ设计文档&lt;/a&gt;写成&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文档撰写的内容截至[ca892e73]&lt;/p&gt;&#xA;&lt;p&gt;请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！&lt;/p&gt;&#xA;&lt;h1 id=&#34;loadqueuerar-简介&#34;&gt;LoadQueueRAR 简介&lt;/h1&gt;&#xA;&lt;p&gt;LoadQueueRAR用于保存已经完成的load指令的用于load to load违例检测的信息。&lt;/p&gt;&#xA;&lt;p&gt;多核环境下会出现load to load违例。单核环境下相同地址的load乱序执行本来是不关心的，但是如果两个load之间有另外一个核做了相同地址的store，并且本身这个核的两个load做了乱序调度，就有可能导致新的load没有看到store更新的结果，但是旧的load看到了，出现了顺序错误。&lt;/p&gt;&#xA;&lt;p&gt;多核环境下的load-load违例有一个特征，当前DCache一定会收到L2 cache发来的Probe请求，使得DCache主动释放掉这个数据副本，这时DCache会通知load queue，将相同地址的load queue中已经完成访存的项做一个release标记。后续发往流水线的load指令会查询load queue中在它之后相同地址的load指令，如果存在release标记，就发生了load-load违例。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;L2Cache&lt;/td&gt;&#xA;          &lt;td&gt;二级高速缓存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;DCache&lt;/td&gt;&#xA;          &lt;td&gt;数据缓存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ROB&lt;/td&gt;&#xA;          &lt;td&gt;重排序缓冲区&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CAM&lt;/td&gt;&#xA;          &lt;td&gt;内容可寻址存储器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;FTQ&lt;/td&gt;&#xA;          &lt;td&gt;取指目标队列&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;ld-ld违例&#34;&gt;ld-ld违例&lt;/h2&gt;&#xA;&lt;p&gt;多核环境下，可能会出现load to load违例：在单核环境中，相同地址的load乱序执行通常不被关注，因为它们在同一核内执行，不会影响其他核的状态，也不会被其他核的操作影响。但是，当两个load操作之间有另一个核对相同地址进行了store操作，情况就变得复杂。&lt;/p&gt;&#xA;&lt;p&gt;考虑以下指令序列：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;load1（core1）&#xA;store（core2） &#xA;load2（core1）&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;指令的实际执行顺序为：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;load2（core1）&#xA;store（core2） &#xA;load1（core1）&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于指令的乱序执行，可能导致以下情况：旧的 load1 指令在执行时读取到了 store 修改后的新数据，而新的 load2 指令却读取到了未被修改的旧数据。这种执行顺序的变化会导致数据的不一致性，进而引发访存错误。&lt;/p&gt;&#xA;&lt;p&gt;因此，在多核环境中，正确处理指令的执行顺序和内存一致性是至关重要的，以确保所有核都能看到一致的内存状态。&lt;/p&gt;&#xA;&lt;h2 id=&#34;整体框图&#34;&gt;整体框图&lt;/h2&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../LoadQueueRAR_structure.svg&#34;&#xA;         alt=&#34;LoadQueueRAR结构示意图&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#xA;    图1：LoadQueueRAR结构示意图&lt;br&gt;&lt;br&gt;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;LoadQueueRAR最多能够存储72条指令（为了同VirtualLoadQueue的大小保持一致），每条指令占用一个条目。每个条目包含指令的物理地址（paddr）、与指令相关的信息（uop）、以及标记为已释放（released）和已分配（allocated）的状态寄存器。&lt;/p&gt;&#xA;&lt;p&gt;该模块通过 FreeList 子模块管理 entry 资源，FreeList 中存储的是 entry 的编号。当一条指令满足入队条件时，FreeList 会为其分配一个 entry 编号，并将该指令存放在相应的 entry 中。指令出队时，需要释放所占用的 entry 资源，并将条目编号重新放回 FreeList 中，以供后续指令使用。&lt;/p&gt;&#xA;&lt;p&gt;PaddrModule 的实现基于内容可寻址存储器（CAM），其深度为 72，数据宽度为 48。CAM 为每条流水线提供一个写端口，其中物理地址（paddr）作为写数据（wdata），条目编号作为写地址（waddr）。此外，CAM 还为每条流水线提供了一个地址查询端口（releaseViolationMdata），并为数据缓存（DCache）提供另一个地址查询端口（releaseMdata）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LoadQueueRAW</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/02_loadqueueraw/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/02_loadqueueraw/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文档参考&lt;a href=&#34;https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ&#34;&gt;香山LSQ设计文档&lt;/a&gt;写成&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文档撰写的内容截至[ca892e73]&lt;/p&gt;&#xA;&lt;p&gt;请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！&lt;/p&gt;&#xA;&lt;h1 id=&#34;loadqueueraw-简介&#34;&gt;LoadQueueRAW 简介&lt;/h1&gt;&#xA;&lt;p&gt;LoadQueueRAW是用于处理store-load违例的。由于load和store在流水线中都是乱序执行，会经常出现load越过了更老的相同地址的store，即这条load本应该前递store的数据，但是由于store地址或者数据没有准备好，导致这条load没有前递到store的数据就已经提交，后续使用这条load结果的指令也都发生了错误，于是产生store to load forwarding违例。&lt;/p&gt;&#xA;&lt;p&gt;当store address通过STA保留站发射出来进入store流水线时，会去查询LQRAW中在这条store后面的所有已经完成访存的相同地址的load，以及load流水线中正在进行的在该条store之后的相同地址的load，一旦发现有，就发生了store to load forwarding违例，可能有多个load发生了违例，需要找到离store最近的load，也就是最老的违例的load，然后给RedirectGenerator部件发送重定向请求，冲刷最老的违例的load及之后的所有指令。&lt;/p&gt;&#xA;&lt;p&gt;当store流水线执行cbo zero指令时，也需要进行store-load违例检查。&lt;/p&gt;&#xA;&lt;h2 id=&#34;st-ld违例&#34;&gt;st-ld违例&lt;/h2&gt;&#xA;&lt;p&gt;在现代处理器中，Load 和 Store 指令通常采用乱序执行的方式进行处理。这种执行策略旨在提高处理器的并行性和整体性能。然而，由于 Load 和 Store 指令在流水线中的乱序执行，常常会出现 Load 指令越过更早的相同地址的 Store 指令的情况。这意味着，Load 指令本应通过前递（forwarding）机制从 Store 指令获取数据，但由于 Store 指令的地址或数据尚未准备好，导致 Load 指令未能成功前递到 Store 的数据，而 Store 指令已被提交。由此，后续依赖于该 Load 指令结果的指令可能会出现错误，这就是 st-ld 违例。&lt;/p&gt;&#xA;&lt;p&gt;考虑以下伪代码示例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ST R1, 0(R2)  ; 将 R1 的值存储到 R2 指向的内存地址&#xA;LD R3, 0(R2)  ; 从 R2 指向的内存地址加载值到 R3&#xA;ADD R4, R3, R5 ; 使用 R3 的值进行计算&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设在这个过程中，Store 指令由于某种原因（如缓存未命中）未能及时完成，而 Load 指令已经执行并读取了旧的数据（例如，从内存中读取到的值为 &lt;code&gt;0&lt;/code&gt;）。此时，Load 指令并未获得 Store 指令更新后的值，导致后续计算的数据错误。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LoadQueueReplay</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/03_loadqueuereplay/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/03_loadqueuereplay/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文档参考&lt;a href=&#34;https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ&#34;&gt;香山LSQ设计文档&lt;/a&gt;写成&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文档撰写的内容截至[ca892e73]&lt;/p&gt;&#xA;&lt;p&gt;请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！&lt;/p&gt;&#xA;&lt;h1 id=&#34;loadqueuereplay-简介&#34;&gt;LoadQueueReplay 简介&lt;/h1&gt;&#xA;&lt;p&gt;LoadQueueReplay 模块是现代处理器架构中用于处理 Load 指令重发的重要组成部分。它负责管理因各种原因而需要重发的 Load 指令，确保指令执行的正确性和高效性。&lt;/p&gt;&#xA;&lt;h2 id=&#34;整体框图&#34;&gt;整体框图&lt;/h2&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../LoadQueueReplay_structure.png&#34;&#xA;         alt=&#34;LoadQueueReplay结构示意图&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#xA;    图1：LoadQueueReplay结构示意图&lt;br&gt;&lt;br&gt;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;LoadQueueReplay 最多存放72条指令，涉及多个状态和存储的信息。其关键组成部分如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Allocated&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;表示某个 Load 重发队列项是否已经被分配，反映该项的有效性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Scheduled&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指示某个 Load 重发队列项是否已被调度，意味着该项已经被选出，并将被发送至 Load Unit 进行重发。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Uop&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;该队列项对应的 Load 指令执行信息，包括微操作（uop）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Cause&lt;/strong&gt;：指示该 Load 指令重发的原因，主要包括以下几种情况：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_MA&lt;/strong&gt;：存储-加载（st-ld）违反重新执行。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_TM&lt;/strong&gt;：TLB（翻译后备页表）缺失。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_FF&lt;/strong&gt;：存储-加载转发。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_DR&lt;/strong&gt;：数据缓存（dcache）需要重发。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_DM&lt;/strong&gt;：数据缓存缺失。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_WF&lt;/strong&gt;：路径预测失败。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_BC&lt;/strong&gt;：数据缓存路径冲突。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_RAR&lt;/strong&gt;：读取-读取（RAR）队列无法接收。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_RAW&lt;/strong&gt;：读取-写入（RAW）队列无法接收。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_NK&lt;/strong&gt;：存储-加载违反。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Blocking&lt;/strong&gt;：指示该 Load 指令因等待条件而被阻塞，不能被调度重发。阻塞的原因和解除阻塞的条件包括：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_MA&lt;/strong&gt;：存储指令的地址就绪。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_TM&lt;/strong&gt;：TLB 回填完毕，并发送 Hint 信号。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_FF&lt;/strong&gt;：存储指令的数据就绪。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_DM&lt;/strong&gt;：数据缓存回填完毕。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_RAR&lt;/strong&gt;：RAR 队列未满，且 Load 指令比 Load Queue 的写回项更老。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C_RAW&lt;/strong&gt;：RAW 队列未满，且 Load 指令比 Store Queue 中所有地址准备好的项都更老。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;LoadReplayQueue 通过 FreeList 管理队列的空闲状态。FreeList 的大小等于 LoadReplayQueue 的项数，分配宽度为3（Load Unit 的数量），释放宽度为 4。同时，Free List 可以反馈 Load Replay Queue 的空余项数量以及是否已满的信息。除了FreeList，LoadQueueReplay还包含两个子模块：AgeDetector 和 LqVAddrModule，其中 AgeDetector 用于寻找一系列load replay queue项中最早入队的一项。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LoadQueueUncache</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/04_loadqueueuncache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/04_loadqueueuncache/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文档参考&lt;a href=&#34;https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ&#34;&gt;香山LSQ设计文档&lt;/a&gt;写成&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文档撰写的内容截至[66e9b546]&lt;/p&gt;&#xA;&lt;p&gt;请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！&lt;/p&gt;&#xA;&lt;h1 id=&#34;loadqueueuncache-简介&#34;&gt;LoadQueueUncache 简介&lt;/h1&gt;&#xA;&lt;p&gt;LoadQueueUncache 和 Uncache 模块，对于 uncache load 访问请求来说，起到一个从 LoadUnit 流水线到总线访问的中间站作用。其中 Uncache 模块，作为靠近总线的一方，主要用于处理 uncache 访问到总线的请求和响应。LoadQueueUncache 作为靠近流水线的一方，需要承担以下责任：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;接收 LoadUnit 流水线传过来的 uncache load 请求。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;选择已准备好 uncache 访问的 uncache load 请求 发送到 Uncache Buffer。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;接收来自 Uncache Buffer 的处理完的 uncache load 请求。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;将处理完的 uncache load 请求 返回给 LoadUnit。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;LoadQueueUncache 结构上，目前有 4 项（项数可配）UncacheEntry，每一项独立负责一个请求并利用一组状态寄存器控制其具体处理流程；有一个 FreeList，管理各项分配和回收的情况。而 LoadQueueUncache 主要是协同 4 项的新项分配、请求选择、响应分派、出队等统筹逻辑。&lt;/p&gt;&#xA;&lt;h2 id=&#34;整体框图&#34;&gt;整体框图&lt;/h2&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../LoadQueueUncache_structure.svg&#34;&#xA;         alt=&#34;LoadQueueUncache结构示意图&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#xA;    图1：LoadQueueUncache结构示意图&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;UnCacheBuffer 最多存放4条指令，除了 FreeList 之外，另一个重要的子模块是 UncacheEntry，管理每个Uncahce请求，负责发起Uncache，写回Uncache数据。每个Entry内维护一个用于发起Uncache请求的状态机，状态机的状态转换图如下：&lt;/p&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../UncacheEntry.png&#34;&#xA;         alt=&#34;UncacheEntry结构示意图&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#xA;    图2：UncacheEntry状态转换图&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;s_idl:该项还未发起一个MMIO请求。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;s_req:向uncache模块发起MMIO请求，等待请求被接收。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;s_resp:等待uncache模块的MMIO响应。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;s_wait:等待将MMIO结果写回流水线。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;功能简介&#34;&gt;功能简介&lt;/h1&gt;&#xA;&lt;mrs-functions&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;功能1uncache指令请求入队&#34;&gt;功能1：Uncache指令请求入队&lt;/h3&gt;&#xA;&lt;p&gt;LoadQueueUncache 负责接收来自 LoadUnit 0、1、2 三个模块的请求，这些请求可以是 MMIO 请求，也可以是 NC 请求。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MainPipe</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/02_mainpipe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/02_mainpipe/</guid>
      <description>&lt;div class=&#34;icache-ctx&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;mainpipe&#34;&gt;MainPipe&lt;/h2&gt;&#xA;&lt;p&gt;MainPipe 为 ICache 的主流水，为三级流水设计，负责从 DataArray 中读取数据，pmp 检查，缺失处理，并且将结果返回给 IFU。&lt;/p&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../mainpipe_structure.png&#34;&#xA;         alt=&#34;MainPipe结构示意图&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#x9;&#x9;&#xA;    MainPipe结构示意图&#x9;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;br&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从 WayLookup 获取信息，访问 DataArray 单路（S0 阶段）&#xA;在 S0 流水级，从 WayLookup 获取元数据，包括路命中信息和 ITLB 查询结果，访问 DataArray 的单路，如果 DataArray 正在被写或 WayLookup 中没有有效表项，流水线就会阻塞。每次重定向后，FTQ 中同一个请求被同时发送到 MainPipe 和 IPrefetchPipe 中，MainPipe 始终需要等待 IPrefetchPipe 将请求的查询信息写入 WayLookup 后才能向下走，导致了 1 拍重定向延迟，当预取超过取指时，该延迟就会被覆盖。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接收并解析来自 FTQ 的取指请求，提取必要的请求信息，如虚拟地址、缓存组索引、块内偏移、是否为双行读、后端的异常信息。&lt;/li&gt;&#xA;&lt;li&gt;从 WayLookup 模块获取缓存命中信息和 TLB 信息，包括 waymask、物理标签、虚拟机物理地址、是否为叶节点、 ITLB 异常、ITLB 的 PBMT 信息、缓存元数据的校验码。&lt;/li&gt;&#xA;&lt;li&gt;访问 DataArray 的单路，如果 DataArray 正在被写或 WayLookup 中没有有效表项，流水线就会阻塞。&lt;/li&gt;&#xA;&lt;li&gt;每次重定向后，FTQ 中同一个请求被同时发送到 MainPipe 和 IPrefetchPipe 中，MainPipe 始终需要等待 IPrefetchPipe 将请求的查询信息写入 WayLookup 后才能向下走，导致了 1 拍重定向延迟，当预取超过取指时，该延迟就会被覆盖。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;接收上一个阶段的信息并进行数据暂存、PMP 检查、从 DataArray 获取读响应异常合并、替换策略更新以及监控 MissUnit（S1 阶段）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;寄存并延迟 S0 阶段信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从 S0 获取的地址、tag、命中方式（waymask）、TLB 异常标志、下一拍要用的数据等，都会在 S1 寄存一拍，保证在流水线停顿时也能维持正确值。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Meta ECC 检查&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对 S0 读出的 meta 和其校验码（ECC/Parity）进行比对，判断是否发生错误。如果关闭 parity 功能，则跳过该检查。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;更新 replacer&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对确定命中的访问请求，进行“touch”更新，标记最近使用过的 way，以便后续替换算法正确运行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;PMP 检查&#xA;&lt;ul&gt;&#xA;&lt;li&gt;根据 S0 得到的物理地址（paddr），在 S1 对其进行 PMP 检查，判断是否拥有执行权限、是否为 MMIO 等。在当拍收到响应，将结果寄存到下一流水级进行处理。&lt;/li&gt;&#xA;&lt;li&gt;需要指出，IPrefetchPipe s1 流水级也会进行 PMP 检查，和此处的检查实际上是完全一样的，分别检查只是为了优化时序（避免 &lt;code&gt;ITLB(reg) -&amp;gt; ITLB.resp -&amp;gt; PMP.req -&amp;gt; PMP.resp -&amp;gt; WayLookup.write -&amp;gt; bypass -&amp;gt; WayLookup.read -&amp;gt; MainPipe s1(reg)&lt;/code&gt; 的超长组合逻辑路径）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;异常合并&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将 ITLB 与 PMP 异常进行优先级合并，产生最终的异常标记。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;选择数据来源：MSHR 或 SRAM&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接收 DataArray 返回的 data 和 code 并寄存，同时监听 MSHR 的响应，当 DataArray 和 MSHR 的响应同时有效时，后者的优先级更高。当 MSHR 已在填充一些数据，如果当前请求与 MSHR 命中，可以在 S1 阶段直接选用 MSHR 的数据，而不必依赖 SRAM 读出的结果。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;监控 MissUnit，在 ECC 校验、异常处理和缺失处理之后，将最终的数据、异常信息传递给 IFU，完成取指流程（S2 阶段）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ECC 校验&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DataArray ECC 校验，对 S1 流水级寄存的 code 进行校验，生成 data 是否损坏信号 s2_data_corrupt。如果校验出错，就将错误报告给 BEU。&lt;/li&gt;&#xA;&lt;li&gt;MetaArray ECC 校验，IPrefetchPipe 读出 MetaArray 的数据后会直接进行校验，并将校验结果随命中信息一起入队 WayLookup 并随 MainPipe 流水到达 S2 级（meta_corrupt 信号），在此处随 DataArray 的 ECC 校验结果一起报告给 BEU。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;监控 MissUnit 响应端口&#xA;&lt;ul&gt;&#xA;&lt;li&gt;检查当前 S2 阶段的请求是否与 MSHR 中的条目匹配，命中时寄存 MSHR 响应的数据，为了时序在下一拍才将数据发送到 IFU。&lt;/li&gt;&#xA;&lt;li&gt;更新 Data 和其是否来自 MSHR 的信息。&lt;/li&gt;&#xA;&lt;li&gt;更新 s2_hits 和处理异常。&lt;/li&gt;&#xA;&lt;li&gt;处理 L2 Cache 的 Corrupt 标志。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;缺失处理，发送 Miss 请求到 MSHR&#xA;&lt;ul&gt;&#xA;&lt;li&gt;计算是否需要重新获取（Refetch）。&lt;/li&gt;&#xA;&lt;li&gt;通过是否命中、ECC 错误、正确跨行、是否异常和是否属于 MMIO 区域来发送 Miss 请求。&lt;/li&gt;&#xA;&lt;li&gt;设置 Arbiter 合并多个端口的 Miss 请求，确保一次只处理一个请求，同时有避免重复请求的设置。&lt;/li&gt;&#xA;&lt;li&gt;判断 Fetch 是否完成。&lt;/li&gt;&#xA;&lt;li&gt;生成 L2 Cache 的异常标记，再将当前 S2 阶段的异常（包括 ITLB、PMP）与 L2 Cache 的异常进行合并。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;响应 IFU&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将最终的数据、异常信息传递给 IFU，完成取指流程。&lt;/li&gt;&#xA;&lt;li&gt;根据请求是否为跨行，决定如何处理双行数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;报告 TileLink 的 Corrupt 错误&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于每个端口，如果在当前周期 s2_fire 时检测到来自 L2 Cache 的数据 corrupt 错误，就将错误报告给 BEU。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;mainpipe-的功能点和测试点&#34;&gt;MainPipe 的功能点和测试点&lt;/h2&gt;&#xA;&lt;h3 id=&#34;访问-dataarray-的单路&#34;&gt;访问 DataArray 的单路&lt;/h3&gt;&#xA;&lt;p&gt;根据从 WayLookup 获取信息，包括路命中信息和 ITLB 查询结果还有 DataArray 当前的情况，决定是否需要从 DataArray 中读取数据。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MissUnit</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/04_missunit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/04_missunit/</guid>
      <description>&lt;div class=&#34;icache-ctx&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;子模块fifo&#34;&gt;子模块：FIFO&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个先入先出的循环队列，目前仅在 MissUnit 中有使用，作为优先队列 priorityFIFO。&lt;/li&gt;&#xA;&lt;li&gt;按照在 MissUnit 中的实例化，pipe 是默认值 false，hasflush 是 true。&lt;/li&gt;&#xA;&lt;li&gt;队列的指针都是环形的，分为入队指针（写指针，ent_ptr）和出队指针（读指针，deq_ptr），记录读和写的位置。&lt;/li&gt;&#xA;&lt;li&gt;两个指针都有对应的 flag 位，当指针超过队列大小时，flag 位会翻转，用以判断是否已经循环。&lt;/li&gt;&#xA;&lt;li&gt;在入队、出队对应的 fire（valid &amp;amp;&amp;amp; ready） 信号有效时，移动对应的指针。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;fifo-的功能点和测试点&#34;&gt;FIFO 的功能点和测试点&lt;/h2&gt;&#xA;&lt;h3 id=&#34;入队操作&#34;&gt;入队操作&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;队未满，正常入队&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当队列未满，且空位不小于一时，可以正常入队，如果从零号位开始入队到最大容量，入队指针的 flag 不会翻转。&lt;/li&gt;&#xA;&lt;li&gt;io.enq.fire 为高有效，regFiles(enq_ptr.value) = io.enq.bits，enq_ptr.value+1 入队指针移动，入队指针标记位不翻转。&lt;/li&gt;&#xA;&lt;li&gt;重复以上操作至队满。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;队未满，入队后标记位翻转&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当队未满，但是空位却是靠近队尾时，入队一位后就到达了队头，入队指针的 flag 会翻转。&lt;/li&gt;&#xA;&lt;li&gt;队列的容量为 10，入队指针指向 9，队未满。此时如果 io.enq.fire 为高，则 regFiles(9) = io.enq.bits，enq_ptr.value+1（循环队列，加完后 enq_ptr.value=0）入队指针移动，入队指针标记位翻转。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;队满，入队就绪信号为低，无法入队&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当队满时，(enq_ptr.value === deq_ptr.value) &amp;amp;&amp;amp; (enq_ptr.flag ^ deq_ptr.flag) 为高，io.enq.ready 为低，io.enq.fire 为低无效。&lt;/li&gt;&#xA;&lt;li&gt;此时入队，入队指针的 value 和 flag 不变。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;出队操作&#34;&gt;出队操作&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;队非空，正常出队&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当队列非空时，可以正常出队，如果出队指针不经过最大容量位置，出队指针的 flag 不会翻转。&lt;/li&gt;&#xA;&lt;li&gt;io.deq.fire 为高有效，io.deq.bits = regFiles(deq_ptr.value)，deq_ptr.value+1 出队指针移动，出队指针标记位不翻转。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;队非空，出队后标记位翻转&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当队非空，但是出队指针是靠近队尾时，出队一位后就到达了队头，出队指针的 flag 会翻转。&lt;/li&gt;&#xA;&lt;li&gt;队列的容量为 10，出队指针指向 9，队非空。此时如果 io.deq.fire 为高，则 io.deq.bits = regFiles(9)，deq_ptr.value+1（循环队列，加完后 deq_ptr.value=0）出队指针移动，出队指针标记位翻转。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;队空，出队有效信号为低，无法出队&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当队空时，enq_ptr === deq_ptr 为高，io.deq.valid 为低，io.deq.fire 为低无效。&lt;/li&gt;&#xA;&lt;li&gt;此时出队，出队指针的 value 和 flag 不变。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;刷新清空操作&#34;&gt;刷新清空操作&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;flush 清空&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当刷新信号有效时，重置出队和入队的指针和标记位，清空队列。&lt;/li&gt;&#xA;&lt;li&gt;当 flush 为高时，deq_ptr.value=0，enq_ptr.value=0，deq_ptr.flag=false，enq_ptr.flag=false，empty=true,full=false。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;missunit&#34;&gt;MissUnit&lt;/h2&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../missunit_structure.png&#34;&#xA;         alt=&#34;MissUnit 结构&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#x9;&#x9;&#xA;    MissUnit 结构&#x9;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;br&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接收并管理多个 Miss 请求&#xA;&lt;ul&gt;&#xA;&lt;li&gt;处理来自 Fetch 和 Prefetch 的 Miss 请求。&lt;/li&gt;&#xA;&lt;li&gt;将这些请求分派给适当数量的 MSHR 进行排队和状态管理。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;管理 MSHR&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ICacheMissUnit 使用多个 MSHR 来跟踪和管理未完成的缓存未命中请求。为了防止 flush 时取指 MSHR 不能完全释放，设置取指 MSHR 的数量为 4，预取 MSHR 的数量为 10。采用数据和地址分离的设计方法，所有的 MSHR 共用一组数据寄存器，在 MSHR 只存储请求的地址信息、状态等信息。&lt;/li&gt;&#xA;&lt;li&gt;接收来自 MainPipe 的取指请求和来自 IPrfetchPipe 的预取请求，取指请求只能被分配到 fetchMSHR，预取请求只能分配到 prefetchMSHR，入队时采用低 index 优先的分配方式。&lt;/li&gt;&#xA;&lt;li&gt;在入队的同时对 MSHR 进行查询，如果请求已经在 MSHR 中存在，就丢弃该请求，对外接口仍表现 fire，只是不入队到 MSHR 中。==在入队时向 Replacer 请求写入 waymask==。当请求完成后，MSHR 会被释放，以便处理新的请求。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通过 TileLink 协议与 L2 缓存进行通信，发送获取缓存块的请求（mem_acquire），并接收 L2 缓存的响应（mem_grant）。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当到 L2 的总线空闲时，选择 MSHR 表现进行处理，整体 fetchMSHR 的优先级高于 prefetchMSHR，只有没有需要处理的 fetchMSHR，才会处理 prefetchMSHR。&lt;/li&gt;&#xA;&lt;li&gt;对于 fetchMSHR，采用低 index 优先的优先级策略，因为同时最多只有两个请求需要处理，并且只有当两个请求都处理完成时才能向下走，所有 fetchMSHR 之间的优先级并不重要。&lt;/li&gt;&#xA;&lt;li&gt;对于 prefetchMSHR，考虑到预取请求之间具有时间顺序，采用先到先得的优先级策略，在入队时通过一个 FIFO 记录入队顺序，处理时按照入队顺序进行处理。&lt;/li&gt;&#xA;&lt;li&gt;通过状态机与 Tilelink 的 D 通道进行交互，到 L2 的带宽为 32byte，需要分 2 次传输，并且不同的请求不会发生交织，所以只需要一组寄存器来存储数据。&lt;/li&gt;&#xA;&lt;li&gt;当一次传输完成时，根据传输的 id 选出对应的 MSHR，从 MSHR 中读取地址、掩码等信息，将相关信息写入 SRAM，同时将 MSHR 释放。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;向 MetaArray 和 DataArray 发送写请求，向 MainPipe 发送响应&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当数据传回后，MissUnit 根据相应的替换策略信息（victim way），将新数据写回 ICache 的 SRAM(Meta/Data) 。&lt;/li&gt;&#xA;&lt;li&gt;同时向取指端（或预取端）返回“Miss 已完成”的响应，包括：写入了哪一路（way）、实际数据以及可能的校验信息（如 corrupt 标记等）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;处理特殊情况（如 flush、fencei、数据损坏等）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;遇到 Flush 或 fence.i 等指令时，MissUnit 可以终止或跳过某些 Miss 请求的写回，从而保证不在无效或过期的情况下写入缓存。&lt;/li&gt;&#xA;&lt;li&gt;数据若出现 corrupt（部分拍损坏），也会在写回或发给前端时进行特殊处理或标记。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;过程：&lt;/p&gt;</description>
    </item>
    <item>
      <title>PredChecker</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/04_pred_checker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/04_pred_checker/</guid>
      <description>&lt;div class=&#34;ifu-ctx&#34;&gt;&#xA;&lt;h1 id=&#34;子模块predchecker简介&#34;&gt;子模块：PredChecker简介&lt;/h1&gt;&#xA;&lt;p&gt;分支预测检查器PredChecker接收来自IFU的预测块信息（包括预测跳转指令在预测块的位置、预测的跳转目标、预译码得到的指令信息、指令PC以及预译码得到的跳转目标偏移等），在模块内部检查五种类型的分支预测错误。模块内部分为两个流水线stage，分别输出信息，第一个stage输出给IFU的f3阶段，用于修正预测块的指令范围和预测结果。第二个stage输出给wb阶段，用于在发现分支预测错误时产生前端重定向以及写回给FTQ（Fetch Target Queue）正确的预测信息。&lt;/p&gt;&#xA;&lt;h2 id=&#34;predchecker功能介绍&#34;&gt;PredChecker功能介绍&lt;/h2&gt;&#xA;&lt;h3 id=&#34;jal预测错误检查&#34;&gt;JAL预测错误检查&lt;/h3&gt;&#xA;&lt;p&gt;jal指令预测错误的条件是，预测块中有一条有效jal指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条jal指令之后（即这条jal指令没有被预测跳转）。&lt;/p&gt;&#xA;&lt;h3 id=&#34;jalr预测错误检查&#34;&gt;JALR预测错误检查&lt;/h3&gt;&#xA;&lt;p&gt;jalr指令预测错误的条件是，预测块中有一条有效jalr指令（由预译码信息给出），而且这个指令不是ret指令，但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条jalr指令之后（即这条jalr指令没有被预测跳转）。&lt;/p&gt;&#xA;&lt;h3 id=&#34;ret预测错误检查&#34;&gt;RET预测错误检查&lt;/h3&gt;&#xA;&lt;p&gt;ret指令预测错误的条件是，预测块中有一条有效ret指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条ret指令之后（即这条ret指令没有被预测跳转）。&lt;/p&gt;&#xA;&lt;h3 id=&#34;更新指令有效范围向量&#34;&gt;更新指令有效范围向量&lt;/h3&gt;&#xA;&lt;p&gt;PredChecker在检查出Jal/Ret/JALR指令预测错误时，需要重新生成指令有效范围向量，有效范围截取到Jal/Ret指令的位置，之后的bit全部置为0。&#xA;需要注意的是，jal和ret指令的错误检查都会导致指令有效范围的缩短，&#xA;所以需要重新生成指令有效范伟fixedRange，同时修复预测结果。需要注意的是，这个修复只会针对RET预测错误和JAL预测错误导致的范围错误，对于后续要介绍的非CFI（控制流指令）预测错误和无效指令预测错误，尽管他们会造成预测块的范围偏小，但是不会进行修复，而是直接在这里进行重定向。这样，重定向后重新取的指令会从这个出错的指令开始。&lt;/p&gt;&#xA;&lt;h3 id=&#34;非cfi预测错误检查&#34;&gt;非CFI预测错误检查&lt;/h3&gt;&#xA;&lt;p&gt;非CFI预测错误的条件是被预测跳转的指令根据预译码信息显示不是一条CFI指令。&lt;/p&gt;&#xA;&lt;h3 id=&#34;无效指令预测错误检查&#34;&gt;无效指令预测错误检查&lt;/h3&gt;&#xA;&lt;p&gt;无效指令预测错误的条件是被预测的指令的位置根据预译码信息中的指令有效向量显示不是一条有效指令的开始。&lt;/p&gt;&#xA;&lt;h3 id=&#34;目标地址预测错误检查&#34;&gt;目标地址预测错误检查&lt;/h3&gt;&#xA;&lt;p&gt;目标地址预测错误的条件是，被预测的是一条有效的jal或者branch指令，同时预测的跳转目标地址和由指令码计算得到的跳转目标不一致。&lt;/p&gt;&#xA;&lt;h3 id=&#34;分级输出检查结果&#34;&gt;分级输出检查结果&lt;/h3&gt;&#xA;&lt;p&gt;以上PredChecker检查结果会分为两级分别输出，前面已经提到，Jal/Ret指令由于需要重新生成指令有效范围向量和重新指定预测位置，&#xA;所以需要在错误产生的当拍（F3）直接输出结果到Ibuffer用于及时更正进入后端的指令 。而由于时序的考虑，其他错误信息（比如五种错误的错误位置、正确的跳转地址等）则是等到下一拍（WB）阶段才返回给IFU做前端重定向。&lt;/p&gt;&#xA;&lt;h2 id=&#34;predchecker接口说明&#34;&gt;PredChecker接口说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;输入接口&#34;&gt;输入接口&lt;/h3&gt;&#xA;&lt;p&gt;fire_in：这个信号可以简单认为是模块有效性的控制信号。&lt;/p&gt;&#xA;&lt;p&gt;ftqOffset：来自BPU（分支预测单元）的预测信息，表示该预测块的跳转指令是否存在（valid），以及跳转指令的序号（bits）。&lt;/p&gt;&#xA;&lt;p&gt;instrRange：来自PreDecode的预译码信息，对每条指令，表示该指令是否在预测块的有效指令范围内。&lt;/p&gt;&#xA;&lt;p&gt;instrValid：来自PreDecode的预译码信息，表示的是对于每条32位的拼接指令，其是否为一条有效的指令（即低16位为一条RVC指令，或者整个32位为一条RVI指令）。&lt;/p&gt;&#xA;&lt;p&gt;jumpOffset：来自PreDecode的预译码信息，如果某一指令为跳转指令，jumpOffset表示这个指令的跳转目标。&lt;/p&gt;&#xA;&lt;p&gt;pc：指令的pc。&lt;/p&gt;&#xA;&lt;p&gt;pds：来自PreDecode模块的预译码信息，包含指令的brType、是否为Ret（isRet）、是否为RVC指令（isRVC）。&lt;/p&gt;&#xA;&lt;p&gt;target：来自BPU，下个预测块的开始地址。&lt;/p&gt;&#xA;&lt;h3 id=&#34;输出接口&#34;&gt;输出接口&lt;/h3&gt;&#xA;&lt;h4 id=&#34;第一阶段输出&#34;&gt;第一阶段输出&lt;/h4&gt;&#xA;&lt;p&gt;fixedRange：修复的指令有效范围向量，对每条指令i，fixedRange_i为真表示这条指令是否在当前预测块的有效指令范围内&lt;/p&gt;&#xA;&lt;p&gt;fixedTaken：修复过后的CFI指令选取情况，对每条指令，fixedTaken_i为真表示这条指令是否是这个预测块的第一条CFI指令&lt;/p&gt;&#xA;&lt;h4 id=&#34;第二阶段输出&#34;&gt;第二阶段输出&lt;/h4&gt;&#xA;&lt;p&gt;fixedMissPred：对每条指令，PredChecker检查出的存在预测错误的情况，fixedMissPred_i为真表示这条指令存在预测错误&lt;/p&gt;&#xA;&lt;p&gt;fixedTarget：对每条指令，给出修复过的下一条指令的位置（可以是常规的pc+2或+4，或者如果是跳转指令，给出跳转目标）。&lt;/p&gt;&#xA;&lt;p&gt;jalTarget：对每条指令，给出跳转目标。&lt;/p&gt;&#xA;&lt;p&gt;faultType：每条指令的错误类型，取指范围包含noFault，jalFault，retFault，targetFault，notCFIFault，invalidTaken，jalrFault，分别对应数字0～6&lt;/p&gt;&#xA;&lt;h2 id=&#34;predchecker测试点和功能点&#34;&gt;PredChecker测试点和功能点&lt;/h2&gt;&#xA;&lt;h3 id=&#34;功能点1-bpu预测信息的jal预测错误检查&#34;&gt;功能点1 BPU预测信息的JAL预测错误检查&lt;/h3&gt;&#xA;&lt;p&gt;PredChecker会对传入的预测块进行JAL预测错误预检查并修正指令有效范围向量和预测的跳转指令。&lt;/p&gt;&#xA;&lt;p&gt;对这一模块的测试，我们分为两部分：正确的输入是否会误检和确有JAL检测错误的预测块输入能否检出。&lt;/p&gt;&#xA;&lt;p&gt;对于误检，我们设计如下的测试点:&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.1.1&lt;/td&gt;&#xA;          &lt;td&gt;误检测试1&lt;/td&gt;&#xA;          &lt;td&gt;预测块中没有JAL指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JAL预测错误。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.1.2&lt;/td&gt;&#xA;          &lt;td&gt;误检测试2&lt;/td&gt;&#xA;          &lt;td&gt;预测块中有JAL指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JAL预测错误。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;对于JAL预测错误的正确检验，我们设计如下的测试点：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.2.1&lt;/td&gt;&#xA;          &lt;td&gt;存在JAL未预测&lt;/td&gt;&#xA;          &lt;td&gt;预测块中存在JAL指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出JAL预测错误。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.2.2&lt;/td&gt;&#xA;          &lt;td&gt;预测的JAL并非第一条&lt;/td&gt;&#xA;          &lt;td&gt;预测块中存在JAL指令，但是BPU预测信息取的跳转指令在第一条JAL指令之后，检查PredChecker是否能检测出JAL预测错误。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;功能点2-bpu预测信息的ret预测错误检查&#34;&gt;功能点2 BPU预测信息的RET预测错误检查&lt;/h3&gt;&#xA;&lt;p&gt;PredChecker会对传入的预测块进行RET预测错误预检查并修正指令有效范围向量和新的预测结果。&lt;/p&gt;</description>
    </item>
    <item>
      <title>PreDecode</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/01_predecode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/01_predecode/</guid>
      <description>&lt;div class=&#34;ifu-ctx&#34;&gt;&#xA;&lt;h1 id=&#34;子模块predecoder简介&#34;&gt;子模块：PreDecoder简介&lt;/h1&gt;&#xA;&lt;p&gt;预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。&lt;/p&gt;&#xA;&lt;p&gt;所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。&lt;/p&gt;&#xA;&lt;p&gt;预译码器的输出是：16x4B的拼接指令码；对每个4B指令码，该条指令是否为RVI或RVC指令（RVC指令只考虑该4B的低2B）；对每个4B指令码，该条指令的跳转偏移；两个16位的有效指令开始向量，其中第一种向量假定当前预测块的起始2字节为一条有效指令的开始，而第二种向量假定当前预测块的起始2字节为一条有效RVI指令的结束（但是由于第二种向量的前两位必然为0和1,所以编译优化后，第二种向量实际只有14个信号，表示2-15位；同理，第1种向量的第0位因为恒为1,所以也被优化）&lt;/p&gt;&#xA;&lt;h3 id=&#34;功能介绍&#34;&gt;功能介绍&lt;/h3&gt;&#xA;&lt;h3 id=&#34;指令码生成&#34;&gt;指令码生成&lt;/h3&gt;&#xA;&lt;p&gt;预译码器接受来自IFU完成指令切分的17 × 2字节的初始指令码，并以4字节为窗口，2字节为步进长度，&#xA;从第1个2字节开始，直到第16个2字节，选出总共16个4字节的指令码。&lt;/p&gt;&#xA;&lt;h3 id=&#34;预译码信息生成&#34;&gt;预译码信息生成&lt;/h3&gt;&#xA;&lt;p&gt;预译码器根据指令码产生预译码信息，主要包括：是否是RVC指令、是否是CFI指令、&#xA;CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移。&lt;/p&gt;&#xA;&lt;p&gt;首先是判断是否是RVC指令，RVC指令的具体格式参阅RISCV手册的描述：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;RVCtable.png&#34; alt=&#34;RVC&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;其中，决定指令是否为RVC的部分在于指令的[1, 0]两位，不为3的情况下都是RVC指令。&lt;/p&gt;&#xA;&lt;p&gt;其余的指令性质判定功能（CFI类型、是否为call和ret）被时序优化到了F3PreDecoder中，不过也可以认为是PreDecoder的一部分，可以设置测试点进行测试&lt;/p&gt;&#xA;&lt;p&gt;最后比较麻烦的是CFI指令的目标地址计算偏移，主要是对J和BR分支指令进行的计算，这需要综合RVI和RVC中jal和br指令的结构。&#xA;首先，是手册中对于C.J的描述&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;JOP.png&#34; alt=&#34;JOP&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里对imm立即数的注解是，立即数的每一位最后对应到的是偏移的哪一位。&lt;/p&gt;&#xA;&lt;p&gt;所以，可以认为立即数是这么重组的：&lt;/p&gt;&#xA;&lt;p&gt;instr(12) + instr(8) + instr(10, 9) + instr(6) + instr(7) + instr(2) + instr(11) +instr(5,3) + &amp;ldquo;0&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;而RVI中，对于JAL指令，是这么定义的：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;RVIJ.png&#34; alt=&#34;RVIJ&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们可以类似地计算立即数。&lt;/p&gt;&#xA;&lt;p&gt;同样的，我们可以查询手册，参考BR类指令的立即数计算RVC和RVI指令对应的偏移。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;RVIBR.png&#34; alt=&#34;RVIBR&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;RVCBR.png&#34; alt=&#34;RVCBR&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;predecode接口说明&#34;&gt;PreDecode接口说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;输入接口&#34;&gt;输入接口&lt;/h3&gt;&#xA;&lt;p&gt;in_bits_data 17 x 2B的初始指令码，其中，每2个字节既可以代表一条RVC指令，也可以代表一个RVI指令的一半。&lt;/p&gt;&#xA;&lt;h3 id=&#34;输出接口&#34;&gt;输出接口&lt;/h3&gt;&#xA;&lt;p&gt;instr：拼接后的 16 x 4B的初始指令码&lt;/p&gt;&#xA;&lt;p&gt;jumpOffset：如果这条指令是跳转指令，则jumpOffset表示其跳转偏移&lt;/p&gt;&#xA;&lt;p&gt;pd：每条指令预译码信息，包括valid、isRVC、brType、isRet、isCall。其中第0条指令的valid已经被优化了&lt;/p&gt;&#xA;&lt;p&gt;hasHalfValid：这个信号需要和pd的valid结合起来看，PreDecode的一个功能是求出指令开始向量，也就是对每个4B的拼接指令，判断其低2B是否为一条有效指令的开始（即一条RVI指令的前半部分，或者一条RVC指令），但是需要分类讨论该预测块的第一个2B是否为一条有效指令的开始。hasHalfValid表示的是当前预测块的第一个2B指令为一条RVI指令的后半部分时，给出的指令开始向量。类似地，pd中的valid指的是当前预测块的第一个2B指令为一条指令的开始时，给出的指令开始向量。&lt;/p&gt;&#xA;&lt;h2 id=&#34;predecoder测试点和功能点&#34;&gt;PreDecoder测试点和功能点&lt;/h2&gt;&#xA;&lt;h3 id=&#34;功能点1-生成指令码&#34;&gt;功能点1 生成指令码&lt;/h3&gt;&#xA;&lt;p&gt;子模块：PreDecoder简介&lt;/p&gt;&#xA;&lt;p&gt;预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。&lt;/p&gt;&#xA;&lt;p&gt;所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。&lt;/p&gt;</description>
    </item>
    <item>
      <title>RVCExpander</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/03_ifu_rvc_exp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/03_ifu_rvc_exp/</guid>
      <description>&lt;div class=&#34;ifu-ctx&#34;&gt;&#xA;&lt;h1 id=&#34;子模块rvcexpander简介&#34;&gt;子模块：RVCExpander简介&lt;/h1&gt;&#xA;&lt;p&gt;RVCExpander是IFU的子模块，负责对传入的指令进行指令扩展，并解码计算非法信息。&lt;/p&gt;&#xA;&lt;p&gt;该模块接收的输入量是两个：一条RVC指令或者RVI指令；CSR对fs.status的使能情况。&lt;/p&gt;&#xA;&lt;p&gt;输出量也是两个：输入指令对应的RVI指令；RVC指令是否非法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;指令扩展&#34;&gt;指令扩展&lt;/h2&gt;&#xA;&lt;p&gt;如果是RVI指令，则无需扩展。&lt;/p&gt;&#xA;&lt;p&gt;否则对RVC指令，按照手册的约定进行扩展。&lt;/p&gt;&#xA;&lt;h2 id=&#34;非法指令判断&#34;&gt;非法指令判断&lt;/h2&gt;&#xA;&lt;p&gt;RVI指令永远判断为合法。&lt;/p&gt;&#xA;&lt;p&gt;对于RVC指令的判定，详细内容参阅20240411的RISCV手册的26.8节表格列出的指令条件。&lt;/p&gt;&#xA;&lt;h2 id=&#34;常量说明&#34;&gt;常量说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;常量名&lt;/th&gt;&#xA;          &lt;th&gt;常量值&lt;/th&gt;&#xA;          &lt;th&gt;解释&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;XLEN&lt;/td&gt;&#xA;          &lt;td&gt;64&lt;/td&gt;&#xA;          &lt;td&gt;通用寄存器位宽，决定指令扩展时使用rv32还是rv64还是rv128&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;fLen&lt;/td&gt;&#xA;          &lt;td&gt;64&lt;/td&gt;&#xA;          &lt;td&gt;香山支持d扩展，故为64&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;rvcexpander接口说明&#34;&gt;RVCExpander接口说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;输入接口&#34;&gt;输入接口&lt;/h3&gt;&#xA;&lt;p&gt;fsIsOff：表示CSR是否使能&lt;code&gt;fs.status&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;in：传入一个32位数据，其可以是一个完整的RVI指令，也可以是低16位RVC指令+高16位为RVI指令的一半（当然低16位也有可能是RVI指令的后半部分，但是RVCExpander不会区分，可以认为RVCExpander假定传入的32位数据的低16位一定为一条指令的开始）&lt;/p&gt;&#xA;&lt;h3 id=&#34;输出接口&#34;&gt;输出接口&lt;/h3&gt;&#xA;&lt;p&gt;ill：表示这条指令是否为非法指令&lt;/p&gt;&#xA;&lt;p&gt;out_bits：对RVI指令，直接返回，对RVC指令，返回扩展后的32位指令。&lt;/p&gt;&#xA;&lt;h2 id=&#34;功能点和测试点&#34;&gt;功能点和测试点&lt;/h2&gt;&#xA;&lt;h3 id=&#34;功能点1-指令扩展&#34;&gt;功能点1 指令扩展&lt;/h3&gt;&#xA;&lt;p&gt;RVCExpander负责接收预译码器拼接的指令码，并进行指令扩展，如果是16位RVC指令，需要按照RISCV手册的约定完成扩展&lt;/p&gt;&#xA;&lt;p&gt;对此，我们需要随机生成RVI指令和RVC指令，送入预译码器：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;          &lt;td&gt;RVI指令保留&lt;/td&gt;&#xA;          &lt;td&gt;构造RVI指令传入，检查保留情况&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.2&lt;/td&gt;&#xA;          &lt;td&gt;RVC指令扩展&lt;/td&gt;&#xA;          &lt;td&gt;构造RVC指令传入，按手册检查扩展结果&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;功能点2-非法指令判断&#34;&gt;功能点2 非法指令判断&lt;/h3&gt;&#xA;&lt;p&gt;RVCExpander在解析指令时，如发现指令违反了手册的约定，则需要判定该指令非法&lt;/p&gt;&#xA;&lt;p&gt;对此，我们需要随机生成非法指令送入RVI中，并检测RVCExpander对合法位的校验；同时，我们还需要校验合法指令是否会被误判为非法指令：&lt;/p&gt;&#xA;&lt;p&gt;此外，需要判定C.fp指令在CSR未使能fs.status的情况下，能否将这类指令判定为非法。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.1&lt;/td&gt;&#xA;          &lt;td&gt;常规非法指令测试&lt;/td&gt;&#xA;          &lt;td&gt;随机构造非法RVC指令传入，检查判断结果&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.2&lt;/td&gt;&#xA;          &lt;td&gt;合法指令测试&lt;/td&gt;&#xA;          &lt;td&gt;随机构造合法RVC指令传入，检查判断结果&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.3&lt;/td&gt;&#xA;          &lt;td&gt;C.fp指令测试&lt;/td&gt;&#xA;          &lt;td&gt;CSR未使能fs.status的情况下，C.fp指令应该为非法&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;测试点汇总&#34;&gt;测试点汇总 &lt;a id=&#34;rvc_expander_functions&#34;&gt; &lt;/a&gt;&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;序号&lt;/th&gt;&#xA;          &lt;th&gt;功能&lt;/th&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;          &lt;td&gt;指令扩展&lt;/td&gt;&#xA;          &lt;td&gt;RVI指令保留&lt;/td&gt;&#xA;          &lt;td&gt;构造RVI指令传入，检查保留情况&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1.2&lt;/td&gt;&#xA;          &lt;td&gt;指令扩展&lt;/td&gt;&#xA;          &lt;td&gt;RVC指令扩展&lt;/td&gt;&#xA;          &lt;td&gt;构造RVC指令传入，按手册检查扩展结果&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.1&lt;/td&gt;&#xA;          &lt;td&gt;非法指令判断&lt;/td&gt;&#xA;          &lt;td&gt;非法指令测试&lt;/td&gt;&#xA;          &lt;td&gt;随机构造非法RVC指令传入，检查判断结果&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.2&lt;/td&gt;&#xA;          &lt;td&gt;非法指令判断&lt;/td&gt;&#xA;          &lt;td&gt;合法指令测试&lt;/td&gt;&#xA;          &lt;td&gt;随机构造合法RVC指令传入，检查判断结果&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.3&lt;/td&gt;&#xA;          &lt;td&gt;C.fp指令测试&lt;/td&gt;&#xA;          &lt;td&gt;CSR未使能fs.status的情况下，C.fp指令应该为非法&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;rvc扩展辅助阅读材料&#34;&gt;RVC扩展辅助阅读材料&lt;/h2&gt;&#xA;&lt;p&gt;为方便参考模型的书写，在这里根据20240411版本的手册内容整理了部分指令扩展的思路。&lt;/p&gt;</description>
    </item>
    <item>
      <title>StoreQueue</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/06_storequeue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/06_storequeue/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文档参考&lt;a href=&#34;https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ&#34;&gt;香山LSQ设计文档&lt;/a&gt;写成&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文档撰写的内容截至[ca892e73]&lt;/p&gt;&#xA;&lt;p&gt;请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！&lt;/p&gt;&#xA;&lt;h1 id=&#34;storequeue-简介&#34;&gt;StoreQueue 简介&lt;/h1&gt;&#xA;&lt;p&gt;StoreQueue是一个队列，用来装所有的 store 指令，功能如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在跟踪 store 指令的执行状态&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;存储 store 的数据，跟踪数据的状态（是否到达）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;为load提供查询接口，让load可以forward相同地址的store&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;负责 MMIO store和NonCacheable store的执行&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;将被 ROB 提交的 store 写到 sbuffer 中&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;维护地址和数据就绪指针，用于LoadQueueRAW的释放和LoadQueueReplay的唤醒&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;store进行了地址与数据分离发射的优化，即 StoreUnit 是 store 的地址发射出来走的流水线，StdExeUnit 是 store 的数据发射出来走的流水线，是两个不同的保留站，store 的数据就绪了就可以发射到 StdExeUnit，store 的地址就绪了就可以发射到 StoreUnit。&lt;/p&gt;&#xA;&lt;h2 id=&#34;整体框图&#34;&gt;整体框图&lt;/h2&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../StoreQueue_structure.svg&#34;&#xA;         alt=&#34;StoreQueue结构示意图&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#xA;    图1：StoreQueue结构示意图&lt;br&gt;&lt;br&gt;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;StoreQueue最多可以存放64条指令，&lt;strong&gt;store queue 中重要的状态位有：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;allocated：RS在storeQueue队列有空闲时，会设置这个entry的allocated状态，开始记录这条store 的生命周期。同时发射到StoreUnit/ StdExeUnit 2条流水。当这条store指令被提交到Sbuffer时，allocated状态被清除。&lt;/li&gt;&#xA;&lt;li&gt;addrvalid：在StoreUnit的S1更新，表示是否已经经过了地址转换得到物理地址，用于 load forward 检查时的 cam 比较。&lt;/li&gt;&#xA;&lt;li&gt;datavalid：在StdExeUnit 的S1更新，表示store 的数据是否已经被发射出来，是否已经可用&lt;/li&gt;&#xA;&lt;li&gt;committed：在store 是否已经被 ROB commit 了&lt;/li&gt;&#xA;&lt;li&gt;pending：在StoreUnit的S2更新，在这条 store 是否是 MMIO 空间的 store，主要是用于控制 MMIO 的状态机&lt;/li&gt;&#xA;&lt;li&gt;mmio：在StoreUnit的S2更新，这条 store 是否是 MMIO 空间的 store，主要是用于控制对 sbuffer 的写&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;非对齐store指令&#34;&gt;非对齐store指令&lt;/h2&gt;&#xA;&lt;p&gt;StoreQueue支持处理非对齐的Store指令，每一个非对齐的Store指令占用一项，并在写入dataBuffer对地址和数据对齐后写入。&lt;/p&gt;</description>
    </item>
    <item>
      <title>StoreUnit</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/03_lsu/01_storeunit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/03_lsu/01_storeunit/</guid>
      <description>&lt;h4 id=&#34;本文档参考香山storeunit设计文档写成&#34;&gt;本文档参考&lt;a href=&#34;https://github.com/OpenXiangShan/XiangShan-Design-Doc/blob/master/docs/zh/memblock/LSU/index.md&#34;&gt;香山StoreUnit设计文档&lt;/a&gt;写成&lt;/h4&gt;&#xA;&lt;p&gt;请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！&lt;/p&gt;&#xA;&lt;h1 id=&#34;storeunit说明文档&#34;&gt;StoreUnit说明文档&lt;/h1&gt;&#xA;&lt;h2 id=&#34;文档概述&#34;&gt;文档概述&lt;/h2&gt;&#xA;&lt;p&gt;本文档描述了StoreUnit的结构与功能，并根据功能给出测试点参考，方便测试的参与者理解测试需求，编写相关测试用例。&#xA;StoreUnit 是存储指令执行单元 ，由多个协同工作的子模块组成，包括其五级流水线处理流程、支持的三种类型store指令（标量、向量、非对齐）、接口设计与信号交互逻辑。该模块用于执行Store类指令的地址生成与处理，是Load/Store流水线中的关键组成部分。&lt;/p&gt;&#xA;&lt;h2 id=&#34;术语说明&#34;&gt;术语说明&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;名称&lt;/th&gt;&#xA;          &lt;th&gt;定义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TLB（Translation Lookaside Buffer）&lt;/td&gt;&#xA;          &lt;td&gt;地址转换旁路缓冲器，用于虚拟地址到物理地址的快速转换&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;PMP（Physical Memory Protection）&lt;/td&gt;&#xA;          &lt;td&gt;物理内存访问权限检查机制&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;RAW（Read After Write）违例&lt;/td&gt;&#xA;          &lt;td&gt;写后读违例，表示一个load指令读取尚未写入的store数据&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;MMIO（Memory-Mapped Input/Output）&lt;/td&gt;&#xA;          &lt;td&gt;内存映射IO&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;存储指令执行&#34;&gt;存储指令执行&lt;/h3&gt;&#xA;&lt;p&gt;内存单元里包含2条Store地址流水线与2条Store数据流水线。各流水线独立接收并执行对应发射队列派发的指令。&lt;/p&gt;&#xA;&lt;h4 id=&#34;存储地址流水线&#34;&gt;存储地址流水线&lt;/h4&gt;&#xA;&lt;p&gt;&lt;img src=&#34;scalar.png&#34; alt=&#34;Scalar&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;由4级结构组成：&lt;/p&gt;&#xA;&lt;p&gt;​Store地址流水线（4级结构）​​&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;stage 0:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;计算VA地址&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;非对齐 &amp;gt; 向量 &amp;gt; 标量请求的优先级仲裁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;地址非对齐检查更新到uop.exceptionVec&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对地址的16字节边界检测&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;发出DTLB读请求到tlb&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;更新指令的掩码信息到s0_mask_out发送到StoreQueue&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;判断是否为数据宽度为128bits的store指令。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;stage 1:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;接收TLB地址转换响应，TLB若缺失则重试&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;查询LoadQueueRAW以进行违规检查&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;与加载单元s1和s2阶段的Load指令进行RAW冒险检测&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果DTLB hit，将store issue信息发送到后端&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;stage 2:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;mmio/PMP检查、检查原子操作权限&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;更新storeQueue中标记为地址就绪状态&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;更新DTLB结果通过feedback_slow更新到后端&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;stage 3:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;标量store发起写回，通过stout发送给后端&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;StoreQueue条目释放与状态清理&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;存储数据流水线&#34;&gt;存储数据流水线&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从发射队列（issue queue）接收数据&lt;/li&gt;&#xA;&lt;li&gt;将数据写回StoreQueue&lt;/li&gt;&#xA;&lt;li&gt;标记发射队列接收的数据为就绪状态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;向量存储指令执行&#34;&gt;向量存储指令执行&lt;/h3&gt;&#xA;&lt;p&gt;对于除 SEG指令外的向量内存访问指令，VSSplit 负责接收向量内存访问指令发射队列发送的微操作（uop），并将该微操作拆分为多个元素。随后VSSplit 将这些元素发送至StoreUnit 执行，执行流程与标量内存访问指令相同。执行完成后，元素会被写回至 VSMerge，其中 Merge 模块会将这些元素收集并组合成微操作，最终写回向量寄存器文件。&#xA;SEG 指令则由独立的 VSegmentUnit 模块处理。&lt;/p&gt;</description>
    </item>
    <item>
      <title>VirtualLoadQueue</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/05_virtualloadqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/01_lsq/05_virtualloadqueue/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文档参考&lt;a href=&#34;https://github.com/OpenXiangShan/XiangShan-Design-Doc/tree/master/docs/memblock/LSU/LSQ&#34;&gt;香山LSQ设计文档&lt;/a&gt;写成&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文档撰写的内容截至[ca892e73]&lt;/p&gt;&#xA;&lt;p&gt;请注意，本文档撰写的测试点仅供参考，如能补充更多测试点，最终获得的奖励可能更高！&lt;/p&gt;&#xA;&lt;h1 id=&#34;virtualloadqueue-简介&#34;&gt;VirtualLoadQueue 简介&lt;/h1&gt;&#xA;&lt;p&gt;Virtualloadqueue是一个队列，用于存储所有load指令的微操作(MicroOp)，并维护这些load指令之间的顺序，它的功能类似于重排序缓冲区（Reorder Buffer, ROB），但专注于load指令的管理。其主要功能是跟踪Load指令执行状态，以确保在并发执行的环境中，加载操作能够正确、有序地完成。&lt;/p&gt;&#xA;&lt;h2 id=&#34;整体框图&#34;&gt;整体框图&lt;/h2&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../VirtualLoadQueue_structure.png&#34;&#xA;         alt=&#34;VirtualLoadQueue结构示意图&#34;&#xA;         style=&#34;zoom:100%&#34;/&gt;&#xA;    &lt;br&gt;&#xA;    图1：VirtualLoadQueue结构示意图&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;Virtualloadqueue最多可以存放72条指令，dispatch阶段最多支持6条指令同时入队，最多支持8条指令出队。Virtualloadqueue对于每一个 entry 中的 load 指令都有若干状态位来标识这个 load 处于什么状态：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;allocated&lt;/strong&gt;：该项是否分配了load，用于确定load指令的生命周期。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;isvec&lt;/strong&gt;：该指令是否是向量load指令。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;committed&lt;/strong&gt;: 该项是否提交。&lt;/p&gt;&#xA;&lt;h1 id=&#34;功能简介&#34;&gt;功能简介&lt;/h1&gt;&#xA;&lt;mrs-functions&gt;&#xA;&lt;h2 id=&#34;模块功能说明&#34;&gt;模块功能说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;功能1load指令请求入队&#34;&gt;功能1：load指令请求入队&lt;/h3&gt;&#xA;&lt;p&gt;在调度阶段，保留站通过入队（enq）总线向VirtualLoadQueue发起入队请求，最多支持六组并发请求。成功入队的条件包括以下几点：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;StoreQueue 和 LoadQueue 有预留空间：确保LoadQueue有足够的容量来接收新的加载指令，以避免队列溢出。确保StoreQueu有预留空间则是基于数据一致性和避免指令阻塞的考虑，因为store指令入队阻塞可能会导致load指令无法正确读取或forward到数据。&lt;/li&gt;&#xA;&lt;li&gt;入队请求有效：入队请求必须是合法的，确保指令在调度过程中可以被正确处理。&lt;/li&gt;&#xA;&lt;li&gt;指令未被冲刷：确保指令在入队时没有被系统标记为无效或被撤销。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;成功入队之后，系统会执行以下操作：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;将指令的lqidx作为索引，将对应的allocated寄存器置1，bits信息写入uop寄存器。&lt;/li&gt;&#xA;&lt;li&gt;计算新的lqidx值，作为enq_resp传送给保留站。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;功能2接收load流水线写回的数据&#34;&gt;功能2：接收load流水线写回的数据&lt;/h3&gt;&#xA;&lt;p&gt;在 load 流水线的s3阶段，load unit会将指令执行的信息通过总线 ldin 写回到 VirtualLoadQueue。具体写回信息包括：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;是否发生了异常以及异常类型&lt;/li&gt;&#xA;&lt;li&gt;dcache是否命中&lt;/li&gt;&#xA;&lt;li&gt;tlb是否命中&lt;/li&gt;&#xA;&lt;li&gt;是否为mmio指令&lt;/li&gt;&#xA;&lt;li&gt;是否为软件预取或者硬件预取&lt;/li&gt;&#xA;&lt;li&gt;是否需要重发以及重发的原因&lt;/li&gt;&#xA;&lt;li&gt;写uop的使能信号&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;写回需要满足的条件如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;ldin 总线的 valid 信号需要拉高，表明当前正在进行有效的数据传输。&lt;/li&gt;&#xA;&lt;li&gt;指令不应需要重发（即 &lt;code&gt;need_rep&lt;/code&gt; 信号为 0），否则将影响写回的正常进行。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;在满足写回条件后，系统将生成相应的写回响应，具体包括以下几个方面：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果在执行过程中发生了异常、TLB命中或软件预取操作，&lt;code&gt;addrvalid&lt;/code&gt; 信号将被置为 1，表示地址信息有效。&lt;/li&gt;&#xA;&lt;li&gt;如果在执行过程中发生了异常、MMIO操作、DCACHE命中并且不需要重发，或是软件预取操作，&lt;code&gt;datavalid&lt;/code&gt; 信号将被置为 1，表示数据有效。&lt;/li&gt;&#xA;&lt;li&gt;指令在流水线的 S3 阶段有效（注意：不能是硬件预取指令）。当 &lt;code&gt;ldin&lt;/code&gt; 总线的写使能信号 &lt;code&gt;data_wen_dup&lt;/code&gt; 拉高时，将更新队列中的uop信息，以确保指令的状态及时反映。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;系统将&lt;code&gt;addrvalid&lt;/code&gt;和&lt;code&gt;datavalid&lt;/code&gt;分开进行处理是考虑到在一些情况下，地址可以被重用，而数据可能需要重新请求（如dcache miss/mmio/软件预取等）。分开标识可以减少流水线停顿，允许处理器在地址有效时继续执行其他指令，而不必等待数据有效性确认，从而优化整体性能。&lt;/p&gt;</description>
    </item>
    <item>
      <title>WayLookup</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/03_waylookup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/03_waylookup/</guid>
      <description>&lt;div class=&#34;icache-ctx&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;waylookup&#34;&gt;WayLookup&lt;/h2&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../waylookup_structure_rw.png&#34;&#xA;         alt=&#34;WayLookup 读写结构&#34;&#xA;         style=&#34;zoom:40%&#34;/&gt;&#xA;    &lt;br&gt;&#x9;&#x9;&#xA;    WayLookup 读写结构&#x9;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;br&gt;&#xA;&lt;div&gt;&#x9;&#x9;&#x9;&#xA;    &lt;center&gt;&#x9;&#xA;    &lt;img src=&#34;../waylookup_structure_update.png&#34;&#xA;         alt=&#34;WayLookup 更新结构&#34;&#xA;         style=&#34;zoom:40%&#34;/&gt;&#xA;    &lt;br&gt;&#x9;&#x9;&#xA;    WayLookup 更新结构&#x9;&#xA;    &lt;/center&gt;&#xA;&lt;/div&gt;&#xA;&lt;br&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内部是 FIFO 环形队列结构。暂存 IPrefetchPipe 查询 MetaArray 和 ITLB 得到的元数据，以备 MainPipe 使用。同时监听 MSHR 写入 SRAM 的 cacheline，对命中信息进行更新。&lt;/li&gt;&#xA;&lt;li&gt;通过 readPtr 和 writePtr 来管理读写位置。当有 flush 信号时，读写指针都会被重置。当写入数据时，写指针递增；读取时，读指针递增。需要处理队列的空和满的情况，empty 是读指针等于写指针，而 full 则是两者的值相同且标志位不同。&lt;/li&gt;&#xA;&lt;li&gt;处理 GPF 的部分，有一个 gpf_entry 寄存器，存储 GPF 的相关信息。当写入的数据包含 GPF 异常时，需要将信息存入 gpf_entry，并记录当前的写指针位置到 gpfPtr。当读取的时候，如果当前读指针的位置与 gpfPtr 匹配，并且 gpf_entry 有效，那么就将 GPF 信息一并输出。&lt;/li&gt;&#xA;&lt;li&gt;IPrefetchPipe 向其写入 WayLookupInfo 信息（包括 vSetIdx，waymask，ptag，itlb_exception，itlb_pbmt，meta_codes，gpaddr，isForVSnonLeafPTE）。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;写入前，需要考虑队列是否已满，以及是否有 GPF 阻塞。如果有 GPF 信息待读取且未被处理，则写入需要等待，防止覆盖 GPF 信息。写入时，如果数据中包含 GPF 异常，就将信息存入 gpf_entry，并更新 gpfPtr。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;MainPipe 从其读出 WayLookupInfo 信息。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在读取上，有两种情况：当队列为空但有写请求时，可以直接将写的数据旁路（bypass）给读端口；否则就从 entries 数组中读取对应读指针的数据。同时，如果当前读的位置存在 GPF 信息，就将 GPF 信息一起输出，并在读取后清除有效位。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;允许 bypass（当队列为空但有写请求时，可以直接将写的数据旁路给读端口），为了不将更新逻辑的延迟引入到 DataArray 的访问路径上，在 MSHR 有新的写入时禁止出队，MainPipe 的 S0 流水级也需要访问 DataArray，当 MSHR 有新的写入时无法向下走，所以该措施并不会带来额外影响。&lt;/li&gt;&#xA;&lt;li&gt;MissUnit 向其写入命中信息。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若是命中则将 waymask 更新 ICacheMissResp 信息（包括 blkPaddr，vSetIdx，waymask，data，corrupt）且 meta_codes 也更新，否则 waymask 清零。更新逻辑与 IPrefetchPipe 中相同，见 &lt;a href=&#34;https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/04_icache/01_iprefetchpipe/#%e5%91%bd%e4%b8%ad%e4%bf%a1%e6%81%af%e7%9a%84%e6%9b%b4%e6%96%b0&#34;&gt;IPrefetchPipe 子模块文档中的“命中信息的更新”&lt;/a&gt;一节。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;gpaddr-省面积机制&#34;&gt;GPaddr 省面积机制&lt;/h3&gt;&#xA;&lt;p&gt;由于 &lt;code&gt;gpaddr&lt;/code&gt; 仅在 guest page fault 发生时有用，并且每次发生 gpf 后前端实际上工作在错误路径上，后端保证会送一个 redirect（WayLookup flush）到前端（无论是发生 gpf 前就已经预测错误/发生异常中断导致的；还是 gpf 本身导致的），因此在 WayLookup 中只需存储 reset/flush 后第一个 gpf 有效时的 gpaddr。对双行请求，只需存储第一个有 gpf 的行的 &lt;code&gt;gpaddr。&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>功能详述</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_func/</guid>
      <description>&lt;h2 id=&#34;支持-sv48-分页机制&#34;&gt;支持 SV48 分页机制&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;SV48&lt;/code&gt; （&lt;code&gt;Supervisor-mode Virtual Memory&lt;/code&gt;）是一种基于 &lt;code&gt;RISC-V&lt;/code&gt; 的页表虚拟内存寻址模式，指定了 &lt;code&gt;48&lt;/code&gt; 位虚拟地址空间的结构，支持 &lt;code&gt;256TB&lt;/code&gt; 的虚拟内存地址空间。使用四级页表结构：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;Sv48_vaddr.png&#34; alt=&#34;Sv48_vaddr&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;Sv48_paddr.png&#34; alt=&#34;Sv48_paddr&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;Sv48_pagetable.png&#34; alt=&#34;Sv48_pagetable&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在 &lt;code&gt;SV48&lt;/code&gt; 的一个 &lt;code&gt;PTE&lt;/code&gt; 中包含了如下字段：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;N&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指示是否为 &lt;code&gt;NAPOT PTE&lt;/code&gt;。供 &lt;code&gt;Svnapot&lt;/code&gt; 扩展使用，如果未实现 &lt;code&gt;Svnapot&lt;/code&gt; 则该位必须由软件置 &lt;code&gt;0&lt;/code&gt;，否则应当出现 &lt;code&gt;Page Fault&lt;/code&gt;。目前香山昆明湖架构尚未支持此扩展。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;PBMT&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Page-Based Memory Types&lt;/code&gt;，即基于页面的内存类型，供 &lt;code&gt;Svpbmt&lt;/code&gt; 扩展使用，允许操作系统为每个页面指定不同的内存访问属性。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;0&lt;/code&gt;: &lt;code&gt;None&lt;/code&gt;，没有特定的内存属性。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;1&lt;/code&gt;: &lt;code&gt;NC&lt;/code&gt;，非缓存、幂等、弱序（&lt;code&gt;RVWMO&lt;/code&gt;），适用于主存。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;2&lt;/code&gt;: &lt;code&gt;IO&lt;/code&gt;，非缓存、非幂等、强序（&lt;code&gt;I/O&lt;/code&gt; 排序），适用于 &lt;code&gt;I/O&lt;/code&gt; 设备。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;3&lt;/code&gt;: &lt;code&gt;Reserved&lt;/code&gt;，保留供将来标准使用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;同样的，如果未实现 &lt;code&gt;Svpbmt&lt;/code&gt; 则这两位必须由软件置 &lt;code&gt;0&lt;/code&gt;，否则应当出现 &lt;code&gt;Page Fault&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;Reserved&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;保留位，供未来的标准使用。如果有任意一位不是 &lt;code&gt;0&lt;/code&gt; 则会触发 &lt;code&gt;PF&lt;/code&gt; 异常。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;PPN&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;表示物理页框号，指向实际的物理内存页。&lt;code&gt;PPN&lt;/code&gt; 与页面内偏移结合形成完整的物理地址，用于地址转换。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;RSW&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;保留供软件使用的位，通常用于特定的标志或操作，以便在软件实现中提供灵活性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;D&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;脏位，指示该页面是否被写入。如果该位为 &lt;code&gt;1&lt;/code&gt;，表示该页的数据已被修改，需在换出时写回到存储设备。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;A&lt;/code&gt;:&lt;/p&gt;</description>
    </item>
    <item>
      <title>关键信号说明</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/03_keysignal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/03_keysignal/</guid>
      <description>&lt;h2 id=&#34;相关-csr-寄存器&#34;&gt;相关 CSR 寄存器&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;csr&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Input&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;TlbCsrBundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;csr&lt;/code&gt;：包含 &lt;code&gt;satp&lt;/code&gt;、&lt;code&gt;vsatp&lt;/code&gt;、&lt;code&gt;hgatp&lt;/code&gt; 三个寄存器的信息以及一些权限信息。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;TlbCsrBundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;implicit&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;p&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;Parameters&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;XSBundle&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;satp&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;TlbSatpBundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;vsatp&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;TlbSatpBundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;hgatp&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;TlbHgatpBundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;priv&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Bundle&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;mxr&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Bool&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Bool&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;vmxr&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Bool&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;vsum&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Bool&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;virt&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Bool&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;spvp&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;W&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;imode&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;W&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;dmode&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;W&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;toPrintable&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;Printable&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#000&#34;&gt;p&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Satp mode:0x${Hexadecimal(satp.mode)} asid:0x${Hexadecimal(satp.asid)} ppn:0x${Hexadecimal(satp.ppn)} &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#000&#34;&gt;p&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Priv mxr:${priv.mxr} sum:${priv.sum} imode:${priv.imode} dmode:${priv.dmode}&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;TlbCsrBundle&lt;/code&gt; 中包含了 &lt;code&gt;satp&lt;/code&gt;、&lt;code&gt;vsatp&lt;/code&gt;、&lt;code&gt;hgatp&lt;/code&gt; 以及 &lt;code&gt;priv&lt;/code&gt; 特权标志。其中 &lt;code&gt;satp&lt;/code&gt; 与 &lt;code&gt;vsatp&lt;/code&gt; 通过 &lt;code&gt;TlbSatpBundle&lt;/code&gt; 实现，包括 &lt;code&gt;mode&lt;/code&gt;、&lt;code&gt;asid&lt;/code&gt;、&lt;code&gt;ppn&lt;/code&gt;、&lt;code&gt;changed&lt;/code&gt; 以及一个 &lt;code&gt;apply&lt;/code&gt; 方法：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;SatpStruct&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;implicit&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;p&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;Parameters&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;XSBundle&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;mode&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;4.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;W&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;asid&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;16.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;W&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ppn&lt;/span&gt;  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;44.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;W&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;TlbSatpBundle&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;implicit&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;p&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;Parameters&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;SatpStruct&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;changed&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Bool&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Todo: remove it&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;apply&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;satp_value&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;Unit&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#000&#34;&gt;require&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;satp_value&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;getWidth&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;XLEN&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sa&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;satp_value&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;asTypeOf&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;SatpStruct&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#000&#34;&gt;mode&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sa&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;mode&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#000&#34;&gt;asid&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sa&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;asid&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#000&#34;&gt;ppn&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sa&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ppn&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#000&#34;&gt;changed&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;DataChanged&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;sa&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;asid&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// when ppn is changed, software need do the flush&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&#x9;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;hgatp&lt;/code&gt; 通过 &lt;code&gt;TlbHgatpBundle&lt;/code&gt; 实现，区别在于将 &lt;code&gt;asid&lt;/code&gt; 替换为 &lt;code&gt;vmid&lt;/code&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>环境配置</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_env/</guid>
      <description>&lt;h2 id=&#34;wsl2ubuntu2204gtkwavewindows用户推荐使用&#34;&gt;WSL2+Ubuntu22.04+GTKWave（Windows用户推荐使用）&lt;/h2&gt;&#xA;&lt;p&gt;我们推荐 Windows10/11 用户通过 WSL2 进行开发，在此给出通过此方法进行环境配置的教程集锦，仅供参考。如环境安装过程中出现任何问题，欢迎在QQ群（群号：&lt;b&gt;976081653&lt;/b&gt;）中提出，我们将尽力帮助解决。此页面将收集大家提出的所有环境配置相关问题并提供解决方案，欢迎随时向我们提问！&lt;/p&gt;&#xA;&lt;h3 id=&#34;1在-windows-下安装-wsl2ubuntu2204&#34;&gt;1、在 Windows 下安装 WSL2（Ubuntu22.04）&lt;/h3&gt;&#xA;&lt;p&gt;参考资源：&lt;/p&gt;&#xA;&lt;p&gt;&amp;mdash; 微软官方教程：&lt;a href=&#34;https://learn.microsoft.com/zh-cn/windows/wsl/install&#34;&gt;如何使用 WSL 在 Windows 上安装 Linux&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&amp;mdash; 其它资源：&lt;a href=&#34;https://blog.csdn.net/HHHBan/article/details/126843786&#34;&gt;安装WSL2和Ubuntu22.04版本&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;2打开-wsl换源&#34;&gt;2、打开 WSL，换源&lt;/h3&gt;&#xA;&lt;p&gt;推荐使用清华源：&lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/&#34;&gt;清华大学开源软件镜像站-Ubuntu软件仓库&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;3配置验证环境&#34;&gt;3、配置验证环境&lt;/h3&gt;&#xA;&lt;p&gt;请参照&lt;a href=&#34;https://open-verify.cc/mlvp/docs/quick-start/installer/&#34;&gt;开放验证平台学习资源-快速开始-搭建验证环境&lt;/a&gt;配置环境。&lt;/p&gt;&#xA;&lt;p&gt;以下是示例方法：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 基本工具包&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; ~ &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sudo apt-get update&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo apt-get install -y build-essential cmake git wget curl lcov autoconf flex bison libgoogle-perftools-dev gcc python3.11 python3.11-dev python3.11-distutils python3-pip python-is-python3&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rm -rf /var/lib/apt/lists/*&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.11 &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;curl -sS https://bootstrap.pypa.io/get-pip.py &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;|&lt;/span&gt; python3.11&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# verilator&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone https://github.com/verilator/verilator.git&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; verilator&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git checkout v4.218 &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 4.218为最低需求版本，可自行查看并选择新版本&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;autoconf &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./configure &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -j&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;$(&lt;/span&gt;nproc&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; .. &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -rf verilator&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# verible&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;curl -sS https://github.com/chipsalliance/verible/releases/download/v0.0-3946-g851d3ff4/verible-v0.0-3946-g851d3ff4-linux-static-x86_64.tar.gz -o /tmp/&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tar -zxvf /tmp/verible-v0.0-3946-g851d3ff4-linux-static-x86_64.tar.gz -C /tmp/&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;copy /tmp/verible-v0.0-3946-g851d3ff4/bin/verible-* /usr/local/bin/&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo chmod +x /usr/local/bin/verible-*&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rm /tmp/verible-*&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# pcre2&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;curl -sS https://github.com/PCRE2Project/pcre2/releases/download/pcre2-10.45/pcre2-10.45.tar.gz -o /tmp/&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tar -zxvf /tmp/pcre2-10.45.tar.gz -C /tmp/&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; /tmp/pcre2-10.45&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./configure --prefix&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;/usr/local &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -j&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;$(&lt;/span&gt;nproc&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rm -rf /tmp/pcre2* &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; ~&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# swig &lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 注意不要使用 apt install swig，将会下载不符合最低要求的版本 4.0.2&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;curl -sS http://prdownloads.sourceforge.net/swig/swig-4.3.0.tar.gz -o /tmp/&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tar -zxvf /tmp/swig-4.3.0.tar.gz -C /tmp/&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; /tmp/swig-4.3.0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./configure --prefix&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;/usr/local &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -j&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;$(&lt;/span&gt;nproc&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rm -rf /tmp/swig* &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; ~&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 更新本地包&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;apt-get update &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get -y upgrade&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# picker&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone https://github.com/XS-MLVP/picker.git --depth&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; picker&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make init &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; .. &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -rf picker&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# UnityChipForXiangShan&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone https://github.com/XS-MLVP/UnityChipForXiangShan.git&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; UnityChipForXiangShan&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pip3 install --no-cache-dir -r requirements.txt&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;4使用-gtkwave-查看波形文件&#34;&gt;4、使用 GTKWave 查看波形文件&lt;/h3&gt;&#xA;&lt;p&gt;使用&lt;a href=&#34;https://co.ccslab.cn/tips/win-gtkwave/&#34;&gt;重庆大学硬件综合设计实验文档-Windows原生GTKWave&lt;/a&gt;给出的方法，可以通过在WSL中输入 &lt;code&gt;gtkwave.exe wave.fst&lt;/code&gt; 打开在 Windows 下安装的 GTKWave。请注意，gtkwave在使用中需要进入 fst 文件所在文件夹，否则会出现无法&#xA;initialize 的情况。&lt;/p&gt;</description>
    </item>
    <item>
      <title>目标验证单元</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/00_unitychip_for_xiangshan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/00_unitychip_for_xiangshan/</guid>
      <description>&lt;script src=&#34;../../js/echarts.min.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;../../js/chart_datatree.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script&gt;&#xA;function update_dut_charts(data_url){&#xA;    show_datatree_chart(&#34;datatree_chart&#34;, data_url)&#xA;}&#xA;&lt;/script&gt;&#xA;&lt;br&gt;&#xA;&lt;div id=&#34;datatree_chart&#34; style=&#34;width: 90%;height:800px;&#34;&gt;&lt;/div&gt;&#xA;&lt;div style=&#34;text-align: center; width: 100%;&#34;&gt;&#xA;&#xA;&lt;label&gt;当前版本：&lt;/label&gt;&#xA;&lt;select id=&#34;duturlSelect&#34; onchange=&#34;updateLink()&#34; style=&#34;border: 0px&#34;&gt;&#xA;    &#xA;    &#xA;    &#xA;    &#xA;    &#xA;    &lt;option value=&#34;20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty&#34; data-url=&#34;../../data/reports//UnityChipForXiangShan/20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty&#34;  selected&gt;20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty&lt;/option&gt;&#xA;    &#xA;&lt;/select&gt;&#xA;&lt;a id=&#34;dutgoLink&#34; href=&#34;#&#34; target=“_blank“&gt;查看测试报告&lt;/a&gt;&#xA;&#xA;&lt;script&gt;&#xA;function updateLink() {&#xA;    var select = document.getElementById(&#34;duturlSelect&#34;);&#xA;    var goLink = document.getElementById(&#34;dutgoLink&#34;);&#xA;    var opt = select.options[select.selectedIndex];&#xA;    if(!opt){&#xA;        return&#xA;    }&#xA;    var url = opt.getAttribute(&#34;data-url&#34;).replaceAll(&#34;/UnityChipForXiangShan/&#34;, &#34;&#34;);&#xA;    goLink.href = url;&#xA;    &#xA;    window[&#34;update_dut_charts&#34;](url + &#34;/ut_data_progress.json&#34;);&#xA;    &#xA;}&#xA;document.addEventListener(&#39;DOMContentLoaded&#39;, function() {&#xA;    updateLink()&#xA;});&#xA;&lt;/script&gt;&#xA;&#xA;&lt;/div&gt;&#xA;&lt;br&gt;&#xA;&lt;p&gt;上图共有&lt;em id=&#34;em_id_report_dut_total&#34;&gt;-&lt;/em&gt;个模块，默认情况下模块为灰色，当模块中的测试用例数大于&lt;em id=&#34;em_id_report_dut_min_light&#34;&gt;-&lt;/em&gt;时，该模块被完全点亮。目前已经完全点亮的模块为&lt;em  id=&#34;em_id_report_dut_lighted&#34;&gt;-&lt;/em&gt;个，待点亮的模块有&lt;em  id=&#34;em_id_report_dut_lighted_no&#34;&gt;-&lt;/em&gt;个。&lt;/p&gt;&#xA;&lt;h4 id=&#34;通用处理器模块简介&#34;&gt;通用处理器模块简介&lt;/h4&gt;&#xA;&lt;p&gt;高性能处理器是现代计算设备的核心，它们通常由三个主要部分组成：前端、后端和访存系统。这些部分协同工作，以确保处理器能够高效地执行复杂的计算任务。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;前端&lt;/strong&gt;：前端部分，也被称为指令获取和解码阶段，负责从内存中获取指令并将其解码成处理器可以理解的格式。这一阶段是处理器性能的关键，因为它直接影响到处理器可以多快地开始执行指令。前端通常包括指令缓存、分支预测单元和指令解码器。指令缓存用于存储最近访问过的指令，以减少对主内存的访问次数，从而提高处理速度。分支预测单元则尝试预测程序中的条件分支，以便提前获取和解码后续指令，这样可以减少等待分支结果的时间。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;后端&lt;/strong&gt;：后端部分，也称为执行阶段，是处理器中负责实际执行指令的地方。这一阶段包括了算术逻辑单元（ALU）、浮点单元（FPU）和各种执行单元。这些单元负责进行算术运算、逻辑运算、数据传输和其他处理器操作。后端的设计通常非常复杂，因为它需要支持多种指令集架构（ISA）并优化性能。为了提高效率，现代处理器通常采用超标量架构，这意味着它们可以同时执行多条指令。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;访存&lt;/strong&gt;：访存系统是处理器与内存之间交互的桥梁。它包括了数据缓存、内存控制器和高速缓存一致性协议。数据缓存用于存储处理器频繁访问的数据，以减少对主内存的访问次数。内存控制器负责管理处理器与内存之间的数据传输。高速缓存一致性协议确保在多处理器系统中，所有处理器看到的内存状态是一致的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;高性能处理器的设计需要在这三个部分之间找到平衡，以实现最佳的性能。这通常涉及到复杂的微架构设计，以及对处理器流水线的优化。&lt;/p&gt;</description>
    </item>
    <item>
      <title>微报告模板</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/03_lsu/00_template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/03_memblock/03_lsu/00_template/</guid>
      <description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;SCALAR_DISPATCH 测试点&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;功能描述&#34;&gt;功能描述&lt;/h3&gt;&#xA;&lt;p&gt;本测试点验证标量Store指令（如sb、sh、sw、sd）从发射队列派发到StoreUnit时，是否正确分配一个StoreQueue（SQ）条目。测试确保指令派发机制正常工作，包括SQ索引分配、状态标记和信号交互。这是StoreUnit最基本的功能，涉及指令派发流水线的初始阶段。&lt;/p&gt;&#xA;&lt;h3 id=&#34;输入参数&#34;&gt;输入参数&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;虚拟地址（vaddr）​​：0x1000&lt;/li&gt;&#xA;&lt;li&gt;存储数据（data）​​：0x12345678&lt;/li&gt;&#xA;&lt;li&gt;存储大小（size）​​：1、2、4、8字节&lt;/li&gt;&#xA;&lt;li&gt;首次派发标志（is_first_issue）​​：true或false&lt;/li&gt;&#xA;&lt;li&gt;指令类型​：通过fuOpType设置&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;输出验证&#34;&gt;输出验证&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;派发成功信号​：io_stin_ready和io_stin_valid同时为高，表示指令被接收。&lt;/li&gt;&#xA;&lt;li&gt;SQ条目分配​：io_lsq_valid为高，且io_lsq_bits_updateAddrValid为高，表示SQ地址更新有效。&lt;/li&gt;&#xA;&lt;li&gt;SQ索引范围​：io_lsq_bits_uop_sqIdx_value在0到SQ_SIZE-1之间（如0-63）。&lt;/li&gt;&#xA;&lt;li&gt;状态标记​：SQ条目中的valid位被设置为1，robIdx正确记录。&lt;/li&gt;&#xA;&lt;li&gt;后续准备​：io_stin_ready保持为高，表示可接收新指令。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;边界条件分析&#34;&gt;边界条件分析&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;不同存储大小​：测试了1字节（sb）、2字节（sh）、4字节（sw）和8字节（sd）指令，确保所有大小都能正确分配SQ条目。&lt;/li&gt;&#xA;&lt;li&gt;地址对齐​：测试对齐地址（如0x1000）和不对齐地址（如0x1001），验证地址计算不影响派发。&lt;/li&gt;&#xA;&lt;li&gt;首次派发与重发​：设置is_first_issue为true和false，模拟首次派发和重发场景，确保重发机制不干扰SQ分配。&lt;/li&gt;&#xA;&lt;li&gt;​SQ容量边界​：通过多次派发指令，测试SQ接近满时的行为，确保索引不溢出。&lt;/li&gt;&#xA;&lt;li&gt;信号时序​：验证在时钟上升沿信号稳定，避免时序问题导致派发失败。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;结果总结&#34;&gt;结果总结&lt;/h3&gt;&#xA;&lt;p&gt;测试通过，所有验证点均符合预期。标量Store指令派发功能正常，SQ条目分配正确，边界条件处理稳健。覆盖了标量存储的所有大小类型和常见地址场景，为后续流水线阶段提供了可靠基础。无异常或错误发生，测试完整性高。&lt;/p&gt;</description>
    </item>
    <item>
      <title>准备验证环境</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/01_verfiy_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/01_verfiy_env/</guid>
      <description>&lt;h4 id=&#34;基础环境需求&#34;&gt;基础环境需求&lt;/h4&gt;&#xA;&lt;p&gt;本项目基于&lt;code&gt;Python&lt;/code&gt;编程语言进行UT验证，采用的工具和测试框架为&lt;a href=&#34;https://github.com/XS-MLVP/picker&#34;&gt;picker&lt;/a&gt;和&lt;a href=&#34;https://github.com/XS-MLVP/toffee&#34;&gt;toffee&lt;/a&gt;，&lt;strong&gt;环境需求&lt;/strong&gt;如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Linux操作系统。建议WSL2下安装Ubuntu22.04。&lt;/li&gt;&#xA;&lt;li&gt;Python。建议Python3.11。&lt;/li&gt;&#xA;&lt;li&gt;picker。按照&lt;a href=&#34;https://open-verify.cc/mlvp/docs/quick-start/installer/&#34;&gt;快速开始&lt;/a&gt;中的提示安装最新版本。&lt;/li&gt;&#xA;&lt;li&gt;lcov。用于后续test阶段报告生成。使用包管理器即可下载：&lt;code&gt;sudo apt install lcov&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;环境配置完成&lt;/strong&gt;后，clone仓库：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone https://github.com/XS-MLVP/UnityChipForXiangShan.git&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; UnityChipForXiangShan&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pip3 install -r requirements.txt &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 安装 python 依赖（例如 toffee）&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;下载rtl代码&#34;&gt;下载RTL代码：&lt;/h4&gt;&#xA;&lt;p&gt;默认从仓库&lt;a href=&#34;https://github.com/XS-MLVP/UnityChipXiangShanRTLs&#34;&gt;https://github.com/XS-MLVP/UnityChipXiangShanRTLs&lt;/a&gt;中下载。用户也可以自行按照XiangShan文档编译生成RTL。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make rtl    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 该命令下载最新的 rtl 代码，解压至 rtl 目录，并创建软链接&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以用以下命令指定下载的 rtl 版本：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make rtl &lt;span style=&#34;color:#000&#34;&gt;args&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;rtl.version=\&amp;#39;openxiangshan-kmh-fad7803d-24120901\&amp;#39;&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所有RTL下载包请在&lt;a href=&#34;https://github.com/XS-MLVP/UnityChipXiangShanRTLs&#34;&gt;UnityChipXiangShanRTLs&lt;/a&gt;中查看。&lt;/p&gt;&#xA;&lt;p&gt;RTL压缩包的命名规范为：&lt;code&gt;名称-微架构-Git标记-日期编号.tar.gz&lt;/code&gt;，例如&lt;code&gt;openxiangshan-kmh-97e37a2237-24092701.tar.gz&lt;/code&gt;。在使用时，仓库代码会过滤掉 git 标记和后缀，例如通过 cfg.rtl.version 访问到的版本号为：&lt;code&gt;openxiangshan-kmh-24092701&lt;/code&gt;。压缩包内的目录结构为：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;openxiangshan-kmh-97e37a2237-24092701.tar.gz&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;└── rtl           &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 目录&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;|&lt;/span&gt;-- *.sv      &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 所有sv文件&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#4e9a06&#34;&gt;`&lt;/span&gt;-- *.v       &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 所有v文件&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;编译dut&#34;&gt;编译DUT&lt;/h4&gt;&#xA;&lt;p&gt;该过程的目的是将RTL通过picker工具打包为Python模块。可以通过make命令指定被打包DUT，也可以一次性打包所有DUT。&lt;/p&gt;&#xA;&lt;p&gt;如果想要自行打包某个dut，需要创建编写scripts目录中的build_ut_&amp;lt;name&amp;gt;.py脚本。这一脚本必须实现一个build方法，在打包时会被自动调用。此外还有一个line_coverage_files方法，用于指定行覆盖率参考的文件。&lt;/p&gt;&#xA;&lt;p&gt;picker的打包支持内部信号的加入，详见picker的--internal参数，传递给其一个自定义的yaml即可。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 调用scripts目录中的build_ut_&amp;lt;name&amp;gt;.py中的build方法，创建待验证的Python版DUT&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make dut &lt;span style=&#34;color:#000&#34;&gt;DUTS&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&amp;lt;name&amp;gt;  &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# DUTS的值如果有多个，需要用逗号隔开，支持通配符。DUTS默认值为 &amp;#34;*&amp;#34;，编译所有DUT&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 例如：&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make dut &lt;span style=&#34;color:#000&#34;&gt;DUTS&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;backend_ctrl_block_decode&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以&lt;code&gt;make dut DUTS=backend_ctrl_block_decode&lt;/code&gt;为例，命令执行完成后，会在dut目录下生成对应的Python包：&lt;/p&gt;</description>
    </item>
    <item>
      <title>运行测试</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/02_run_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/02_run_test/</guid>
      <description>&lt;p&gt;本项目基于PyTest测试框架进行验证。运行测试时，PyTest框架自动搜索所有&lt;code&gt;test_*.py&lt;/code&gt;文件，并自动执行其中所有以&lt;code&gt;test_&lt;/code&gt;开头的测试用例（Test Case）。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 执行所有ut_*目录中的test case&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make test_all&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 执行指定目录下的test case&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make &lt;span style=&#34;color:#204a87&#34;&gt;test&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&amp;lt;dir&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 例如执行ut_backend/ctrl_block/decode目录中所有的test case&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make &lt;span style=&#34;color:#204a87&#34;&gt;test&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;ut_backend/ctrl_block/decode&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可通过&lt;code&gt;args&lt;/code&gt;参数传递Pytest的运行参数，例如启动x-dist插件的多核功能：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make &lt;span style=&#34;color:#204a87&#34;&gt;test&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;args&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;-n 4&amp;#34;&lt;/span&gt;     &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 启用 4 个进程&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make &lt;span style=&#34;color:#204a87&#34;&gt;test&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;args&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;-n auto&amp;#34;&lt;/span&gt;  &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 让框架自动选择启用多少个进程&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;*注：x-dist可以在多节点上并发运行测试，可参考其&lt;a href=&#34;https://pytest-xdist.readthedocs.io/en/stable/remote.html&#34;&gt;文档&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;运行完成后，默认在&lt;code&gt;out/report&lt;/code&gt;目录会生成html版本的测试报告，其 html 文件可通过浏览器直接打开查看（VS Code IDE建议安装&lt;code&gt;Open In Default Browser&lt;/code&gt;插件）。&lt;/p&gt;&#xA;&lt;p&gt;运行测试主要完成以下三部分内容：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;按要求运行Test Case，可通过&lt;code&gt;cfg.tests&lt;/code&gt;中的选项进行配置&lt;/li&gt;&#xA;&lt;li&gt;统计测试结果，输出测试报告。有toffee-report自动生成 (总测试报告，所有Test的结果合并在一起)&lt;/li&gt;&#xA;&lt;li&gt;根据需要（&lt;code&gt;cfg.doc_result.disable = True&lt;/code&gt;）在测试报告上进行进一步数据统计&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>如何参与本项目</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/06_join_us/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/06_join_us/</guid>
      <description>&lt;h3 id=&#34;如何提交bug&#34;&gt;如何提交Bug&lt;/h3&gt;&#xA;&lt;p&gt;按 ISSUE 模板进行提交，标记上对应的标签（bug，bug等级等）&lt;/p&gt;&#xA;&lt;p&gt;对应模块的维护者进行检查，并修改他给出的标记和香山分支&lt;/p&gt;&#xA;&lt;h3 id=&#34;如何提交文档&#34;&gt;如何提交文档&lt;/h3&gt;&#xA;&lt;p&gt;本仓库文档以PR的形式在本仓库提交，DUT文档在仓库&lt;a href=&#34;https://github.com/XS-MLVP/UnityChipForXiangShan/tree/main/documents/content/zh-cn/docs/98_UT&#34;&gt;UnityChipForXiangShan/documents/content/zh-cn/docs/98_UT&lt;/a&gt;中进行提交。&lt;/p&gt;&#xA;&lt;p&gt;本项目欢迎任何人以&lt;a href=&#34;https://github.com/XS-MLVP/UnityChipForXiangShan/issues&#34;&gt;&lt;code&gt;ISSUE&lt;/code&gt;&lt;/a&gt;、&lt;a href=&#34;https://github.com/XS-MLVP/env-xs-ov-00-bpu/discussions&#34;&gt;&lt;code&gt;DISCUSS&lt;/code&gt;&lt;/a&gt;、&lt;a href=&#34;https://github.com/XS-MLVP/UnityChipForXiangShan/fork&#34;&gt;&lt;code&gt;Fork&lt;/code&gt;&lt;/a&gt;、&lt;a href=&#34;https://github.com/XS-MLVP/env-xs-ov-00-bpu/pulls&#34;&gt;&lt;code&gt;PR&lt;/code&gt;&lt;/a&gt;的方式参与。&lt;/p&gt;&#xA;&lt;p&gt;万众一芯QQ交流群：&lt;/p&gt;&#xA;&lt;image src=&#34;600480230.jpg&#34; alter=&#34;600480230&#34; width=300px /&gt;</description>
    </item>
    <item>
      <title>模板-PR</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/08_template_pr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/08_template_pr/</guid>
      <description>&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000080;font-weight:bold&#34;&gt;# Description&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Please include a summary of the changes and the related issue. &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Please also include relevant motivation and context. &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;List any dependencies that are required for this change.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Fixes # (issue)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## Type of change&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Please delete options that are not relevant.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; Bug fix (non-breaking change which fixes an issue)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; New feature (non-breaking change which adds functionality)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; Breaking change (fix or feature that would cause existing functionality to not work as expected)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; This change requires a documentation update&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000080;font-weight:bold&#34;&gt;# How Has This Been Tested?&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Please describe the tests that you ran to verify your changes. Provide instructions so we can reproduce. &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Please also list any relevant details for your test configuration&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; Test A&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [x]&lt;/span&gt; Test B&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;**Test Configuration**&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;*&lt;/span&gt; Firmware version:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;*&lt;/span&gt; Hardware:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;*&lt;/span&gt; Toolchain:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;*&lt;/span&gt; SDK:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000080;font-weight:bold&#34;&gt;# Checklist:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; My code follows the style guidelines of this project&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; I have performed a self-review of my code&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; I have commented my code, particularly in hard-to-understand areas&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; I have made corresponding changes to the documentation&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; My changes generate no new warnings&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; I have added tests that prove my fix is effective or that my feature works&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; New and existing unit tests pass locally with my changes&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; Any dependent changes have been merged and published in downstream modules&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;展示效果如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>模板-ISSUE</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/09_template_issue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/09_template_issue/</guid>
      <description>&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## Description&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;A brief description of the issue.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## Steps to Reproduce&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;1.&lt;/span&gt; Describe the first step&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;2.&lt;/span&gt; Describe the second step&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;3.&lt;/span&gt; Describe the third step&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;4.&lt;/span&gt; ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## Expected Result&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Describe what you expected to happen.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## Actual Result&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Describe what actually happened.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## Screenshots&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;If applicable, add screenshots to help explain your problem.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## Environment&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;-&lt;/span&gt; OS: [e.g. Windows 10, macOS 10.15, Ubuntu 20.04]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;-&lt;/span&gt; Browser: [e.g. Chrome 86, Firefox 82, Safari 14]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;-&lt;/span&gt; Version: [e.g. 1.0.0]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## Additional Information&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Add any other context about the problem here.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;展示效果如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>模板-UT-README</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/10_template_ut_readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/10_template_ut_readme/</guid>
      <description>&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000080;font-weight:bold&#34;&gt;# 模块名称&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 测试目标&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;测试目标&lt;/span&gt;&lt;span style=&#34;color:#a40000&#34;&gt;、&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;测试方法描述&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 测试环境&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;测试环境描述&lt;/span&gt;&lt;span style=&#34;color:#a40000&#34;&gt;，&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;依赖描述&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 功能检测&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;给出目标待测功能与对应的检测方法&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;|序号|所属模块|功能描述|检查点描述|检查标识|检查项|&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;|-|-|-|-|-|-|&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;|-|-|-|-|-|-|&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 验证接口&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;接口的描述&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 用例说明&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;#### 测试用例1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;|步骤|操作内容|预期结果|覆盖功能点|&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;|-|-|-|-|&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;|-|-|-|-|&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;#### 测试用例2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;|步骤|操作内容|预期结果|覆盖功能点|&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;|-|-|-|-|&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;|-|-|-|-|&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 目录结构&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;对本模块的目录结构进行描述&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;## 检测列表&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#800080;font-weight:bold&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; 本文档符合指定[模板]()要求&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; Env提供的API不包含任何DUT引脚和时序信息&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; Env的API保持稳定（共有[ X ]个）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; Env中对所支持的RTL版本（支持版本[ X ]）进行了检查&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; 功能点（共有[ X ]个）与[设计文档]()一致&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; 检查点（共有[ X ]个）覆盖所有功能点&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; 检查点的输入不依赖任何DUT引脚，仅依赖Env的标准API&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; 所有测试用例（共有[ X ]个）都对功能检查点进行了反标&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; 所有测试用例都是通过 assert 进行的结果判断&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; 所有DUT或对应wrapper都是通过fixture创建&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; 在上述fixture中对RTL版本进行了检查&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; 创建DUT或对应wrapper的fixture进行了功能和代码行覆盖率统计&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;- [ ]&lt;/span&gt; 设置代码行覆盖率时对过滤需求进行了检查&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;展示效果如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>常用API</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/95_api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/95_api/</guid>
      <description>&lt;h2 id=&#34;comm-模块&#34;&gt;comm 模块&lt;/h2&gt;&#xA;&lt;p&gt;在comm中提供了部分可公用的API，可通过以下方式进行调用：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# import all&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# or direct import functions you need&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;com&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;function_you_need&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# or access from module&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;function_you_need&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;cfg-子模块&#34;&gt;cfg 子模块&lt;/h3&gt;&#xA;&lt;h4 id=&#34;get_configcfgnone&#34;&gt;get_config(cfg=None)&lt;/h4&gt;&#xA;&lt;p&gt;获取当前的Config配置&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;输入：如果cfg不为空，则返回cfg。否则则自动通过toffee获取全局Config。&lt;/li&gt;&#xA;&lt;li&gt;返回：Config对象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;cfg&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;get_config&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;print&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cfg&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;rtl&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;version&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;cfg_as_strcfg-cfgobject&#34;&gt;cfg_as_str(cfg: CfgObject):&lt;/h4&gt;&#xA;&lt;p&gt;把config对象转换为字符类型&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;输入：Config对象&lt;/li&gt;&#xA;&lt;li&gt;返回：编码后的Config对象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;cfg_str&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cfg_as_str&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;get_config&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;())&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;cfg_from_strcfg_str&#34;&gt;cfg_from_str(cfg_str)&lt;/h4&gt;&#xA;&lt;p&gt;把字符类型的Config对象还原&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;输入：编码后的Config对象&lt;/li&gt;&#xA;&lt;li&gt;返回：Config对象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;cfg&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cfg_from_str&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cfg_str&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;dump_cfgcfg-cfgobject--none-cfg_filenone&#34;&gt;dump_cfg(cfg: CfgObject = None, cfg_file=None)&lt;/h4&gt;&#xA;&lt;p&gt;把config对象保持到文件&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;输入：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;cfg 需要保存的config&lt;/li&gt;&#xA;&lt;li&gt;cfg_file 目标文件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;cfg&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;get_config&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dump_cfg&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cfg&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;config.yaml&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;functions-子模块&#34;&gt;functions 子模块&lt;/h3&gt;&#xA;&lt;h4 id=&#34;get_log_dirsubdir-cfgnone&#34;&gt;get_log_dir(subdir=&amp;quot;&amp;quot;, cfg=None)&lt;/h4&gt;&#xA;&lt;p&gt;获取日志目录&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;输入：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;subdir： 子目录&lt;/li&gt;&#xA;&lt;li&gt;cfg：配置文件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;输出：日志目录&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;my_log&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;comm&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;get_log_dir&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;my_log&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;print&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;my_log&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# /workspace/UnityChipForXiangShan/out/log/my_log&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;get_out_dirsubdir-cfgnone&#34;&gt;get_out_dir(subdir=&amp;quot;&amp;quot;, cfg=None)&lt;/h4&gt;&#xA;&lt;p&gt;获取输出目录&lt;/p&gt;</description>
    </item>
    <item>
      <title>其他</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/96_others/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/96_others/</guid>
      <description>&lt;h2 id=&#34;测试用例管理&#34;&gt;测试用例管理&lt;/h2&gt;&#xA;&lt;p&gt;如果测试用例和目标RTL版本紧密相关，RTL发生变化，之前的测试用例不一定适用。此外，不同场景下有不同需求，例如验证测试环境时，不运行耗时太长的用例等。因此需要对用例进行管理，让用户能在在特定场景下跳过某些用例。为了实现该目标，我们需要通过&lt;code&gt;pytest.mark.toffee_tags&lt;/code&gt;对于每个用例进行tag和version标记。然后在配置文件中设置需要跳过哪些tag或者只运行哪些tag的测试。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5c35cc;font-weight:bold&#34;&gt;@pytest.mark.toffee_tags&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;my_tag&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;version1 &amp;lt; version13&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;test_case_1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;():&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例如上述&lt;code&gt;test_case_1&lt;/code&gt;被标记上了标签&lt;code&gt;my_tag&lt;/code&gt;，支持版本设置为&lt;code&gt;version1&lt;/code&gt;到&lt;code&gt;version13&lt;/code&gt;。因此可以在配置文件中指定&lt;code&gt;test.skip-tags=[&amp;quot;my_tag&amp;quot;]&lt;/code&gt;，来表示运行过程中跳过该用例。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;pytest.mark.toffee_tags&lt;/code&gt;的参数说明如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5c35cc;font-weight:bold&#34;&gt;@pytest.mark.toffee_tags&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;tag&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Optional&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;list&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;str&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;     &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 用例标签&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;version&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Optional&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;list&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;str&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[],&lt;/span&gt;   &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 用例rtl版本需求&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;skip&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;callable&lt;/span&gt;               &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;None&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 自定义是否调过该用例，skip(tag, version, item): (skip, reason)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;toffee_tags&lt;/code&gt;函数的参数&lt;code&gt;tag&lt;/code&gt;支持&lt;code&gt;str&lt;/code&gt;和&lt;code&gt;list[str]&lt;/code&gt;类型。&lt;code&gt;version&lt;/code&gt;参数也可以是&lt;code&gt;str&lt;/code&gt;和&lt;code&gt;list[str]&lt;/code&gt;类型，当为&lt;code&gt;list&lt;/code&gt;类型时，进行精确匹配，如果为&lt;code&gt;str&lt;/code&gt;则匹配规则如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;name-number1 &amp;lt; namer-number2:&lt;/code&gt; 表示版本需要在&lt;code&gt;number1&lt;/code&gt;和&lt;code&gt;number2&lt;/code&gt;之间（包含边界，&lt;code&gt;number&lt;/code&gt;表示数字，也可以为小数，eg &lt;code&gt;1.11&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;name-number1+&lt;/code&gt;：表示&lt;code&gt;number1&lt;/code&gt;版本以及以后的版本&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;name-number1-&lt;/code&gt;：表示&lt;code&gt;number1&lt;/code&gt;版本以及以前的版本&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;如果不存在上述情况，且有&lt;code&gt;*&lt;/code&gt;或者&lt;code&gt;?&lt;/code&gt;表示通配符类型。其他情况为精确匹配。&lt;/p&gt;&#xA;&lt;p&gt;预定义标签，可以在comm/constants.py中查看，例如：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# Predefined tags for test cases&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;TAG_LONG_TIME_RUN&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;LONG_TIME_RUN&amp;#34;&lt;/span&gt;  &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 运行时间长&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;TAG_SMOKE&lt;/span&gt;         &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;SMOKE&amp;#34;&lt;/span&gt;          &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 冒烟测试&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;TAG_RARELY_USED&lt;/span&gt;   &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;RARELY_USED&amp;#34;&lt;/span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 非常少用&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;TAG_REGRESSION&lt;/span&gt;    &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;REGRESSION&amp;#34;&lt;/span&gt;     &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 回归测试&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;TAG_PERFORMANCE&lt;/span&gt;   &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;PERFORMANCE&amp;#34;&lt;/span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 性能测试&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;TAG_STABILITY&lt;/span&gt;     &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;STABILITY&amp;#34;&lt;/span&gt;      &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 稳定测试&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;TAG_SECURITY&lt;/span&gt;      &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;SECURITY&amp;#34;&lt;/span&gt;       &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 安全测试&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;TAG_COMPATIBILITY&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;COMPATIBILITY&amp;#34;&lt;/span&gt;  &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 兼容测试&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;TAG_OTHER&lt;/span&gt;         &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;OTHER&amp;#34;&lt;/span&gt;          &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 其他&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;TAG_CI&lt;/span&gt;            &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;CI&amp;#34;&lt;/span&gt;             &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 集成测试&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;TAG_DEBUG&lt;/span&gt;         &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;DEBUG&amp;#34;&lt;/span&gt;          &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 测试&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;TAG_DEMO&lt;/span&gt;          &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;DEMO&amp;#34;&lt;/span&gt;           &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# demo&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在默认配置中(&lt;code&gt;config/_default.yaml&lt;/code&gt;)，会过滤掉：&lt;code&gt;LONG_TIME_RUN&lt;/code&gt;、&lt;code&gt;REGRESSION&lt;/code&gt;、&lt;code&gt;RARELY_USED&lt;/code&gt;、&lt;code&gt;CI&lt;/code&gt; 标记的测试。&lt;/p&gt;&#xA;&lt;p&gt;可以通过&lt;code&gt;@pytest.mark.toffee_tags&lt;/code&gt;可以为每个用例添加标签，也可以在模块中定义如下变量，实现对整个模块的所有测试用例添加标签。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;toffee_tags_default_tag&lt;/span&gt;     &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt;   &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 对应 tag 参数&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;toffee_tags_default_version&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt;   &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 对应 version 参数&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;toffee_tags_default_skip&lt;/span&gt;    &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;None&lt;/span&gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 对应 skip 参数&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;*注：本环境中的版本号会自动过滤掉git标记，例如下载的RTL名称为&lt;code&gt;openxiangshan-kmh-97e37a2237-24092701.tar.gz&lt;/code&gt;，则其版本号在本项目中为：&lt;code&gt;openxiangshan-kmh-24092701&lt;/code&gt;, 可通过&lt;code&gt;cfg.rtl.version&lt;/code&gt;或者&lt;code&gt;comm.get_config().rtl.version&lt;/code&gt;获得。&lt;/p&gt;</description>
    </item>
    <item>
      <title>必要规范</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/97_constraint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/97_constraint/</guid>
      <description>&lt;p&gt;为了方便将所有人的贡献集合在一起，需要在编码、环境、文档编写等方面采用相同的“规范”。&lt;/p&gt;&#xA;&lt;h3 id=&#34;环境要求&#34;&gt;环境要求&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;python：&lt;/strong&gt; 在python编码过程中，尽可能的采用标准库，采用兼容Python3大部分版本的通用语法（尽可能的在Python3.6 - Python3.12中通用），不要使用过旧或者过新的语法。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;操作系统：&lt;/strong&gt; 建议Ubuntu 22.04，windows下，建议使用WSL2环境。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;hugo&lt;/strong&gt; 建议版本 0.124.1（版本过旧不支持软连接）&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;少依赖&lt;/strong&gt; 尽可能少的使用第三方C++/C库&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;picker&lt;/strong&gt; 建议使用wheel安装picker工具和xspcomm库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;测试用例&#34;&gt;测试用例&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;代码风格&lt;/strong&gt; 建议采用 &lt;a href=&#34;https://peps.python.org/pep-0008/&#34;&gt;PEP 8 规范&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;build脚本&lt;/strong&gt; 需要按DUT的命名结构进行规范命名，不然无法正确收集验证结果。例如&lt;code&gt;backend.ctrl_block.decode&lt;/code&gt;UT在scripts目录中对应的build文件名称应该为&lt;code&gt;build_ut_backend_ctrl_block_decode.py&lt;/code&gt;(以固定前缀&lt;code&gt;build_ut_&lt;/code&gt;开始，点&lt;code&gt;.&lt;/code&gt;用下划线&lt;code&gt;_&lt;/code&gt;进行替换)。在脚本中实现 &lt;code&gt;build(cfg) -&amp;gt; bool&lt;/code&gt; 和 &lt;code&gt;line_coverage_files(cfg) -&amp;gt; list[str]&lt;/code&gt; 方法。&lt;code&gt;build&lt;/code&gt;用于编译DUT为&lt;code&gt;python&lt;/code&gt;模块，&lt;code&gt;line_coverage_files&lt;/code&gt;方法用于返回需要统计的代码行覆盖率文件。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;用例标签&lt;/strong&gt; 如果用例无法做到版本通用，需要用&lt;code&gt;pytest.mark.toffee_tags&lt;/code&gt;标记支持的版本。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;用例抽象&lt;/strong&gt; 编写的测试用例输入不能出现DUT的具体引脚等强耦合内容，只能调用基于DUT之上的函数封装。例如对于加法器 adder，需要把dut的目标功能封装为 &lt;code&gt;dut_wrapper.add(a: int, b: int) -&amp;gt; int, bool&lt;/code&gt;，在test_case中仅仅调用 &lt;code&gt;sum, c = add(a, b)&lt;/code&gt;进行测试。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;覆盖抽象&lt;/strong&gt; 在编写功能覆盖率时，其检查点函数的输入也不能有DUT引脚。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;环境抽象&lt;/strong&gt; 对于一个验证，通常分为2部分：Test Case 和 Env （用例以外的都统一称为Env，它包含DUT、驱动、监控等），其中Env需要提供对外的功能抽象接口，不能对外呈现出太多细节。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;测试说明&lt;/strong&gt; 在每个DUT的验证环境中，需要通过&lt;code&gt;README.md&lt;/code&gt;对该环境进行说明，例如需要对Env提供给Case的接口进行说明，目录结构说明等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;pr编写&#34;&gt;PR编写&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;标题&lt;/strong&gt; 简洁明了，能概括PR的主要内容。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;详细描述&lt;/strong&gt; 详细说明PR的目的，修改的内容以及相关背景信息。入解决已有的问题需要给出链接（例如Issue）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;关联问题&lt;/strong&gt; 在描述中关联相关问题，例如 &lt;code&gt;Fixes #123&lt;/code&gt;，以便在合并PR时关闭关联问题。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;测试&lt;/strong&gt; 需要进行测试，并对测试结果进行描述&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;文档&lt;/strong&gt; PR涉及到的文档需要同步修改&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;分解&lt;/strong&gt; 当PR涉及到的修改很多时，需要判断是否拆分成多个PR&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;检查清单&lt;/strong&gt; 检查编译是否通过、代码风格是否合理、是否测试通过、是否有必要的注释等&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;模板&lt;/strong&gt; 以及提供的PR模块请&lt;a href=&#34;08_pr_template/&#34;&gt;参考链接&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;issue编写&#34;&gt;ISSUE编写&lt;/h3&gt;&#xA;&lt;p&gt;要求同上&lt;/p&gt;</description>
    </item>
    <item>
      <title>维护者</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/99_maintain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/99_maintain/</guid>
      <description>&lt;p&gt;在提交 issue、pull request、discussion 时，如果指定对应模块的 maintainer 能更及时的得到响应。目前已有的维护人员如下（首字母排名）：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;验证工具：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;picker：&lt;a href=&#34;https://github.com/Makiras&#34;&gt;Makiras&lt;/a&gt;, &lt;a href=&#34;https://github.com/SFangYy&#34;&gt;SFangYy&lt;/a&gt;, &lt;a href=&#34;https://github.com/yaozhicheng&#34;&gt;yaozhicheng&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;toffee/toffe-test：&lt;a href=&#34;https://github.com/Miical&#34;&gt;Miical&lt;/a&gt;, &lt;a href=&#34;https://github.com/yaozhicheng&#34;&gt;yaozhicheng&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!-- &lt;script src=&#34;../../js/echarts.min.js&#34;&gt;&lt;/script&gt; --&gt;&#xA;&lt;script&gt;&#xA;function update_maintainers(data_url){&#xA;    updateMaintainers(data_url)&#xA;}&#xA;&lt;/script&gt;&#xA;&lt;div style=&#34;text-align: center; width: 100%;&#34;&gt;&#xA;&#xA;&lt;label&gt;当前版本：&lt;/label&gt;&#xA;&lt;select id=&#34;maintainersurlSelect&#34; onchange=&#34;updateLink()&#34; style=&#34;border: 0px&#34;&gt;&#xA;    &#xA;    &#xA;    &#xA;    &#xA;    &#xA;    &lt;option value=&#34;20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty&#34; data-url=&#34;../../data/reports//UnityChipForXiangShan/20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty&#34;  selected&gt;20250915034133-main-bcfbe7afca8060ad7ddee7f9fde14aed0da25f3c-dirty&lt;/option&gt;&#xA;    &#xA;&lt;/select&gt;&#xA;&lt;a id=&#34;maintainersgoLink&#34; href=&#34;#&#34; target=“_blank“&gt;&lt;/a&gt;&#xA;&#xA;&lt;script&gt;&#xA;function updateLink() {&#xA;    var select = document.getElementById(&#34;maintainersurlSelect&#34;);&#xA;    var goLink = document.getElementById(&#34;maintainersgoLink&#34;);&#xA;    var opt = select.options[select.selectedIndex];&#xA;    if(!opt){&#xA;        return&#xA;    }&#xA;    var url = opt.getAttribute(&#34;data-url&#34;).replaceAll(&#34;/UnityChipForXiangShan/&#34;, &#34;&#34;);&#xA;    goLink.href = url;&#xA;    &#xA;    window[&#34;update_maintainers&#34;](url + &#34;/ut_data_progress.json&#34;);&#xA;    &#xA;}&#xA;document.addEventListener(&#39;DOMContentLoaded&#39;, function() {&#xA;    updateLink()&#xA;});&#xA;&lt;/script&gt;&#xA;&#xA;&lt;/div&gt;&#xA;&lt;br&gt;&#xA;&#xA;&lt;style&gt;&#xA;#father-maintainers{&#xA;    font-size: 18px;&#xA;}&#xA;&#xA;#son-maintainers{&#xA;    font-size: 16px;&#xA;}&#xA;&#xA;#father-maintainers p, #son-maintainers .dynamic {&#xA;    margin-left: 20px;  &#xA;    text-indent: -20px;  &#xA;    padding-left: 20px;  &#xA;    position: relative;&#xA;}&#xA;&#xA;#father-maintainers p::before, #son-maintainers .dynamic::before {&#xA;    content: &#34;•&#34;;  &#xA;    font-size: 18px;  &#xA;    color: black;  &#xA;    position: absolute;&#xA;    left: 0;&#xA;    top: 0;&#xA;}&#xA;    &#xA;&lt;/style&gt;&#xA;    &#xA;    &#xA;&lt;div id=&#34;div-maintainers&#34;&gt;&#xA;    &lt;div id=&#34;father-maintainers&#34;&gt;&#xA;        &lt;p style=&#34;font-weight: bold;&#34;&gt;主UT模块&lt;/p&gt;</description>
    </item>
    <item>
      <title>搜索结果</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/search/</guid>
      <description></description>
    </item>
  </channel>
</rss>
