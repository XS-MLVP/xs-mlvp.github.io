<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XiangShan UT Docs on 万众一芯之香山处理器</title>
    <link>https://open-verify.cc/UnityChipForXiangShan/</link>
    <description>Recent content in XiangShan UT Docs on 万众一芯之香山处理器</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/UnityChipForXiangShan/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>添加编译脚本</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/01_build_script/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/01_build_script/</guid>
      <description>脚本目标 在scripts目录下使用python编写对应rtl的编译文件（例如build_ut_frontend_ifu_rvc_expander.py）。&#xA;该脚本的目标是提供 RTL 到 Python DUT 的编译、目标覆盖文件，以及自定义功能等内容。&#xA;创建过程 确定文件名称 在香山昆明湖 DUT 验证进展中选择需要验证的 UT，如果没有或者进一步细化，可通过编辑configs/dutree/xiangshan-kmh.yaml自行添加。&#xA;比如，我们要验证的是前端部分的ifu模块下的rvc_expander模块，那么需要在configs/dutree/xiangshan-kmh.yaml中添加对应的部分（目前yaml中已经有该模块了，此处为举例）：&#xA;name: &amp;#34;kmh_dut&amp;#34; desc: &amp;#34;所有昆明湖DUT&amp;#34; children: - name: &amp;#34;frontend&amp;#34; desc: &amp;#34;前端模块&amp;#34; children: - name: &amp;#34;ifu&amp;#34; desc: &amp;#34;指令单元 (Instruction Fetch Unit)&amp;#34; children: - name: &amp;#34;rvc_expander&amp;#34; desc: &amp;#34;RVC指令扩充器&amp;#34; 脚本文件的命名格式如下：&#xA;scripts/build_&amp;lt;顶层模块&amp;gt;_&amp;lt;下层模块名&amp;gt;_..._&amp;lt;目标模块名&amp;gt;.py 目前本项目内置了 4 个顶层模块：&#xA;ut_frontend 前端 ut_backend 后端 ut_mem_block 访存 ut_misc 其他 其中的子模块没有ut_前缀（顶层目录有该前缀是为了和其他目录区分开）。&#xA;例如验证目标 DUT 为rvc_expander模块：&#xA;该模块是属于前端的，所以顶级模块为ut_frontend，它的下层模块为ifu，目标模块为rvc_expander。&#xA;通过刚才我们打开的yaml文件也可以知道，frontend的children 为ifu，ifu的children 为rvc_expander。 所以，需要创建的脚本名称为build_ut_frontend_ifu_rvc_expander.py。&#xA;编写 build(cfg) -&amp;gt; bool 函数 build 函数定义如下：&#xA;def build(cfg) -&amp;gt; bool: &amp;#34;&amp;#34;&amp;#34;编译DUT Args: cfg: 运行时配置，可通过它访问配置项，例如 cfg.</description>
    </item>
    <item>
      <title>构建测试环境</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/02_build_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/02_build_env/</guid>
      <description>确定目录结构 UT(Unit Test, 单元测试)所在的目录位置的层级结构应该与名称一致，例如frontend.ifu.rvc_expander应当位于ut_frontend/ifu/rvc_expander目录，且每层目录都需要有__init__.py，便于通过 python 进行import。&#xA;本章节的文件为your_module_wrapper.py（如果你的模块是rvc_expander，那么文件就是rvc_expander_wrapper.py）。&#xA;wrapper 是包装的意思，也就是我们测试中需要用到的方法封装成和dut解耦合的API提供给测试用例使用。&#xA;*注：解耦合是为了测试用例和 DUT 解耦，使得测试用例可以独立于 DUT 进行编写和调试，也就是在测试用例中，不需要知道 DUT 的具体实现细节，只需要知道如何使用 API 即可。可以参照将验证代码与DUT进行解耦&#xA;该文件应该放于ut_frontend_or_backend/top_module/your_module/env（这里依然以rvc_expander举例：rvc_expander属于前端，其顶层目录则应该是ut_frontend；rvc_expander的顶层模块是ifu，那么次级目录就是ifu;之后的就是rvc_expander自己了；最后，由于我们是在构建测试环境，再建一级env目录。将它们连起来就是：ut_frontend_or_backend/top_module/your_module/env）目录下。&#xA;ut_frontend/ifu/rvc_expander ├── classical_version │ ├── env │ │ ├── __init__.py │ │ └── rvc_expander_wrapper.py │ ├── __init__.py │ └── test_rvc_expander.py ├── __init__.py ├── README.md └── toffee_version ├── agent │ └── __init__.py ├── bundle │ └── __init__.py ├── env │ ├── __init__.py │ └── ref_rvc_expand.py ├── __init__.py └── test ├── __init__.py ├── rvc_expander_fixture.</description>
    </item>
    <item>
      <title>添加测试用例</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/03_add_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/03_add_test/</guid>
      <description>命名要求 所有测试用例文件请以test_*.py的方式进行命名，*用测试目标替换（例如test_rvc_expander.py）。所有测试用例也需要以test_前缀开头。用例名称需要具有明确意义。&#xA;命名举例如下：&#xA;def test_a(): # 不合理，无法通过a判断测试目标 pass def test_rvc_expand_16bit_full(): # 合理，可以通过用例名称大体知道测试内容 pass 使用 Assert 在每个测试用例中，都需要通过assert来判断本测试是否通过。 pytest统计的是assert语句的结果，因此assert语句需要保证能够通过。&#xA;以下内容位于ut_frontend/ifu/rvc_expander/classical_version/test_rvc_expander.py中：&#xA;def rvc_expand(rvc_expander, ref_insts, is_32bit=False, fsIsOff=False): &amp;#34;&amp;#34;&amp;#34;compare the RVC expand result with the reference Args: rvc_expander (warpper): the fixture of the RVC expander ref_insts (list[int]]): the reference instruction list &amp;#34;&amp;#34;&amp;#34; find_error = 0 for insn in ref_insts: insn_disasm = disasmbly(insn) value, instr_ex = rvc_expander.expand(insn, fsIsOff) if is_32bit: assert value == insn, &amp;#34;RVC expand error, 32bit instruction need to be the same&amp;#34; if (insn_disasm == &amp;#34;unknown&amp;#34;) and (instr_ex == 0): debug(f&amp;#34;find bad inst:{insn}, ref: 1, dut: 0&amp;#34;) find_error +=1 elif (insn_disasm !</description>
    </item>
    <item>
      <title>代码覆盖率</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</guid>
      <description>代码覆盖率是一项评价指标，它衡量了被测代码中哪些部分被执行了，哪些部分没有被执行。通过统计代码覆盖率，可以评估测试的有效性和覆盖程度。&#xA;代码覆盖率包括：&#xA;行覆盖率(line coverage): 被测代码中被执行的行数，最简单的指标，一般期望达到 100%。 条件覆盖率(branch coverage): 每一个控制结构的每个分支是否均被执行。例如，给定一个 if 语句，其 true 和 false 分支是否均被执行？ 有限状态机覆盖率(fsm coverage): 状态机所有状态是否都达到过。 翻转覆盖率(toggle coverage): 统计被测代码中被执行的翻转语句，检查电路的每个节点是否都有 0 -&amp;gt; 1 和 1 -&amp;gt; 0 的跳变。 路径覆盖率(path coverage): 检查路径的覆盖情况。在 always 语句块和 initial 语句块中，有时会使用 if &amp;hellip; else 和 case 语句，在电路结构上便会产生一系列的数据路径。。 *我们主要使用的模拟器是 Verilator,优先考虑行覆盖率。Verilator 支持覆盖率统计，因此我们在构建 DUT 时，如果要开启覆盖率统计，需要在编译选项中添加-c参数。&#xA;本项目中相关涉及位置 开启覆盖率需要在编译时（使用 picker 命令时）加上“-c”参数（参考 picker 的参数解释），同时在文件中设置启用行覆盖率，这样在使用 toffee 测试时，才能够生成覆盖率统计文件。&#xA;结合上面的描述，在本项目中也就是编译，编写和启用行覆盖率函数和测试的时候会涉及到代码覆盖率：&#xA;添加编译脚本部分 编写编译脚本&#xA;# 省略前面 if not os.path.exists(get_root_dir(&amp;#34;dut/RVCExpander&amp;#34;)): info(&amp;#34;Exporting RVCExpander.sv&amp;#34;) s, out, err = exe_cmd(f&amp;#39;picker export --cp_lib false {get_rtl_dir(&amp;#34;rtl/RVCExpander.</description>
    </item>
    <item>
      <title>功能覆盖率</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</guid>
      <description>功能覆盖率（Functional Coverage）是一种用户定义的度量标准，用于度量验证中已执行的设计规范的比例。功能覆盖率关注的是设计的功能和特性是否被测试用例覆盖到了。&#xA;反标是指将功能点与测试用例对应起来。这样，在统计时，就能看到每个功能点对应了哪些测试用例，从而方便查看哪些功能点用的测试用例多，哪些功能点用的测试用例少，有利于后期的测试用例优化。&#xA;本项目中相关涉及位置 功能覆盖率需要我们先定义了才能统计，主要是在构建测试环境的时候涉及。&#xA;在构建测试环境中：&#xA;定义功能覆盖率： 创建了功能覆盖率组,添加观察点和反标 定义必要 fixture： 把统计结果传递给 toffee-report 统计覆盖率： 添加观察点和反标 其他：&#xA;在 Test case 中使用，可以在每个测试用例里也编写一个功能点。 功能覆盖率使用流程 指定 Group 名称 测试报告通过 Group 名字和 DUT 名字进行匹配，利用 comm.UT_FCOV 获取 DUT 前缀，例如在 Python 模块ut_frontend/ifu/rvc_expander/classical_version/env/rvc_expander_wrapper.py中进行如下调用：&#xA;from comm import UT_FCOV # 本模块名为：ut_frontend.ifu.rvc_expander.classical_version.env.rvc_expander_wrapper # 通过../../../去掉了classical_version和上级模块env，rvc_expander_wrapper # UT_FCOV会默认去掉前缀 ut_ g = fc.CovGroup(UT_FCOV(&amp;#34;../../../CLASSIC&amp;#34;)) # name = UT_FCOV(&amp;#34;../../../CLASSIC&amp;#34;) name 的值为frontend.ifu.rvc_expander.CLASSIC，在最后统计结果时，会按照最长前缀匹配到目标 UT（即匹配到：frontend.ifu.rvc_expander 模块）&#xA;创建覆盖率组 使用toffee的funcov可以创建覆盖率组。&#xA;import toffee.funcov as fc # 使用上面指定的GROUP名字 g = fc.CovGroup(name) 这两步也可以合成一句g = fc.CovGroup(UT_FCOV(&amp;quot;../../../CLASSIC&amp;quot;))。 创建的g对象就表示了一个功能覆盖率组，可以使用其来提供观察点和反标。</description>
    </item>
    <item>
      <title>支持 SV48 分页机制</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/01_sv48/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/01_sv48/</guid>
      <description>SV48 （Supervisor-mode Virtual Memory）是一种基于 RISC-V 的页表虚拟内存寻址模式，指定了 48 位虚拟地址空间的结构，支持 256TB 的虚拟内存地址空间。使用四级页表结构：&#xA;在 SV48 的一个 PTE 中包含了如下字段：&#xA;N:&#xA;指示是否为 NAPOT PTE。供 Svnapot 扩展使用，如果未实现 Svnapot 则该位必须由软件置 0，否则应当出现 Page Fault。目前香山昆明湖架构尚未支持此扩展。 PBMT:&#xA;Page-Based Memory Types，即基于页面的内存类型，供 Svpbmt 扩展使用，允许操作系统为每个页面指定不同的内存访问属性。 0: None，没有特定的内存属性。 1: NC，非缓存、幂等、弱序（RVWMO），适用于主存。 2: IO，非缓存、非幂等、强序（I/O 排序），适用于 I/O 设备。 3: Reserved，保留供将来标准使用。 同样的，如果未实现 Svpbmt 则这两位必须由软件置 0，否则应当出现 Page Fault。&#xA;Reserved:&#xA;保留位，供未来的标准使用。如果有任意一位不是 0 则会触发 PF 异常。 PPN:&#xA;表示物理页框号，指向实际的物理内存页。PPN 与页面内偏移结合形成完整的物理地址，用于地址转换。 RSW:&#xA;保留供软件使用的位，通常用于特定的标志或操作，以便在软件实现中提供灵活性。 D:&#xA;脏位，指示该页面是否被写入。如果该位为 1，表示该页的数据已被修改，需在换出时写回到存储设备。 A:&#xA;访问位，指示该页是否被访问过。如果该位为 1，表示该页已被读取或写入，用于页面替换算法。 G:&#xA;全局页位，指示该页是否是全局页。如果该位为 1，表示该页对所有进程可见，用于共享代码或数据。 U:</description>
    </item>
    <item>
      <title>支持缓存映射条目</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/02_tlbstorage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/02_tlbstorage/</guid>
      <description>TLB 中存储的条目并不是页表项 PTE，而是一个映射，一个从虚拟地址（来自于请求）到物理地址（来自于查找结果）的映射，当然还有一些访问所必须的信息。在目前的香山中 TLB 所存储的条目包含 tag[35]、asid[16]、vmid[14]、level[2]、ppn[33]、8 × ppn_low[3]、8 × valididx、8 × pteidx、s2xlate、perm[6]、g_perm[4]。为供以后使用 svpbmt 扩展，还存储了 pbmt 与 g_pbmt 字段。&#xA;tag[34:0]&#xA;tag，用于匹配条目。来源于 VPN 的高 35 位，在匹配的过程中，输入一个 38 位的 VPN，通过将输入的 VPN 的前 35 位与 tag 比较找到对应的条目，可以看到在一个条目中存储了 PPN 的高位部分和 8 个 ppn_low，之后将 VPN 的后三位作为索引，可以索引这 8 个 ppn_low，即可将 ppn 与 ppn_low[vpn_low] 拼接得到物理页框号。 asid[15:0]&#xA;地址空间标识符，用于区分不同的进程地址空间。 vmid[13:0]&#xA;虚拟机标识符，用于区分不同的虚拟机。 level[1:0]&#xA;指示页面的大小。0：4KB，1：2MB，2：1GB，3：512GB。 ppn[32:0]&#xA;物理页框号的高 33 位。在 Sv48 要求下本该是 41 位，出于面积考虑优化至 33 位（见支持 Sv48 分页机制部分）。 ppn_low[2:0]×8&#xA;物理页框号的低 3 位。用于 TLB 压缩（见支持 TLB 压缩部分）。 valididx×8</description>
    </item>
    <item>
      <title>支持保存全部大小页</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/03_pagesize/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/03_pagesize/</guid>
      <description>在 RISC-V 架构中，大小页机制旨在优化虚拟内存的使用效率和性能。Sv48 支持多种页面大小，包括 4KB、2MB、1GB 页，在标准的设计中没有定义 512GB 的页，理论上可行，但目前并没有这样的需要，512GB 的页也无法加载进内存，因此标准不做要求。但是出于对完整性的考虑，香山中依然实现了对 512GB 大页的支持。&#xA;在一般的应用程序需求中，4KB 的页面足够满足日常的使用，可以存储较小的数据结构以及程序等，常用于大多数应用程序中。然而，有的程序可能会需要频繁访问大的数据结构或数据集，这时引入大页可以提升内存访问效率。每个大页覆盖的虚拟地址空间更大，可以显著减少页表条目的数量；在映射相同数量的内存时，所需的页表条目会大幅降低，这可以减少内存开销、减少页表查找频率，从而优化内存访问速度，尤其对频繁访问大块内存的应用，能够显著提升性能。大页通常包含连续的数据，可以提高命中率，更有效地利用缓存资源。&#xA;当然，由于大页覆盖的地址空间较大，可能导致内存碎片，而未被使用的大页空间无法被其他请求有效利用，也会浪费一定的内存资源。同时，管理不同大小的页面为内存管理带来了额外的复杂性。在混合使用小页和大页时，操作系统需要复杂的算法来优化内存分配和使用。现代操作系统通常采用混合使用大小页的模式以满足不同应用的不同需求。&#xA;在香山的 TLB 中，支持保存任意大小的页面，这是通过保存页面的 level 来实现的。根据不同的 level，可以决定最终生成物理地址的方法（index 为页内偏移，来源于 vaddr 的低 12 位；ppn、ppn_low、tag 来源于 TLB 中存储的映射条目）：&#xA;level 页面大小 paddr[47:0] 0 4KB ppn[32:0] + ppn_low[2:0] + index[11:0] 1 2MB ppn[32:6] + tag[8:0] + index[11:0] 2 1GB ppn[32:15] + tag[17:0] + index[11:0] 3 512GB ppn[32:24] + tag[26:0] + index[11:0] </description>
    </item>
    <item>
      <title>支持 TLB 压缩</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/04_tlbcompression/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/04_tlbcompression/</guid>
      <description>随着虚拟地址空间的不断扩展，传统 TLB 的大小和效率面临挑战，可能不足以覆盖应用程序的需求，导致频繁的缺失（TLB miss），从而影响系统性能，导致性能瓶颈。为了应对这一问题，TLB 压缩技术应运而生，旨在提高 TLB 的有效性和性能。&#xA;在操作系统分配内存的时候，由于使用伙伴地址分配策略等原因，会倾向于将连续的物理页分配给连续的虚拟页。虽然随着程序的不断运行，页分配逐渐的从有序趋向于无序，但是这种页的相连性普遍存在，因此可以通过将多个连续的页表项在 TLB 硬件中合成为一个 TLB 项，以增大 TLB 容量。TLB 压缩通过优化页表结构，支持连续的映射，通过引入范围映射（range mapping）机制，一个 TLB 条目可以映射一段连续的虚拟地址到一段连续的物理地址。&#xA;在实际中，以香山昆明湖架构为例，在 TLB 中存储 35 位的 vpn_high（即 tag），剩下的三位用于索引对应的 ppn_low（一共有 8 个所以需要 3 位来索引）。每次匹配中，TLB 用传入的 vaddr[49:15]（高 35 位）与 tag 进行匹配，找到对应的条目，这个条目中可以存储 8 个 PTE，再根据 vaddr[14:12] 找到对应的 ppn_low，之后检查对应的 valididx 是否有效，如果有效说明 hit，将 ppn_low 与 ppn_high 拼接得到 PPN，再与 vaddr[11:0] 拼接得到 paddr。&#xA;在支持了 H 扩展后（见支持两阶段虚实地址翻译），TLB 压缩仅在 OnlyStage1 和 noS2xlate 下启用，在其他情况下不启用。&#xA;支持 TLB 压缩后 TLB 中缓存的条目会有所变化（表中未提及的条目即没有变化）：&#xA;是否压缩 tag ppn valididx pteidx ppn_low 否 38位 36位 不保存 不保存 不保存 是 35位 33位 8位 8位 8×3位 在支持了大小页的情况下，TLB 压缩在大页情况下（2MB/1GB/512GB）不启用，仅在查询结果为小页（4KB）情况下启用。大页在返回时会将 valididx 的 8 位全部设置为 1，而由于大页的查询过程中只需要 PPN 的高位，大页下不使用 ppn_low，ppn_low 的值在此时是未定义的。</description>
    </item>
    <item>
      <title>支持 Hypervisor 扩展与两阶段虚实地址翻译</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/05_hypervisor2leveltrans/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/05_hypervisor2leveltrans/</guid>
      <description>在 RISC-V 特权指令手册中定义了虚实地址的翻译过程：&#xA;设 a 为 satp.ppn × PAGESIZE，并设 i = LEVELS - 1。（对于 Sv48，PAGESIZE = 2^{12}，LEVELS = 4）此时，satp 寄存器必须处于活动状态，即有效的特权模式必须是 S 模式或 U 模式。&#xA;设 pte 为地址 a + va.vpn[i] × PTESIZE 处的 PTE 值。（对于 Sv48，PTESIZE = 8）如果访问 pte 违反了 PMA 或 PMP 检查，则引发与原始访问类型相应的访问错误异常。&#xA;如果 pte.v = 0，或者 pte.r = 0 且 pte.w = 1，或者 pte 中设置了任何为未来标准使用保留的位或编码，则停止并引发与原始访问类型相应的页面错误异常。&#xA;否则，PTE 是有效的。如果 pte.r = 1 或 pte.x = 1，则转到步骤 5。否则，此 PTE 是指向下一级页面表的指针。设 i = i - 1。如果 i &amp;lt; 0，则停止并引发与原始访问类型相应的页面错误异常。否则，设 a = pte.</description>
    </item>
    <item>
      <title>支持阻塞式与非阻塞式访问</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/06_blocknonblock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/06_blocknonblock/</guid>
      <description>阻塞式访问代表着 TLB 的端口同时仅支持一个请求，阻塞端口带 valid-ready 握手信号。在 TLB 准备好接收请求时，会将 ready 置 1，由外部检测到 ready 后会发送请求。请求到达 TLB 时 valid 为 1 则 TLB 接收请求并将 ready 置 0，不再接受新的请求。之后 TLB 会对请求进行匹配，查找结果，如果 miss 则发送 ptw 请求（同样为阻塞），等待直到 ptw 返回结果（物理地址或 pf 异常），然后 TLB 将结果保存并上报给请求方，再将 ready 置 1。&#xA;对于非阻塞式请求，仅带 valid 信号，每当 valid 置 1，TLB 即接受请求并在下一拍返回结果（hit/miss/异常），无论是否命中都能在请求下一拍得到结果。如果 miss 的话，TLB 在返回 miss 结果同时会发起 PTW 请求（非阻塞），PTW 接收到请求则进行处理，在处理完成后回填进 TLB 中，然后如果请求方再次发起请求就可以命中。在香山 ITLB 的具体实现中，TLB 本体虽然是非阻塞的，不存储请求的信息，但当前端发起的取指请求 miss 后，将会由前端进行调度不断发起相同取指请求直到 hit，才能将指令送到处理器进行处理，因此会体现出阻塞的效果。&#xA;请求来源 iCache IFU 请求数量 2 1 请求类型 非阻塞请求 阻塞请求 握手信号 仅带 valid 信号 带 valid 和 ready 信号 处理方式 可以继续处理其他指令 等待 iTLB 响应后继续处理指令 </description>
    </item>
    <item>
      <title>支持读取 PTW 返回条目</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/07_refill_from_ptw/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/07_refill_from_ptw/</guid>
      <description>每次 TLB 发生 miss 之后，会向 L2TLB 发送 Page Table Walk 请求。由于 TLB 与 L2TLB 之间有比较长的物理距离，需要在中间加拍，这项工作由 repeator 完成。同时，repeator 还需要对 PTW 请求进行过滤，以避免 TLB 中出现重复项，因此也被称为 filter。目前香山中 TLB 发出的 PTW 请求的内容包含 VPN、s2xlate、getGPA 三个信号以及必要的控制信号：&#xA;VPN：&#xA;虚拟页框号，TLB 在 miss 之后会将 VPN 发送给 PTW 用于索引对应的物理页，PTW 会将叶子页表的 PPN 返回给 TLB，下次 TLB 查询的时候就可以找到该页并可以通过页内偏移找到物理地址。 s2xlate：&#xA;两阶段地址转换标志，指示当前的两阶段地址转换模式。TLB 中该标志将通过 vsatp 与 hgatp 寄存器的 mode 域进行判断： s2xlate vsatp.mode hgatp.mode 0b00 0 0 0b01 1 0 0b10 0 1 0b11 1 1 getGPA：&#xA;指示当前 PTW 请求是否为请求客户机物理地址。用于客户机缺页等情况的处理（详见支持发生 GPF 时重新发起请求部分）。 在支持了 TLB 压缩后，PTW 返回的结果主要包括 resp_valid、tag[33:0]、asid[15:0]、perm[6:0]、level[1:0]、ppn[35:0]、addr_low[2:0]、ppn_low[2:0] × 8、valididx × 8、pteidx × 8、pf、af（各个信号的含义可见支持缓存映射条目部分）。TLB 接收到有效的 PTW resp 后即将这些条目存进自己的缓存中。</description>
    </item>
    <item>
      <title>支持回填条目与两阶段条目融合</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/08_refill2stage_fusion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/08_refill2stage_fusion/</guid>
      <description>参照支持缓存映射条目与支持读取 PTW 返回条目，对于主机地址转换（nos2xlate）的情况对应填入 entry 中的对应表项即可，此时访客有关信号无效。注意大页时，即 level 不为 0 时，ppn_low 无效。&#xA;TLB entry 填入的来自 PTW 的信号 s2xlate[1:0] 0b00 (nos2xlate) tag[34:0] s1.tag[34:0] asid[15:0] s1.asid[15:0] vmid[13:0] 无效 level[1:0] s1.level[1:0] ppn[32:0] s1.ppn[32:0] ppn_low[2:0]×8 s1.ppn_low_* valididx×8 s1.valididx_* pteidx×8 s1.pteidx_* perm_pf s1.pf perm_af s1.af perm_a s1.perm.a perm_g s1.perm.g perm_u s1.perm.u perm_x s1.perm.x gperm_gpf 无效 gperm_gaf 无效 gperm_a 无效 gperm_x 无效 s2xlate=0b00 时填入 TLB entry 示意表 在 OnlyStage1 的情况下，主机的异常信号以及部分不可复用的权限位无效，其余均与主机地址转换一致。&#xA;TLB entry 填入的来自 PTW 的信号 s2xlate[1:0] 0b01 (OnlyStage1) tag[34:0] s1.</description>
    </item>
    <item>
      <title>支持发生 GPF 时重新发起 PTW 请求</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/09_guest_page_fault/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/09_guest_page_fault/</guid>
      <description>在香山的 TLB 中并不会保存中间物理地址。在两阶段地址转换过程中，如果第一阶段发生缺页异常，即 PTW 返回 gpf，此时 TLB 将 PTW 返回的结果存入 TLB 项内，请求方再次请求的时候发现 gpf，此时 TLB 会返回 miss，即使已经存储了这个映射。同时，TLB 将发起带 getGPA 标志的 PTW 请求，请求这个虚拟地址，并维护一组寄存器暂存相关信号：&#xA;信号 作用 need_gpa 表示此时有一个请求正在获取 gpaddr need_gpa_robidx 存储请求的 ROB（Reorder Buffer）索引，用于跟踪请求来源，目前未使用 need_gpa_vpn[37:0] 存储请求的 vpn，即 50 位虚拟地址的高 38 位 need_gpa_gvpn[43:0] 存储获取的 gpaddr 的 gvpn，虚拟机通过转换得到的 56 位虚拟机物理地址的高 44 位，前六位在第二阶段地址转换中被要求为全 0 need_gpa_refill 表示该请求的 gpaddr 已经被填入 need_gpa_gvpn 每当 TLB 发起带 getGPA 标志的请求时，就会将 need_gpa 置 1，并将请求的 vpn 填入到 need_gpa_vpn 中，同时将 need_gpa_refill 置 0。当 PTW 返回结果的时候，TLB 将 PTW resp 中的 vpn 提取出来与 need_gpa_vpn 进行比较，判断是否是对之前 getGPA 请求的回应。如果是，那么将 PTW resp 中的 s2 tag 填入到 need_gpa_gvpn 中并将 need_gpa_refill 置 1，表示已经获取到需要的 gvpn。下一次 TLB 接收到相同请求时就可以通过 need_gpa_gvpn 得到 gpaddr，之后 TLB 会将 need_gpa 置 0，但保留其它寄存器，因此下次其它的请求发生 gpf 时也可以再次使用相同的 need_gpa_vpn 找到 paddr 而无需再次发起 PTW 请求。</description>
    </item>
    <item>
      <title>环境配置</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_env/</guid>
      <description>推荐使用WSL2+Ubuntu22.04+GTKWave 我们推荐Windows10/11用户通过WSL2进行开发，在此给出通过此方法进行环境配置的教程集锦，仅供参考。如环境安装过程中出现任何问题，欢迎在QQ群（群号：976081653）中提出，我们将尽力帮助解决。此页面将收集大家提出的所有环境配置相关问题并提供解决方案，欢迎随时向我们提问！&#xA;1、在Windows下安装WSL2（Ubuntu22.04） 参考资源：&#xA;&amp;mdash; 微软官方教程：如何使用 WSL 在 Windows 上安装 Linux&#xA;&amp;mdash; 其它资源：安装WSL2和Ubuntu22.04版本&#xA;2、打开WSL，换源 推荐使用清华源：清华大学开源软件镜像站-Ubuntu软件仓库&#xA;3、配置picker环境 请参照开放验证平台学习资源-快速开始-搭建验证环境配置picker环境。&#xA;4、使用 GTKWave 使用重庆大学硬件综合设计实验文档-Windows原生GTKWave给出的方法，可以通过在WSL中输入 gtkwave.exe wave.fst 打开在Windows下安装的GTKWave。</description>
    </item>
    <item>
      <title>支持 PLRU 替换算法</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/10_plru/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/10_plru/</guid>
      <description>LRU（Least Recently Used）算法核心思想就是替换掉最近最少使用的页，也就是最长时间没有访问的页。LRU 算法将内存中的每个页组织成了一个链表的形式，如图所示：&#xA;链表有两端，一端是最近最少使用的页，可以称为 LRU 端，另一端是最近刚刚使用的页，即最近使用最频繁的页，称之为 MRU（Most Recently Used）端。每次访问的时候如果命中，那么就将命中的页移动到 MRU 端，如果 miss 则触发缺页，此时需要加载页面。如果这时候内存已满，那么就需要进行页面替换，选择 LRU 端的页进行替换，并把新访问的页放在 MRU 端。这就是 LRU 替换算法，是 cache 替换的经典算法。&#xA;但是由于 LRU 需要为 cache 行维护一个链表数据结构，在多路组相联的 cache 行中需要为每一路配置链表并跟踪每一行的使用时间，LRU 算法有着巨大的开销。因此虽然 LRU 在页面替换中表现出色，也依然不常使用。&#xA;在香山的昆明湖架构中，TLB 采用 PLRU（pseudo-LRU）替换算法，详细来说是 tree-based PLRU 算法。假设当前 Cache 是 n 路组相联（n 一般是 2 的整数幂）的结构，那么需要定义 n-1 位用来进行二叉树索引，假设为 0 表示左，为 1 表示右，如图所示：&#xA;对目前的香山昆明湖架构来说，采用每路 48 cache 行的二路组相联结构下，PLRU 需要维护一个 48 项的链表和一个一级的二叉树（1 位），而采用 LRU 将需要维护一个 48 项的链表和 48 个 2 项的链表，有一定的开销优势，随着路数的增加，优势会更加明显；同时，对二叉树的维护成本也比链表更低。&#xA;当然，PLRU 多级二叉树的选择策略下并不能做到与 LRU 一样精确控制，每次二分地排除掉一半不一定能找到绝对 LRU 的条目。</description>
    </item>
    <item>
      <title>支持 SFENCE.VMA 指令</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/11_sfence_vma/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/11_sfence_vma/</guid>
      <description>SFENCE.VMA 指令（Supervisor Memory-Management Fence Instruction）是定义在 RISC-V 指令架构的指令：&#xA;在内存管理中，页表负责将虚拟地址映射到物理地址。当修改了页表后，这些修改不会自动在处理器的缓存中生效。为了确保后续的指令能使用更新后的页表，必须通过 SFENCE.VMA 指令来刷新这些缓存。此外，处理器在执行指令时，可能隐式地对内存管理数据结构进行读取和写入操作，但这些隐式操作和显式的内存操作通常是无序的。SFENCE.VMA 指令可以强制处理器将某些隐式操作在显式操作之前完成，从而确保操作的顺序性。&#xA;SFENCE.VMA 是 RISC-V 架构中的一条特权指令，用于刷新与地址翻译相关的本地硬件缓存，处理内存管理数据结构的同步，特别是当需要确保对这些数据结构的修改在不同的硬件组件之间保持一致时需要频繁使用该指令。SFENCE.VMA 只影响本地核心（hart），如果需要在多个核心之间同步，则需要核间中断等额外机制。虽然 SFENCE.VMA 指令对于维护一致性至关重要，但频繁调用可能会影响系统性能，因此，应根据实际需要合理使用，以平衡一致性和性能之间的关系。&#xA;SFENCE.VMA 的行为依赖于 rs1 和 rs2，在 RISC-V 特权指令集中如下所述：&#xA;条件 - 如果 rs1=x0 且 rs2=x0，栅栏会对所有地址空间的页面表的所有读写进行排序，并将所有地址翻译缓存条目标记为 invalid。 - 如果 rs1=x0 且 rs2 不是 x0，栅栏会对指定的地址空间的页面表的所有读写进行排序，但不对全局映射进行排序。它还会失效与指定地址空间匹配的地址翻译缓存条目，但不包括全局映射的条目。 - 如果 rs1 不是 x0 且 rs2=x0，栅栏会对所有地址空间的与 rs1 对应的虚拟地址的叶子页面表条目的读写进行排序，并失效包含该虚拟地址的所有叶子页面表条目的地址翻译缓存条目。 - 如果 rs1 不是 x0 且 rs2 不是 x0，栅栏会对与 rs1 对应的虚拟地址在指定地址空间的叶子页面表条目的读写进行排序，并失效与 rs1 对应的虚拟地址并匹配指定地址空间的所有叶子页面表条目的地址翻译缓存条目，但不包括全局映射的条目。 - 如果 rs1 中的值不是有效的虚拟地址，则 SFENCE.VMA 指令没有效果，且不会引发异常。 - 当 rs2=x0 时，rs2 中的值的 SXLEN-1:ASIDMAX 位保留供将来标准使用。在标准扩展定义其用法之前，这些位应由软件置为零并被当前实现忽略。此外，如果 ASIDLEN &amp;lt; ASIDMAX，则实现应忽略 rs2 中值的 ASIDMAX-1:ASIDLEN 位。 SFENCE.</description>
    </item>
    <item>
      <title>支持 HFENCE.VVMA 与 HFENCE.GVMA 指令</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/12_hfence_v_gvma/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/12_hfence_v_gvma/</guid>
      <description>事实上，对 hv（SFENCE Bundle 中的信号，用于刷新第一阶段地址转换的条目）和 hg（SFENCE Bundle 中的信号，用于刷新第二阶段地址转换的条目）信号不为 0 的情况执行的指令并不是 SFENCE.VMA，而是 HFENCE.VVMA 和 HFENCE.GVMA：&#xA;这两个指令与 SFENCE.VMA 功能很相似，区别在于 HFENCE.VVMA 适用于由 vsatp 控制的 VS 级别内存管理数据结构；HFENCE.GVMA 适用于由 hgatp 控制的虚拟机监管程序 G 阶段内存管理数据结构。&#xA;HFENCE.VVMA 仅在 M 模式或 HS 模式生效，类似于暂时进入 VS 模式并执行 SFENCE.VMA 指令，可以保证当前 hart 之前的所有存储操作在后续的隐式读取 VS 级别内存管理数据结构之前都已经排序；注意这里所说的隐式读取指的仅有在 HFENCE.VVMA 之后执行的，并且 hgatp.VMID 与执行 HFENCE.VVMA 相同的时候，简单来说就是仅对当前这一个虚拟机生效。rs1 与 rs2 的功能与 SFENCE.VMA 相同。&#xA;对 HFENCE.GVMA 来说，rs1 指定的是客机的物理地址。由于主机采用 SV48 而虚拟机采用 SV48x4，客机物理地址比主机物理地址多两位，因此此时需要将 rs1 对应的客机物理地址右移两位。如果某一个虚拟机的地址翻译模式更改了，也即 hgatp.MODE 对某个 VMID 更改了，则必须使用 HFENCE.GVMA 指令，将 rs1 设为 0，rs2 设为 0 或 VMID 进行刷新。</description>
    </item>
    <item>
      <title>支持 SINVAL 扩展</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/13_sinval/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/13_sinval/</guid>
      <description>在 RISC-V 特权指令集中定义了 Svinval 扩展（Supervisor Virtual Address Invalidation），在香山昆明湖架构实现了该扩展。Svinval 扩展的意义在于将 SFENCE.VMA 指令更加细化为 SFENCE.W.INVAL、SINVAL.VMA、SFENCE.INVAL.IR 三条指令（HFENCE.VVMA 和 HFENCE.GVMA 同理）。&#xA;SINVAL.VMA 指令事实上与 SFENCE.VMA 指令的功能基本一致，只是添加了对 SFENCE.W.INVAL 与 SFENCE.INVAL.IR 两个指令的相互排序，可以理解为需要在两个指令中间进行。SFENCE.W.INVAL 指令用于确保当前 RISC-V hart 可见的任何先前存储在后续由同一个 hart 执行的 SINVAL.VMA 指令之前被重新排序。SFENCE.INVAL.IR 指令确保当前 hart 执行的任何先前 SINVAL.VMA 指令在后续隐式引用内存管理数据结构之前被排序。当由单个 hart 按顺序（不一定连续）执行 SFENCE.W.INVAL、SINVAL.VMA 和 SFENCE.INVAL.IR 时，可以相当于执行了 SFENCE.VMA 指令。</description>
    </item>
    <item>
      <title>支持软件更新 A/D 位</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/14_software_update_a_d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/01_func/14_software_update_a_d/</guid>
      <description>A 位（Access）用于指示某一页面是否被访问过。如果处理器对该页面进行任何形式的访问（读/写/取指），则 A 位会被设置为 1。每当 CPU 访问某个页面时，操作系统或硬件会自动将 A 位设置为 1，这种更新通常是硬件支持的，由处理器在地址转换时自动进行。&#xA;D 位（Dirty）指示页面是否被修改。如果页面在内存中被写入，则 D 位会被设置为 1，表示该页面的内容已被更改。当处理器对页面进行写操作时，通常会自动将 D 位设置为 1，这种更新通常也是由硬件支持的。在页面替换过程中，操作系统会检查 D 位，如果 D 位为 1，操作系统会将页面写回到磁盘，并在写回后清除 D 位，以表示页面已经被保存且不再是“脏”的。&#xA;在香山昆明湖架构中，并不支持硬件更新 A/D 位，而是在需要更新的时候通过 Page Fault 通知软件进行页表更新。具体来说，每当处理器访问某一页时检查该页 A 位如果是 0，那么会发生 PF；同样的，每当处理器写入某一页时检查该页的 D 位如果是 0，同样会发生 PF。在软件处理异常后，操作系统会允许处理器再次访问页面，只有在页表得到更新且相关状态位（A 和 D 位）被正确设置后，处理器才能继续进行后续的内存访问。</description>
    </item>
    <item>
      <title>IO接口说明</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_io/</guid>
      <description>香山实例化 TLB.sv 接口说明（ITLB） 基本控制信号 clock: 时钟信号，驱动 TLB 的时序逻辑。 reset: 复位信号，用于重置 TLB 的状态。 刷新（SFENCE）接口信号 io_sfence_valid: SFENCE 操作的有效性标志。 io_sfence_bits_rs1: SFENCE 操作是否使用寄存器 rs1 的值。 io_sfence_bits_rs2: SFENCE 操作是否使用寄存器 rs2 的值。 io_sfence_bits_addr: SFENCE 操作指定的地址，用于选择性刷新特定地址的 TLB 条目。 io_sfence_bits_id: 刷新操作指定的 asid/vmid，用于选择性刷新特定地址空间的 TLB 条目。 io_sfence_bits_flushPipe: 刷新整个管道。 io_sfence_bits_hv: 指示指令是否为 HFENCE.VVMA，即是否刷新虚拟化下由 vsatp 寄存器控制的条目。 io_sfence_bits_hg: 指示指令是否为 HFENCE.GVMA，即是否刷新由 hgatp 寄存器控制的条目。 控制与状态寄存器（CSR）接口信号 io_csr_satp_mode: SATP 寄存器的模式字段（如裸模式、Sv32、Sv39 等）。 io_csr_satp_asid: 当前 SATP 寄存器的 ASID（地址空间标识符）。 io_csr_satp_changed: 指示 SATP 寄存器的值是否已更改。 io_csr_vsatp_mode: VSATP 寄存器的模式字段。 io_csr_vsatp_asid: VSATP 寄存器的 ASID。 io_csr_vsatp_changed: 指示 VSATP 寄存器的值是否已更改。 io_csr_hgatp_mode: HGATP 寄存器的模式字段。 io_csr_hgatp_vmid: HGATP 寄存器的 VMID（虚拟机标识符）。 io_csr_hgatp_changed: 指示 HGATP 寄存器的值是否已更改。 io_csr_priv_virt: 指示是否在虚拟模式下运行。 io_csr_priv_imode: 指令模式的特权级（如用户态、内核态等）。 请求者（Requestor）接口信号 Requestor 0 信号 io_requestor_0_req_valid: requestor0 的请求有效信号。 io_requestor_0_req_bits_vaddr: requestor0 的请求虚拟地址。 io_requestor_0_resp_bits_paddr_0: requestor0 的物理地址响应信号。 io_requestor_0_resp_bits_gpaddr_0: requestor0 的物理地址转换为 GPA（Guest Physical Address）的响应信号。 io_requestor_0_resp_bits_miss: requestor0 请求的地址未命中的信号。 io_requestor_0_resp_bits_excp_0_gpf_instr: requestor0 出现 General Protection Fault (GPF) 异常的信号。 io_requestor_0_resp_bits_excp_0_pf_instr: requestor0 出现 Page Fault (PF) 异常的信号。 io_requestor_0_resp_bits_excp_0_af_instr: requestor0 出现 Access Fault (AF) 异常的信号。 Requestor 1 信号 io_requestor_1_req_valid: requestor1 的请求有效信号。 io_requestor_1_req_bits_vaddr: requestor1 的请求虚拟地址。 io_requestor_1_resp_bits_paddr_0: requestor1 的物理地址响应信号。 io_requestor_1_resp_bits_gpaddr_0: requestor1 的 GPA 响应信号。 io_requestor_1_resp_bits_miss: requestor1 的未命中信号。 io_requestor_1_resp_bits_excp_0_gpf_instr: requestor1 出现 GPF 异常的信号。 io_requestor_1_resp_bits_excp_0_pf_instr: requestor1 出现 PF 异常的信号。 io_requestor_1_resp_bits_excp_0_af_instr: requestor1 出现 AF 异常的信号。 Requestor 2 信号 io_requestor_2_req_ready: requestor2 的请求就绪信号。 io_requestor_2_req_valid: requestor2 的请求有效信号。 io_requestor_2_req_bits_vaddr: requestor2 的请求虚拟地址。 io_requestor_2_resp_ready: requestor2 的响应就绪信号。 io_requestor_2_resp_valid: requestor2 的响应有效信号。 io_requestor_2_resp_bits_paddr_0: requestor2 的物理地址响应信号。 io_requestor_2_resp_bits_gpaddr_0: requestor2 的 GPA 响应信号。 io_requestor_2_resp_bits_excp_0_gpf_instr: requestor2 出现 GPF 异常的信号。 io_requestor_2_resp_bits_excp_0_pf_instr: requestor2 出现 PF 异常的信号。 io_requestor_2_resp_bits_excp_0_af_instr: requestor2 出现 AF 异常的信号。 刷新管道（Flush Pipe）信号 io_flushPipe_0: 刷新管道 0 的信号。 io_flushPipe_1: 刷新管道 1 的信号。 io_flushPipe_2: 刷新管道 2 的信号。 页表遍历（Page Table Walker, PTW）接口信号 PTW 请求信号 io_ptw_req_0_valid: PTW req0 有效信号。 io_ptw_req_0_bits_vpn: PTW req0 的虚拟页号（VPN）。 io_ptw_req_0_bits_s2xlate: 指示 PTW req0 的转换模式。 io_ptw_req_0_bits_getGpa: PTW req0 的获取 GPA 信号。 io_ptw_req_1_valid: PTW req1 有效信号。 io_ptw_req_1_bits_vpn: PTW req1 的虚拟页号。 io_ptw_req_1_bits_s2xlate: 指示 PTW req1 的转换模式。 io_ptw_req_1_bits_getGpa: PTW req1 的获取 GPA 信号。 io_ptw_req_2_ready: PTW req2 就绪信号。 io_ptw_req_2_valid: PTW req2 有效信号。 io_ptw_req_2_bits_vpn: PTW req2 的虚拟页号。 io_ptw_req_2_bits_s2xlate: 指示 PTW req2 的转换模式。 io_ptw_req_2_bits_getGpa: PTW req2 的获取 GPA 信号。 PTW 响应信号 io_ptw_resp_valid: PTW resp 有效信号。 io_ptw_resp_bits_s2xlate: 指示 PTW resp 的地址转换类型。 io_ptw_resp_bits_s1_entry_tag: PTW resp 的第一阶段页表条目标签。 io_ptw_resp_bits_s1_entry_asid: PTW resp 的第一阶段页表条目 ASID。 io_ptw_resp_bits_s1_entry_vmid: PTW resp 的第一阶段页表条目 VMID。 io_ptw_resp_bits_s1_entry_perm_d: PTW resp 的第一阶段页表条目可写位。 io_ptw_resp_bits_s1_entry_perm_a: PTW resp 的第一阶段页表条目已访问位。 io_ptw_resp_bits_s1_entry_perm_g: PTW resp 的第一阶段页表条目全局位。 io_ptw_resp_bits_s1_entry_perm_u: PTW resp 的第一阶段页表条目用户模式位。 io_ptw_resp_bits_s1_entry_perm_x: PTW resp 的第一阶段页表条目可执行位。 io_ptw_resp_bits_s1_entry_perm_w: PTW resp 的第一阶段页表条目可写位。 io_ptw_resp_bits_s1_entry_perm_r: PTW resp 的第一阶段页表条目可读位。 io_ptw_resp_bits_s1_entry_level: PTW resp 的第一阶段页表条目级别。 io_ptw_resp_bits_s1_entry_ppn: PTW resp 的第一阶段页表条目物理页号（PPN）。 io_ptw_resp_bits_s1_addr_low: PTW resp 的第一阶段页表条目地址低位。 io_ptw_resp_bits_s1_ppn_low_*: PTW resp 的第一阶段页表条目 PPN 低位。 io_ptw_resp_bits_s1_valididx_*: PTW resp 的第一阶段页表条目有效索引。 io_ptw_resp_bits_s1_pteidx_*: PTW resp 的第一阶段页表条目 PTE 索引。 io_ptw_resp_bits_s1_pf: PTW resp 的第一阶段页表条目出现 PF。 io_ptw_resp_bits_s1_af: PTW resp 的第一阶段页表条目出现 AF。 io_ptw_resp_bits_s2_entry_tag: PTW resp 的第二阶段页表条目标签。 io_ptw_resp_bits_s2_entry_vmid: PTW resp 的第二阶段页表条目 VMID。 io_ptw_resp_bits_s2_entry_ppn: PTW resp 的第二阶段页表条目 PPN。 io_ptw_resp_bits_s2_entry_perm_*: PTW resp 的第二阶段页表条目的权限位。 io_ptw_resp_bits_s2_entry_level: PTW resp 的第二阶段页表条目级别。 io_ptw_resp_bits_s2_gpf: PTW resp 的第二阶段页表条目 GPF 信号。 io_ptw_resp_bits_s2_gaf: PTW resp 的第二阶段页表条目 GAF 信号。 io_ptw_resp_bits_getGpa: PTW resp 的获取 GPA 信号。 </description>
    </item>
    <item>
      <title>AsidLength</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_keysignal/05_asidlen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_keysignal/05_asidlen/</guid>
      <description>def AsidLength = coreParams.AsidLength // Parameters.scala: line 619 AsidLength: Int = 16 // Parameters.scala: line 79 ASID 位宽：16 位 作用：标识地址空间，防止进程/虚拟机虚拟地址冲突 支持规模： 最大 65536 个并发进程（16 位） 虚拟机通过 vmid 标识（14 位，支持 16384 个虚拟机，符合手册要求） </description>
    </item>
    <item>
      <title>相关 CSR 寄存器</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_keysignal/01_csr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_keysignal/01_csr/</guid>
      <description>val csr = Input(new TlbCsrBundle) csr：包含 satp、vsatp、hgatp 三个寄存器的信息以及一些权限信息。&#xA;class TlbCsrBundle(implicit p: Parameters) extends XSBundle { val satp = new TlbSatpBundle() val vsatp = new TlbSatpBundle() val hgatp = new TlbHgatpBundle() val priv = new Bundle { val mxr = Bool() val sum = Bool() val vmxr = Bool() val vsum = Bool() val virt = Bool() val spvp = UInt(1.W) val imode = UInt(2.W) val dmode = UInt(2.W) } override def toPrintable: Printable = { p&amp;#34;Satp mode:0x${Hexadecimal(satp.</description>
    </item>
    <item>
      <title>F3PreDecoder</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/02_f3predecoder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/02_f3predecoder/</guid>
      <description>子模块：F3PreDecoder模块简介 这个模块是从PreDecoder中时序优化出来的，负责判定CFI指令的类型&#xA;F3PreDecoder功能介绍 CFI指令类型判定 要想确定CFI指令类型，只需要分别尝试匹配JAL、JALR、BR和他们的RVC版本即可，注意，RVC的EBREAK 不应该被视为CFI指令。在匹配的过程中，自然CFI指令的类型就被甄别出来了。在这一步中，我们将所有指令分到如下四类brType中：&#xA;CFI指令类型 brType类型编码 非CFI 00 branch指令 01 jal指令 10 jalr指令 11 ret、call判定 然后，我们需要判断是否为call或者ret，这可以通过rd和rs的取值来考察，具体来说，RISCV的RVI指令中，提供了对rd和rs取值的约定， 当二者取到link寄存器的序号（x1为标准的返回地址寄存器，x5为备用的link寄存器），分别对应着压栈和弹栈。详细的对应情况如下：&#xA;F3Predecoder接口说明 in_instr: 传递 16 x 4B的拼接指令码&#xA;out_pd：每条指令的预译码信息，在F3Predecoder分析得到的是brType、isCall和isRet&#xA;F3PreDecoder子模块测试点和功能点 功能点1 CFI指令类型判定 要想确定CFI指令类型，只需要分别尝试匹配JAL、JALR、BR和他们的RVC版本即可，注意，RVC的EBREAK 不应该被视为CFI指令。&#xA;序号 名称 描述 1.1 非CFI判定 对传入的非CFI指令（包括RVC.EBREAK），应该判定为类型0 1.2 BR判定 对传入的BR指令，应该判定为类型1 1.3 JAL判定 对传入的JAL指令，应该判定为类型2 1.4 JALR判定 对传入的JALR指令，应该判定为类型3 功能点2 ret、call判定 然后，需要判断是否为call或者ret，这可以通过rd和rs的取值来考察。当然，首先必须得满足无条件跳转指令。&#xA;对于类型2，只有不为RVC指令且目的寄存器rd为link寄存器（x1或x5）时，才为Call。&#xA;对于类型3，在RVI指令下，当rd为link寄存器时，必为Call。当rs为link寄存器且rd不为时，必为Ret。 在RVC指令下，对C.JALR指令，为call，对C.JR指令，当rs1为link时，为Ret&#xA;序号 名称 描述 2.1 非CFI和BR不判定 对传入的非CFI和BR指令，都不应判定为call或者ret 2.2.1.1 RVI.JAL判定call 对传入的RVI.JAL指令，当rd设置为1或5，应当判定该指令为call 2.2.1.2 RVI.JAL例外 对传入的RVI.JAL指令，当rd设置为1和5之外的值，不应当判定该指令为call或ret 2.2.2 RVC.JAL不判定 对传入的RVC.JAL指令，无论什么情况都不能判定为call或ret 2.3.1.1 RVI.JALR和rd为link 传入RVI.</description>
    </item>
    <item>
      <title>FrontendTrigger</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/05_frontend_trigger/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/05_frontend_trigger/</guid>
      <description>FrontendTrigger子模块 该子模块的主要作用是在前端设置硬件断点和检查。&#xA;该模块的输入pc有一个隐含条件，那就是这个pc是通过ftq传递的startAddr计算出来的。&#xA;FrontendTrigger功能介绍 断点设置和断点检查 在IFU的FrontendTrigger模块里共4个Trigger，编号为0,1,6,8，每个Trigger的配置信息（断点类型、匹配地址等）保存在tdata寄存器中。&#xA;当软件向CSR寄存器tselect、tdata1/2写入特定的值时，CSR会向IFU发送tUpdate请求，更新FrontendTrigger内的tdata寄存器中的配置信息。 目前前端的Trigger仅可以配置成PC断点（mcontrol(tdata1)寄存器的select位为0；当select=1时，该Trigger将永远不会命中，且不会产生异常）。&#xA;在取指时，IFU的F3流水级会向FrontendTrigger模块发起查询并在同一周期得到结果。后者会对取指块内每一条指令在每一个Trigger上做检查， 当指令的PC和tdata2寄存器内容的关系满足mcontrol的match位所指示的关系（香山支持match位为0、2、3，对应等于、大于、小于）时， 该指令会被标记为Trigger命中，随着执行在后端产生断点异常，进入M-Mode或调试模式。&#xA;链式断点 前端的0、6、8号Trigger支持Chain功能。 当它们对应的Chain位被置时，只有当该Trigger和编号在它后面一位的Trigger同时命中，且timing配置相同时，处理器才会产生异常。其中可以和6,8号trigger实现chain功能的7,9号trigger在后端访存部件中&#xA;FrontendTrigger 接口说明 设计上并没有提供一个或一组对外的接口来查询某个断点的状态，因此，要在测试中检查断点状态，要么需要检查内部信号的情况（仓库中提供的构建脚本已经暴露了所有内部信号），要么通过具体执行过程中，断点的触发情况来判定。&#xA;输入接口 主要分为控制接口和执行信息（目前执行信息只有pc）&#xA;控制接口 io_frontendTrigger 本接口存储了frontendTrigger的控制信息，包含以下信号/信号组：&#xA;debugMode 当前是否处于debug模式下&#xA;tEnableVec 对FrontendTrigger的每个断点，指示其是否有效。&#xA;tUpdate 更新断点的控制信息，包含以下信号/信号组：&#xA;valid：此次更新是否有效/是否更新。&#xA;bits_addr：此次更新的是哪个断点（0~3）&#xA;bits_tdata_action：断点触发条件达成后的行为&#xA;bits_tdata_chain：断点是否链式传导&#xA;bits_tdata_matchType：断点匹配类型（等于、大于、小于三种）&#xA;bits_tdata_select：目前为止，select为0时为pc断点&#xA;bits_tdata_tdata2：用于和PC比较的基准值&#xA;triggerCanRaiseBpExp trigger是否可以引起异常&#xA;pc pc有一个隐含条件，就是16条指令的pc必定是连续的&#xA;输出接口 triggered：16条指令的断点触发情况。&#xA;FrontEndTrigger 测试点和功能点 功能点1 设置断点和断点检查 FrontEndTrigger目前仅支持设置PC断点，这通过设置断点的tdata1寄存器的select位为0实现。 同时，tdata2寄存器的mcontrol位负责设置指令PC和tdata2寄存器的地址需要满足的关系， 关系满足时，该指令会被标记为trigger命中。&#xA;所以，基于以上功能描述，我们需要测试：&#xA;select位为1时，断点是否永远不会触发。&#xA;select位为0时，当PC和tdata2的数据的关系满足tdata2的match位时，是否会设置断点。&#xA;select位为0时，当PC和tdata2的数据的关系不满足tdata2的match位时，断点是否一定不会触发。&#xA;综上所述，我们在这一功能点设计的测试点如下：&#xA;序号 名称 描述 1.1 select1判定 给定tdata1的select位为1，随机构造其它输入，检查断点是否没有触发 1.2.1 select0关系匹配判定 给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位匹配的输入，检查断点是否触发 1.2.2 select0关系不匹配判定 给定tdata1的select位为0，构造PC与tdata2数据的关系同tdata2的match位不匹配的输入，检查断点是否触发 功能点2 链式断点 当某一个trigger的chain位被置后，当其后的trigger的chain位未设置，且两个trigger均命中并且两个trigger的timing相同时，后一个trigger才会触发。&#xA;对0号trigger，不需要考虑链式的情况</description>
    </item>
    <item>
      <title>PredChecker</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/04_pred_checker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/04_pred_checker/</guid>
      <description>子模块：PredChecker简介 分支预测检查器PredChecker接收来自IFU的预测块信息（包括预测跳转指令在预测块的位置、预测的跳转目标、预译码得到的指令信息、指令PC以及预译码得到的跳转目标偏移等），在模块内部检查五种类型的分支预测错误。模块内部分为两个流水线stage，分别输出信息，第一个stage输出给f3阶段，用于修正预测块的指令范围和预测结果。第二个stage输出给wb阶段，用于在发现分支预测错误时产生前端重定向以及写回给FTQ正确的预测信息。&#xA;PredChecker功能介绍 JAL预测错误检查 jal指令预测错误的条件是，预测块中有一条jal指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条jal指令之后（即这条jal指令没有被预测跳转）。&#xA;RET预测错误检查 ret指令预测错误的条件是，预测块中有一条ret指令（由预译码信息给出），但是要么这个预测块没有预测跳转，要么此预测块预测跳转的指令在这条ret指令之后（即这条ret指令没有被预测跳转）。&#xA;更新指令有效范围向量 PredChecker在检查出Jal/Ret指令预测错误时，需要重新生成指令有效范围向量，有效范围截取到Jal/Ret指令的位置，之后的bit全部置为0。 需要注意的是，jal和ret指令的错误检查都会导致指令有效范围的缩短， 所以需要重新生成指令有效范伟fixedRange，同时修复预测结果。需要注意的是，这个修复只会针对RET预测错误和JAL预测错误导致的范围错误，对于后续要介绍的非CFI预测错误和无效指令预测错误，尽管他们会造成预测块的范围偏小，但是不会进行修复，而是直接在这里进行重定向。这样，重定向后重新取的指令会从这个出错的指令开始。&#xA;非CFI预测错误检查 非CFI预测错误的条件是被预测跳转的指令根据预译码信息显示不是一条CFI指令。&#xA;无效指令预测错误检查 无效指令预测错误的条件是被预测的指令的位置根据预译码信息中的指令有效向量显示不是一条有效指令的开始。&#xA;目标地址预测错误检查 目标地址预测错误的条件是，被预测的是一条有效的jal或者branch指令，同时预测的跳转目标地址和由指令码计算得到的跳转目标不一致。&#xA;分级输出检查结果 以上PredChecker检查结果会分为两级分别输出，前面已经提到，Jal/Ret指令由于需要重新生成指令有效范围向量和重新指定预测位置， 所以需要在错误产生的当拍（F3）直接输出结果到Ibuffer用于及时更正进入后端的指令 。而由于时序的考虑，其他错误信息（比如五种错误的错误位置、正确的跳转地址等）则是等到下一拍（WB）阶段才返回给IFU做前端重定向。&#xA;PredChecker接口说明 输入接口 fire_in：这个信号可以简单认为是模块有效性的控制信号。&#xA;ftqOffset：表示该预测块的跳转指令是否存在（valid），以及跳转指令的序号（bits）。&#xA;instrRange：对每条指令，表示该指令是否在预测块的有效指令范围内。&#xA;instrValid：表示的是对于每条32位的拼接指令，其是否为一条有效的指令（即低16位为一条RVC指令，或者整个32位为一条RVI指令）。&#xA;jumpOffset：如果某一指令为跳转指令，jumpOffset表示这个指令的跳转目标。&#xA;pc：指令的pc。&#xA;pds：预译码信息，包含指令的brType、是否为Ret（isRet）、是否为RVC指令（isRVC）。&#xA;target：下个预测块的开始地址。&#xA;输出接口 第一阶段输出 fixedRange：修复的指令有效范围向量，对每条指令i，fixedRange_i为真表示这条指令是否在当前预测块的有效指令范围内&#xA;fixedTaken：修复过后的CFI指令选取情况，对每条指令，fixedTaken_i为真表示这条指令是否是这个预测块的第一条CFI指令&#xA;第二阶段输出 fixedMissPred：对每条指令，PredChecker检查出的存在预测错误的情况，fixedMissPred_i为真表示这条指令存在预测错误&#xA;fixedTarget：对每条指令，给出修复过的下一条指令的位置（可以是常规的pc+2或+4，或者如果是跳转指令，给出跳转目标）。&#xA;jalTarget：对每条指令，给出跳转目标。&#xA;PredChecker测试点和功能点 功能点1 BPU预测信息的JAL预测错误检查 PredChecker会对传入的预测块进行JAL预测错误预检查并修正指令有效范围向量和预测的跳转指令。&#xA;对这一模块的测试，我们分为两部分：正确的输入是否会误检和确有JAL检测错误的预测块输入能否检出。&#xA;对于误检，我们设计如下的测试点:&#xA;序号 名称 描述 1.1.1 误检测试1 预测块中没有JAL指令且BPU预测信息也没有取用任何跳转指令的输入，检查PredChecker是否会误报JAL预测错误。 1.1.2 误检测试2 预测块中有JAL指令且BPU预测信息取用的正是本条跳转指令的输入，检查PredChecker是否会误报JAL预测错误。 对于JAL预测错误的正确检验，我们设计如下的测试点：&#xA;序号 名称 描述 1.2.1 存在JAL未预测 预测块中存在JAL指令，但是BPU预测信息未预测跳转，检查PredChecker是否能检测出JAL预测错误。 1.2.2 预测的JAL并非第一条 预测块中存在JAL指令，但是BPU预测信息取的跳转指令在第一条JAL指令之后，检查PredChecker是否能检测出JAL预测错误。 功能点2 BPU预测信息的RET预测错误检查 PredChecker会对传入的预测块进行RET预测错误预检查并修正指令有效范围向量和新的预测结果。&#xA;和JAL预测错误类似，我们也按照误检和正检来构造。&#xA;对于误检，我们设计如下的测试点：</description>
    </item>
    <item>
      <title>PreDecode</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/01_predecode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/01_predecode/</guid>
      <description>子模块：PreDecoder简介 预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。&#xA;所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。&#xA;预译码器的输出是：16x4B的拼接指令码；对每个4B指令码，该条指令是否为RVI或RVC指令（RVC指令只考虑该4B的低2B）；对每个4B指令码，该条指令的跳转偏移；两个16位的有效指令开始向量，其中第一种向量假定当前预测块的起始2字节为一条有效指令的开始，而第二种向量假定当前预测块的起始2字节为一条有效RVI指令的结束（但是由于第二种向量的前两位必然为0和1,所以编译优化后，第二种向量实际只有14个信号，表示2-15位；同理，第1种向量的第0位因为恒为1,所以也被优化）&#xA;功能介绍 指令码生成 预译码器接受来自IFU完成指令切分的17 × 2字节的初始指令码，并以4字节为窗口，2字节为步进长度， 从第1个2字节开始，直到第16个2字节，选出总共16个4字节的指令码。&#xA;预译码信息生成 预译码器根据指令码产生预译码信息，主要包括：是否是RVC指令、是否是CFI指令、 CFI指令类型（branch/jal/jalr/call/ret）、CFI指令的目标地址计算偏移。&#xA;首先是判断是否是RVC指令，RVC指令的具体格式参阅RISCV手册的描述：&#xA;其中，决定指令是否为RVC的部分在于指令的[1, 0]两位，不为3的情况下都是RVC指令。&#xA;其余的指令性质判定功能（CFI类型、是否为call和ret）被时序优化到了F3PreDecoder中，不过也可以认为是PreDecoder的一部分。&#xA;最后比较麻烦的是CFI指令的目标地址计算偏移，主要是对J和BR分支指令进行的计算，这需要综合RVI和RVC中jal和br指令的结构。 首先，是手册中对于C.J的描述&#xA;这里对imm立即数的注解是，立即数的每一位最后对应到的是偏移的哪一位。&#xA;所以，可以认为立即数是这么重组的：&#xA;instr(12) + instr(8) + instr(10, 9) + instr(6) + instr(7) + instr(2) + instr(11) +instr(5,3) + &amp;ldquo;0&amp;rdquo;&#xA;而RVI中，对于JAL指令，是这么定义的：&#xA;我们可以类似地计算立即数。&#xA;同样的，我们可以查询手册，参考BR类指令的立即数计算RVC和RVI指令对应的偏移。&#xA;PreDecode接口说明 输入接口 in_bits_data 17 x 2B的初始指令码，其中，每2个字节既可以代表一条RVC指令，也可以代表一个RVI指令的一半。&#xA;输出接口 instr：拼接后的 16 x 4B的初始指令码&#xA;jumpOffset：如果这条指令是跳转指令，则jumpOffset表示其跳转偏移&#xA;pd：每条指令预译码信息，在时序优化之后，PreDecode模块的控制信息只剩下了valid和isRVC，后者表示这条指令是否为RVC指令&#xA;hasHalfValid：这个信号需要和pd的valid结合起来看，PreDecode的一个功能是求出指令开始向量，也就是对每个4B的拼接指令，判断其低2B是否为一条有效指令的开始（即一条RVI指令的前半部分，或者一条RVC指令），但是需要分类讨论该预测块的第一个2B是否为一条有效指令的开始。hasHalfValid表示的是当前预测块的第一个2B指令为一条RVI指令的后半部分时，给出的指令开始向量。类似地，pd中的valid指的是当前预测块的第一个2B指令为一条指令的开始时，给出的指令开始向量。&#xA;PreDecoder测试点和功能点 功能点1 生成指令码 子模块：PreDecoder简介&#xA;预译码器PreDeocoder接受初始指令码并进行指令码拼接，拼接之后对每个指令码查询预译码表产生预译码信息，预译码信息包括该位置是否是有效指令开始、CFI指令类型、是否是RVC指令、是否是Call指令以及是否是Ret指令。预译码器会产生两种有效指令开始的向量，一种是默认第1个二字节必为有效指令开始，另一种是默认第2个二字节必为有效指令的开始，最终的选择在IFU端做。&#xA;所以，预译码器接收的输入是： 17 x 2B的初始指令码，这个2字节的初始指令码要么是一条RVC指令，要么是一条RVI指令的前半或后半部分。&#xA;预译码器的输出是：16x4B的拼接指令码；对每个4B指令码，该条指令是否为RVI或RVC指令（RVC指令只考虑该4B的低2B）；对每个4B指令码，该条指令的跳转偏移；两个16位的有效指令开始向量，其中第一种向量假定当前预测块的起始2字节为一条有效指令的开始，而第二种向量假定当前预测块的起始2字节为一条有效RVI指令的结束（但是由于第二种向量的前两位必然为0和1,所以编译优化后，第二种向量实际只有14个信号，表示2-15位；同理，第1种向量的第0位因为恒为1,所以也被优化） 功能介绍 指令码生成</description>
    </item>
    <item>
      <title>RVCExpander</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/03_ifu_rvc_exp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/01_ifu/03_ifu_rvc_exp/</guid>
      <description>子模块：RVCExpander简介 RVCExpander是IFU的子模块，负责对传入的指令进行指令扩展，并解码计算非法信息。&#xA;该模块接收的输入量是两个：一条RVC指令或者RVI指令；CSR对fs.status的使能情况。&#xA;输出量也是两个：输入指令对应的RVI指令；RVC指令是否非法。&#xA;指令扩展 如果是RVI指令，则无需扩展。&#xA;否则对RVC指令，按照手册的约定进行扩展。&#xA;非法指令判断 RVI指令永远判断为合法。&#xA;对于RVC指令的判定，详细内容参阅20240411的RISCV手册的26.8节表格列出的指令条件。&#xA;RVCExpander接口说明 输入接口 fsIsOff：表示CSR是否使能fs.status&#xA;in：传入一个32位数据，其可以是一个完整的RVI指令，也可以是低16位RVC指令+高16位为RVI指令的一半（当然低16位也有可能是RVI指令的后半部分，但是RVCExpander不会区分，可以认为RVCExpander假定传入的32位数据的低16位一定为一条指令的开始）&#xA;输出接口 ill：表示这条指令是否为非法指令&#xA;out_bits：对RVI指令，直接返回，对RVC指令，返回扩展后的32位指令。&#xA;功能点和测试点 功能点1 指令扩展 RVCExpander负责接收预译码器拼接的指令码，并进行指令扩展，如果是16位RVC指令，需要按照RISCV手册的约定完成扩展&#xA;对此，我们需要随机生成RVI指令和RVC指令，送入预译码器：&#xA;序号 名称 描述 1.1 RVI指令保留 构造RVI指令传入，检查保留情况 1.2 RVC指令扩展 构造RVC指令传入，按手册检查扩展结果 功能点2 非法指令判断 RVCExpander在解析指令时，如发现指令违反了手册的约定，则需要判定该指令非法&#xA;对此，我们需要随机生成非法指令送入RVI中，并检测RVCExpander对合法位的校验；同时，我们还需要校验合法指令是否会被误判为非法指令：&#xA;此外，需要判定C.fp指令在CSR未使能fs.status的情况下，能否将这类指令判定为非法。&#xA;序号 名称 描述 2.1 常规非法指令测试 随机构造非法RVC指令传入，检查判断结果 2.2 合法指令测试 随机构造合法RVC指令传入，检查判断结果 2.3 C.fp指令测试 CSR未使能fs.status的情况下，C.fp指令应该为非法 测试点汇总 序号 功能 名称 描述 1.1 指令扩展 RVI指令保留 构造RVI指令传入，检查保留情况 1.2 指令扩展 RVC指令扩展 构造RVC指令传入，按手册检查扩展结果 2.1 非法指令判断 非法指令测试 随机构造非法RVC指令传入，检查判断结果 2.2 非法指令判断 合法指令测试 随机构造合法RVC指令传入，检查判断结果 2.</description>
    </item>
    <item>
      <title>sfence</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_keysignal/02_sfence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_keysignal/02_sfence/</guid>
      <description>val sfence = Input(new SfenceBundle) sfence：用于传入 SfenceBundle，执行 SFENCE 指令刷新 TLB 缓存。&#xA;class SfenceBundle(implicit p: Parameters) extends XSBundle { val valid = Bool() val bits = new Bundle { val rs1 = Bool() val rs2 = Bool() val addr = UInt(VAddrBits.W) val id = UInt((AsidLength).W) // asid or vmid val flushPipe = Bool() val hv = Bool() val hg = Bool() } override def toPrintable: Printable = { p&amp;#34;valid:0x${Hexadecimal(valid)} rs1:${bits.rs1} rs2:${bits.rs2} addr:${Hexadecimal(bits.</description>
    </item>
    <item>
      <title>VAddrBits</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_keysignal/04_vaddrbits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_keysignal/04_vaddrbits/</guid>
      <description>def VAddrBits = { if (HasHExtension) { if (EnableSv48) coreParams.GPAddrBitsSv48x4 else coreParams.GPAddrBitsSv39x4 } else { if (EnableSv48) coreParams.VAddrBitsSv48 else coreParams.VAddrBitsSv39 } } // Parameters.scala: line 596~608 // 相关参数定义 def HasHExtension = coreParams.HasHExtension // Parameters.scala: line582 coreParams.HasHExtension: Boolean = true // Parameters.scala: line66 coreParams.EnableSv48: Boolean = true // Parameters.scala: line91 // 地址位宽定义 coreParams.VAddrBitsSv39: Int = 39 coreParams.GPAddrBitsSv39x4: Int = 41 coreParams.VAddrBitsSv48: Int = 48 coreParams.GPAddrBitsSv48x4: Int = 50 // Parameters.scala: line71~74 香山昆明湖架构下的值：50 地址处理逻辑： 主机地址转换时仅使用后 48 位（前两位忽略） 支持虚拟机时，物理地址扩展为 50 位（符合 Sv48x4 规范） </description>
    </item>
    <item>
      <title>外部传入参数</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_keysignal/03_para/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/98_ut/01_frontend/02_itlb/02_keysignal/03_para/</guid>
      <description>参数说明 class TLB(Width: Int, nRespDups: Int = 1, Block: Seq[Boolean], q: TLBParameters)(implicit p: Parameters) extends TlbModule with HasCSRConst with HasPerfEvents 参数 说明 Width: Int 指示 requestor 的数量 nRespDups: Int = 1 需要复制 response 的数目，默认为 1（不复制） Block: Seq[Boolean] 指示每个 requestor 是否被阻塞 q: TLBParameters TLB 使用的参数 p: Parameter 全局参数（香山架构参数） 实例化 TLB 时以香山架构的 itlb 为例：&#xA;val itlb = Module(new TLB(coreParams.itlbPortNum, nRespDups = 1, Seq.fill(PortNumber)(false) ++ Seq(true), itlbParams)) Width 值为 coreParams.itlbParams（实际计算逻辑）：&#xA;itlbPortNum: Int = ICacheParameters().</description>
    </item>
    <item>
      <title>目标验证单元</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/00_unitychip_for_xiangshan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/00_unitychip_for_xiangshan/</guid>
      <description>当前版本： 20250210003155-main-2b529583954cafe6f145a5d8d49740ebd4d0fa4c 20250206064001-main-8e09f7c86acf67eb7649bd67df3ec51dccc77aaa 20250201121154-main-9595c680af64cc08a12f22a1d595ce111249f153 20250123032900-main-88fa1057ab93bd8286fc2705a1fd203397995702 20250121015322-main-2f2073ab1f56cc01fed1da01d6ddc6ed52880693 20241223133801-main-2a8c1ab351e4ea786c55435dd18f60c0c523cc8a 20241220061304-main-187577e01df03a8ff7ffc828b79070bd5e582436 20241218062220-main-a866912fc3a6df3d17b857a1a898f6f9e5c5957c 20241217100236-main-53f30b46ed6e6eeb261894c4a71a60f69777ef8c 20241216044913-main-7d081626cef0910d9490d169053ee32a8e0c51db 20241213025923-main-d09f78a58caeeb64347ca2587f1f3f2b2a59e6a0 20241212091919-main-c54c0c2e590cf334b986f8ef3eacc53329f4ed1e 20241204085334-main-335e7e0d4ffc2c7a17f8d95e7c75cbd428b14a61 20241204062337-main-f8903a8c4021ba3e310bf097b07147892729341c 20241201142531-main-365f53f574ba5c6875b3389824a3c898c642ed2b 20241129112435-main-79ccae9d5df92c4e167547564b97bd8846b7ecb6 20241129111104-main-8e0cb45a86ec3ffd779723e17ede379081431c42 查看测试报告 上图共有-个模块，默认情况下模块为灰色，当模块中的测试用例数大于-时，该模块被完全点亮。目前已经完全点亮的模块为-个，待点亮的模块有-个。&#xA;通用处理器模块简介 高性能处理器是现代计算设备的核心，它们通常由三个主要部分组成：前端、后端和访存系统。这些部分协同工作，以确保处理器能够高效地执行复杂的计算任务。&#xA;前端：前端部分，也被称为指令获取和解码阶段，负责从内存中获取指令并将其解码成处理器可以理解的格式。这一阶段是处理器性能的关键，因为它直接影响到处理器可以多快地开始执行指令。前端通常包括指令缓存、分支预测单元和指令解码器。指令缓存用于存储最近访问过的指令，以减少对主内存的访问次数，从而提高处理速度。分支预测单元则尝试预测程序中的条件分支，以便提前获取和解码后续指令，这样可以减少等待分支结果的时间。&#xA;后端：后端部分，也称为执行阶段，是处理器中负责实际执行指令的地方。这一阶段包括了算术逻辑单元（ALU）、浮点单元（FPU）和各种执行单元。这些单元负责进行算术运算、逻辑运算、数据传输和其他处理器操作。后端的设计通常非常复杂，因为它需要支持多种指令集架构（ISA）并优化性能。为了提高效率，现代处理器通常采用超标量架构，这意味着它们可以同时执行多条指令。&#xA;访存：访存系统是处理器与内存之间交互的桥梁。它包括了数据缓存、内存控制器和高速缓存一致性协议。数据缓存用于存储处理器频繁访问的数据，以减少对主内存的访问次数。内存控制器负责管理处理器与内存之间的数据传输。高速缓存一致性协议确保在多处理器系统中，所有处理器看到的内存状态是一致的。&#xA;高性能处理器的设计需要在这三个部分之间找到平衡，以实现最佳的性能。这通常涉及到复杂的微架构设计，以及对处理器流水线的优化。</description>
    </item>
    <item>
      <title>准备验证环境</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/01_verfiy_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/01_verfiy_env/</guid>
      <description>基础环境需求 本项目基于Python编程语言进行UT验证，采用的工具和测试框架为picker和toffee，环境需求如下：&#xA;Linux操作系统。建议WSL2下安装Ubuntu22.04。 Python。建议Python3.11。 picker。按照快速开始中的提示安装最新版本。 toffee。按照快速开始中的提示安装最新版本。 lcov 用于后续test阶段报告生成。使用包管理器即可下载：sudo apt install lcov 环境配置完成后，clone仓库：&#xA;git clone https://github.com/XS-MLVP/UnityChipForXiangShan.git cd UnityChipForXiangShan pip3 install -r requirements.txt # 安装python依赖（例如 toffee） 下载RTL代码： 默认从仓库https://github.com/XS-MLVP/UnityChipXiangShanRTLs中下载。用户也可以自行按照XiangShan文档编译生成RTL。&#xA;make rtl # 该命下载最新的rtl代码，并解压至rtl目录，并创建软连接 可以用以下命令指定下载的rtl版本：&#xA;make rtl args=&amp;#34;rtl.version=\&amp;#39;openxiangshan-kmh-fad7803d-24120901\&amp;#39;&amp;#34; 所有RTL下载包请在UnityChipXiangShanRTLs中查看。&#xA;RTL压缩包的命名规范为：名称-微架构-Git标记-日期编号.tar.gz，例如openxiangshan-kmh-97e37a2237-24092701.tar.gz。在使用时，仓库代码会过滤掉git标记和后缀，例如通过 cfg.rtl.version 访问到的版本号为：openxiangshan-kmh-24092701。压缩包内的目录结构为：&#xA;openxiangshan-kmh-97e37a2237-24092701.tar.gz └── rtl # 目录 |-- *.sv # 所有sv文件 `-- *.v # 所有v文件 编译DUT 该过程的目的是将RTL通过picker工具打包为Python模块。可以通过make命令指定被打包DUT，也可以一次性打包所有DUT。&#xA;如果想要自行打包某个dut，需要创建编写scripts目录中的build_ut_&amp;lt;name&amp;gt;.py脚本。这一脚本必须实现一个build方法，在打包时会被自动调用。此外还有一个line_coverage_files方法，用于指定行覆盖率参考的文件。&#xA;picker的打包支持内部信号的加入，详见picker的--internal参数，传递给其一个自定义的yaml即可。&#xA;# 调用scripts目录中的build_ut_&amp;lt;name&amp;gt;.py中的build方法，创建待验证的Python版DUT make dut DUTS=&amp;lt;name&amp;gt; # DUTS的值如果有多个，需要用逗号隔开，支持通配符。DUTS默认值为 &amp;#34;*&amp;#34;，编译所有DUT # 例如： make dut DUTS=backend_ctrl_block_decode 以make dut DUTS=backend_ctrl_block_decode为例，命令执行完成后，会在dut目录下生成对应的Python包：</description>
    </item>
    <item>
      <title>运行测试</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/02_run_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/02_run_test/</guid>
      <description>本项目基于PyTest测试框架进行验证。运行测试时，PyTest框架自动搜索所有test_*.py文件，并自动执行其中所有以test_开头的测试用例（Test Case）。&#xA;# 执行所有ut_*目录中的test case make test_all # 执行指定目录下的test case make test target=&amp;lt;dir&amp;gt; # 例如执行ut_backend/ctrl_block/decode目录中所有的test case make test target=ut_backend/ctrl_block/decode 可通过args参数传递Pytest的运行参数，例如启动x-dist插件的多核功能：&#xA;make test args=&amp;#34;-n 4&amp;#34; # 启用 4 个进程 make test args=&amp;#34;-n auto&amp;#34; # 让框架自动选择启用多少个进程 *注：x-dist可以在多节点上并发运行测试，可参考其文档&#xA;运行完成后，默认在out/report目录会生成html版本的测试报告，其 html 文件可通过浏览器直接打开查看（VS Code IDE建议安装Open In Default Browser插件）。&#xA;运行测试主要完成以下三部分内容：&#xA;按要求运行Test Case，可通过cfg.tests中的选项进行配置 统计测试结果，输出测试报告。有toffee-report自动生成 (总测试报告，所有Test的结果合并在一起) 根据需要（cfg.doc_result.disable = True）在测试报告上进行进一步数据统计 </description>
    </item>
    <item>
      <title>如何参与本项目</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/06_join_us/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/06_join_us/</guid>
      <description>如何提交Bug 按 ISSUE 模板进行提交，标记上对应的标签（bug，bug等级等）&#xA;对应模块的维护者进行检查，并修改他给出的标记和香山分支&#xA;如何提交文档 本仓库文档以PR的形式在本仓库提交，DUT文档在仓库UnityChipForXiangShan/documents/content/zh-cn/docs/98_UT中进行提交。&#xA;本项目欢迎任何人以ISSUE、DISCUSS、Fork、PR的方式参与。&#xA;万众一芯QQ交流群：</description>
    </item>
    <item>
      <title>模板-PR</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/08_template_pr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/08_template_pr/</guid>
      <description># Description Please include a summary of the changes and the related issue. Please also include relevant motivation and context. List any dependencies that are required for this change. Fixes # (issue) ## Type of change Please delete options that are not relevant. - [ ] Bug fix (non-breaking change which fixes an issue) - [ ] New feature (non-breaking change which adds functionality) - [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected) - [ ] This change requires a documentation update # How Has This Been Tested?</description>
    </item>
    <item>
      <title>模板-ISSUE</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/09_template_issue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/09_template_issue/</guid>
      <description>## Description A brief description of the issue. ## Steps to Reproduce 1. Describe the first step 2. Describe the second step 3. Describe the third step 4. ... ## Expected Result Describe what you expected to happen. ## Actual Result Describe what actually happened. ## Screenshots If applicable, add screenshots to help explain your problem. ## Environment - OS: [e.g. Windows 10, macOS 10.15, Ubuntu 20.04] - Browser: [e.g. Chrome 86, Firefox 82, Safari 14] - Version: [e.</description>
    </item>
    <item>
      <title>模板-UT-README</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/10_template_ut_readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/10_template_ut_readme/</guid>
      <description># 模块名称 ## 测试目标 &amp;lt;测试目标、测试方法描述&amp;gt; ## 测试环境 &amp;lt;测试环境描述，依赖描述&amp;gt; ## 功能检测 &amp;lt;给出目标待测功能与对应的检测方法&amp;gt; |序号|所属模块|功能描述|检查点描述|检查标识|检查项| |-|-|-|-|-|-| |-|-|-|-|-|-| ## 验证接口 &amp;lt;接口的描述&amp;gt; ## 用例说明 #### 测试用例1 |步骤|操作内容|预期结果|覆盖功能点| |-|-|-|-| |-|-|-|-| #### 测试用例2 |步骤|操作内容|预期结果|覆盖功能点| |-|-|-|-| |-|-|-|-| ## 目录结构 &amp;lt;对本模块的目录结构进行描述&amp;gt; ## 检测列表 - [ ] 本文档符合指定[模板]()要求 - [ ] Env提供的API不包含任何DUT引脚和时序信息 - [ ] Env的API保持稳定（共有[ X ]个） - [ ] Env中对所支持的RTL版本（支持版本[ X ]）进行了检查 - [ ] 功能点（共有[ X ]个）与[设计文档]()一致 - [ ] 检查点（共有[ X ]个）覆盖所有功能点 - [ ] 检查点的输入不依赖任何DUT引脚，仅依赖Env的标准API - [ ] 所有测试用例（共有[ X ]个）都对功能检查点进行了反标 - [ ] 所有测试用例都是通过 assert 进行的结果判断 - [ ] 所有DUT或对应wrapper都是通过fixture创建 - [ ] 在上述fixture中对RTL版本进行了检查 - [ ] 创建DUT或对应wrapper的fixture进行了功能和代码行覆盖率统计 - [ ] 设置代码行覆盖率时对过滤需求进行了检查 展示效果如下：</description>
    </item>
    <item>
      <title>常用API</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/95_api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/95_api/</guid>
      <description>comm 模块 在comm中提供了部分可公用的API，可通过以下方式进行调用：&#xA;# import all from comm import * # or direct import functions you need from com import function_you_need # or access from module import comm comm.function_you_need() cfg 子模块 get_config(cfg=None) 获取当前的Config配置&#xA;输入：如果cfg不为空，则返回cfg。否则则自动通过toffee获取全局Config。 返回：Config对象 import comm cfg = comm.get_config() print(cfg.rtl.version) cfg_as_str(cfg: CfgObject): 把config对象转换为字符类型&#xA;输入：Config对象 返回：编码后的Config对象 import comm cfg_str = comm.cfg_as_str(comm.get_config()) cfg_from_str(cfg_str) 把字符类型的Config对象还原&#xA;输入：编码后的Config对象 返回：Config对象 import comm cfg = comm.cfg_from_str(cfg_str) dump_cfg(cfg: CfgObject = None, cfg_file=None) 把config对象保持到文件&#xA;输入： cfg 需要保存的config cfg_file 目标文件 import comm cfg = comm.</description>
    </item>
    <item>
      <title>其他</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/96_others/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/96_others/</guid>
      <description>测试用例管理 如果测试用例和目标RTL版本紧密相关，RTL发生变化，之前的测试用例不一定适用。此外，不同场景下有不同需求，例如验证测试环境时，不运行耗时太长的用例等。因此需要对用例进行管理，让用户能在在特定场景下跳过某些用例。为了实现该目标，我们需要通过pytest.mark.toffee_tags对于每个用例进行tag和version标记。然后在配置文件中设置需要跳过哪些tag或者只运行哪些tag的测试。&#xA;@pytest.mark.toffee_tags(&amp;#34;my_tag&amp;#34;, &amp;#34;version1 &amp;lt; version13&amp;#34;) def test_case_1(): ... 例如上述test_case_1被标记上了标签my_tag，支持版本设置为version1到version13。因此可以在配置文件中指定test.skip-tags=[&amp;quot;my_tag&amp;quot;]，来表示运行过程中跳过该用例。&#xA;pytest.mark.toffee_tags的参数说明如下：&#xA;@pytest.mark.toffee_tags( tag: Optional[list, str] = [] # 用例标签 version: Optional[list, str] = [], # 用例rtl版本需求 skip: callable = None, # 自定义是否调过该用例，skip(tag, version, item): (skip, reason) ) toffee_tags函数的参数tag支持str和list[str]类型。version参数也可以是str和list[str]类型，当为list类型时，进行精确匹配，如果为str则匹配规则如下：&#xA;name-number1 &amp;lt; namer-number2: 表示版本需要在number1和number2之间（包含边界，number表示数字，也可以为小数，eg 1.11） name-number1+：表示number1版本以及以后的版本 name-number1-：表示number1版本以及以前的版本 如果不存在上述情况，且有*或者?表示通配符类型。其他情况为精确匹配。&#xA;预定义标签，可以在comm/constants.py中查看，例如：&#xA;# Predefined tags for test cases TAG_LONG_TIME_RUN = &amp;#34;LONG_TIME_RUN&amp;#34; # 运行时间长 TAG_SMOKE = &amp;#34;SMOKE&amp;#34; # 冒烟测试 TAG_RARELY_USED = &amp;#34;RARELY_USED&amp;#34; # 非常少用 TAG_REGRESSION = &amp;#34;REGRESSION&amp;#34; # 回归测试 TAG_PERFORMANCE = &amp;#34;PERFORMANCE&amp;#34; # 性能测试 TAG_STABILITY = &amp;#34;STABILITY&amp;#34; # 稳定测试 TAG_SECURITY = &amp;#34;SECURITY&amp;#34; # 安全测试 TAG_COMPATIBILITY = &amp;#34;COMPATIBILITY&amp;#34; # 兼容测试 TAG_OTHER = &amp;#34;OTHER&amp;#34; # 其他 TAG_CI = &amp;#34;CI&amp;#34; # 集成测试 TAG_DEBUG = &amp;#34;DEBUG&amp;#34; # 测试 TAG_DEMO = &amp;#34;DEMO&amp;#34; # demo 在默认配置中(config/_default.</description>
    </item>
    <item>
      <title>必要规范</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/97_constraint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/97_constraint/</guid>
      <description>为了方便将所有人的贡献集合在一起，需要在编码、环境、文档编写等方面采用相同的“规范”。&#xA;环境要求 python： 在python编码过程中，尽可能的采用标准库，采用兼容Python3大部分版本的通用语法（尽可能的在Python3.6 - Python3.12中通用），不要使用过旧或者过新的语法。 操作系统： 建议Ubuntu 22.04，windows下，建议使用WSL2环境。 hugo 建议版本 0.124.1（版本过旧不支持软连接） 少依赖 尽可能少的使用第三方C++/C库 picker 建议使用wheel安装picker工具和xspcomm库 测试用例 代码风格 建议采用 PEP 8 规范 build脚本 需要按DUT的命名结构进行规范命名，不然无法正确收集验证结果。例如backend.ctrl_block.decodeUT在scripts目录中对应的build文件名称应该为build_ut_backend_ctrl_block_decode.py(以固定前缀build_ut_开始，点.用下划线_进行替换)。在脚本中实现 build(cfg) -&amp;gt; bool 和 line_coverage_files(cfg) -&amp;gt; list[str] 方法。build用于编译DUT为python模块，line_coverage_files方法用于返回需要统计的代码行覆盖率文件。 用例标签 如果用例无法做到版本通用，需要用pytest.mark.toffee_tags标记支持的版本。 用例抽象 编写的测试用例输入不能出现DUT的具体引脚等强耦合内容，只能调用基于DUT之上的函数封装。例如对于加法器 adder，需要把dut的目标功能封装为 dut_wrapper.add(a: int, b: int) -&amp;gt; int, bool，在test_case中仅仅调用 sum, c = add(a, b)进行测试。 覆盖抽象 在编写功能覆盖率时，其检查点函数的输入也不能有DUT引脚。 环境抽象 对于一个验证，通常分为2部分：Test Case 和 Env （用例以外的都统一称为Env，它包含DUT、驱动、监控等），其中Env需要提供对外的功能抽象接口，不能对外呈现出太多细节。 测试说明 在每个DUT的验证环境中，需要通过README.md对该环境进行说明，例如需要对Env提供给Case的接口进行说明，目录结构说明等。 PR编写 标题 简洁明了，能概括PR的主要内容。 详细描述 详细说明PR的目的，修改的内容以及相关背景信息。入解决已有的问题需要给出链接（例如Issue）。 关联问题 在描述中关联相关问题，例如 Fixes #123，以便在合并PR时关闭关联问题。 测试 需要进行测试，并对测试结果进行描述 文档 PR涉及到的文档需要同步修改 分解 当PR涉及到的修改很多时，需要判断是否拆分成多个PR 检查清单 检查编译是否通过、代码风格是否合理、是否测试通过、是否有必要的注释等 模板 以及提供的PR模块请参考链接。 ISSUE编写 要求同上</description>
    </item>
    <item>
      <title>维护者</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/docs/99_maintain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/docs/99_maintain/</guid>
      <description>在提交 issue、pull request、discussion 时，如果指定对应模块的 maintainer 能更及时的得到响应。目前已有的维护人员如下（首字母排名）：&#xA;验证工具：&#xA;picker：Makiras, SFangYy, yaozhicheng toffee/toffe-test：Miical, yaozhicheng 当前版本： 20250210003155-main-2b529583954cafe6f145a5d8d49740ebd4d0fa4c 20250206064001-main-8e09f7c86acf67eb7649bd67df3ec51dccc77aaa 20250201121154-main-9595c680af64cc08a12f22a1d595ce111249f153 20250123032900-main-88fa1057ab93bd8286fc2705a1fd203397995702 20250121015322-main-2f2073ab1f56cc01fed1da01d6ddc6ed52880693 20241223133801-main-2a8c1ab351e4ea786c55435dd18f60c0c523cc8a 20241220061304-main-187577e01df03a8ff7ffc828b79070bd5e582436 20241218062220-main-a866912fc3a6df3d17b857a1a898f6f9e5c5957c 20241217100236-main-53f30b46ed6e6eeb261894c4a71a60f69777ef8c 20241216044913-main-7d081626cef0910d9490d169053ee32a8e0c51db 20241213025923-main-d09f78a58caeeb64347ca2587f1f3f2b2a59e6a0 20241212091919-main-c54c0c2e590cf334b986f8ef3eacc53329f4ed1e 20241204085334-main-335e7e0d4ffc2c7a17f8d95e7c75cbd428b14a61 20241204062337-main-f8903a8c4021ba3e310bf097b07147892729341c 20241201142531-main-365f53f574ba5c6875b3389824a3c898c642ed2b 20241129112435-main-79ccae9d5df92c4e167547564b97bd8846b7ecb6 20241129111104-main-8e0cb45a86ec3ffd779723e17ede379081431c42 主UT模块&#xA;子UT模块&#xA;*其他维护者陆续更新中&#xA;如果您对本项目感兴趣，欢迎申请成为本项目中的维护者。</description>
    </item>
    <item>
      <title>搜索结果</title>
      <link>https://open-verify.cc/UnityChipForXiangShan/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/UnityChipForXiangShan/search/</guid>
      <description></description>
    </item>
  </channel>
</rss>
