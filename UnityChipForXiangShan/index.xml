<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XiangShan UT Docs on 万众一芯之香山处理器</title>
    <link>https://xs-mlvp.github.io/UnityChipForXiangShan/</link>
    <description>Recent content in XiangShan UT Docs on 万众一芯之香山处理器</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://xs-mlvp.github.io/UnityChipForXiangShan/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>添加编译脚本</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/01_build_script/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/01_build_script/</guid>
      <description>脚本目标 该脚本的目标是提供RTL到Python DUT的编译、目标覆盖文件，以及自定义功能等内容。&#xA;创建过程 确定文件名称 在香山昆明湖DUT验证进展中选择需要验证的UT，如果没有或者进一步细化，可通过编辑config/dutree/xiangshan=lmh.yaml自行添加。&#xA;脚本文件的命名格式如下：&#xA;scripts/build_ut_&amp;lt;顶层模块&amp;gt;_&amp;lt;下层模块名&amp;gt;[...].&amp;lt;目标模块名&amp;gt;.py 目前本项目内置了4个顶层模块：&#xA;ut_frontend 前端 ut_backend 后端 ut_mem_block 访存 ut_misc 其他 其中的子模块没有ut_前缀（顶层目录有该前缀是为了和其他目录区分开）。&#xA;例如验证目标DUT为：backend.ctrl_block.decode，需要创建的脚本名称为 build_ut_backend_ctrl_block_decode.py。&#xA;编写 build(cfg) -&amp;gt; bool 函数 build函数定义如下：&#xA;def build(cfg) -&amp;gt; bool: &amp;#34;&amp;#34;&amp;#34;编译DUT Args: cfg: 运行时配置，可通过它访问配置项，例如 cfg.rtl.version Return: 返回 True 或者 False，表明该函数是否完成预期目标 &amp;#34;&amp;#34;&amp;#34; build在make dut 时会被调用，其主要是将目标 RTL 转换为 Python 模块。在该过程中也可以加入其他必要过程，例如编译依赖项等。以build_ut_backend_ctrl_block_decode.py为例，主要完成了RTL检查、DUT检查、RTL编译、disasm依赖编译等工作：&#xA;def build(cfg) -&amp;gt; bool: # import 相关依赖 from toffee_test.markers import match_version from comm import is_all_file_exist, get_rtl_dir, exe_cmd, get_root_dir # 检查RTL版本（version参数为空，表示所有版本都支持） if not match_version(cfg.</description>
    </item>
    <item>
      <title>构建测试环境</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/02_build_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/02_build_env/</guid>
      <description>确定目录结构 单元测试所在的目录位置的层级结构应该与名称一致，例如backend.ctrl_block.decode应当位于ut_backend/ctrl_block/decode目录，且每层目录都需要有__init__.py，便于通过Python进行import。模块（例如decode）中的代码目录结构由贡献者自行决定，当需要满足python规范，且逻辑合理，命名合理。&#xA;编写测试环境 在UT验证模块的测试环境中，目标是完成以下工作：&#xA;对DUT进行功能封装，提供稳定测试API 定义功能覆盖率 定义必要fixture提供给测试用例 在合理时刻统计覆盖率 以decode环境中的RVCExpander为例（ut_backend/ctrl_block/decode/env/decode_wrapper.py）：&#xA;1. DUT封装 class RVCExpander(toffee.Bundle): def __init__(self, cover_group, **kwargs): super().__init__() self.cover_group = cover_group self.dut = DUTRVCExpander(**kwargs) # 创建DUT self.dut.io_in.AsImmWrite() # DUTRVCExpander为组合电路，将输入引脚设置为ImmWrite写入模式 self.io = toffee.Bundle.from_prefix(&amp;#34;io_&amp;#34;, self.dut) # 通过 Bundle 关联引脚 self.bind(self.dut) # 把 Bunldle 与 DUT 进行绑定 def expand(self, instr): self.io[&amp;#34;in&amp;#34;].value = instr # 给DUT引脚赋值 self.dut.RefreshComb() # 推动组合电路 self.cover_group.sample() # 调用sample对功能覆盖率进行统计 return self.io[&amp;#34;out_bits&amp;#34;].value, self.io[&amp;#34;ill&amp;#34;].value # 返回结果 和 是否是非法指令 def stat(self): # 获取当前状态 return { &amp;#34;instr&amp;#34;: self.</description>
    </item>
    <item>
      <title>添加测试用例</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/03_add_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/03_add_test/</guid>
      <description>命名要求 所有测试用例文件请以test_*.py的方式进行命名，*用测试目标替换。所有测试用例也需要以test_前缀开头。用例名称需要具有明确意义。&#xA;命名举例如下：&#xA;def test_a(): # 不合理，无法通过a判断测试目标 pass def test_rvc_expand_16bit_full(): # 合理，可以通过用例名称大体知道测试内容 pass 使用Assert 在每个测试用例中，都需要通过 assert 来判断本测试是否通过。&#xA;编写注释 每个测试用例都需要添加必要的说明和注释，需要满足Python注释规范。&#xA;测试用例说明参考格式：&#xA;def test_&amp;lt;name&amp;gt;(a: type_a, b: type_b): &amp;#34;&amp;#34;&amp;#34;Test abstract Args: a (type_a): description of arg a. b (type_b): description of arg b. Detailed test description here (if need). &amp;#34;&amp;#34;&amp;#34; ... 用例管理 为了方便测试用例管理，可通过toffee-test提供的@pytest.mark.toffee_tags标签功能，请参考此处。&#xA;参考用例 如果很多测试用例（Test）具有相同的操作，该公共操作部分可以提炼成一个通用函数。以RVCExpander验证为例，可以把压缩指令的展开与参考模型（disasm）的对比封装成以下函数：&#xA;def rvc_expand(rvc_expander, ref_insts): &amp;#34;&amp;#34;&amp;#34;compare the RVC expand result with the reference Args: rvc_expander (warpper): the fixture of the RVC expander ref_insts (list[int]]): the reference instruction list &amp;#34;&amp;#34;&amp;#34; find_error = 0 for insn in ref_insts: insn_disasm = disasmbly(insn) _, instr_ex = rvc_expander.</description>
    </item>
    <item>
      <title>代码覆盖率</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/04_cover_line/</guid>
      <description>TBD [简单描述 + 参考]&#xA;本项目中相关涉及位置 1. build script picker命令行开启代码覆盖率(picker -c参数)、设置目标覆盖文件(line_coverage_files函数)&#xA;1. Env中的fixture 通过函数toffee-test.set_line_coverage把覆盖率文件传递给toffe-test。&#xA;忽略指定统计 1、通过 verilator 指定忽略统计的内容&#xA;2、提过toffee指定需要过滤掉的内存&#xA;def set_line_coverage(request, datfile, ignore=[]): &amp;#34;&amp;#34;&amp;#34;Pass Args: request (pytest.Request): Pytest的默认fixture， datfile (string): DUT生成的 ignore (list[str]): 覆盖率过滤文件/或者文件夹 &amp;#34;&amp;#34;&amp;#34; ignore参数可以指定在覆盖率文件中需要过滤掉的内容，例如：&#xA;... set_line_coverage(request, coverage_file, get_root_dir(&amp;#34;scripts/backend_ctrlblock_decode&amp;#34;)) 在统计覆盖率时，会在&amp;quot;scripts/backend_ctrlblock_decode&amp;quot;目录中搜索到line_coverage.ignore文件，然后按其中没行的通配符进行过滤。&#xA;查看统计结果 在 测试报告 和 进度章节 有展示</description>
    </item>
    <item>
      <title>功能覆盖率</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/03_add_test/05_cover_func/</guid>
      <description>什么是功能覆盖率 [TBD]、为什么需要反标&#xA;本项目中相关涉及位置 1、Env 中创建 cover group 2、Env 或者 Test case中使用 3、fixture传递结果给toffee-report&#xA;指定Group名称 测试报告通过Group名字和 DUT名字进行匹配，利用comm.UT_FCOV 获取 DUT前缀，例如在Python模块ut_backend/ctrl_block/decode/env/decode_wrapper.py中进行如下调用：&#xA;from comm import UT_FCOV # 本模块名为：ut_backend.ctrl_block.decode.env.decode_wrapper # 通过../../去掉了上级模块env和decode_wrapper # UT_FCOV会默认去掉前缀 ut_ name = UT_FCOV(&amp;#34;../../INT&amp;#34;) name的值为backend.ctrl_block.decode.INT，在最后统计结果时，会安装最长前缀匹配到目标UT（即匹配到：backend.ctrl_block.decode 模块）</description>
    </item>
    <item>
      <title>目标验证单元</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/00_unitychip_for_xiangshan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/00_unitychip_for_xiangshan/</guid>
      <description>当前版本： 20241201142531-main-365f53f574ba5c6875b3389824a3c898c642ed2b 20241129112435-main-79ccae9d5df92c4e167547564b97bd8846b7ecb6 20241129111104-main-8e0cb45a86ec3ffd779723e17ede379081431c42 查看测试报告 上图共有-个模块，默认情况下模块为灰色，当模块中的测试用例数大于-时，该模块被完全点亮。目前已经完全点亮的模块为-个，待点亮的模块有-个。&#xA;通用处理器模块简介 高性能处理器是现代计算设备的核心，它们通常由三个主要部分组成：前端、后端和访存系统。这些部分协同工作，以确保处理器能够高效地执行复杂的计算任务。&#xA;前端：前端部分，也被称为指令获取和解码阶段，负责从内存中获取指令并将其解码成处理器可以理解的格式。这一阶段是处理器性能的关键，因为它直接影响到处理器可以多快地开始执行指令。前端通常包括指令缓存、分支预测单元和指令解码器。指令缓存用于存储最近访问过的指令，以减少对主内存的访问次数，从而提高处理速度。分支预测单元则尝试预测程序中的条件分支，以便提前获取和解码后续指令，这样可以减少等待分支结果的时间。&#xA;后端：后端部分，也称为执行阶段，是处理器中负责实际执行指令的地方。这一阶段包括了算术逻辑单元（ALU）、浮点单元（FPU）和各种执行单元。这些单元负责进行算术运算、逻辑运算、数据传输和其他处理器操作。后端的设计通常非常复杂，因为它需要支持多种指令集架构（ISA）并优化性能。为了提高效率，现代处理器通常采用超标量架构，这意味着它们可以同时执行多条指令。&#xA;访存：访存系统是处理器与内存之间交互的桥梁。它包括了数据缓存、内存控制器和高速缓存一致性协议。数据缓存用于存储处理器频繁访问的数据，以减少对主内存的访问次数。内存控制器负责管理处理器与内存之间的数据传输。高速缓存一致性协议确保在多处理器系统中，所有处理器看到的内存状态是一致的。&#xA;高性能处理器的设计需要在这三个部分之间找到平衡，以实现最佳的性能。这通常涉及到复杂的微架构设计，以及对处理器流水线的优化。</description>
    </item>
    <item>
      <title>准备验证环境</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/01_verfiy_env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/01_verfiy_env/</guid>
      <description>基础环境需求 本项目基于Python编程语言进行UT验证，采用的工具和测试框架为picker和toffe，环境需求如下：&#xA;Linux操作系统。建议WSL2下安装Ubuntu22.04。 Python。建议Python3.11。 picker。按照快速开始中的提示安装最新版本。 lcov 用于后续test阶段报告生成。使用包管理器即可下载：sudo apt install lcov 环境配置完成后，clone仓库：&#xA;git clone https://github.com/XS-MLVP/UnityChipForXiangShan.git cd UnityChipForXiangShan pip3 install -r requirements.txt # 安装python依赖（例如 toffee） 下载RTL代码： 默认从仓库https://github.com/XS-MLVP/UnityChipXiangShanRTLs中下载。用户也可以自行按照XiangShan文档编译生成RTL。&#xA;make rtl # 该命下载最新的rtl代码，并解压至rtl目录，并创建软连接 所有RTL下载包请在UnityChipXiangShanRTLs中查看。&#xA;RTL压缩包的命名规范为：名称-微架构-Git标记-日期编号.tar.gz，例如openxiangshan-kmh-97e37a2237-24092701.tar.gz。在使用时，仓库代码会过滤掉git标记和后缀，例如通过 cfg.rtl.version 访问到的版本号为：openxiangshan-kmh-24092701。压缩包内的目录结构为：&#xA;openxiangshan-kmh-97e37a2237-24092701.tar.gz └── rtl # 目录 |-- *.sv # 所有sv文件 `-- *.v # 所有v文件 编译DUT 该过程的目的是将RTL通过picker工具打包为Python模块。可以通过make命令指定被打包DUT，也可以一次性打包所有DUT。&#xA;如果想要自行打包某个dut，需要创建编写scripts目录中的build_ut_&amp;lt;name&amp;gt;.py脚本。这一脚本必须实现一个build方法，在打包时会被自动调用。此外还有一个line_coverage_files方法，用于指定行覆盖率参考的文件。&#xA;picker的打包支持内部信号的加入，详见picker的--internal参数，传递给其一个自定义的yaml即可。&#xA;# 调用scripts目录中的build_ut_&amp;lt;name&amp;gt;.py中的build方法，创建待验证的Python版DUT make dut DUTS=&amp;lt;name&amp;gt; # DUTS的值如果有多个，需要用逗号隔开，支持通配符。DUTS默认值为 &amp;#34;*&amp;#34;，编译所有DUT # 例如： make dut DUTS=backend_ctrl_block_decode 以make dut DUTS=backend_ctrl_block_decode为例，命令执行完成后，会在dut目录下生成对应的Python包：&#xA;dut/ ├── __init__.py ├── DecodeStage ├── Predecode └── RVCExpander 完成转换后，在测试用例代码中可以import对应的DUT，例如：</description>
    </item>
    <item>
      <title>运行测试</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/02_run_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/02_run_test/</guid>
      <description>本项目基于PyTest测试框架进行验证。运行测试时，PyTest框架自动搜索所有test_*.py文件，并自动执行其中所有以test_开头的测试用例（Test Case）。&#xA;# 执行所有ut_*目录中的test case make test_all # 执行指定目录下的test case make test target=&amp;lt;dir&amp;gt; # 例如执行ut_backend/ctrl_block/decode目录中所有的test case make test target=ut_backend/ctrl_block/decode 可通过args参数传递Pytest的运行参数，例如启动x-dist插件的多核功能：&#xA;make test args=&amp;#34;-n 4&amp;#34; # 启用 4 个进程 make test args=&amp;#34;-n auto&amp;#34; # 让框架自动选择启用多少个进程 *注：x-dist可以在多节点上并发运行测试，可参考其文档&#xA;运行完成后，默认在out/report目录会生成html版本的测试报告，其 html 文件可通过浏览器直接打开查看（VS Code IDE建议安装Open In Default Browser插件）。&#xA;运行测试主要完成以下三部分内容：&#xA;按要求运行Test Case，可通过cfg.tests中的选项进行配置 统计测试结果，输出测试报告。有toffee-report自动生成 (总测试报告，所有Test的结果合并在一起) 根据需要（cfg.doc_result.disable = True）在测试报告上进行进一步数据统计 </description>
    </item>
    <item>
      <title>如何参与本项目</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/06_join_us/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/06_join_us/</guid>
      <description>如何提交Bug 按 ISSUE 模板进行提交，标记上对应的标签（bug，bug等级等）&#xA;对应模块的维护者进行检查，并修改他给出的标记和香山分&#xA;如何提交文档 本仓库文档文档以PR的形式在本仓库提交，DUT文档在仓库xxxxx中进行提交。&#xA;本项目欢迎任何人以ISSUE、DISCUSS、Fork、PR的方式参与。&#xA;万众一芯QQ交流群：</description>
    </item>
    <item>
      <title>模板-PR</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/08_template_pr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/08_template_pr/</guid>
      <description># Description Please include a summary of the changes and the related issue. Please also include relevant motivation and context. List any dependencies that are required for this change. Fixes # (issue) ## Type of change Please delete options that are not relevant. - [ ] Bug fix (non-breaking change which fixes an issue) - [ ] New feature (non-breaking change which adds functionality) - [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected) - [ ] This change requires a documentation update # How Has This Been Tested?</description>
    </item>
    <item>
      <title>模板-ISSUE</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/09_template_issue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/09_template_issue/</guid>
      <description>## Description A brief description of the issue. ## Steps to Reproduce 1. Describe the first step 2. Describe the second step 3. Describe the third step 4. ... ## Expected Result Describe what you expected to happen. ## Actual Result Describe what actually happened. ## Screenshots If applicable, add screenshots to help explain your problem. ## Environment - OS: [e.g. Windows 10, macOS 10.15, Ubuntu 20.04] - Browser: [e.g. Chrome 86, Firefox 82, Safari 14] - Version: [e.</description>
    </item>
    <item>
      <title>模板-UT-README</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/10_template_ut_readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/10_template_ut_readme/</guid>
      <description># 模块名称 ## 测试目标 &amp;lt;测试目标、测试方法描述&amp;gt; ## 测试环境 &amp;lt;测试环境描述，依赖描述&amp;gt; ## 功能检测 &amp;lt;给出目标待测功能与对应的检测方法&amp;gt; |序号|所属模块|功能描述|检查点描述|检查标识|检查项| |-|-|-|-|-|-| |-|-|-|-|-|-| ## 验证接口 &amp;lt;接口的描述&amp;gt; ## 用例说明 #### 测试用例1 |步骤|操作内容|预期结果|覆盖功能点| |-|-|-|-| |-|-|-|-| #### 测试用例2 |步骤|操作内容|预期结果|覆盖功能点| |-|-|-|-| |-|-|-|-| ## 目录结构 &amp;lt;对本模块的目录结构进行描述&amp;gt; ## 检测列表 - [ ] 本文档符合指定[模板]()要求 - [ ] Env提供的API不包含任何DUT引脚和时序信息 - [ ] Env的API保持稳定（共有[ X ]个） - [ ] Env中对所支持的RTL版本（支持版本[ X ]）进行了检查 - [ ] 功能点（共有[ X ]个）与[设计文档]()一致 - [ ] 检查点（共有[ X ]个）覆盖所有功能点 - [ ] 检查点的输入不依赖任何DUT引脚，仅依赖Env的标准API - [ ] 所有测试用例（共有[ X ]个）都对功能检查点进行了反标 - [ ] 所有测试用例都是通过 assert 进行的结果判断 - [ ] 所有DUT或对应wrapper都是通过fixture创建 - [ ] 在上述fixture中对RTL版本进行了检查 - [ ] 创建DUT或对应wrapper的fixture进行了功能和代码行覆盖率统计 - [ ] 设置代码行覆盖率时对过滤需求进行了检查 展示效果如下：</description>
    </item>
    <item>
      <title>常用API</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/97_api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/97_api/</guid>
      <description>comm 模块 在comm中提供了部分可公用的API，可通过以下方式进行调用：&#xA;# import all from comm import * # or direct import functions you need from com import function_you_need # or access from module import comm comm.function_you_need() cfg 子模块 get_config(cfg=None) 获取当前的Config配置&#xA;输入：如果cfg不为空，则返回cfg。否则则自动通过toffee获取全局Config。 返回：Config对象 import comm cfg = comm.get_config() print(cfg.rtl.version) cfg_as_str(cfg: CfgObject): 把config对象转换为字符类型&#xA;输入：Config对象 返回：编码后的Config对象 import comm cfg_str = comm.cfg_as_str(comm.get_config()) cfg_from_str(cfg_str) 把字符类型的Config对象还原&#xA;输入：编码后的Config对象 返回：Config对象 import comm cfg = comm.cfg_from_str(cfg_str) dump_cfg(cfg: CfgObject = None, cfg_file=None) 把config对象保持到文件&#xA;输入： cfg 需要保存的config cfg_file 目标文件 import comm cfg = comm.</description>
    </item>
    <item>
      <title>其他</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_others/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/98_others/</guid>
      <description>测试用例管理 如果测试用例和目标RTL版本紧密相关，RTL发生变化，之前的测试用例不一定适用。此外，不同场景下有不同需求，例如验证测试环境时，不运行耗时太长的用例等。因此需要对用例进行管理，让用户能在在特定场景下跳过某些用例。为了实现该目标，我们需要通过pytest.mark.toffee_tags对于每个用例进行tag和version标记。然后在配置文件中设置需要跳过哪些tag或者只运行哪些tag的测试。&#xA;@pytest.mark.toffee_tags(&amp;#34;my_tag&amp;#34;, &amp;#34;version1 &amp;lt; version13&amp;#34;) def test_case_1(): ... 例如上述test_case_1被标记上了标签my_tag，支持版本设置为version1到version13。因此可以在配置文件中指定test.skip-tags=[&amp;quot;my_tag&amp;quot;]，来表示运行过程中跳过该用例。&#xA;pytest.mark.toffee_tags的参数说明如下：&#xA;@pytest.mark.toffee_tags( tag: Optional[list, str] = [] # 用例标签 version: Optional[list, str] = [], # 用例rtl版本需求 skip: callable = None, # 自定义是否调过该用例，skip(tag, version, item): (skip, reason) ) toffee_tags函数的参数tag支持str和list[str]类型。version参数也可以是str和list[str]类型，当为list类型时，进行精确匹配，如果为str则匹配规则如下：&#xA;name-number1 &amp;lt; namer-number2: 表示版本需要在number1和number2之间（包含边界，number表示数字，也可以为小数，eg 1.11） name-number1+：表示number1版本以及以后的版本 name-number1-：表示number1版本以及以前的版本 如果不存在上述情况，且有*或者?表示通配符类型。其他情况为精确匹配。&#xA;预定义标签，可以在comm/constants.py中查看，例如：&#xA;# Predefined tags for test cases TAG_LONG_TIME_RUN = &amp;#34;LONG_TIME_RUN&amp;#34; # 运行时间长 TAG_SMOKE = &amp;#34;SMOKE&amp;#34; # 冒烟测试 TAG_RARELY_USED = &amp;#34;RARELY_USED&amp;#34; # 非常少用 TAG_REGRESSION = &amp;#34;REGRESSION&amp;#34; # 回归测试 TAG_PERFORMANCE = &amp;#34;PERFORMANCE&amp;#34; # 性能测试 TAG_STABILITY = &amp;#34;STABILITY&amp;#34; # 稳定测试 TAG_SECURITY = &amp;#34;SECURITY&amp;#34; # 安全测试 TAG_COMPATIBILITY = &amp;#34;COMPATIBILITY&amp;#34; # 兼容测试 TAG_OTHER = &amp;#34;OTHER&amp;#34; # 其他 TAG_CI = &amp;#34;CI&amp;#34; # 集成测试 TAG_DEBUG = &amp;#34;DEBUG&amp;#34; # 测试 TAG_DEMO = &amp;#34;DEMO&amp;#34; # demo 在默认配置中(config/_default.</description>
    </item>
    <item>
      <title>必要规范</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/99_constraint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/docs/99_constraint/</guid>
      <description>为了方便将所有人的贡献集合在一起，需要在编码、环境、文档编写等方面采用相同的“规范”。&#xA;环境要求 python： 在python编码过程中，尽可能的采用标准库，采用兼容Python3大部分版本的通用语法（尽可能的在Python3.6 - Python3.12中通用），不要使用过旧或者过新的语法。 操作系统： 建议Ubuntu 22.04，windows下，建议使用WSL2环境。 hugo 建议版本 0.124.1（版本过旧不支持软连接） 少依赖 尽可能少的使用第三方C++/C库 picker 建议使用wheel安装picker工具和xspcomm库 测试用例 代码风格 建议采用 PEP 8 规范 build脚本 需要按DUT的命名结构进行规范命名，不然无法正确收集验证结果。例如backend.ctrl_block.decodeUT在scripts目录中对应的build文件名称应该为build_ut_backend_ctrl_block_decode.py(以固定前缀build_ut_开始，点.用下划线_进行替换)。在脚本中实现 build(cfg) -&amp;gt; bool 和 line_coverage_files(cfg) -&amp;gt; list[str] 方法。build用于编译DUT为python模块，line_coverage_files方法用于返回需要统计的代码行覆盖率文件。 用例标签 如果用例无法做到版本通用，需要用pytest.mark.toffee_tags标记支持的版本。 用例抽象 编写的测试用例输入不能出现DUT的具体引脚等强耦合内容，只能调用基于DUT之上的函数封装。例如对于加法器 adder，需要把dut的目标功能封装为 dut_wrapper.add(a: int, b: int) -&amp;gt; int, bool，在test_case中仅仅调用 sum, c = add(a, b)进行测试。 覆盖抽象 在编写功能覆盖率时，其检查点函数的输入也不能有DUT引脚。 环境抽象 对于一个验证，通常分为2部分：Test Case 和 Env （用例以外的都统一称为Env，它包含DUT、驱动、监控等），其中Env需要提供对外的功能抽象接口，不能对外呈现出太多细节。 测试说明 在每个DUT的验证环境中，需要通过README.md对该环境进行说明，例如需要对Env提供给Case的接口进行说明，目录结构说明等。 PR编写 标题 简洁明了，能概括PR的主要内容。 详细描述 详细说明PR的目的，修改的内容以及相关背景信息。入解决已有的问题需要给出链接（例如Issue）。 关联问题 在描述中关联相关问题，例如 Fixes #123，以便在合并PR时关闭关联问题。 测试 需要进行测试，并对测试结果进行描述 文档 PR涉及到的文档需要同步修改 分解 当PR涉及到的修改很多时，需要判断是否拆分成多个PR 检查清单 检查编译是否通过、代码风格是否合理、是否测试通过、是否有必要的注释等 模板 以及提供的PR模块请参考链接。 ISSUE编写 要求同上</description>
    </item>
    <item>
      <title>搜索结果</title>
      <link>https://xs-mlvp.github.io/UnityChipForXiangShan/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xs-mlvp.github.io/UnityChipForXiangShan/search/</guid>
      <description></description>
    </item>
  </channel>
</rss>
