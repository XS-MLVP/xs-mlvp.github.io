<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>香山微架构开放验证第一期：昆明湖BPU模块UT验证实战 – 香山 BPU 子模块</title>
    <link>https://xs-mlvp.github.io/xs-bpu/categories/%E9%A6%99%E5%B1%B1-bpu-%E5%AD%90%E6%A8%A1%E5%9D%97/</link>
    <description>Recent content in 香山 BPU 子模块 on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	  <atom:link href="https://xs-mlvp.github.io/xs-bpu/categories/%E9%A6%99%E5%B1%B1-bpu-%E5%AD%90%E6%A8%A1%E5%9D%97/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: BPU 顶层模块</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/modules/00_bpu_top/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/modules/00_bpu_top/</guid>
      <description>
        
        
        &lt;p&gt;BPU 顶层整体的功能和结构已经在之前的文档中粗略的描述，对于验证 BPU 顶层的同学来说，可能还需要更加细致的描述。由于 BPU 顶层功能较多，本节将 BPU 划分为了几大功能点进行更进一步的描述。但由于 BPU 顶层细节过多，更进一步的细节需参照代码进行理解。&lt;/p&gt;
&lt;h2 id=&#34;生成器维护方法&#34;&gt;生成器维护方法&lt;/h2&gt;
&lt;p&gt;通过香山的基础设计文档，我们知道，BPU 顶层是通过一个个生成器来维护 s0 周期的各类变量的，例如 PC、分支历史等，并且其核心概念是，通过预测结果重定向信号决定采用哪个流水级的结果。&lt;/p&gt;
&lt;p&gt;BPU 顶层中所有的生成器共有 6 个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;npcGen&lt;/strong&gt; 维护 pc&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ghistPtrGen&lt;/strong&gt; 维护全局历史指针&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ghvBitWriteGens&lt;/strong&gt; 维护全局历史写入数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;foledGhGen&lt;/strong&gt; 维护折叠历史&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lastBrNumOHGen&lt;/strong&gt; 维护上周期最后一个生效的分支指令位置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;aheadFhObGen&lt;/strong&gt; 维护分支历史最老位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，除了 &lt;code&gt;npcGen&lt;/code&gt; 以外，其余生成器都会在本文档中进行介绍。本节中我们着重探讨一下生成器的产生下一次预测的方法。&lt;/p&gt;
&lt;p&gt;在代码中你可以看到生成器用类似下面这种方式进行定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;PhyPriorityMuxGenerator&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，代码通过多条语句对生成器的数据来源进行注册：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;B&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;reg&lt;/span&gt;&lt;span style=&#34;color:#a40000&#34;&gt;，&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;s1_valid&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s1_target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;s2_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;s3_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3_target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;do_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;valid&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;do_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;bits&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cfiUpdate&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每一行被称作一次注册，在一次注册中第一个信号参数是数据有效信号，第二个信号参数包含具体的数据。 生成器的优先级也是按照注册的顺序来决定，越往后优先级越高，因此，同一时刻的优先级从低到高依次为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;s0 阻塞的数据&lt;/li&gt;
&lt;li&gt;根据 s1 预测结果更新后的数据&lt;/li&gt;
&lt;li&gt;根据 s2 预测结果更新后的数据&lt;/li&gt;
&lt;li&gt;根据 s3 预测结果更新后的数据&lt;/li&gt;
&lt;li&gt;BPU 外部重定向中的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样一来，我们就可以在预测结果重定向有效时，避免采用较早流水级的预测结果，而采用纠正后的预测结果。也使得我们可以将外部重定向请求作为最高优先级去处理。&lt;/p&gt;
&lt;p&gt;我们可以得出所有生成器产生 s0 信号的方法：&lt;strong&gt;在所有数据有效信号中，如果只有一个有效的，则选取它对应的数据，如果有多个数据有效信号生效，则选取优先级最高的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;全局分支历史&#34;&gt;全局分支历史&lt;/h2&gt;
&lt;p&gt;我们知道，全局分支历史在 BPU 顶层进行维护，维护的策略与 PC 的维护策略一致。即在每个阶段流水级预测结果产生之后，会根据相应信号对全局分支历史进行更新。&lt;/p&gt;
&lt;p&gt;顶层为了维护全局分支历史定义了两组信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ghv&lt;/strong&gt; 存储了全局分支历史（最大长度 256）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ghist_ptr&lt;/strong&gt; 全局分支历史指针，指向全局分支历史当前的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与 &lt;code&gt;s0_pc&lt;/code&gt;, &lt;code&gt;s1_pc&lt;/code&gt;, &lt;code&gt;s2_pc&lt;/code&gt; 一样，BPU 顶层为全局历史指针也维护了每一阶段的信号 &lt;code&gt;s0_ghist_ptr&lt;/code&gt;, &lt;code&gt;s1_ghist_ptr&lt;/code&gt;, &lt;code&gt;s2_ghist_ptr&lt;/code&gt; ，但 &lt;strong&gt;&lt;code&gt;ghv&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;中的内容是位置固定的，我们仅通过&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;ghist_ptr&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;来定位当前的全局分支历史从哪里开始。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;通过-ghist_ptr-计算当前全局分支历史&#34;&gt;通过 ghist_ptr 计算当前全局分支历史&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ghist_ptr&lt;/code&gt; 的使用仅在 BPU 顶层可见，而我们向子预测器传入的，是全局历史寄存器中的数据根据 &lt;code&gt;ghist_ptr&lt;/code&gt; 所移位之后的全局分支历史。&lt;strong&gt;在子预测器拿到的全局分支历史中，最低位对应全局分支历史的最新位，最高位对应全局分支历史的最老位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么是怎样进行移位的呢，我们首先来看一下全局历史是怎样在 &lt;code&gt;ghv&lt;/code&gt; 中进行存储的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Plain&#34; data-lang=&#34;Plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;|===== ghist =====&amp;gt;| =======&amp;gt;|
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;n                  ^         0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                   ghist_ptr
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上图所示，序列表示整个 &lt;code&gt;ghv&lt;/code&gt; 寄存器，&lt;code&gt;ghist_ptr&lt;/code&gt; 指向 &lt;code&gt;ghv&lt;/code&gt; 中的某个位置，这个位置代表了全局分支历史的最新位。当需要添加一位新的全局历史记录时，首先将 &lt;code&gt;ghist_ptr&lt;/code&gt; 减 1，然后将该位写在其所指向的位置。当 &lt;code&gt;ghist_ptr&lt;/code&gt; 减到 0 后，又会循环回来指向最高位，因此会覆盖之前写入的全局分支历史。&lt;/p&gt;
&lt;p&gt;但不管怎样，从 &lt;code&gt;ghist_ptr&lt;/code&gt; 所指向的位置开始，指针越增加，历史越老。因此，当&lt;strong&gt;我们需要计算当前全局分支历史时，只需要将&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;ghv&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;寄存器循环右移&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;ghist_ptr&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;位即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;全局分支历史的更新&#34;&gt;全局分支历史的更新&lt;/h3&gt;
&lt;p&gt;全局分支历史的更新策略与 &lt;code&gt;pc&lt;/code&gt; 更新的策略一致，在每一个流水级都需要根据当前流水级的预测结果生成一个 &lt;strong&gt;当前流水级的指针及&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;ghv&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;的更新说明&lt;/strong&gt;，最终都送给相关生成器来处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ghv&lt;/code&gt; 的更新说明即 用于指导 &lt;code&gt;ghv&lt;/code&gt; 寄存器的更新的某些信息。香山 BPU 中维护了两个信息来完成这一职责：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ghv_wdata&lt;/code&gt; 需要向 ghv 中写入的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ghv_wens&lt;/code&gt; 写入位掩码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终更新时，只需要将 &lt;code&gt;ghv_wens&lt;/code&gt; 所标识的位写入 &lt;code&gt;ghv_wdata&lt;/code&gt; 的对应位即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此每个流水级需要负责产生三组信息：&lt;/strong&gt;&lt;code&gt;ghist_ptr&lt;/code&gt;,&lt;code&gt;ghv_wdata&lt;/code&gt;, &lt;code&gt;ghv_wens&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;具体地，预测结果中最多含有两条分支指令，我们只需将实际情况来设置这几个信息即可，举几种情况的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有第一个槽有效，并且其中条件分支指令被预测为不跳转。则将 &lt;code&gt;ghv_wens&lt;/code&gt; 的下一个位置置 0 ，&lt;code&gt;ghv_wens&lt;/code&gt; 的对应位置置 1, 同时 &lt;code&gt;ghist_ptr&lt;/code&gt; 减一。&lt;/li&gt;
&lt;li&gt;两个槽都存放了条件分支指令，第一条被预测为不跳转, 第二条被预测为跳转。此时 &lt;code&gt;ghist_ptr&lt;/code&gt; 应该减二，并且其他两个信息应该指示向 &lt;code&gt;ghv&lt;/code&gt; 中写入 01。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此处在生成器中只维护了一个 &lt;code&gt;ghv_wdata&lt;/code&gt; 信息（通过 &lt;code&gt;ghvBitWriteGens&lt;/code&gt; 生成器维护），&lt;code&gt;ghv_wens&lt;/code&gt; 并没有通过生成器来维护。这是因为此处使用了一个小技巧，使用了生成器的 &lt;code&gt;ghv_wdata&lt;/code&gt; 最终输出的是被选中阶段的结果，而 &lt;code&gt;ghv_wens&lt;/code&gt; 将所有阶段的 &lt;code&gt;ghv_wens&lt;/code&gt; 进行&lt;strong&gt;按位或&lt;/strong&gt;来使用。&lt;/p&gt;
&lt;p&gt;这是基于如下考虑的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果较晚的流水线阶段有效。全局历史指针被恢复到较老的位置，即便被早期流水的 &lt;code&gt;ghv_wens&lt;/code&gt; 修改了较新位置的历史也没关系。&lt;/li&gt;
&lt;li&gt;如果较早的流水线阶段有效。全局历史指针继续向较新的位置更新，而后期流水线会因为 redirect 未生效而不把 &lt;code&gt;ghv_wens&lt;/code&gt; 置位。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分支折叠历史&#34;&gt;分支折叠历史&lt;/h2&gt;
&lt;p&gt;送入预测器的分支折叠历史也是由顶层 BPU 来维护的，BPU 为了缩短折叠历史的更新延迟，维护了很多变量，来支持分支折叠历史的快速更新，我们将会重点介绍这一策略，并介绍每一个变量的作用。&lt;/p&gt;
&lt;p&gt;在开始之前，我们先来看一下分支折叠历史是怎样定义的，结构又是怎样的。&lt;/p&gt;
&lt;h3 id=&#34;分支折叠历史-1&#34;&gt;分支折叠历史&lt;/h3&gt;
&lt;p&gt;如果你查看了 BPU 全局接口的文档，你就会知道，子预测器拿到的是一个不同长度位向量的数组，代表了各种长度的折叠历史，而这些&lt;strong&gt;折叠历史都是由全局分支历史压缩而成&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于全局分支历史，我们有一个存放全局分支历史的寄存器，长度为 256。为了方便举例，我们假设全局分支历史的长度为 15 位，并且经过移位之后，我们可以拿到一个这样的分支历史：最低位是最新的历史记录，最高位是最老的历史记录。&lt;/p&gt;
&lt;p&gt;此时如果我们需要用这 15 位，产生一个 6 位的折叠历史，会使用异或的策略进行压缩，具体过程是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Plain&#34; data-lang=&#34;Plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    h[5]         h[4]       h[3]    h[2]   h[1]   h[0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    h[11]        h[10]      h[9]    h[8]   h[7]   h[6]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^                                   h[14]  h[13]  h[12]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;---------------------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    h[5]^h[11]   h[4]^h[10]         ...           h[0]^h[6]^h[12]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即将其按照上面的方式排列之后，将每一位上的值进行异或，结果便是求出的长度为 6 的折叠历史。&lt;/p&gt;
&lt;h3 id=&#34;分支折叠历史更新方法&#34;&gt;分支折叠历史更新方法&lt;/h3&gt;
&lt;p&gt;此时我们想要对这一分支折叠历史进行更新，当我们向全局分支历史插入一位新历史时，是从最低位插入的，也就是说原来的 h[0] 变为了 h[1]，如果我们想求此时的分支折叠历史，只需要再进行一遍异或运算。但这样的效率太低了，因为异或的操作有可能变得特别长，我们可以来探寻一下一次更新对分支折叠历史的影响。&lt;/p&gt;
&lt;p&gt;上述例子中，插入一位新历史之前，6 位折叠历史的生成是按照下面这种排列生成的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Plain&#34; data-lang=&#34;Plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;h[5]   h[4]   h[3]  h[2]  h[1]  h[0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;h[11]  h[10]  h[9]  h[8]  h[7]  h[6]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    h[14] h[13] h[12]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;插入一位新历史之后变成了下面这样&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Plain&#34; data-lang=&#34;Plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;h[4]   h[3]   h[2]  h[1]  h[0]  h[new]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;h[10]  h[9]   h[8]  h[7]  h[6]  h[5]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           (h[14])  h[13] h[12] h[11]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以发现一些规律&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Plain&#34; data-lang=&#34;Plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;插入前：
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;h[5]   {h[4]   h[3]  h[2]  h[1]  h[0] }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;h[11]  {h[10]  h[9]  h[8]  h[7]  h[6] }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       {             h[14] h[13] h[12]}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;插入后：
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{h[4]   h[3]   h[2]  h[1]  h[0] } h[new]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{h[10]  h[9]   h[8]  h[7]  h[6] } h[5]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{           (h[14])  h[13] h[12]} h[11]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;大括号中的内容发生了整体的左移，h[5] 和 h[11]，由最高位变到了最低位。那么表现在压缩后的历史上不就是我们常见的循环左移吗！&lt;/p&gt;
&lt;p&gt;但其中有且仅有两个位的值发生了变化，一个是新加入的 h[new]，一个是被舍弃掉的 h[14]。h[new] 肯定在第一位，被舍弃的位置也是固定的。&lt;strong&gt;因此我们想要完成一次更新，只需要知道 新插入历史的值 和 前一次历史的最老位即可&lt;/strong&gt;。循环移位后，将这两个位置根据实际情况进行一次修改便可拿到更新后的折叠历史。&lt;/p&gt;
&lt;h3 id=&#34;更新方法实现&#34;&gt;更新方法实现&lt;/h3&gt;
&lt;p&gt;BPU 顶层为了实现这种更新，正是通过维护最老位，这通过两个额外的变量来实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ahead_fh_oldest_bits&lt;/strong&gt;  全局分支历史的最老位，还额外往前存储了若干位&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;last_br_num_oh&lt;/strong&gt;  上一次预测最后一个生效的分支指令在第几个槽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里有一处为时序所优化的点，因为当流水级的预测结果出来时，全局历史指针才能通过跳转情况进行更新，等到全局历史指针更新完再来更新最老位会增加时延。因此我们将跳转情况维护起来，等到下一周期用的时候再来用跳转情况更新最老位。&lt;/p&gt;
&lt;p&gt;此时的最老位也需要多往前维护几位，因为在使用时，利用跳转情况更新后，前面较新的几位就会变成最老位了。&lt;/p&gt;
&lt;p&gt;所以与折叠历史相关的生成器共有三个：&lt;code&gt;foldedGhGen&lt;/code&gt;, &lt;code&gt;lastBrNumOhGen&lt;/code&gt;, &lt;code&gt;aheadFhObGen&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每次折叠历史更新时需要的信息分别是&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新前的折叠历史信息&lt;/li&gt;
&lt;li&gt;全局分支历史最老位(ahead_fh_oldest_bits）&lt;/li&gt;
&lt;li&gt;上次预测的跳转情况(last_br_num_oh)&lt;/li&gt;
&lt;li&gt;本次更新是否有指令跳转&lt;/li&gt;
&lt;li&gt;本次更新的跳转情况：最后一个生效的分支指令在第几个槽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每次折叠历史更新时，都需要根据 &lt;code&gt;last_br_num_oh&lt;/code&gt; 和 &lt;code&gt;ahead_fh_oldest_bits&lt;/code&gt; 求出真正的最老位，然后通过最老位与本次更新的跳转情况将其中的若干位进行修改，最后进行循环左移，便完成了更新操作。&lt;/p&gt;
&lt;h2 id=&#34;流水线控制方法&#34;&gt;流水线控制方法&lt;/h2&gt;
&lt;p&gt;流水线控制是 BPU 功能的核心，逻辑也最为复杂，BPU 顶层中所有的流水线控制信号如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;s1_valid, s2_valid, s3_valid&lt;/strong&gt; 表示对应流水数据生效&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;s1_ready, s2_ready, s3_ready&lt;/strong&gt; 表示对应流水已准备好继续上一流水级的预测&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;s1_component_ready, s2_component_ready, s3_component_ready&lt;/strong&gt; 表示对应流水子预测器的 ready 情况&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;s0_fire, s1_fire, s2_fire, s3_fire&lt;/strong&gt; 握手成功信号，表示该流水数据生效，并成功传递给了下一流水&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;s1_flush, s2_flush, s3_flush&lt;/strong&gt; 表示当前流水是否需要冲刷&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;s2_redirect, s3_redirect&lt;/strong&gt; 表示当前流水在 fire 的同时，是否预测结果不同，需要产生预测结果重定向&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;valid-ready-与-fire&#34;&gt;valid, ready 与 fire&lt;/h3&gt;
&lt;p&gt;我们会逐步来介绍每个信号的作用，首先我们来看 &lt;code&gt;fire&lt;/code&gt; 信号，这一信号表示的含义是流水线握手成功，数据成功传给了下一流水。这标志着本周期结束时，本流水级的预测也随之结束，下周期开始时，下一流水级的预测即将开始。&lt;/p&gt;
&lt;p&gt;这需要两个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;valid&lt;/code&gt; 本流水级的数据是有效的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ready&lt;/code&gt; 与 &lt;code&gt;component_ready&lt;/code&gt; 分别指示了 BPU 顶层与预测器的下一流水级是否就绪。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当这两个信号同时置高时，&lt;code&gt;fire&lt;/code&gt; 信号有效，表示握手成功。如果我们单独把一次预测拿出来，那么时序应该是这样的（实际中，大多数时间每个流水线都是一直有效的）：&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;1.png&#34; width=&#34;400px&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;上文中提到的四组信号，除了 &lt;code&gt;component_ready&lt;/code&gt; 是由预测器输出，其余信号皆需 BPU 顶层来维护，而最终暴露给子预测器的，只有 &lt;code&gt;fire&lt;/code&gt; 一组信号。&lt;/p&gt;
&lt;p&gt;我们接下来以 s2 为例分别来看每个信号是如何维护的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ready&lt;/strong&gt; &lt;strong&gt;信号&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;s2_ready&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_fire&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;s2_valid&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该赋值语句是一个组合电路赋值，也就是说，&lt;code&gt;s2_ready&lt;/code&gt; 信号是与本周期的 &lt;code&gt;s2_fire&lt;/code&gt; 和 &lt;code&gt;s2_valid&lt;/code&gt; 直接相关联的，分为以下两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;s2_valid&lt;/code&gt; 信号在本周期无效，说明 s2 流水级目前是空的，自然可以接受新的数据，则 &lt;code&gt;s2_ready&lt;/code&gt; 有效&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s2_valid&lt;/code&gt; 信号在本周期有效，说明 s2 流水级目前有数据还未传递给下一级，但如果 &lt;code&gt;s2_fire&lt;/code&gt; ，那么本周期就会传递给下一级。此时 &lt;code&gt;s2_ready&lt;/code&gt; 有效，刚好指示数据可以在下一拍流入。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;valid 信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;s2_valid&lt;/code&gt; 信号目前为止维护是相对简单的，与 &lt;code&gt;s1_fire&lt;/code&gt; 信号和 &lt;code&gt;s2_ready&lt;/code&gt; 信号相关。其关系为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;s1_fire&lt;/code&gt; 有效，说明数据传进来，下一周期 &lt;code&gt;s2_valid&lt;/code&gt; 有效。&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;s2_fire&lt;/code&gt; 有效，说明数据流出去，下一周期 &lt;code&gt;s2_valid&lt;/code&gt; 无效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;fire 信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fire 信号相对特殊，但对于中间的流水级来说，维护非常简单，例如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;s2_fire&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_valid&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3_components_ready&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3_ready&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;只需考虑当前流水级的 &lt;code&gt;valid&lt;/code&gt; 和下一流水级的 &lt;code&gt;ready&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;但对 s0_fire 来说，没有 valid 信号，因此其直接等于 &lt;code&gt;s1_components_ready &amp;amp;&amp;amp; s1_ready&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于 s3_fire 来说，没有下一级的 ready 信号，因此其直接等于 &lt;code&gt;s3_valid&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;加入-flush-和-redirect&#34;&gt;加入 flush 和 redirect&lt;/h3&gt;
&lt;p&gt;我们知道，当流水线出现预测结果不同时，需要产生预测结果重定向信号，并且将之前的流水线清空。&lt;code&gt;flush&lt;/code&gt; 和 &lt;code&gt;redirect&lt;/code&gt; 正是在做这两项工作。&lt;code&gt;redirect&lt;/code&gt; 表示当前流水级是否需要重定向，&lt;code&gt;flush&lt;/code&gt; 则表示当前流水级是否需要冲刷。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;redirect 信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;s2_redirect&lt;/code&gt; 的产生方式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;s2_redirect&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_fire&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_redirect_s1_last_pred&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;也就是说，当 &lt;code&gt;s2_fire&lt;/code&gt; 时，并且 s2 的预测结果与上一周期保存的 s1 预测结果不同时，这个信号便有效。之后该信号将会连接到子预测器的输入，与 BPU 预测结果的输出，分别指导子预测器和  FTQ  的状态恢复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flush 信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;flush 信号是用于指导流水线冲刷的，例如 s3 重定向有效时，说明错误的预测结果已经流入流水线， s1 和 s2 此时全都是基于错误的结果来预测的，因此需要进行流水线冲刷，使之前的流水级都暂停工作，等待新的预测结果流入。&lt;/p&gt;
&lt;p&gt;具体地，他们之间有如下关系：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_flush&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3_flush&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3_redirect&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#000&#34;&gt;s1_flush&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_flush&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_redirect&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;也就是说，某个流水级 &lt;code&gt;redirect&lt;/code&gt; 有效，之前的流水级的 flush 全都会被置为有效。那么 flush 具有什么作用呢？答案是指导 valid 信号，如果本周期 valid 信号有效，但 fire 信号未生效，说明错误的数据没有被下一流水取走，此时 flush 有效后，在下一周期 valid 就会立即变为无效，以这种方式来避免错误数据长期存储在流水线中。&lt;/p&gt;
&lt;p&gt;但 flush 信号对 valid 信号的影响，也根据每一个流水级的不同而有一定差异。例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;s1 流水级。虽然 flush 有效，但是如果此时 &lt;code&gt;s0_fire&lt;/code&gt; 有效，说明新数据流入，那么下周期 valid 依然有效。&lt;/li&gt;
&lt;li&gt;s2 流水级。flush 有效，那么必定下周期不会 valid（因为 s1 也肯定被 flush），此时就可以直接将 valid 置为无效。但还存在一种特殊情况，&lt;code&gt;s2_redirect&lt;/code&gt; 发生时，&lt;code&gt;s2_flush&lt;/code&gt; 并没有被置为有效，此时如果发生 &lt;code&gt;s1_fire&lt;/code&gt;，s1 的错误预测结果也可能流入，此时还需根据 &lt;code&gt;s1_flush&lt;/code&gt; 信号来决定 &lt;code&gt;s2_valid&lt;/code&gt; 是否有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;flush 的使用较复杂，更详细的细节还需参考代码进行理解。&lt;/p&gt;
&lt;h2 id=&#34;重定向恢复逻辑&#34;&gt;重定向恢复逻辑&lt;/h2&gt;
&lt;p&gt;当 FTQ 发往 BPU 的重定向请求生效时就说明所有流水级的预测结果都是不正确的，此时应该将所有流水级进行冲刷，这可以通过将 &lt;code&gt;s3_flush&lt;/code&gt; 置为有效来实现。因此有&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3_flush&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;redirect_req&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;valid&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 BPU 中，重定向请求送入后被延迟一周期才正式使用，因此 &lt;code&gt;s1_valid&lt;/code&gt; 的信号也需要对 &lt;code&gt;flush&lt;/code&gt; 信号的响应做出一些改变。当重定向请求（延迟前）有效时，&lt;code&gt;s1_valid&lt;/code&gt; 下周期立即被置为无效，不需要再去参考 &lt;code&gt;s0_fire&lt;/code&gt; 信号了。&lt;/p&gt;
&lt;p&gt;此时 &lt;code&gt;npcGen&lt;/code&gt; 等生成器也需要直接去采用重定向请求中的数据来生成，这就相当于将 BPU 的状态重定向到出错之前状态的过程。但注意 BPU 默认的重定向等级为 &lt;code&gt;flushAfter&lt;/code&gt; ，即重定向请求会对应一条预测错误的指令，而 BPU 会认为这条指令虽然预测错了，但是已经被纠正并且交由后端执行了，因此下一次预测可以直接从下一条指令开始。&lt;/p&gt;
&lt;p&gt;所以在重定向恢复时，不仅需要将重定向接口中的信息恢复，还需要将这条预测错误的指令的执行情况也更新到历史中去。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 子模块文档</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/modules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/modules/</guid>
      <description>
        
        
        &lt;p&gt;本部分文档将会详细介绍香山分支预测单元的每一个模块，包括 BPU 顶层和五个子预测器。&lt;/p&gt;
&lt;p&gt;在每一个模块的文档中，我们将会详细介绍该模块在香山分支预测单元中所发挥的作用，以及该模块的算法原理、模块结构和时序等。&lt;/p&gt;
&lt;p&gt;负责一个模块验证的同学需要重点阅读对应文档并结合代码进行理解，其他文档亦可进行阅读以帮助你对香山分支预测单元整体功能的理解。理解过程中，你可能需要时刻回顾之前文档中所描述的基础设计思想及接口信号的含义。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: FTB 分支预测器</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/modules/03_ftb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/modules/03_ftb/</guid>
      <description>
        
        
        &lt;h2 id=&#34;ftb-简介&#34;&gt;FTB 简介&lt;/h2&gt;
&lt;p&gt;FTB 是香山 BPU 的第三个子预测器，它也能一并获取到 uFTB 和 TAGE-SC 的输出。在 FTB 的输入接口中，s1 通道含有 uFTB 的基础预测结果，s2 通道和 s3 通道中仅有 &lt;code&gt;br_taken_mask&lt;/code&gt; 一组信号被 TAGE-SC 填充，并无 FTB 项生成的基础预测结果。FTB 的工作便是为 s2 和 s3 通道提供基础预测结果。&lt;/p&gt;
&lt;p&gt;FTB 在功能和结构上都与 uFTB 类似，其主要区别就是 FTB 能够容纳更多的 FTB 项，并且 FTB 的预测结果是在 s2 与 s3 通道输出。正是由于容量大，其读出的速度上会比 uFTB 慢，无法被放置在第一周期产生预测结果，但大容量也使它能够获得更加精准的预测结果。&lt;/p&gt;
&lt;h2 id=&#34;uftb-功能简介&#34;&gt;uFTB 功能简介&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;缓存更多 FTB 项，为 s2 和 s3 通道提供基础预测结果。&lt;/strong&gt; FTB 预测器的本质是一个较大容量的存储器，其会根据当前预测的 PC 读出对应的 FTB 项，并在 s2 阶段产出预测结果。与此同时该 FTB 项还会被再保存一个周期，生成 s3 阶段预测结果。生成结果需要注意的点是要考虑到上一预测器输入的 &lt;code&gt;br_taken_mask&lt;/code&gt; 字段，避免在生成时丢失。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据更新请求，更新存储中的 FTB 项。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ftb-存储结构&#34;&gt;FTB 存储结构&lt;/h2&gt;
&lt;p&gt;FTB 预测器中 FTB 项被放置在了一个专门的存储结构中，叫做 &lt;code&gt;FTBBank&lt;/code&gt; ，在进一步查看 &lt;code&gt;FTBBank&lt;/code&gt; 的结构之前，我们先来看一下 &lt;code&gt;FTBBank&lt;/code&gt; 是怎样使用的。&lt;/p&gt;
&lt;h3 id=&#34;ftb-读请求&#34;&gt;FTB 读请求&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;FTBBank&lt;/code&gt; 的读请求接口如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;req_pc&lt;/strong&gt;  请求的 pc
&lt;ul&gt;
&lt;li&gt;接口类型：&lt;code&gt;Flipped(DecoupledIO(UInt(VAddrBits.W)))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;read_resp&lt;/strong&gt; 读出来的FTB项
&lt;ul&gt;
&lt;li&gt;接口类型：&lt;code&gt;FTBEntry&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;read_hits&lt;/strong&gt; 命中了哪一路 (way)
&lt;ul&gt;
&lt;li&gt;接口类型：&lt;code&gt;Valid(UInt(log2Ceil(numWays).W))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 &lt;code&gt;req_pc&lt;/code&gt; 的接口是 Decoupled 的，也就是说含有 valid 和 ready 信号。 FTB 需要在 s1 阶段开始之前便获取到 pc，因此 &lt;code&gt;s0_pc&lt;/code&gt; 被送入 &lt;code&gt;req_pc&lt;/code&gt; 接口，&lt;code&gt;s0_fire&lt;/code&gt; 信号被连接至 &lt;code&gt;req_pc&lt;/code&gt; 的 valid 信号，&lt;code&gt;ready&lt;/code&gt; 信号被连接至预测器的流水控制信号 &lt;code&gt;s1_ready&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;s0_fire&lt;/code&gt; 之后进入 s1 阶段，&lt;code&gt;s0_fire&lt;/code&gt; 的下一个周期，也就是在 &lt;code&gt;s1_fire&lt;/code&gt; 的同时，FTBBank 已经将读出的 FTB 项输出至 &lt;code&gt;read_resp&lt;/code&gt; 接口，并计算好了 &lt;code&gt;read_hits&lt;/code&gt; 。但此时因为读出已经浪费了过多时延，无法在 s1 阶段进行输出了，因此该读出结果被保存在内部寄存器中。在 s2 和 s3 阶段会在寄存器中读出该 FTB 项并生成预测结果。&lt;/p&gt;
&lt;h3 id=&#34;ftbbank&#34;&gt;FTBBank&lt;/h3&gt;
&lt;p&gt;FTBBank 中定义了一个存储器来存储所有的 FTB 项，存储器采用组相联的结构（如果你不清楚组相联的含义，请自行 RTFM），共含 512 个组（Set），每组有 4 路（Way），最多能存储 2048 个 FTB 项，存储 FTB 的同时还会存储与 FTB 项对应的 tag 用于匹配 FTB 项。&lt;/p&gt;
&lt;p&gt;具体地，tag 被定义为 &lt;code&gt;pc[29:10]&lt;/code&gt;，即在 pc 中截取了 20 位用于标识 FTB 项，pc 的具体划分方式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Plain&#34; data-lang=&#34;Plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  pc: | ... |&amp;lt;-- tag(20 bits) --&amp;gt;|&amp;lt;-- idx(9 bits) --&amp;gt;|&amp;lt;-- instOffset(1 bit) --&amp;gt;|
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;读出时，向存储器提供组序号(idx)，读出该组中所有路，然后检测是否有某一路的 tag 与当前 tag 匹配，如果匹配，则表示命中，读出的 FTB 项通过 &lt;code&gt;read_resp&lt;/code&gt; 接口送出，并把命中的路编号通过 &lt;code&gt;read_hits&lt;/code&gt; 接口送出。&lt;/p&gt;
&lt;h2 id=&#34;预测结果生成&#34;&gt;预测结果生成&lt;/h2&gt;
&lt;p&gt;正如我们之前提到的，对于 FTB 预测器，它需要向 s2, s3 通道提供由 FTB 项转化来的基础预测结果，FTB 项已经在 s1 阶段被读出并保存。在 s2 和 s3 阶段只需直接读出便生成即可，但需要注意的一点就是保护 TAGE-SC 在 s2 及 s3 通道中产生的预测结果 &lt;code&gt;br_taken_mask&lt;/code&gt; 字段，这一字段为条件分支指令提供了精确的预测结果。对于 s1 通道，FTB 预测器不予更改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;s2 和 s3预测结果中的信号产生方式可参考以下列表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;hit&lt;/strong&gt; FTB表项是否命中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：&lt;code&gt;FTBBank&lt;/code&gt; 输出的 &lt;code&gt;read_hits&lt;/code&gt; 信号 valid 位有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;slot_valids&lt;/strong&gt; slot有效位，表示 ftb 项中的每个 slot 是否有效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;targets&lt;/strong&gt; 每个slot对应的跳转目标地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;offsets&lt;/strong&gt; 每个slot中的指令相对于预测块起始地址的偏移&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_jal&lt;/strong&gt; 预测块内包含jal指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_jalr&lt;/strong&gt; 预测块内包含jalr指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_call&lt;/strong&gt; 预测块内包含call指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_ret&lt;/strong&gt; 预测块内包含ret指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;last_may_be_rvi_call&lt;/strong&gt; 预测结果预测块末尾可能为一个RVI类型的call指令信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_br_sharing&lt;/strong&gt; 最后一个slot (tailSlot) 中存储的是条件分支指令信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式： FTB 项中对应字段导出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;fallThroughErr&lt;/strong&gt; FTB项中记录的 &lt;code&gt;pftAddr&lt;/code&gt; 有误&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：比较 &lt;code&gt;pftAddr&lt;/code&gt; 代表的预测块结束地址是否大于预测块的起始地址，如果小于，则代表出现错误，此信号置为有效。这种情况可能会发生在 pc 索引到错误的 FTB 项的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;fallThroughAddr&lt;/strong&gt; 预测块的结束地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：如果 &lt;code&gt;fallThroughErr&lt;/code&gt; 无效，则根据 &lt;code&gt;pftAddr&lt;/code&gt; 生成，否则将其设置为起始地址 + 预测宽度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;br_taken_mask&lt;/strong&gt; 分支预测结果，每个分支(slot)对应一位，表示该分支是否被预测为 taken&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：若 FTB 项命中并且 &lt;code&gt;always_taken&lt;/code&gt; 字段有效，则预测为 taken；否则由&lt;strong&gt;相应通道输入接口&lt;/strong&gt;中提供的 &lt;code&gt;br_taken_mask&lt;/code&gt; 信号来决定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;jalr_target&lt;/strong&gt; 本预测块中的 jalr 的跳转目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：FTB 项中 tailSlot 中的跳转目标。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ftb-meta&#34;&gt;FTB meta&lt;/h3&gt;
&lt;p&gt;在预测的第三周期，FTB 预测器会将本次预测的一些辅助信息输出至 &lt;code&gt;last_stage_meta&lt;/code&gt; 中，还会将读出的 FTB 项送到 &lt;code&gt;last_stage_ftrb_entry&lt;/code&gt; 接口中。&lt;/p&gt;
&lt;p&gt;FTB meta 中含有 &lt;code&gt;hit&lt;/code&gt; 和 &lt;code&gt;writeWay&lt;/code&gt; 两个信息，分别表示本次预测是否命中，以及在哪一路读出。之后更新通道中会产生本次预测的更新信息，这两个信息也会随之送入，来指导更新后的 FTB 项写入的位置。&lt;/p&gt;
&lt;h2 id=&#34;ftb-更新&#34;&gt;FTB 更新&lt;/h2&gt;
&lt;p&gt;update 通道中已经为我们指定好了 pc 以及新 FTB 项，并且还有 meta 信息中的 &lt;code&gt;hit&lt;/code&gt; 和 &lt;code&gt;writeWay&lt;/code&gt; 。如果 meta 中的 &lt;code&gt;hit&lt;/code&gt; 有效，说明之前这一 pc 对应的 FTB 项在存储器中是有存储的，我们只需将它写入到 writeWay 对应的路中即可。&lt;/p&gt;
&lt;p&gt;如果无效，说明以前没有存储，但现在是否存储我们并不知道，有可能在此更新请求之前，该 pc 对应的 FTB 项被另一个更新请求写入了。因此我们还需要给 FTBBank 发送一个读请求，来判断其中是否存在对应的 FTB 项。如果存在，下周期可直接写入到该位置，否则，通知 FTBBank 为其重新分配一个位置。&lt;/p&gt;
&lt;p&gt;因此 FTB 项的更新需要的周期数需随 hit 情况而定。&lt;/p&gt;
&lt;p&gt;我们首先来看一下 FTBBank是怎样处理更新的。&lt;/p&gt;
&lt;h3 id=&#34;ftbbank-更新&#34;&gt;FTBBank 更新&lt;/h3&gt;
&lt;p&gt;FTBBank 的更新接口如下，分为更新读接口和更新写接口两部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;u_req_pc&lt;/strong&gt; 更新读请求 pc&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Flipped(DecoupledIO(UInt(VAddrBits.W)))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;update_hits&lt;/strong&gt; 读出的命中情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Valid(UInt(log2Ceil(numWays).W))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;update_access&lt;/strong&gt; 有更新请求但 meta 信息指示未命中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;update_pc&lt;/strong&gt; 更新写请求 pc&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UInt(VAddrBits.W))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;update_write_data&lt;/strong&gt;  更新请求写入的数据，valid 有效的时候写&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Flipped(Valid(new FTBEntryWithTag))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;update_write_way&lt;/strong&gt;   更新请求写入的路索引&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UInt(log2Ceil(numWays).W))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;update_write_alloc&lt;/strong&gt; 是否需要分配FTB项（以前未命中）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对于更新读接口&lt;/strong&gt;，FTBBank 通过 &lt;code&gt;u_req_pc&lt;/code&gt; 信号获取更新读请求，该请求要比预测时的读请求优先级更高，在下一个周期，FTBBank 会将命中情况通过 &lt;code&gt;update_hits&lt;/code&gt; 接口送出。&lt;code&gt;update_access&lt;/code&gt; 仅用于 FTBBank 内部某些状态判断。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于更新写接口&lt;/strong&gt;，FTBBank 通过 &lt;code&gt;update_pc&lt;/code&gt; 信号获取更新写请求的 pc，并在 &lt;code&gt;update_write_data&lt;/code&gt; 有效时向 &lt;code&gt;update_write_way&lt;/code&gt; 对应的位置写入其中的数据。如果 &lt;code&gt;update_write_alloc&lt;/code&gt; 有效，说明不能直接写入请求中指定的位置，而是需要重新分配一个位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分配的策略如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果所有路均已填充，则使用伪 LRU 替换算法选取要替换的路&lt;/li&gt;
&lt;li&gt;若存在空路，否则选取空路。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;更新请求时序&#34;&gt;更新请求时序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;meta hit 有效&lt;/strong&gt;  若更新请求中 meta 指示为 hit，则我们直接根据更新请求中的信息，指定好写入的地址和数据即可，写入仅需一周期&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;meta hit 无效&lt;/strong&gt;  此时，在接收到更新请求后，我们将请求中的 pc 连接至 FTBBank 的读端口，读端口在下一周期将结果返回。由于时延问题，我们将这一结果保存，并在下一周期使用。下一周期根据结果中的命中情况指定是否需要设置 &lt;code&gt;update_write_alloc&lt;/code&gt;，并发出写请求。这时的更新过程总共花费了三个周期。&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: ITTAGE 分支预测器</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/modules/04_ittage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/modules/04_ittage/</guid>
      <description>
        
        
        &lt;h2 id=&#34;功能介绍&#34;&gt;功能介绍&lt;/h2&gt;
&lt;p&gt;对于一般条件分支指令，只需要预测跳转（taken），或者不跳转（no taken），但是对于&lt;strong&gt;间接跳转&lt;/strong&gt;，如call/jump等指令，需要预测跳转&lt;strong&gt;到哪里去&lt;/strong&gt;（Target）。为了让TAGE支持预测跳转地址，ITTAGE（Indirect Target TAGE）应运而生。&lt;/p&gt;
&lt;p&gt;ITTAGE 与 TAGE 的&lt;strong&gt;主要区别&lt;/strong&gt;在于，在T0和Tn表中，多了 Target PC 数据。预测时，ITTAGE选择匹配到的、历史最长的表项中的 Target 作为预测结果，并利用 2bit 饱和计数器决定是否输出该结果，或选用替代预测结果。TAGE 预测器说明，请参考 &lt;a href=&#34;../02_tage_sc/&#34;&gt;TAGE-SC分支预测器&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;昆明湖-ittage-分支预测器&#34;&gt;昆明湖 ITTAGE 分支预测器&lt;/h2&gt;
&lt;p&gt;由于在昆明湖的BPU设计中，采用多预测器级联的方式进行预测，因此在子预测器实现上，会与原始预测器有所不同，其中多数表现在默认预测结果上。&lt;/p&gt;
&lt;h3 id=&#34;基本功能&#34;&gt;基本功能&lt;/h3&gt;
&lt;p&gt;ITTAGE基本功能类似 TAGE 分支预测器，但存在以下不同点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在表项中增加了 Target 作为跳转的目标地址项，用于预测跳转目标地址。&lt;/li&gt;
&lt;li&gt;饱和计数器ctr也不再提供预测方向，而改为决定是否输出结果（只是预测信息）。&lt;/li&gt;
&lt;li&gt;由于每个分支预测块中只有一个间接跳转指令，所以ITTAGE也只考虑一条指令。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;流水线&#34;&gt;流水线&lt;/h3&gt;
&lt;p&gt;ITTAGE &lt;strong&gt;内含三个流水级&lt;/strong&gt;，第一级计算索引，第二级通过索引读出SRAM表中的结果&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第0拍，s0：第一个流水级的输入，一般是pc和折叠历史。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;第一流水级运行&lt;/strong&gt;：计算index。通过寄存器输出到s1&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第1拍，s1：第二个流水级的输入，为第一级阶段计算好的index等数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;第二流水级运行&lt;/strong&gt;：访存SRAM，读取预测用信息。通过寄存器输出到s2&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第2拍，s2：第三个流水级的输入，为第二级从SRAM中读出的&lt;strong&gt;原始预测信息&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;**第三流水级运行：**处理原始预测信息，决定是否输出预测结果。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第3拍，s3：预测结果就绪，此时已经可以使用&lt;strong&gt;预测结果&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据结构&#34;&gt;数据结构&lt;/h3&gt;
&lt;p&gt;在昆明湖的实现中，T0与Tn的表结构如下所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;预测器&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;表项构成&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;项数&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;基准预测器T0&lt;/td&gt;
&lt;td&gt;用于在其他预测器的预测结果都无效时输出预测结果&lt;/td&gt;
&lt;td&gt;虚表，不存在。 直接将上级预测器FTB 的预测结果作为表项结果&lt;/td&gt;
&lt;td&gt;虚表，不存在。 直接将上级预测器FTB结果作为索引到的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;预测表T1-T2&lt;/td&gt;
&lt;td&gt;对每个预测块的输入，所有Tn表都进行预测，在所有预测有效的结果中，选择历史记录最长的结果作为 原始预测信息。历史记录长度由输入的H决定&lt;/td&gt;
&lt;td&gt;target：39 bitsvalid 1bittag 9bitsctr 2bitsus: 1bit（usefulness计数器）&lt;/td&gt;
&lt;td&gt;256项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;预测表T3-T5&lt;/td&gt;
&lt;td&gt;512项&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;t0tn表的检索方法&#34;&gt;T0，Tn表的检索方法&lt;/h3&gt;
&lt;p&gt;检索方法与 TAGE 分支预测器一致，只是各表的配置选项不同。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;表名称&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;FH长度&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;FH1长度&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;FH2长度&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;最近历史长度（用到GH中的位数）&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;4比特&lt;/td&gt;
&lt;td&gt;4比特&lt;/td&gt;
&lt;td&gt;4比特&lt;/td&gt;
&lt;td&gt;低4位，即把最新4位历史，折叠成FH、FH1、FH2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;低8位，即把最新8位历史，折叠成FH、FH1、FH2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T3&lt;/td&gt;
&lt;td&gt;9比特&lt;/td&gt;
&lt;td&gt;9比特&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;低13位，即把最新13位历史，折叠成FH、FH1、FH2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T4&lt;/td&gt;
&lt;td&gt;9比特&lt;/td&gt;
&lt;td&gt;9比特&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;低16位，即把最新16位历史，折叠成FH、FH1、FH2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T5&lt;/td&gt;
&lt;td&gt;9比特&lt;/td&gt;
&lt;td&gt;9比特&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;低32位，即把最新32位历史，折叠成FH、FH1、FH2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其他过程（&lt;strong&gt;计算方式&lt;/strong&gt; 及 &lt;strong&gt;计算公式&lt;/strong&gt;）类似 &lt;a href=&#34;../02_tage_sc/#MZk7dpG3woapSUx3XO9ceJShn0e&#34;&gt;TAGE-SC分支预测器&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;替代预测器&#34;&gt;替代预测器&lt;/h3&gt;
&lt;p&gt;当Tn表给出的预测结果，“预测信心”不足时，需要对预测结果进行跳转，成为“替代预测器”。该过程与 TAGE 类似，具体请先阅读TAGE的对应部分。与 TAGE 不同，ITTAGE 的 ctr 并不给出预测方向，只决定是否输出该结果（预测信心）。当 ctr 为 2b00 的时候，即认定为弱信心。选择替代预测结果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;如果命中多个个表&lt;/strong&gt;，输出长度第二长的表中表项的 Target&lt;/li&gt;
&lt;li&gt;否则输出  T0 Target（FTB Target）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;预测过程&#34;&gt;预测过程&lt;/h3&gt;
&lt;p&gt;预测过程与 TAGE 类似，但与 TAGE 不同的是ITTAGE 多了一步根据 ctr 决定是否输出预测结果。具体过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当 ITTAGE 表项的 ctr 不为 2b00 时，输出 Target&lt;/li&gt;
&lt;li&gt;当 ITTAGE 表项的 ctr 为 2b00 时，输出替代预测结果
&lt;ol&gt;
&lt;li&gt;如果有次长的历史（第二个表也命中），则输出 次长的 Target&lt;/li&gt;
&lt;li&gt;否则输出 FTB Target&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;当 ITTAGE 表项没命中时，输出 T0 Target（FTB Target）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;训练过程&#34;&gt;训练过程&lt;/h3&gt;
&lt;p&gt;该过程与 TAGE 类似，具体不同点如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表项更新（原始预测数据）：
&lt;ol&gt;
&lt;li&gt;ctr：
&lt;ol&gt;
&lt;li&gt;若预测地址与实际一致，则将对应provider（提供原始预测数据的表）表项的ctr计数器自增1&lt;/li&gt;
&lt;li&gt;若预测地址与实际不一致，则将对应provider表项的ctr计数器自减1&lt;/li&gt;
&lt;li&gt;ITTAGE中，会根据ctr判断是否采取这个预测的跳转目标结果。 如果多个表均命中，且历史最长表的ctr为0，则采取替代预测逻辑（历史次长的表 或 T0）。 更新时始终更新历史最长的表，如果采用了替代预测，&lt;strong&gt;也同时更新&lt;/strong&gt;替代预测表。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;target：
&lt;ol&gt;
&lt;li&gt;当待更新表项在进行本次预测时的ctr为0时，直接将实际的最终跳转结果存入target，覆盖&lt;/li&gt;
&lt;li&gt;如果是在申请新表项，直接将实际的最终跳转结果存入target&lt;/li&gt;
&lt;li&gt;否则不修改target&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;usefulness：
&lt;ol&gt;
&lt;li&gt;当provider&lt;strong&gt;预测正确&lt;/strong&gt;而&lt;strong&gt;替代预测错误&lt;/strong&gt;时provider的usefulness置1&lt;/li&gt;
&lt;li&gt;如果替代预测是弱信心，并且预测正确，则provider的usefulness置1。 如果替代预测是弱信心，并且预测错误，则provider的usefulness置0。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;新表项：
&lt;ol&gt;
&lt;li&gt;每次由于历史最长表有信心的预测出错时（不是由于使用替代预测出错），会尝试随机在历史更长表中申请一个表项。能申请到的条件是对应项的useful为0&lt;/li&gt;
&lt;li&gt;如果更长的useful均不为0，则分配失败&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;重置useful位：
&lt;ol&gt;
&lt;li&gt;每次预测出错时会申请新表项，如果分配失败则tickCtr（用于重置全部useful的8bit饱和计数器） +1，成功则 -1&lt;/li&gt;
&lt;li&gt;当tickCtr为最大值时，设置ITTAGE中的所有useful为0，并设置tickCtr为0。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;接口列表&#34;&gt;接口列表&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;接口类型&lt;/th&gt;
&lt;th&gt;位宽&lt;/th&gt;
&lt;th&gt;信号名&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;clock&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;reset&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_3&lt;/td&gt;
&lt;td&gt;用于预测的PC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_3_hist_14_folded_hist&lt;/td&gt;
&lt;td&gt;T2 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[8:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_3_hist_13_folded_hist&lt;/td&gt;
&lt;td&gt;T3 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_3_hist_12_folded_hist&lt;/td&gt;
&lt;td&gt;T1 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[8:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_3_hist_10_folded_hist&lt;/td&gt;
&lt;td&gt;T5 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[8:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_3_hist_6_folded_hist&lt;/td&gt;
&lt;td&gt;T4 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_3_hist_4_folded_hist&lt;/td&gt;
&lt;td&gt;T3 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_3_hist_3_folded_hist&lt;/td&gt;
&lt;td&gt;T5 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_3_hist_2_folded_hist&lt;/td&gt;
&lt;td&gt;T4 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_0_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;从FTB输入 完全透传到输出 包括jalr_target&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_0_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_0_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_0_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_0_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_0_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_0_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_0_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_0_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_0_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_0_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_0_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_1_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_1_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_1_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_1_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_1_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_1_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_1_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_1_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_1_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_1_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_1_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_1_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_is_jalr&lt;/td&gt;
&lt;td&gt;RAS 模块使用的信息，透传&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_is_call&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_is_ret&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_last_may_be_rvi_call&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_is_br_sharing&lt;/td&gt;
&lt;td&gt;从FTB输入 完全透传到输出 包括jalr_target  fallThroughErr  表示 FTB项 中记录的 pftAddr 有误 生成方式：比较 pftAddr 代表的预测块结束地址是否大于预测块的起始地址，如果小于，则代表出现错误，此信号置为有效。这种情况可能会发生在 pc 索引到错误的 FTB 项的情况。 FTQ使用这个变量，与ITTAGE无关&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_2_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_3_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_3_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_3_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_3_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_3_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_3_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_3_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_3_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_3_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_3_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_3_fallThroughErr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_3_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s2_full_pred_3_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_0_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;除了 jalr_target 可能被修改，其他都是透传&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_0_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_0_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_0_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_0_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_0_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_0_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_0_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_0_fallThroughErr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_0_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_0_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_1_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_1_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_1_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_1_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_1_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_1_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_1_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_1_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_1_fallThroughErr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_1_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_1_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_2_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_2_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_2_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_2_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_2_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_2_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_2_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_2_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_2_fallThroughErr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_2_is_jalr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_2_is_call&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_2_is_ret&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_2_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_2_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_3_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_3_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_3_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_3_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_3_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_3_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_3_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_3_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_3_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_3_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_3_fallThroughErr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_3_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_s3_full_pred_3_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_valid&lt;/td&gt;
&lt;td&gt;透传到output，不做修改 来源是FTB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_brSlots_0_offset&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[11:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_brSlots_0_lower&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[1:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_brSlots_0_tarStat&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_brSlots_0_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_brSlots_0_valid&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_tailSlot_offset&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[19:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_tailSlot_lower&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[1:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_tailSlot_tarStat&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_tailSlot_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_tailSlot_valid&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_pftAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_carry&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_isCall&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_isRet&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_isJalr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_last_may_be_rvi_call&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_always_taken_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_in_bits_resp_in_0_last_stage_ftb_entry_always_taken_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;完全透传传入值 prefix: io_in_bits_resp_in_&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_is_jalr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_is_call&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_is_ret&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_last_may_be_rvi_call&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_fallThroughErr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_0_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;见对应prefix的输入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_0_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_0_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_0_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_0_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_0_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_0_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_0_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_0_fallThroughErr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_0_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_0_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_1_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;见对应prefix的输入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_1_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_1_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_1_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_1_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_1_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_1_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_1_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_1_fallThroughErr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_1_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_1_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;见对应prefix的输入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_fallThroughErr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_is_jalr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_is_call&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_is_ret&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;见对应prefix的输入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_jalr_target&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_fallThroughErr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[218:0]&lt;/td&gt;
&lt;td&gt;io_out_last_stage_meta&lt;/td&gt;
&lt;td&gt;[96:0] 有效，是ITTAGE的Meta信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_valid&lt;/td&gt;
&lt;td&gt;完全透传传入的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_brSlots_0_offset&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[11:0]&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_brSlots_0_lower&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[1:0]&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_brSlots_0_tarStat&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_brSlots_0_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_brSlots_0_valid&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_tailSlot_offset&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[19:0]&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_tailSlot_lower&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[1:0]&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_tailSlot_tarStat&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_tailSlot_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_tailSlot_valid&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_pftAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_carry&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_isCall&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_isRet&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_isJalr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_last_may_be_rvi_call&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_always_taken_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_last_stage_ftb_entry_always_taken_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s0_fire_3&lt;/td&gt;
&lt;td&gt;s0阶段使能信号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s1_fire_3&lt;/td&gt;
&lt;td&gt;s1阶段使能信号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s2_fire_0&lt;/td&gt;
&lt;td&gt;s2阶段使能信号，相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s2_fire_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s2_fire_2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s2_fire_3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_valid&lt;/td&gt;
&lt;td&gt;是否进行更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_pc&lt;/td&gt;
&lt;td&gt;待更新的预测块pc索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_14_folded_hist&lt;/td&gt;
&lt;td&gt;T2 更新时传入的历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[8:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_13_folded_hist&lt;/td&gt;
&lt;td&gt;T3 更新时传入的历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_12_folded_hist&lt;/td&gt;
&lt;td&gt;T1 更新时传入的历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[8:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_10_folded_hist&lt;/td&gt;
&lt;td&gt;T5 更新时传入的历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[8:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_6_folded_hist&lt;/td&gt;
&lt;td&gt;T4 更新时传入的历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_4_folded_hist&lt;/td&gt;
&lt;td&gt;T3 更新时传入的历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_3_folded_hist&lt;/td&gt;
&lt;td&gt;T5 更新时传入的历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_2_folded_hist&lt;/td&gt;
&lt;td&gt;T4 更新时传入的历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_offset&lt;/td&gt;
&lt;td&gt;待更新的FTB项offset&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_sharing&lt;/td&gt;
&lt;td&gt;待更新的FTB项是否是有条件跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_valid&lt;/td&gt;
&lt;td&gt;待更新的tailSlot是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_isRet&lt;/td&gt;
&lt;td&gt;tailSlot是否是Ret指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_isJalr&lt;/td&gt;
&lt;td&gt;tailSlot是否是Jalr指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_cfi_idx_valid&lt;/td&gt;
&lt;td&gt;控制流指令在预测块中的索引.valid信号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_cfi_idx_bits&lt;/td&gt;
&lt;td&gt;控制流指令在预测块中的索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_jmp_taken&lt;/td&gt;
&lt;td&gt;预测块内无条件跳转指令被触发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_mispred_mask_2&lt;/td&gt;
&lt;td&gt;是否预测错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[218:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_meta&lt;/td&gt;
&lt;td&gt;预测时传出 meta 信息的[218:25] 即{25h0, _ubtb_io_out_last_stage_meta[5:0] ,_tage_io_out_last_stage_meta[87:0] ,_ftb_io_out_last_stage_meta[2:0], _ittage_io_out_last_stage_meta[96:0]}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_full_target&lt;/td&gt;
&lt;td&gt;预测块的跳转目标（下一个预测块的起始地址）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;其他meta见对应子预测其文档&#34;&gt;其他Meta见对应子预测其文档&lt;/h2&gt;
&lt;p&gt;_ubtb_io_out_last_stage_meta&lt;/p&gt;
&lt;p&gt;_tage_io_out_last_stage_meta&lt;/p&gt;
&lt;p&gt;_ftb_io_out_last_stage_meta&lt;/p&gt;
&lt;h2 id=&#34;ittage_io_out_last_stage_meta960&#34;&gt;ittage_io_out_last_stage_meta[96:0]&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;位宽&lt;/th&gt;
&lt;th&gt;信号名&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;96&lt;/td&gt;
&lt;td&gt;s3_provided&lt;/td&gt;
&lt;td&gt;是否有结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[95:93]&lt;/td&gt;
&lt;td&gt;s3_provider&lt;/td&gt;
&lt;td&gt;提供结果的表项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;92&lt;/td&gt;
&lt;td&gt;s3_altProvided&lt;/td&gt;
&lt;td&gt;是否有替代预测表项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[91:89]&lt;/td&gt;
&lt;td&gt;s3_altProvider&lt;/td&gt;
&lt;td&gt;提供结果的替代预测表项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;88&lt;/td&gt;
&lt;td&gt;resp_meta_altDiffers&lt;/td&gt;
&lt;td&gt;替代预测是否是弱信心的（FTB不算）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;87&lt;/td&gt;
&lt;td&gt;s3_providerU&lt;/td&gt;
&lt;td&gt;主预测的useful bit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[86:85]&lt;/td&gt;
&lt;td&gt;s3_providerCtr&lt;/td&gt;
&lt;td&gt;主预测给出的置信度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[84:83]&lt;/td&gt;
&lt;td&gt;s3_altProviderCtr&lt;/td&gt;
&lt;td&gt;替代预测给出的置信度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;82&lt;/td&gt;
&lt;td&gt;resp_meta_allocate_valid_r&lt;/td&gt;
&lt;td&gt;有空余的表项可供申请&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[81:79]&lt;/td&gt;
&lt;td&gt;resp_meta_allocate_bits_r&lt;/td&gt;
&lt;td&gt;申请哪个表中的表项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;78&lt;/td&gt;
&lt;td&gt;s3_tageTaken_dup_3&lt;/td&gt;
&lt;td&gt;在不使用FTB的情况下始为true，使用FTB也为true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[77:39]&lt;/td&gt;
&lt;td&gt;s3_providerTarget&lt;/td&gt;
&lt;td&gt;主预测给出的跳转地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[38:0]&lt;/td&gt;
&lt;td&gt;s3_altProviderTarget&lt;/td&gt;
&lt;td&gt;替代预测给出的跳转地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: RAS 分支预测器</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/modules/05_ras/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/modules/05_ras/</guid>
      <description>
        
        
        &lt;h2 id=&#34;ras介绍&#34;&gt;RAS介绍&lt;/h2&gt;
&lt;p&gt;RAS 指的是 &amp;ldquo;Return Address Stack&amp;rdquo;，即返回地址栈。它通过跟踪程序的返回地址，帮助确定程序中的分支行为。由前所述，在程序中存在很多分支：if/else、 switch/case、while/for loop、iteration、call/return&lt;/p&gt;
&lt;p&gt;等。RAS分支预测器则专门针对 call/return类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;_add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#a40000&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;  &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#a40000&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sub&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;d&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sub&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上图所示，在main函数中调用了add和sub，add又调用了函数_add。在该过程中，每次调用（call）的跳转地址和返回的地址固定，且在call的时候，就可以同时得到返回地址。函数的调用过程是一个“栈的出入”过程，因此可以通过“栈”结构进行分支预测：每遇到call指令，把当前PC+4（压缩指令和普通指令的偏移不同）进行压栈push操作；遇到return指令，则进行进行pop操作，得到的地址即为目标跳转地址。在基于“预测块”的BPU中，RAS无法知道当前块是否是call或者ret，因此需要依赖其他预测器，利用前级预测器的结果进行RAS操作。&lt;/p&gt;
&lt;p&gt;具体的，在香山的RAS预测器中，其s2阶段，需要判断上一级s2的输出是否预测为call或者ret（即输入信号io.s2_full_pred.hit_taken_on_call/ret有效 ），如果是call则push其后续指令地址入栈，是ret则从栈中pop出地址作为预测结果。因为在BPU的预测器中，人为假定s3阶段得到的结果比s2阶段好，所以RAS预测器在s3阶段需要进行检查，如果上一级的s3预测结果与s2不一致，则采信s3的结果，并按需求判断是否需要撤销或者补齐之前s2阶段的栈操作。例如s2阶段预测为call指令，进行了push操作，而s3为普通分支指令，不需要进行任何操作，此时就需要撤销push；如果s2预测为普通分支指令，s3预测为call，则需要进行push操作补齐。&lt;/p&gt;
&lt;h2 id=&#34;ras的栈操作&#34;&gt;RAS的栈操作&lt;/h2&gt;
&lt;p&gt;在RAS设计中，通过栈进行预测函数返回地址。在理想情况下，本节假定RAS可进行随时备份，栈顶指针用sp表示，预测地址用paddr表示。RAS的基本操作有以下4种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h3 id=&#34;push&#34;&gt;PUSH&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于预测可能会出错，出错时需要回到原始状态，因此在push时需要对当前栈的状态进行备份（在软件领域，通常称为“快照”，本文在后继内容中也用快照进行称呼），标记为s。当遇到call指令时，获取call指令的返回地址 addr = 当前pc + 4（如果是压缩指令则addr = pc+2），然后压栈：sp = addr；sp += 1。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;h3 id=&#34;pop&#34;&gt;POP&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;原因同上，对当前栈进行快照，标记为s。当遇到ret指令时，预测的跳转地址 paddr = sp，然后进行出栈， sp = sp - 1。对当前栈进行快照，标记为s。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;h3 id=&#34;重定向操作&#34;&gt;重定向操作&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于BPU是对程序的分支进行预测，因此就有“预测对”和“预测错”两种情况，当CPU后端发现分支预测错误，就会进行重定向（redirect）操作，告诉BPU哪个地方预测错误，正确结果是多少。重定向时RAS模块会收到正确的分支和当时预测时RAS栈信息。根据正确分支指令类型不同，首先恢复快照s有如下情形：&lt;/p&gt;
&lt;p&gt;（1）之前被预测的指令，实际是 call指令，根据redirect中给的addr地址，执行push操作；&lt;/p&gt;
&lt;p&gt;（2）之前被预测的指令，实际是 ret指令，执行pop操作；&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;h3 id=&#34;提交操作&#34;&gt;提交操作&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;提交（Commit）操作即后端告诉前端，之前预测的结果正确。理想情况下，RAS预测器此时不需要进行任何操作。&lt;/p&gt;
&lt;h2 id=&#34;昆明湖中ras的实现&#34;&gt;昆明湖中RAS的实现&lt;/h2&gt;
&lt;p&gt;在实际电路设计中，不可能存在无限大的栈，且能进行时刻备份，所以在昆明湖的 RAS 实现中，需要解决的问题和应对方案如下：&lt;/p&gt;
&lt;h3 id=&#34;每次预测时ras栈的快照如何获得&#34;&gt;&lt;strong&gt;每次预测时，RAS栈的快照如何获得？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;为了实现对RAS栈进行快照的功能，昆明湖采用了基于循环数组的 &lt;strong&gt;&amp;ldquo;链式表示“&lt;/strong&gt; 。设计具体如下：&lt;/p&gt;
&lt;image src=&#34;Linked_RAS.png&#34; width=&#34;800px&#34;&gt;
&lt;p&gt;如上图所示，在该设计中，利用一个循环数组进行数据管理。循环数组有一个起始地址标记为BOS，有一个尾指针标记为TOSW，他们之间的数据为有效数据，之外的数据为空闲数据。在有效数据中，用一个链式结构对“RAS栈”进行表示，即每一个栈元素都记录其上一个数据的编号，当进行栈操作时可以通过该编号获取对应上一个元素。RAS栈的栈底指针公用BOS。如图中的初始状态S，其中RAS栈对应的元素为0，1，3，5。元素5中记录了它的上一个元素的位置3，同理元素3中记录了其上一个元素的位置1。每次需要进行push操作时，让RAS栈顶指针TOSR = TOSW，在新的TOSR位置7中存入新的元素，并在新元素中记录其上一个元素的位置5，然后TOSW后移（TOSW = TOSW+1）。在进行Pop操作时，RAS栈顶指针TOSR根据栈顶元素保存的索引移动到上一个元素的位置3。因此在栈不溢出的情况下，上述RAS栈每次都是通过TOSW在数组上分配新数据，因此在栈的正常Push/Pop中，所有过程状态和中间数据都有保存。所以当要恢复到S状态时，只需要把对应的栈指针复位即可。因此在RAS每次预测时，需要把对应的栈指针（BOS、TOSR、TOSW）也保存于预测结果中，用于之后万一发生重定向操作时恢复到原始栈状态。上述结构的优点是可以保存完整过程数据，但频繁的push操作，会导致空间资源消耗大。&lt;/p&gt;
&lt;h3 id=&#34;链式ra存储空间浪费&#34;&gt;&lt;strong&gt;链式RA存储空间浪费？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;由于预测结果在commit后即表示预测正确，不会再进行“栈”回滚，即RAS预测器收到预测块“P”的commit消息后，就不可能再收到P块的redirect消息，在对P块进行push操作时的快照也将不会被用到。因此可以对RAS栈中的元素进行分类，把还未commit的元素用“链式”结构进行存储，已经commit的元素通过普通的基于循环数组的栈表示（即把原始RAS栈拆分成了两部分进行表示，还未commit可能需要快照恢复的部分用可以保存快照的链式结构保存，已经commit不需要快速恢复的部分用普通栈结构保存）。优化后的RAS结构如下所示：&lt;/p&gt;
&lt;image src=&#34;RAS_Arch.png&#34; width=&#34;800px&#34;&gt;
&lt;p&gt;在实现上，RASStack是对RAS栈操作的实现，对外逻辑表现为”理想栈“，内部为了节约硬件资源，用了两种栈结构：（1）链式栈，用于保存中间结果，在RASStack内部称为“预测栈”；（2）普通栈，用于保存commit之后的RAS栈，在RASStack中称为“提交栈”。这两种栈之间存在数据交互，即当commit时，需要把对应的元素从“预测栈”中去除，然后放到“提交栈”中。在RASStack中，利用变量ssp表示“逻辑上”的栈顶，每次push操作ssp+=1，每次pop操作ssp-=1。由于栈结构发生了变化，具体的Pop/Push操作如下：&lt;/p&gt;
&lt;p&gt;1、Push操作：当前被预测的块还没有commit，所以只能在预测栈上进行push，具体操作为链式栈Push过程；&lt;/p&gt;
&lt;p&gt;2、Pop操作：首先通过“预测栈”是否为空，来判断当前栈顶是在预测栈上，还是在提交栈上。然后获取对应的栈顶元素，按照“栈”结构自己对应的方法进行pop。链式结构，TOSR按索引指向上一个元素，普通结构，ssp-=1；&lt;/p&gt;
&lt;p&gt;3、Commit操作：预测块为call正确：需要进行push操作，需要压栈的元素消息（预测地址）来自“预测栈”，具体位置信息POS由commit消息提供。完成提交栈的压栈操作后，对预测栈的栈低指针BOS进行更新，设置BOS=POS。预测块为ret正确：需要进行pop操作。在call/ret序列中，肯定是先call后ret，所以此时ret对应的call时压栈的元素肯定在提交栈中，所以直接从commit消息中获取提交栈顶指针nsp，进行nsp -= 1操作。&lt;/p&gt;
&lt;p&gt;4、Redirect操作：从redirect消息中获取之前预测时的栈指针（BOS、TOSR、TOSW，ssp），覆盖当前值指针值完成RAS栈回滚。&lt;/p&gt;
&lt;h3 id=&#34;输入端s3的预测结果和s2不一致时该如何处理&#34;&gt;&lt;strong&gt;输入端，S3的预测结果和S2不一致时该如何处理？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;由于假定S3的结果比S2好，因此发生不一致时，需要再次对RAS栈进行修复。具体不一致情况和对应的修复操作如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;S2预测结果&lt;/th&gt;
&lt;th&gt;S3预测结果&lt;/th&gt;
&lt;th&gt;修复操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;push&lt;/td&gt;
&lt;td&gt;keep&lt;/td&gt;
&lt;td&gt;pop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;keep&lt;/td&gt;
&lt;td&gt;pop&lt;/td&gt;
&lt;td&gt;pop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pop&lt;/td&gt;
&lt;td&gt;keep&lt;/td&gt;
&lt;td&gt;push&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;keep&lt;/td&gt;
&lt;td&gt;push&lt;/td&gt;
&lt;td&gt;push&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;S2和S3的操作不存在，pop/push或者push/pop情况（为什么不存在？）&lt;/p&gt;
&lt;h2 id=&#34;其他优化&#34;&gt;其他优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;每个RAS栈中的元素都有一个counter计数器，用于节约重复值（递归调用）。例如：当第一次push地址为0xff00，第二次push的也为0xff00时，则只需要把栈顶元素的 counter 进行+1，不需真的进行push操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;
&lt;p&gt;在RAS预测器中，核心组件为 &lt;strong&gt;RASStack&lt;/strong&gt; ，其接口说明如下:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;接口名称&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;功能描述&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;接口名称&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;功能描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;in.spec_push_valid&lt;/td&gt;
&lt;td&gt;进行PUSH操作&lt;/td&gt;
&lt;td&gt;in.s2_fire&lt;/td&gt;
&lt;td&gt;s2信号有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.spec_pop_valid&lt;/td&gt;
&lt;td&gt;进行POP操作&lt;/td&gt;
&lt;td&gt;in.s3_fire&lt;/td&gt;
&lt;td&gt;s3信号有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.spec_push_addr&lt;/td&gt;
&lt;td&gt;PUSH地址&lt;/td&gt;
&lt;td&gt;in.s3_cancel&lt;/td&gt;
&lt;td&gt;s3的信号表示需要撤销s2的操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out.spec_pop_addr&lt;/td&gt;
&lt;td&gt;RAS的栈顶数据&lt;/td&gt;
&lt;td&gt;in.s3_meta&lt;/td&gt;
&lt;td&gt;s3需要的s2时的现场信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out.ssp&lt;/td&gt;
&lt;td&gt;commit栈顶指针&lt;/td&gt;
&lt;td&gt;in.s3_missed_pop&lt;/td&gt;
&lt;td&gt;s3判断需要再次进行pop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out.sctr&lt;/td&gt;
&lt;td&gt;commit栈顶重复元素计数器&lt;/td&gt;
&lt;td&gt;in.s3_missed_push&lt;/td&gt;
&lt;td&gt;s3判断需要再次进行push&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out.nsp&lt;/td&gt;
&lt;td&gt;commit栈顶，会被ssp覆盖&lt;/td&gt;
&lt;td&gt;in.s3_pushAddr&lt;/td&gt;
&lt;td&gt;需要再次push时的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out.TOSR&lt;/td&gt;
&lt;td&gt;spec栈栈顶指针&lt;/td&gt;
&lt;td&gt;in.redirect_valid&lt;/td&gt;
&lt;td&gt;是否发生了重定向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out.TOSW&lt;/td&gt;
&lt;td&gt;spec栈数据分配指针&lt;/td&gt;
&lt;td&gt;in.redirect_isCall&lt;/td&gt;
&lt;td&gt;真实情况是call&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out.BOS&lt;/td&gt;
&lt;td&gt;spec栈栈低指针&lt;/td&gt;
&lt;td&gt;in.redirect_isRet&lt;/td&gt;
&lt;td&gt;真实情况是return&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.commit_push_valid&lt;/td&gt;
&lt;td&gt;push操作正确&lt;/td&gt;
&lt;td&gt;in.redirect_meta_ssp&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息ssp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.commit_pop_valid&lt;/td&gt;
&lt;td&gt;pop操作正确&lt;/td&gt;
&lt;td&gt;in.redirect_meta_sctr&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息sctr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.commit_push_addr&lt;/td&gt;
&lt;td&gt;push的正确地址&lt;/td&gt;
&lt;td&gt;in.redirect_meta_TOSW&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息TOSW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.commit_meta_TOSW&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息TOSW&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.redirect_meta_TOSR&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息TOSR&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.commit_meta_TOSR&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息TOSR&lt;/td&gt;
&lt;td&gt;in.redirect_meta_NOS&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息NOS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.commit_meta_ssp&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息SSP&lt;/td&gt;
&lt;td&gt;in.redirect_callAddr&lt;/td&gt;
&lt;td&gt;重定向地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.commit_meta_sctr&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息SCTR&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;RASStack模块与BasePredictor的接口关系如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;stack接口&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;转换过程&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;s.spec_push_valid&lt;/td&gt;
&lt;td&gt;io.s2_fire(2) &amp;amp;&amp;amp; s2_full_pred.hit_taken_on_call &amp;amp;&amp;amp; !io.s3_redirect(2)&lt;/td&gt;
&lt;td&gt;s2输入有效，且上级预测为call跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.spec_pop_valid&lt;/td&gt;
&lt;td&gt;io.s2_fire(2) &amp;amp;&amp;amp; s2_full_pred.hit_taken_on_ret  &amp;amp;&amp;amp; !io.s3_redirect(2)&lt;/td&gt;
&lt;td&gt;s2输入有效，且上级预测为ret跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.spec_push_addr&lt;/td&gt;
&lt;td&gt;s2_full_pred.fallThroughAddr + Mux(s2_full_pred.last_may_be_rvi_call, 2.U, 0.U)&lt;/td&gt;
&lt;td&gt;上级预测器s2预测的fallThroughAddr（即PC+2），判断是否压缩指令是否需要 +2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.redirect_isCall&lt;/td&gt;
&lt;td&gt;redirect.bits.level === 0.U &amp;amp;&amp;amp; recover_cfi.pd.isCall&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.redirect_isRet&lt;/td&gt;
&lt;td&gt;redirect.bits.level === 0.U &amp;amp;&amp;amp; recover_cfi.pd.isRet&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.redirect_meta_*&lt;/td&gt;
&lt;td&gt;redirect.bits.cfiUpdate.*&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.commit_push_valid&lt;/td&gt;
&lt;td&gt;io.update.is_call_taken&lt;/td&gt;
&lt;td&gt;call指令预测正确&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.commit_push_valid&lt;/td&gt;
&lt;td&gt;io.update.is_ret_taken&lt;/td&gt;
&lt;td&gt;ret指令预测正确&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.commit_push_addr&lt;/td&gt;
&lt;td&gt;update.ftb_entry.getFallThrough(update.pc) + Mux(update.ftb_entry.last_may_be_rvi_call, 2.U, 0.U)&lt;/td&gt;
&lt;td&gt;根据是否为压缩指令，进行地址+2或者+0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.commit_meta_*&lt;/td&gt;
&lt;td&gt;io.update.bits.meta.asTypeOf(new RASMeta)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;io.out.last_stage_spec_info.*&lt;/td&gt;
&lt;td&gt;s3_meta.*&lt;/td&gt;
&lt;td&gt;s3_meta = RegEnable(s2_meta, io.s2_fire(2))由s2_meta延迟一怕得到&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;io.out.last_stage_meta&lt;/td&gt;
&lt;td&gt;s3_meta&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;io.out.s2.full_pred.*.jalr_target&lt;/td&gt;
&lt;td&gt;:=stack.spec_pop_addr&lt;/td&gt;
&lt;td&gt;预测地址（栈顶地址，只预测ret）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;io.out.s3.full_pred.*.jalr_target&lt;/td&gt;
&lt;td&gt;:=RegEnable(stack.spec_pop_addr, io.s2_fire(2))&lt;/td&gt;
&lt;td&gt;由s2延迟一拍得到&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;io.out.s2/3.full_pred.targets.last&lt;/td&gt;
&lt;td&gt;:=Mux(s2/3_is_jalr, s2/3_jalr_target, s2/3_last_target_in)&lt;/td&gt;
&lt;td&gt;如果时call执行，更新targets.last的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;时序说明&#34;&gt;时序说明&lt;/h2&gt;
&lt;p&gt;在RAS中，只涉及到2拍，S2和S3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;S2中的主要工作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、根据上一个预测器的S2预测结果，完成通过Push/PoP过程完成预测，并得到结果sepc_pop_addr。&lt;/p&gt;
&lt;p&gt;2、根据commit信号执行更新操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;S3中的主要工作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、根据上一个预测器S3中的预测结果，以及S2进行的操作，判断是否需要进行Pop/Push的撤销操作。预测器假定S3的预测结果比S2好，如果发生S2和S3预测不一致时，RAS预测器采信S3结果进行栈操作。&lt;/p&gt;
&lt;p&gt;2、S3和S2的预测过程一致，只是数据不同。&lt;/p&gt;
&lt;p&gt;3、执行重定向（重定向信息由前一拍获得）操作&lt;/p&gt;
&lt;p&gt;由于RASStack对外表现为当拍内就能完成任务，因此在Stack内需要进行数据旁路，对数据进行缓存。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
