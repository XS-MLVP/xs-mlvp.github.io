<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>香山 BPU 子模块 on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</title>
    <link>https://open-verify.cc/xs-bpu/categories/%E9%A6%99%E5%B1%B1-bpu-%E5%AD%90%E6%A8%A1%E5%9D%97/</link>
    <description>Recent content in 香山 BPU 子模块 on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/xs-bpu/categories/%E9%A6%99%E5%B1%B1-bpu-%E5%AD%90%E6%A8%A1%E5%9D%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>BPU 顶层模块</title>
      <link>https://open-verify.cc/xs-bpu/docs/modules/00_bpu_top/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/modules/00_bpu_top/</guid>
      <description>&lt;p&gt;BPU 顶层整体的功能和结构已经在之前的文档中粗略的描述，对于验证 BPU 顶层的同学来说，可能还需要更加细致的描述。由于 BPU 顶层功能较多，本节将 BPU 划分为了几大功能点进行更进一步的描述。但由于 BPU 顶层细节过多，更进一步的细节需参照代码进行理解。&lt;/p&gt;&#xA;&lt;h2 id=&#34;生成器维护方法&#34;&gt;生成器维护方法&lt;/h2&gt;&#xA;&lt;p&gt;通过香山的基础设计文档，我们知道，BPU 顶层是通过一个个生成器来维护 s0 周期的各类变量的，例如 PC、分支历史等，并且其核心概念是，通过预测结果重定向信号决定采用哪个流水级的结果。&lt;/p&gt;&#xA;&lt;p&gt;BPU 顶层中所有的生成器共有 6 个：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;npcGen&lt;/strong&gt; 维护 pc&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ghistPtrGen&lt;/strong&gt; 维护全局历史指针&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ghvBitWriteGens&lt;/strong&gt; 维护全局历史写入数据&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;foledGhGen&lt;/strong&gt; 维护折叠历史&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;lastBrNumOHGen&lt;/strong&gt; 维护上周期最后一个生效的分支指令位置&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;aheadFhObGen&lt;/strong&gt; 维护分支历史最老位&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;其中，除了 &lt;code&gt;npcGen&lt;/code&gt; 以外，其余生成器都会在本文档中进行介绍。本节中我们着重探讨一下生成器的产生下一次预测的方法。&lt;/p&gt;&#xA;&lt;p&gt;在代码中你可以看到生成器用类似下面这种方式进行定义：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;PhyPriorityMuxGenerator&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，代码通过多条语句对生成器的数据来源进行注册：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;B&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;reg&lt;/span&gt;&lt;span style=&#34;color:#a40000&#34;&gt;，&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;s1_valid&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s1_target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;s2_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;s3_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3_target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;do_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;valid&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;do_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;bits&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cfiUpdate&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每一行被称作一次注册，在一次注册中第一个信号参数是数据有效信号，第二个信号参数包含具体的数据。 生成器的优先级也是按照注册的顺序来决定，越往后优先级越高，因此，同一时刻的优先级从低到高依次为：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;s0 阻塞的数据&lt;/li&gt;&#xA;&lt;li&gt;根据 s1 预测结果更新后的数据&lt;/li&gt;&#xA;&lt;li&gt;根据 s2 预测结果更新后的数据&lt;/li&gt;&#xA;&lt;li&gt;根据 s3 预测结果更新后的数据&lt;/li&gt;&#xA;&lt;li&gt;BPU 外部重定向中的数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这样一来，我们就可以在预测结果重定向有效时，避免采用较早流水级的预测结果，而采用纠正后的预测结果。也使得我们可以将外部重定向请求作为最高优先级去处理。&lt;/p&gt;&#xA;&lt;p&gt;我们可以得出所有生成器产生 s0 信号的方法：&lt;strong&gt;在所有数据有效信号中，如果只有一个有效的，则选取它对应的数据，如果有多个数据有效信号生效，则选取优先级最高的数据。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;全局分支历史&#34;&gt;全局分支历史&lt;/h2&gt;&#xA;&lt;p&gt;我们知道，全局分支历史在 BPU 顶层进行维护，维护的策略与 PC 的维护策略一致。即在每个阶段流水级预测结果产生之后，会根据相应信号对全局分支历史进行更新。&lt;/p&gt;&#xA;&lt;p&gt;顶层为了维护全局分支历史定义了两组信号&lt;/p&gt;</description>
    </item>
    <item>
      <title>子模块文档</title>
      <link>https://open-verify.cc/xs-bpu/docs/modules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/modules/</guid>
      <description>&lt;p&gt;本部分文档将会详细介绍香山分支预测单元的每一个模块，包括 BPU 顶层和五个子预测器。&lt;/p&gt;&#xA;&lt;p&gt;在每一个模块的文档中，我们将会详细介绍该模块在香山分支预测单元中所发挥的作用，以及该模块的算法原理、模块结构和时序等。&lt;/p&gt;&#xA;&lt;p&gt;负责一个模块验证的同学需要重点阅读对应文档并结合代码进行理解，其他文档亦可进行阅读以帮助你对香山分支预测单元整体功能的理解。理解过程中，你可能需要时刻回顾之前文档中所描述的基础设计思想及接口信号的含义。&lt;/p&gt;</description>
    </item>
    <item>
      <title>FTB 分支预测器</title>
      <link>https://open-verify.cc/xs-bpu/docs/modules/03_ftb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/modules/03_ftb/</guid>
      <description>&lt;h2 id=&#34;ftb-简介&#34;&gt;FTB 简介&lt;/h2&gt;&#xA;&lt;p&gt;FTB 是香山 BPU 的第三个子预测器，它也能一并获取到 uFTB 和 TAGE-SC 的输出。在 FTB 的输入接口中，s1 通道含有 uFTB 的基础预测结果，s2 通道和 s3 通道中仅有 &lt;code&gt;br_taken_mask&lt;/code&gt; 一组信号被 TAGE-SC 填充，并无 FTB 项生成的基础预测结果。FTB 的工作便是为 s2 和 s3 通道提供基础预测结果。&lt;/p&gt;&#xA;&lt;p&gt;FTB 在功能和结构上都与 uFTB 类似，其主要区别就是 FTB 能够容纳更多的 FTB 项，并且 FTB 的预测结果是在 s2 与 s3 通道输出。正是由于容量大，其读出的速度上会比 uFTB 慢，无法被放置在第一周期产生预测结果，但大容量也使它能够获得更加精准的预测结果。&lt;/p&gt;&#xA;&lt;h2 id=&#34;uftb-功能简介&#34;&gt;uFTB 功能简介&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;缓存更多 FTB 项，为 s2 和 s3 通道提供基础预测结果。&lt;/strong&gt; FTB 预测器的本质是一个较大容量的存储器，其会根据当前预测的 PC 读出对应的 FTB 项，并在 s2 阶段产出预测结果。与此同时该 FTB 项还会被再保存一个周期，生成 s3 阶段预测结果。生成结果需要注意的点是要考虑到上一预测器输入的 &lt;code&gt;br_taken_mask&lt;/code&gt; 字段，避免在生成时丢失。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;根据更新请求，更新存储中的 FTB 项。&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;ftb-存储结构&#34;&gt;FTB 存储结构&lt;/h2&gt;&#xA;&lt;p&gt;FTB 预测器中 FTB 项被放置在了一个专门的存储结构中，叫做 &lt;code&gt;FTBBank&lt;/code&gt; ，在进一步查看 &lt;code&gt;FTBBank&lt;/code&gt; 的结构之前，我们先来看一下 &lt;code&gt;FTBBank&lt;/code&gt; 是怎样使用的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ITTAGE 分支预测器</title>
      <link>https://open-verify.cc/xs-bpu/docs/modules/04_ittage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/modules/04_ittage/</guid>
      <description>&lt;h2 id=&#34;功能介绍&#34;&gt;功能介绍&lt;/h2&gt;&#xA;&lt;p&gt;对于一般条件分支指令，只需要预测跳转（taken），或者不跳转（no taken），但是对于&lt;strong&gt;间接跳转&lt;/strong&gt;，如call/jump等指令，需要预测跳转&lt;strong&gt;到哪里去&lt;/strong&gt;（Target）。为了让TAGE支持预测跳转地址，ITTAGE（Indirect Target TAGE）应运而生。&lt;/p&gt;&#xA;&lt;p&gt;ITTAGE 与 TAGE 的&lt;strong&gt;主要区别&lt;/strong&gt;在于，在T0和Tn表中，多了 Target PC 数据。预测时，ITTAGE选择匹配到的、历史最长的表项中的 Target 作为预测结果，并利用 2bit 饱和计数器决定是否输出该结果，或选用替代预测结果。TAGE 预测器说明，请参考 &lt;a href=&#34;../02_tage_sc/&#34;&gt;TAGE-SC分支预测器&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;昆明湖-ittage-分支预测器&#34;&gt;昆明湖 ITTAGE 分支预测器&lt;/h2&gt;&#xA;&lt;p&gt;由于在昆明湖的BPU设计中，采用多预测器级联的方式进行预测，因此在子预测器实现上，会与原始预测器有所不同，其中多数表现在默认预测结果上。&lt;/p&gt;&#xA;&lt;h3 id=&#34;基本功能&#34;&gt;基本功能&lt;/h3&gt;&#xA;&lt;p&gt;ITTAGE基本功能类似 TAGE 分支预测器，但存在以下不同点：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在表项中增加了 Target 作为跳转的目标地址项，用于预测跳转目标地址。&lt;/li&gt;&#xA;&lt;li&gt;饱和计数器ctr也不再提供预测方向，而改为决定是否输出结果（只是预测信息）。&lt;/li&gt;&#xA;&lt;li&gt;由于每个分支预测块中只有一个间接跳转指令，所以ITTAGE也只考虑一条指令。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;流水线&#34;&gt;流水线&lt;/h3&gt;&#xA;&lt;p&gt;ITTAGE &lt;strong&gt;内含三个流水级&lt;/strong&gt;，第一级计算索引，第二级通过索引读出SRAM表中的结果&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;第0拍，s0：第一个流水级的输入，一般是pc和折叠历史。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;第一流水级运行&lt;/strong&gt;：计算index。通过寄存器输出到s1&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;第1拍，s1：第二个流水级的输入，为第一级阶段计算好的index等数据。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;第二流水级运行&lt;/strong&gt;：访存SRAM，读取预测用信息。通过寄存器输出到s2&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;第2拍，s2：第三个流水级的输入，为第二级从SRAM中读出的&lt;strong&gt;原始预测信息&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;**第三流水级运行：**处理原始预测信息，决定是否输出预测结果。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;第3拍，s3：预测结果就绪，此时已经可以使用&lt;strong&gt;预测结果&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;数据结构&#34;&gt;数据结构&lt;/h3&gt;&#xA;&lt;p&gt;在昆明湖的实现中，T0与Tn的表结构如下所示：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&lt;strong&gt;预测器&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;表项构成&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;项数&lt;/strong&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;基准预测器T0&lt;/td&gt;&#xA;          &lt;td&gt;用于在其他预测器的预测结果都无效时输出预测结果&lt;/td&gt;&#xA;          &lt;td&gt;虚表，不存在。 直接将上级预测器FTB 的预测结果作为表项结果&lt;/td&gt;&#xA;          &lt;td&gt;虚表，不存在。 直接将上级预测器FTB结果作为索引到的结果&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;预测表T1-T2&lt;/td&gt;&#xA;          &lt;td&gt;对每个预测块的输入，所有Tn表都进行预测，在所有预测有效的结果中，选择历史记录最长的结果作为 原始预测信息。历史记录长度由输入的H决定&lt;/td&gt;&#xA;          &lt;td&gt;target: 41 bits; valid: 1bit; tag: 9bits; ctr: 2bits; us: 1bit（usefulness计数器）&lt;/td&gt;&#xA;          &lt;td&gt;256项&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;预测表T3-T5&lt;/td&gt;&#xA;          &lt;td&gt;512项&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;t0tn表的检索方法&#34;&gt;T0，Tn表的检索方法&lt;/h3&gt;&#xA;&lt;p&gt;检索方法与 TAGE 分支预测器一致，只是各表的配置选项不同。&lt;/p&gt;</description>
    </item>
    <item>
      <title>RAS 分支预测器</title>
      <link>https://open-verify.cc/xs-bpu/docs/modules/05_ras/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/modules/05_ras/</guid>
      <description>&lt;h2 id=&#34;ras介绍&#34;&gt;RAS介绍&lt;/h2&gt;&#xA;&lt;p&gt;RAS 指的是 &amp;ldquo;Return Address Stack&amp;rdquo;，即返回地址栈。它通过跟踪程序的返回地址，帮助确定程序中的分支行为。由前所述，在程序中存在很多分支：if/else、 switch/case、while/for loop、iteration、call/return&lt;/p&gt;&#xA;&lt;p&gt;等。RAS分支预测器则专门针对 call/return类型。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;_add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#a40000&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;  &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#a40000&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sub&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;d&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sub&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上图所示，在main函数中调用了add和sub，add又调用了函数_add。在该过程中，每次调用（call）的跳转地址和返回的地址固定，且在call的时候，就可以同时得到返回地址。函数的调用过程是一个“栈的出入”过程，因此可以通过“栈”结构进行分支预测：每遇到call指令，把当前PC+4（压缩指令和普通指令的偏移不同）进行压栈push操作；遇到return指令，则进行进行pop操作，得到的地址即为目标跳转地址。在基于“预测块”的BPU中，RAS无法知道当前块是否是call或者ret，因此需要依赖其他预测器，利用前级预测器的结果进行RAS操作。&lt;/p&gt;&#xA;&lt;p&gt;具体的，在香山的RAS预测器中，其s2阶段，需要判断上一级s2的输出是否预测为call或者ret（即输入信号io.s2_full_pred.hit_taken_on_call/ret有效 ），如果是call则push其后续指令地址入栈，是ret则从栈中pop出地址作为预测结果。因为在BPU的预测器中，人为假定s3阶段得到的结果比s2阶段好，所以RAS预测器在s3阶段需要进行检查，如果上一级的s3预测结果与s2不一致，则采信s3的结果，并按需求判断是否需要撤销或者补齐之前s2阶段的栈操作。例如s2阶段预测为call指令，进行了push操作，而s3为普通分支指令，不需要进行任何操作，此时就需要撤销push；如果s2预测为普通分支指令，s3预测为call，则需要进行push操作补齐。&lt;/p&gt;&#xA;&lt;h2 id=&#34;ras的栈操作&#34;&gt;RAS的栈操作&lt;/h2&gt;&#xA;&lt;p&gt;在普通的RAS设计中，通过栈进行预测函数返回地址。在理想情况下，本节假定RAS可进行随时备份，栈顶指针用sp表示，预测地址用paddr表示。RAS的基本操作有以下4种：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;h3 id=&#34;push&#34;&gt;PUSH&lt;/h3&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;由于预测可能会出错，出错时需要回到原始状态，因此在push时需要对当前栈的状态进行备份（在软件领域，通常称为“快照”，本文在后继内容中也用快照进行称呼），标记为s。当遇到call指令时，获取call指令的返回地址 addr = 当前pc + 4（如果是压缩指令则addr = pc+2），然后压栈：sp = addr；sp += 1。&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;h3 id=&#34;pop&#34;&gt;POP&lt;/h3&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;原因同上，对当前栈进行快照，标记为s。当遇到ret指令时，预测的跳转地址 paddr = sp，然后进行出栈， sp = sp - 1。对当前栈进行快照，标记为s。&lt;/p&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;h3 id=&#34;重定向操作&#34;&gt;重定向操作&lt;/h3&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;由于BPU是对程序的分支进行预测，因此就有“预测对”和“预测错”两种情况，当CPU后端发现分支预测错误，就会进行重定向（redirect）操作，告诉BPU哪个地方预测错误，正确结果是多少。重定向时RAS模块会收到正确的分支和当时预测时RAS栈信息。根据正确分支指令类型不同，首先恢复快照s有如下情形：&lt;/p&gt;&#xA;&lt;p&gt;（1）之前被预测的指令，实际是 call指令，根据redirect中给的addr地址，执行push操作；&lt;/p&gt;&#xA;&lt;p&gt;（2）之前被预测的指令，实际是 ret指令，执行pop操作；&lt;/p&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;h3 id=&#34;提交操作&#34;&gt;提交操作&lt;/h3&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;提交（Commit）操作即后端告诉前端，之前预测的结果正确。理想情况下，RAS预测器此时不需要进行任何操作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;昆明湖中ras的实现&#34;&gt;昆明湖中RAS的实现&lt;/h2&gt;&#xA;&lt;p&gt;由于处理器在执行过程中可能会进行错误的猜测，导致数据污染，RAS需要通过恢复机制来确保数据的准确性。特别是在昆明湖的实际电路设计中，不可能有无限大的栈，也无法随时备份数据。因此，昆明湖的RAS实现中，使用了基于持久化栈的返回地址预测器。具体来说，将RAS分为提交栈（commit stack）和推测栈（spec queue）两个部分，推测栈利用了香山BPU的预测结果来进行预测，然后根据后端返回的信息将数据压入提交栈中。下面详细介绍昆明湖的RAS设计：&lt;/p&gt;&#xA;&lt;h3 id=&#34;每次预测时ras栈的快照如何获得&#34;&gt;&lt;strong&gt;每次预测时，RAS栈的快照如何获得？&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;为了实现对RAS栈进行快照的功能，昆明湖的&lt;strong&gt;RAS推测栈&lt;/strong&gt;采用了基于循环数组的 &lt;strong&gt;&amp;ldquo;链式表示“&lt;/strong&gt; 。设计具体如下：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
