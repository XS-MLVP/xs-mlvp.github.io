<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>香山微架构开放验证第一期：昆明湖BPU模块UT验证实战 – 分支预测单元（BPU）</title>
    <link>https://xs-mlvp.github.io/xs-bpu/categories/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%8D%95%E5%85%83bpu/</link>
    <description>Recent content in 分支预测单元（BPU） on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	  <atom:link href="https://xs-mlvp.github.io/xs-bpu/categories/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%8D%95%E5%85%83bpu/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: uFTB 分支预测器</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/modules/01_uftb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/modules/01_uftb/</guid>
      <description>
        
        
        &lt;h2 id=&#34;uftb-简介&#34;&gt;uFTB 简介&lt;/h2&gt;
&lt;p&gt;uFTB 是香山所有预测器中第一个预测器，也是其他预测器产生预测结果的基石。uFTB 工作在 s1 阶段，它获取到 s1_pc 后能在本周期内产生预测结果，并在 s1 通道输出，其他通道不予更改。分支指令的位置、指令的跳转目标都是由它来提供，后续预测器也将会根据这一预测结果进行进一步的预测。&lt;/p&gt;
&lt;p&gt;而其本质则是一个 FTB 项缓存，其中存储了 FTB 项，基础的预测结果将直接由读出的 FTB 项生成。&lt;/p&gt;
&lt;p&gt;因此，在你开始文档的阅读之前，请确保你理解了 FTB 项和含义以及预测结果接口的具体细节。&lt;/p&gt;
&lt;h2 id=&#34;uftb-功能简介&#34;&gt;uFTB 功能简介&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;缓存FTB项，生成一周期预测结果&lt;/strong&gt;    uFTB 中维护了一个小型的 FTB 项缓存，拿到 PC 之后，会在一周期之内读出 PC 所对应的 FTB 项，并从 FTB 项生成 s1 阶段预测结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;维护两比特饱和计数器，提供基础条件分支结果&lt;/strong&gt;   uFTB 中为 FTB项缓存的每一行都维护了对应的两比特饱和计数器，其方向预测结果会反映在 uFTB 的预测结果输出中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据更新请求更新 FTB 缓存和两比特饱和计数器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;uftb-缓存结构&#34;&gt;uFTB 缓存结构&lt;/h2&gt;
&lt;p&gt;如上所述，uFTB 本质上是一个存储了 FTB 项的小型缓存，其大致结构如下图所示。&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;1.png&#34; width=&#34;400px&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;在当前版本的香山中，uFTB 共有 32 个缓存行，每个缓存行被称作 &lt;code&gt;FauFTBWay&lt;/code&gt;，一个缓存行中可以存储一个 FTB 项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当 s1 流水有效时&lt;/strong&gt;，uFTB 会使用 &lt;strong&gt;s1_pc&lt;/strong&gt; 来决定读出 uFTB 缓存的哪一项。缓存是根据 PC 中的 tag 字段来索引，tag 字段被定义为 pc[16: 1]，即在 PC 中截取了 16 比特作为标识来匹配缓存中的某一行。&lt;/p&gt;
&lt;p&gt;缓存中的每一行，即 &lt;code&gt;FauFTBWay&lt;/code&gt; 中的数据请求接口有三项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;req_tag&lt;/strong&gt;   输入 pc 中截取的 tag 标识&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;resp&lt;/strong&gt;          输出本行所存储的 FTB 项&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;resp_hit&lt;/strong&gt;  输出指示本行的 FTB 项是否与 req_tag 匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;uFTB 会将 tag 连接到缓存的每一行的数据请求接口，并根据 &lt;code&gt;resp_hit&lt;/code&gt; 信号，选出命中的那一个 FTB 项。后续将会根据这一 FTB 项生成完整预测结果。&lt;/p&gt;
&lt;h2 id=&#34;两比特饱和计数器&#34;&gt;两比特饱和计数器&lt;/h2&gt;
&lt;p&gt;uFTB 中为 FTB 项缓存的每一行都维护了对应的两比特饱和计数器。我们知道，在一个 FTB 项最多可以存储两个条件分支指令，因此每一行对应的两比特饱和计数器也有两个，负责为其中的条件分支指令提供粗略的预测结果。&lt;/p&gt;
&lt;p&gt;uFTB 在索引到 FTB 项时，也会索引到对应的两比特饱和计数器。&lt;/p&gt;
&lt;p&gt;当预测结果生成时，会根据 FTB 项与其对应的两个两比特饱和计数器中的内容来产生。&lt;/p&gt;
&lt;h2 id=&#34;预测结果生成&#34;&gt;预测结果生成&lt;/h2&gt;
&lt;p&gt;uFTB 通过 s1_pc 索引到对应的 FTB 项以及两个两比饱和计数器之后，需要根据他们产生预测结果。uFTB 产生的预测结果，将在 s1 流水有效时，通过 s1 通道进行输出，对于 s2 以及 s3 通道，uFTB 不予更改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;s1 预测结果中的信号产生方式可参考以下列表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;hit&lt;/strong&gt; FTB表项是否命中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：&lt;code&gt;FauFTBWay&lt;/code&gt; 中的 &lt;code&gt;resp_hit&lt;/code&gt; 信号，存在一个有效&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;slot_valids&lt;/strong&gt; slot有效位，表示 ftb 项中的每个 slot 是否有效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;targets&lt;/strong&gt; 每个slot对应的跳转目标地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;offsets&lt;/strong&gt; 每个slot中的指令相对于预测块起始地址的偏移&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_jal&lt;/strong&gt; 预测块内包含jal指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_jalr&lt;/strong&gt; 预测块内包含jalr指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_call&lt;/strong&gt; 预测块内包含call指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_ret&lt;/strong&gt; 预测块内包含ret指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;last_may_be_rvi_call&lt;/strong&gt; 预测结果预测块末尾可能为一个RVI类型的call指令信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_br_sharing&lt;/strong&gt; 最后一个slot (tailSlot) 中存储的是条件分支指令信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式： FTB 项中对应字段导出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;fallThroughErr&lt;/strong&gt; FTB项中记录的 &lt;code&gt;pftAddr&lt;/code&gt; 有误&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：比较 &lt;code&gt;pftAddr&lt;/code&gt; 代表的预测块结束地址是否大于预测块的起始地址，如果小于，则代表出现错误，此信号置为有效。这种情况可能会发生在 pc 索引到错误的 FTB 项的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;fallThroughAddr&lt;/strong&gt; 预测块的结束地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：如果 &lt;code&gt;fallThroughErr&lt;/code&gt; 无效，则根据 &lt;code&gt;pftAddr&lt;/code&gt; 生成，否则将其设置为起始地址 + 预测宽度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;br_taken_mask&lt;/strong&gt; 分支预测结果，每个分支(slot)对应一个 bit，表示该分支是否被预测为 taken&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：根据 FTB 项中的 &lt;code&gt;always_taken&lt;/code&gt; 字段和两比特饱和计数器指示结果生成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;jalr_target&lt;/strong&gt; 本预测块中的 jalr 的跳转目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：FTB 项中 tailSlot 中的跳转目标。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;uftb-更新&#34;&gt;uFTB 更新&lt;/h2&gt;
&lt;p&gt;uFTB 的更新涉及 FTB 项缓存的更新，以及两比特饱和计数器的更新，而更新的内容都是通过更新接口来获取的。&lt;/p&gt;
&lt;p&gt;在 uFTB 预测器中，缓存和两比特饱和计数器的读与写并不冲突，因此我们无需考虑读和更新之间的时序冲突问题，可以将他们看做是独立的两部分。&lt;/p&gt;
&lt;h3 id=&#34;ftb-缓存更新&#34;&gt;FTB 缓存更新&lt;/h3&gt;
&lt;p&gt;FTB 缓存的更新过程很简单，更新通道中已经为我们指定好了 pc 以及新生成的 FTB 项，只需将其写入到缓存的指定位置即可。&lt;/p&gt;
&lt;p&gt;FTB 缓存的更新需要两个周期：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在第一周期，通过 update 中的信号计算出如下内容：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;更新请求对应的预测块在缓存的哪一行&lt;/strong&gt; 更新请求中的 pc 截取 tag 后被发送到 &lt;code&gt;FauFTBWay&lt;/code&gt; 的更新请求通道，根据每一行所返回的 hit 信号计算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在第二周期，根据第一周期求出的需要更新的位置进行更新，如果无任何一行命中，则 uFTB 会使用 &lt;strong&gt;伪 LRU 替换算法&lt;/strong&gt; 选出需要写入的行。
&lt;ul&gt;
&lt;li&gt;具体的，更新通道中的 &lt;code&gt;ftb_entry&lt;/code&gt; 信号组包含了新 FTB 项的完整信息，将该信息发送到需要更新的某一个缓存行即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;两位饱和计数器更新&#34;&gt;两位饱和计数器更新&lt;/h3&gt;
&lt;p&gt;两位饱和计数器的更新则需要结合后续程序的真实执行情况，以及 FTB 项中记录的分支指令信息来进行更新了，而这些信息都可以从更新通道中进行获取。&lt;/p&gt;
&lt;p&gt;两位饱和计数器的更新也需要两个周期：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在第一周期，计算出槽中哪些条件分支指令 对应的两位饱和计数器 需要被更新，这需要满足以下条件：
&lt;ul&gt;
&lt;li&gt;当前分支指令槽有效，并且存放了一条条件分支指令&lt;/li&gt;
&lt;li&gt;当前分支指令槽并没有被标识为 always_taken。（因为被标识为 always_taken 后不会采用两位饱和计数器的结果）&lt;/li&gt;
&lt;li&gt;当前分支指令槽不在实际发生了跳转的分支指令槽之后。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在第二周期，更新饱和计数器
&lt;ul&gt;
&lt;li&gt;根据第一周期生成的需要更新的掩码，以及更新通道中的 &lt;code&gt;br_taken_mask&lt;/code&gt; 信息进行更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;接口列表&#34;&gt;接口列表&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;信号类型&lt;/th&gt;
&lt;th&gt;信号位&lt;/th&gt;
&lt;th&gt;信号名&lt;/th&gt;
&lt;th&gt;信号描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;clock&lt;/td&gt;
&lt;td&gt;输入时钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;reset&lt;/td&gt;
&lt;td&gt;复位信号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[35:0]&lt;/td&gt;
&lt;td&gt;io_reset_vector&lt;/td&gt;
&lt;td&gt;用于reset时，reset s1_pc_dup_0 提供的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_0&lt;/td&gt;
&lt;td&gt;输入位s0_pc 的 第0个复制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_1&lt;/td&gt;
&lt;td&gt;同上 第1个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_2&lt;/td&gt;
&lt;td&gt;同上 第2个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_3&lt;/td&gt;
&lt;td&gt;同上 第3个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_pc_0&lt;/td&gt;
&lt;td&gt;输出s1_pc 的 第0个复制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_pc_1&lt;/td&gt;
&lt;td&gt;同上 第1个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_pc_2&lt;/td&gt;
&lt;td&gt;同上 第2个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_pc_3&lt;/td&gt;
&lt;td&gt;同上 第3个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;solt 0 是否被预测为 always taken&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;solt 1 是否被预测为 always taken&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_slot_valids_0&lt;/td&gt;
&lt;td&gt;solt 0 是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_slot_valids_1&lt;/td&gt;
&lt;td&gt;solt 1 是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_targets_0&lt;/td&gt;
&lt;td&gt;solt 0 对应的跳转目标地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_targets_1&lt;/td&gt;
&lt;td&gt;solt 1 对应的跳转目标地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_offsets_0&lt;/td&gt;
&lt;td&gt;solt 0 中分支指令相对于地址块起始pc的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_offsets_1&lt;/td&gt;
&lt;td&gt;solt 1 中分支指令相对于地址块起始pc的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_fallThroughAddr&lt;/td&gt;
&lt;td&gt;预测块的结束地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_is_br_sharing&lt;/td&gt;
&lt;td&gt;solt 1（无条件跳转）是否被共享为有条件跳转指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;类似 io_out_s1_pc_1 io_out_s1_full_pred_0的复制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_fallThroughErr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[222:0]&lt;/td&gt;
&lt;td&gt;io_out_last_stage_meta&lt;/td&gt;
&lt;td&gt;输出最后阶段的元信息 io_out_last_stage_meta = {213&amp;rsquo;h0, resp_meta_pred_way_r_1, resp_meta_hit_r_1}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_ctrl_ubtb_enable&lt;/td&gt;
&lt;td&gt;控制ubtb是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s0_fire_0&lt;/td&gt;
&lt;td&gt;输入s0_fire_0，与 io_out_s1_pc_0 &amp;lt;= io_in_bits_s0_pc_0 的时钟门控相关&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s0_fire_1&lt;/td&gt;
&lt;td&gt;输入s0_fire_1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s0_fire_2&lt;/td&gt;
&lt;td&gt;输入s0_fire_2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s0_fire_3&lt;/td&gt;
&lt;td&gt;输入s0_fire_3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s1_fire_0&lt;/td&gt;
&lt;td&gt;输入s1_fire_0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s2_fire_0&lt;/td&gt;
&lt;td&gt;输入s2_fire_0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_valid&lt;/td&gt;
&lt;td&gt;更新有效性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_pc&lt;/td&gt;
&lt;td&gt;传回的预测块pc（用于指示更新的预测块）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_brSlots_0_offset&lt;/td&gt;
&lt;td&gt;solt 0 中分支指令相对于地址块起始pc的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[11:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_brSlots_0_lower&lt;/td&gt;
&lt;td&gt;跳转目标地址的低位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[1:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_brSlots_0_tarStat&lt;/td&gt;
&lt;td&gt;跳转后的 pc 高位是否进退位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_brSlots_0_valid&lt;/td&gt;
&lt;td&gt;是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_offset&lt;/td&gt;
&lt;td&gt;solt 1 中分支指令相对于地址块起始pc的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[19:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_lower&lt;/td&gt;
&lt;td&gt;跳转目标地址的低位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[1:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_tarStat&lt;/td&gt;
&lt;td&gt;跳转后的 pc 高位是否进退位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_sharing&lt;/td&gt;
&lt;td&gt;无条件跳转指令槽中存储条件分支指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_valid&lt;/td&gt;
&lt;td&gt;是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_pftAddr&lt;/td&gt;
&lt;td&gt;Partial Fallthrough Addr 如果预测块中没有跳转，那么程序将会顺序执行到达的地址，预测块的结束地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_carry&lt;/td&gt;
&lt;td&gt;pc+pft时是否产生进位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_always_taken_0&lt;/td&gt;
&lt;td&gt;是否预测为总是跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_always_taken_1&lt;/td&gt;
&lt;td&gt;是否预测为总是跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;是否跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;是否跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: TAGE-SC 分支预测器</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/modules/02_tage_sc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/modules/02_tage_sc/</guid>
      <description>
        
        
        &lt;h2 id=&#34;功能介绍&#34;&gt;功能介绍&lt;/h2&gt;
&lt;p&gt;TAGE-SC 是南湖架构条件分支的&lt;strong&gt;主预测器&lt;/strong&gt;，属于精确预测器（Accurate Predictor，简称 APD）。TAGE-SC 可以看作两个功能相对独立的组件：预测部分 TAGE 和 校验部分 SC。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标记几何历史长度预测器 TAGE （Tagged Geometric History Length Predictor）利用&lt;strong&gt;历史长度不同的多个预测表&lt;/strong&gt;，可以挖掘&lt;strong&gt;极长的分支历史信息&lt;/strong&gt;。TAGE功能是预测一个跳转指令是跳转（Taken），还是不跳转（不Taken）， 它由一个基预测表和多个历史表组成，首先通过多个历史表进行分支预测，如果没有预测结果，则再采用基础预测表的预测结果。&lt;/li&gt;
&lt;li&gt;SC (Statistical Corrector) 是统计校正器。当 SC 会参考 TAGE 的预测结果和&lt;strong&gt;统计偏向的结果&lt;/strong&gt;。并根据这两个结果，&lt;strong&gt;矫正&lt;/strong&gt;最终的预测结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在昆明湖中，由于每个预测块，最多可以有2条跳转指令，因此TAGE在每次预测最多&lt;strong&gt;同时预测 2 条&lt;/strong&gt;条件分支指令。在访问 TAGE 的各个历史表时，用预测块的起始地址作为 PC，同时取出两个预测结果，并&lt;strong&gt;基于相同的全局历史&lt;/strong&gt;进行预测。&lt;/p&gt;
&lt;h2 id=&#34;昆明湖tage分支预测器&#34;&gt;昆明湖Tage分支预测器&lt;/h2&gt;
&lt;h3 id=&#34;基本功能&#34;&gt;基本功能&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; src=&#34;tage.PNG&#34;&gt;&lt;/p&gt;
&lt;p&gt;TAGE预测器的核心思路是提供不同历史长度的预测结果，并选择最合适的结果进行反馈。在TAGE预测器中，一共有 &lt;strong&gt;1+N&lt;/strong&gt; 个表历史记录表，N 为可配置选项。以昆明湖为例，N=4。&lt;/p&gt;
&lt;p&gt;基于 T0 表的预测器为&lt;strong&gt;基础预测器&lt;/strong&gt;。在预测时，直接通过预测块的 PC 地址在 T0 表中查找到该地址对应的 “2 bit 饱和计数器表示的跳转历史信息” ，然后根据历史信息做出预测结果。T0表的表项只有2bit，所以能记录的历史状态有限。&lt;/p&gt;
&lt;p&gt;对于 T0 以外的表，我们用 &lt;strong&gt;Tn&lt;/strong&gt; &lt;strong&gt;进行表示&lt;/strong&gt;。在查表时除了 PC 外，还需要用到&lt;strong&gt;全局跳转历史信息H&lt;/strong&gt;进行查找。&lt;strong&gt;查找命中后&lt;/strong&gt;，根据 “3bit饱和预测器” 进行跳转或者不跳转的预测。Tn 表的n越大，其用到的H中的位数越多。&lt;/p&gt;
&lt;p&gt;对于每一次预测，TAGE 从所有 Tn 命中表项中选择&lt;strong&gt;全局跳转历史最长&lt;/strong&gt;的表项。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果该表项存在，且预测结果置信度高就用该项作为最终预测结果。&lt;/li&gt;
&lt;li&gt;如果置信度低，就通过另外一个内部计数器来判断选择该项还是 T0 作为最后预测。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在实现上，为了节约空间，检索 Tn 表时，输入的跳转历史信息H需要进行&lt;strong&gt;压缩&lt;/strong&gt;，该过程也称为&lt;strong&gt;历史折叠&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;各预测表的表项包含如下元素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;T0 表项通过 pc 直接索引
&lt;ol&gt;
&lt;li&gt;2 bit pred &lt;strong&gt;无符号&lt;/strong&gt;饱和计数器（给出预测方向和信心强度）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Tn 表项通过 异或 pc 与 折叠全局历史 索引
&lt;ol&gt;
&lt;li&gt;1 bit valid 有效位&lt;/li&gt;
&lt;li&gt;3 bit pred &lt;strong&gt;无符号&lt;/strong&gt;饱和计数器&lt;/li&gt;
&lt;li&gt;8 bit tag （基于Hash校验是否命中，而非巧合）&lt;/li&gt;
&lt;li&gt;1 bit useful 用于控制有效期&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于一个预测块，有可能所有的表都会产生预测结果，此时就需要进行选择。如上图所示，一般情况下，Tn表的编号越大，优先级越高。&lt;/p&gt;
&lt;h3 id=&#34;流水线&#34;&gt;流水线&lt;/h3&gt;
&lt;p&gt;TAGE &lt;strong&gt;内含两个流水级&lt;/strong&gt;，第一级计算索引，第二级通过索引读出SRAM表中的结果&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第0拍，s0：第一个流水级的输入，一般是pc和折叠历史。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;第一流水级运行&lt;/strong&gt;：计算index。通过寄存器输出到s1&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第1拍，s1：第二个流水级的输入，为第一级阶段计算好的index等数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;第二流水级运行&lt;/strong&gt;：访存SRAM，读取预测结果。通过寄存器输出到s2&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第2拍，s2：实际预测结果。TAGE用了2拍进行预测，在2拍之后的第3拍预测结果就绪可用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据结构&#34;&gt;数据结构&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在昆明湖的实现中，T0与Tn的表结构如下所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;预测器&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;表项构成&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;项数&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;基准预测器T0&lt;/td&gt;
&lt;td&gt;用于在其他预测器的预测结果都无效时输出预测结果&lt;/td&gt;
&lt;td&gt;2 bit ctr 饱和计数器最高位决定跳转方向&lt;/td&gt;
&lt;td&gt;2路各2048项，每路对于一条分支指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;预测表T1-T4&lt;/td&gt;
&lt;td&gt;对每个预测块的输入，所有Tn表都进行预测，在所有预测有效的结果中，选择历史记录最长的结果作为最后预测结果。历史记录长度由输入的H决定&lt;/td&gt;
&lt;td&gt;1 bit valid 有效位 3 bit ctr 饱和计数器8 bit tag 校验命中1 bit us 作为usefulness计数器&lt;/td&gt;
&lt;td&gt;4096项、奇数项对应第一条分支指令，偶数项对应第二条分支指令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于每个表Tn，在查询时，其输入“全局分支历史数据H”的长度是不同的。假如总的预测历史长度为S，Tn、Tn+1可能用S的低x，低y位 （&lt;strong&gt;越低的位是越新的历史&lt;/strong&gt;）作为查询输入。一般情况下，Tn表的n越大，其用到的历史信息越长，即 x&amp;lt;y 。&lt;/p&gt;
&lt;p&gt;在进行 Tn 表的查询时，由于历史数据H进行了“压缩”，可能导致一个PC1^H1的结果与另一个PC2^H2的结果相同（类似Hash表的Hash冲突），进而导致索引到无效数据（预测PC1索引到预测PC2的数据）。所以TAGE为每个表提供了一个tag标识，昆明湖中采用了8bit tag，来减小冲突发生的概率，tag的计算方法和查询的索引方法不同，&lt;strong&gt;只有当tag计算相同时查询结果才有效&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在Tn表项中，除了饱和计数器ctr和tag外，还有1bit的&lt;strong&gt;usefulness计数器&lt;/strong&gt;，该计数器为0时，作弱表项，表示可以当作该项可以被重新分配当作他用；不为0时，作强表项，该项不能被分配当作他用。&lt;/p&gt;
&lt;p&gt;为了&lt;strong&gt;尽力避免&lt;/strong&gt;所有表项全为1，无法分配新表项的情况发生，TAGE预期使用计数器bankTickCtrs 对所有usefulness进行清零操作。&lt;/p&gt;
&lt;h3 id=&#34;t0tn表的检索方法&#34;&gt;T0，Tn表的检索方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对于T0表，在查找时用 PC[11:1] 位进行索引2048表项，因此对于T0来说，不可能存在检索不到的情况。&lt;/li&gt;
&lt;li&gt;对于表Tn，除了 PC[11:1] 外，&lt;strong&gt;还需要&lt;/strong&gt;基于全局分支历史进行检索。在昆明湖中，顶层分支预测器维护了一个256bit的全局历史记录GH，可以根据子预测器需要将GH的最近n位历史信息，按目标位数x进行折叠。 即把n，以长度x为基本单元，拆分成ceil(x/n)个长为x的数，然后&lt;strong&gt;按位进行异或&lt;/strong&gt;得到。通常用FH（Folded History）表示，具体流程请参考 &lt;a href=&#34;../00_bpu_top/#%E5%88%86%E6%94%AF%E6%8A%98%E5%8F%A0%E5%8E%86%E5%8F%B2&#34;&gt;分支折叠历史章节&lt;/a&gt;。TAGE预测器查找Tn的表项时，用到了index和tag，他们的计算公式如下表所示：&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;计算方法 公式&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;index = FH ^ ((pc&amp;raquo;1)低位)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tag = FH1 ^ FH2 ^ ((pc&amp;raquo;1)低位)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中FH、FH1、FH2表示按一定规范折叠后的全局分支历史。对于Tn而言，其FH、FH1、FH2都有各自的对于折叠位数，不一定相同。在昆明湖实现中，T0和Tn表的配置如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;表名称&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;FH长度&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;FH1长度&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;FH2长度&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;最近历史长度（用到GH中的位数）&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;7比特&lt;/td&gt;
&lt;td&gt;低8位，即把最新8位历史，折叠成FH、FH1、FH2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;11比特&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;7比特&lt;/td&gt;
&lt;td&gt;低13位，即把最新13位历史，折叠成FH、FH1、FH2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T3&lt;/td&gt;
&lt;td&gt;11比特&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;7比特&lt;/td&gt;
&lt;td&gt;低32位，即把最新32位历史，折叠成FH、FH1、FH2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T4&lt;/td&gt;
&lt;td&gt;11比特&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;7比特&lt;/td&gt;
&lt;td&gt;低119位，即把最新119位历史，折叠成FH、FH1、FH2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注：pc&amp;raquo;1是因为使用了RISC-C拓展，2Byte对齐，而PC本身已经省略了1B对齐，所以只用1b&lt;/p&gt;
&lt;h3 id=&#34;替代预测器&#34;&gt;替代预测器&lt;/h3&gt;
&lt;p&gt;由于 Tn 表使用饱和计数器进行预测，因此其输出结果可能存在“&lt;strong&gt;信心不足&lt;/strong&gt;”的情况。例如在昆明湖中，对3比特饱和计数器，100、011时都是&lt;strong&gt;弱预测&lt;/strong&gt;。为了为该状态提供更多的选择参考，TAGE 预测器还提供了一个“替代预测器”机制，他的作用是告诉 TAGE 在 Tn 表预测的结果 “信心不足” 时，是该选择 Tn 的预测结果，还是选择 T0 的预测结果。&lt;/p&gt;
&lt;p&gt;在昆明湖的具体实现中，“替代预测器” 基于 &lt;strong&gt;useAltOnNaCtrs&lt;/strong&gt; 的寄存器组实现。它由两路128个 &lt;strong&gt;4-bit饱和计数器&lt;/strong&gt; 构成，每个计数器都被初始化为 &lt;strong&gt;0b1000&lt;/strong&gt;。在TAGE进行预测时，使用 &lt;strong&gt;PC(7,1)&lt;/strong&gt; 进行索引得到对应的饱和计数器。如果该计数器的值大于等于预设值，且Tn预测结果信心不高，则选择T0的结果，否则选择Tn的结果。&lt;/p&gt;
&lt;h3 id=&#34;预测过程&#34;&gt;预测过程&lt;/h3&gt;
&lt;p&gt;综上所述，昆明湖中TAGE预测器的预测步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;并行&lt;/strong&gt;索引 T0 表以及 Tn 表，&lt;strong&gt;根据命中结果选择&lt;/strong&gt;使用哪一个表给出预测结果
&lt;ol&gt;
&lt;li&gt;如果有&lt;strong&gt;命中到tag&lt;/strong&gt;匹配的Tn表，由&lt;strong&gt;历史记录最长&lt;/strong&gt;Tn表的ctr饱和计数器给出潜在预测结果。&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;没有命中&lt;/strong&gt;Tn表，则由&lt;strong&gt;T0表&lt;/strong&gt;的饱和计数器给出最终预测结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果匹配到的&lt;strong&gt;Tn表的潜在预测结果为弱预测&lt;/strong&gt;(100,011)，且&lt;strong&gt;替代预测中PC对应4-bit计数器的值&lt;/strong&gt;大于等于阈值，则采用T0表的结果为最终结果，否则采用Tn表的预测结果为最终预测结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;训练过程&#34;&gt;训练过程&lt;/h3&gt;
&lt;p&gt;由于TAGE的预测过程用到了很多计数器和tag，他们需要根据一定的规则进行更新，该过程称为训练。该训练过程发生在BPU的update阶段，该阶段会输入PC，分支历史、以及否预测正确等信息。香山昆明湖的分支预测进行训练的流程根据不同情况，分为如下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;T0&lt;/strong&gt;作为最终使用的预测结果时更新：发生跳转（即taken）则 pc 索引的 ctr 饱和计数器 +1，否则 -1&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;只有T0&lt;/strong&gt;命中时，进行如下操作
&lt;ol&gt;
&lt;li&gt;T0&lt;strong&gt;预测正确&lt;/strong&gt;则不额外更新&lt;/li&gt;
&lt;li&gt;T0&lt;strong&gt;预测错误&lt;/strong&gt;则尝试随机在Tn中的某个表申请一个新表项 申请新表项时需要对应index位置的原表项useful为0 新表项默认是弱预测，useful为0，并设置其tag为计算出来的新tag&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;T0和Tn同时命中&lt;/strong&gt;时，进行如下操作
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Tn&lt;/strong&gt; 始终更新：taken 则 pc 索引的 ctr 饱和计数器 +1，否则 -1 需要注意，”命中“ 表示 index 索引到的表项的 tag 要和计算出的 tag &lt;strong&gt;匹配&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;若&lt;strong&gt;T0和Tn结果相同&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;预测正确&lt;/strong&gt;则不额外更新&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;预测错误&lt;/strong&gt;则尝试在比Tn对应历史更长的表中随机申请一个新表项 申请新表项时需要对应index位置的原表项useful为0 新表项默认是弱预测，useful为0，tag设置为用新历史信息计算出来的tag&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;若&lt;strong&gt;T0和Tn结果不同&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;若&lt;strong&gt;Tn正确&lt;/strong&gt;则表项 useful +1
&lt;ol&gt;
&lt;li&gt;若结果还同时为&lt;strong&gt;弱预测&lt;/strong&gt;，则选用T0的替代预测计数器 -1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;若&lt;strong&gt;Tn错误&lt;/strong&gt;则表项 useful -1，同时如 &lt;strong&gt;3.2.2&lt;/strong&gt; 在更长历史表中申请新表项
&lt;ol&gt;
&lt;li&gt;若结果还同时为&lt;strong&gt;弱预测&lt;/strong&gt;，则选用T0的替代预测计数器 +1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;每次需要分配表时&lt;/strong&gt;，进行动态重置usefulness标志位
&lt;ol&gt;
&lt;li&gt;使用 7bit 的 bankTickCtrs 寄存器，并计算
&lt;ol&gt;
&lt;li&gt;可分配的表数 &lt;strong&gt;a&lt;/strong&gt;（历史长度比当前更长，且对应索引的useful为 0 ）&lt;/li&gt;
&lt;li&gt;不可分配的表数 &lt;strong&gt;b&lt;/strong&gt;（历史长度比当前更长，且对应索引的useful 不为 0 ）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新&lt;/strong&gt; bankTickCtrs += Δ（饱和计数）， &lt;strong&gt;Δ = b - a&lt;/strong&gt;，&lt;/li&gt;
&lt;li&gt;当 bankTickCtrs当为&lt;strong&gt;最大值&lt;/strong&gt;时, &lt;strong&gt;重置所有useful=0&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;昆明湖sc分支预测器&#34;&gt;昆明湖SC分支预测器&lt;/h2&gt;
&lt;h3 id=&#34;基本功能介绍&#34;&gt;基本功能介绍&lt;/h3&gt;
&lt;p&gt;SC（Statistics counter）分支预测器是一种基于历史统计信息的分支预测器。&lt;/p&gt;
&lt;p&gt;与TAGE类似，在SC中通常有多个表Tn，他们对应了不同历史长度的跳转统计。不同点在于，在预测按PC检索时，每个表Tn都会命中，然后SC把每个命中的表项进行求和，计算总的“饱和计数器”跳转信息，最后根&lt;strong&gt;据总的跳转信息判断是否跳转&lt;/strong&gt;。一般情况下，SC采用“有符号饱和计数器”，计数器值大于0时表示跳转，小于0时表示不跳转。计数器的绝对值越大，表示其预测置信度越高。&lt;/p&gt;
&lt;p&gt;在SC预测器中，SC也由多个表组成（例如T1，T2，T3，T4），但相对TAGE预测器少了基础预测表T0。SC中Tn表有6 bit的&lt;strong&gt;有符号&lt;/strong&gt;饱和计数器。SC表的索引方式如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;计算方式&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Index = (FH) ^ ((pc&amp;raquo;1)低位)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对应每个表，其表项数和用到的折叠历史长度如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表名&lt;/th&gt;
&lt;th&gt;表项数&lt;/th&gt;
&lt;th&gt;FH长度&lt;/th&gt;
&lt;th&gt;折叠历史范围&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;不折叠&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;把历史信息的低4位，折叠成FH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T3&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;把历史信息的低10位，折叠成FH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T4&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;把历史信息的低16位，折叠成FH&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在计算统计预测结果时，总得统计结果计算公式如下：&lt;/p&gt;

&lt;div class=&#34;math&#34;&gt;$$scCtrSum=\sum_{i=0}^{i&lt;4}( (ctr_{sc} &lt;&lt; 1) +1)$$&lt;/div&gt;&lt;p&gt;其中ctr_sc表示每个表的有符号饱和计数器。对其进行左移加一是进行&lt;strong&gt;权重调整&lt;/strong&gt;。累加后的scCtrSum就是SC的最终预测结果，如果为该值大于零，则预测跳转，小于零则预测不跳转。其绝对值越大，表示预测置信度越高。&lt;/p&gt;
&lt;p&gt;典型数据转换结果如下（在计算时为了不溢出，扩展到了9位）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;均为 6b100000（强不跳转） ，求得 9b100000100，值为 -252&lt;/li&gt;
&lt;li&gt;均为 6b011111（强跳转），求得 9b011111100，值为 252&lt;/li&gt;
&lt;li&gt;均为 6b000000（弱跳转），求得 9b000000100，值为 4&lt;/li&gt;
&lt;li&gt;均为 6b111111（弱不跳转），求得 9b111111100，值为 -4&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;预测过程-1&#34;&gt;预测过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通过PC和历史信息结算表Tn的索引 Index&lt;/li&gt;
&lt;li&gt;根据Index查询，得到所有表对应的饱和计数器&lt;/li&gt;
&lt;li&gt;所有所有表查询到的饱和计数器进行求和得到最终预测结果（大于0跳转，小于0不跳转）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;训练过程-1&#34;&gt;训练过程&lt;/h3&gt;
&lt;p&gt;在update阶段进行饱和计数器的更新。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果PC对应的真实指令跳转，这所有表中对应的饱和计数器+1&lt;/li&gt;
&lt;li&gt;如果PC对应的真实指令不跳转，这所有表中对应的饱和计数器-1&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;昆明湖tage-sc分支预测器&#34;&gt;昆明湖TAGE-SC分支预测器&lt;/h2&gt;
&lt;h3 id=&#34;有了tage为何还需要sc&#34;&gt;有了TAGE为何还需要SC&lt;/h3&gt;
&lt;p&gt;一些应用上，一些分支行为与分支历史或&lt;strong&gt;路径相关性较弱&lt;/strong&gt;，表现出一个&lt;strong&gt;统计上的预测偏向性&lt;/strong&gt;。对于这些分支，相比基于历史的分支预测，使用&lt;strong&gt;计数器&lt;/strong&gt;捕捉统计偏向的方法更为有效。&lt;/p&gt;
&lt;p&gt;TAGE在预测与历史非常相关的分支时非常有效，但对有统计偏向的分支则支持不佳。例如只对一个方向有小偏差，但与历史路径没有强相关性的分支。为了避免该问题，可以在传统TAGE预测器上增加SC预测器。&lt;/p&gt;
&lt;h3 id=&#34;tage-sc功能介绍&#34;&gt;TAGE-SC功能介绍&lt;/h3&gt;
&lt;p&gt;在昆明湖 TAGE-SC 预测器中，会同时得到 TAGE 和 SC 的预测结果 P1 和 P2，然后对他们的结果进行累加 P = P1+P2 ，如果 P 的绝对值大于 8bit 的阈值 sc_bank_thres，则采用预测器结果 P，否则则采用 P1 作为最终预测结果。&lt;/p&gt;
&lt;p&gt;为了进行动态自适应，阈值sc_thres是需要是动态变化的。为此在实现上TAGE-SC使用了一个5bit的sc_bank_ctr计数器对阈值sc_bank_thres进行调整。另外，由于昆明湖支持同时预测2条分支指令，因此阈值寄存器和对应的控制计数器也是两份。&lt;/p&gt;
&lt;h3 id=&#34;流水线-1&#34;&gt;流水线&lt;/h3&gt;
&lt;p&gt;TAGE-SC 内含 3 个流水级，TAGE的2级流水已经介绍过，SC部分的流水线如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第0拍，s0 读入 pc 和折叠历史&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;第一流水级&lt;/strong&gt;：通过pc和FH计算出index，并输出到s0_idx寄存器&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第1拍，s1 从s0寄存器读出s0_idx作为s1_idx&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;第二流水级&lt;/strong&gt;：找到SCTable中s1_idx对应的计数器数据，输出到s1_scResps寄存器&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第2拍，s2 从s1寄存器读出s1_scResps作为s2_scResps&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;第三流水级&lt;/strong&gt;：根据s2_scResps选择是否需要反转预测结果，输出到s2_disagree寄存器&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第3拍，s3 从s2_disagree中读出结果，作为s3_disagree输出&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;预测过程-2&#34;&gt;预测过程&lt;/h3&gt;
&lt;p&gt;在TAGE-SC预测时，TAGE的预测结果P1用tage_ctr表示，SC的预测结果P2用&lt;strong&gt;scCtrSum&lt;/strong&gt;表示。在预测时，分为如下四步。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;执行SC预测器，得到预测结果scCtrSum&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并行得到TAGE预测器的预测结果 tage_ctr。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;由于TAGE的预测结果是无符号饱和计数器，而SC的预测结果是有符号饱和计数器，如果对他们进行相加，需要进行数据转换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;昆明湖在实现上，采用了对TAGE的结果进行转换。转换后的结果用
tageCtrCentered
表示，具体转换过程如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&#34;math&#34;&gt;$$tageCtrCentered=((((ctr_{tage} -4)&lt;&lt;1)+1)&lt;&lt;3) $$&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;3比特的无符号饱和计数器转换为8比特的有符号饱和计数器结果举例如下所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;3b100 弱跳转 =&amp;gt; 8b00001000 = 8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3b011 弱不跳转 =&amp;gt; 8b11111000 = -8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3b111 强跳转 =&amp;gt; 8b00111000 = 56&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3b000 强不跳转 =&amp;gt; 8b11001000 = -56&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对TAGE和SC的预测结果进行相加得到最终预测结果P，在实现上用totalSum进行表示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&#34;math&#34;&gt;$$totalSum = scCtrSum + tageCtrCentered$$&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;根据 &lt;strong&gt;totalSum 以及 sc_bank_thres&lt;/strong&gt; &lt;strong&gt;决定最终预测方向&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;totalSum  &amp;gt; 0 且绝对值超过阈值则跳转：&lt;/strong&gt; 如果 &lt;strong&gt;scCtrSum &amp;gt;  sc_bank_thres - tageCtrCentered&lt;/strong&gt;  也可以理解成 &lt;strong&gt;totalSum &amp;gt; sc_bank_thres&lt;/strong&gt;  上面的写法可以降低最大位宽（把保证不溢出需要10bit变成9bit）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;totalSum  &amp;lt; 0 且绝对值超过阈值则不跳转：&lt;/strong&gt; 如果 &lt;strong&gt;scCtrSum &amp;lt; -sc_bank_thres - tageCtrCentered&lt;/strong&gt;  也可以理解成 |&lt;strong&gt;totalSum&lt;/strong&gt;| &lt;strong&gt;&amp;gt; sc_bank_thres&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;训练过程-2&#34;&gt;训练过程&lt;/h3&gt;
&lt;p&gt;在对 TAGE 和 SC 进行组合后，TAGE-SC 添加了 sc_bank_ctr 计数器用来控制阈值sc_bank_thres。因此在训练时，除了 TAGE 和 SC 本身的训练外，还需要对新增加的计数器进行更新。&lt;/p&gt;
&lt;p&gt;在update阶段，其具体更新流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TAGE-SC采用了预测结果P（即TAGE+SC后的预测结果），如果 |&lt;strong&gt;totalSum&lt;/strong&gt;| 在 [&lt;strong&gt;sc_bank_thres&lt;/strong&gt; -4, &lt;strong&gt;sc_bank_thres&lt;/strong&gt; -2] 的范围内，则对阈值相关寄存器组进行更新
&lt;ol&gt;
&lt;li&gt;更新 &lt;strong&gt;sc_bank_ctr，饱和计数&lt;/strong&gt; 若预测正确，则 &lt;strong&gt;sc_bank_ctr +=1&lt;/strong&gt; 若预测错误，则 &lt;strong&gt;sc_bank_ctr  -=1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;更新 &lt;strong&gt;sc_bank_thres&lt;/strong&gt; &lt;strong&gt;，受限制的饱和运算，&lt;/strong&gt; 若 &lt;strong&gt;sc_bank_ctr&lt;/strong&gt; 更新后的值已达 0b11111 且 &lt;strong&gt;sc_bank_thres&lt;/strong&gt; &amp;lt;= 31，则 &lt;strong&gt;sc_bank_thres +=2&lt;/strong&gt; 若 &lt;strong&gt;sc_bank_ctr&lt;/strong&gt; 更新后的值为 0 且 &lt;strong&gt;sc_bank_thres&lt;/strong&gt; &amp;gt;=6，则 &lt;strong&gt;sc_bank_thres -=2&lt;/strong&gt; 其余情况thres不变。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sc_bank_thres&lt;/strong&gt; 更新判断结束后，会对 &lt;strong&gt;sc_bank_ctr&lt;/strong&gt; 再做一次判断 若更新后的&lt;strong&gt;sc_bank_ctr&lt;/strong&gt;若为0b11111或0，则thres_ctr会被置回初始值0b10000。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;TAGE-SC采用了预测结果P1（即TAGE的预测结果）不进行任何操作&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;接口列表&#34;&gt;接口列表&lt;/h2&gt;
&lt;h3 id=&#34;tagesc&#34;&gt;TageSC&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;信号类型&lt;/th&gt;
&lt;th&gt;信号宽度&lt;/th&gt;
&lt;th&gt;信号名&lt;/th&gt;
&lt;th&gt;信号描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;clock&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;reset&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[35:0]&lt;/td&gt;
&lt;td&gt;io_reset_vector&lt;/td&gt;
&lt;td&gt;用于reset时，reset s1_pc_dup_0 提供的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_0&lt;/td&gt;
&lt;td&gt;复制的s0_pc的dup数组的第1个，给顶层BPU的PC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_1&lt;/td&gt;
&lt;td&gt;复制的s0_pc第2个，给Tage的PC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_3&lt;/td&gt;
&lt;td&gt;复制的s0_pc的第4个，给SC的PC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[10:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_17_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 2 用到的11bits 折叠历史 从多长历史范围折叠到11bit见前文所述的表 注意TageTable下标+1，此处 T2 是前文 T3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[10:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_16_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 3 用到的11bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_15_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 1 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_14_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 0 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_9_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 2 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_8_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 3 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_7_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 0 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_5_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 3 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_4_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 1 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_3_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 2 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[10:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_1_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 1 用到的11bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_3_hist_12_folded_hist&lt;/td&gt;
&lt;td&gt;SCTable 1 用到的 4bit 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_3_hist_11_folded_hist&lt;/td&gt;
&lt;td&gt;SCTable 2 用到的 8bit 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_3_hist_2_folded_hist&lt;/td&gt;
&lt;td&gt;SCTable 3 用到的 8bit 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_{i}&lt;em&gt;br_taken_mask&lt;/em&gt;{j} Tage 在 s2流水级输出的，复制4份 预测块中第 j 条分支指令TAGE预测结果  这里不该叫mask吧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_0_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_{i}&lt;em&gt;br_taken_mask&lt;/em&gt;{j} Tage 在 s3流水级输出的，复制4份 预测块中第 j 条分支指令SC预测结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_0_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_1_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_1_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*[222:0]&lt;/td&gt;
&lt;td&gt;io_out_last_stage_meta&lt;/td&gt;
&lt;td&gt;见附表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_ctrl_tage_enable&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_ctrl_sc_enable&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s0_fire_0&lt;/td&gt;
&lt;td&gt;s0 阶段流水线控制 相同信号复制多份，0给BPU，1给Tage，3给SC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s0_fire_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s0_fire_3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s1_fire_0&lt;/td&gt;
&lt;td&gt;s1 阶段流水线控制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s1_fire_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s1_fire_2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s1_fire_3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s2_fire_0&lt;/td&gt;
&lt;td&gt;s2 阶段流水线控制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s2_fire_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s2_fire_2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s2_fire_3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s1_ready&lt;/td&gt;
&lt;td&gt;tage的所有表，可以执行读取结果的操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_valid&lt;/td&gt;
&lt;td&gt;从FTQ发向BPU的后端执行结果（更新信号）是否有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[40:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_pc&lt;/td&gt;
&lt;td&gt;（后端执行过的）预测块的PC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[10:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_17_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 2 用到的11bits 折叠历史 预测时使用的分支历史结果，没有更新，转了一圈回来了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[10:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_16_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 3 用到的11bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_15_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 1 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_14_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 0 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[3:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_12_folded_hist&lt;/td&gt;
&lt;td&gt;SCTable 1 用到的 4bit 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_11_folded_hist&lt;/td&gt;
&lt;td&gt;SCTable 2 用到的 8bit 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_9_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 2 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_8_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 3 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_7_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 0 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_5_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 3 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_4_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 1 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_3_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 2 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_2_folded_hist&lt;/td&gt;
&lt;td&gt;SCTable 3 用到的 8bit 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[10:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_1_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 1 用到的11bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_brSlots_0_valid&lt;/td&gt;
&lt;td&gt;FTB 表项的第一个slot是否有效（存储了跳转指令）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_sharing&lt;/td&gt;
&lt;td&gt;FTB 表项的最后一个slot是否存储了条件分支而非无条件跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_valid&lt;/td&gt;
&lt;td&gt;FTB 表项的最后一个slot是否有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_always_taken_0&lt;/td&gt;
&lt;td&gt;历史上slot 0 指令总是跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_always_taken_1&lt;/td&gt;
&lt;td&gt;历史上slot 1 指令总是跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;solt 0 是否 taken&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;solt 1 是否 taken&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_mispred_mask_0&lt;/td&gt;
&lt;td&gt;solt 0 是否预测正确&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_mispred_mask_1&lt;/td&gt;
&lt;td&gt;solt 1 是否预测正确&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[222:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_meta&lt;/td&gt;
&lt;td&gt;见附表&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;io_out_last_stage_meta&#34;&gt;io_out_last_stage_meta&lt;/h3&gt;
&lt;p&gt;需要设计参与优化！&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;信号类型&lt;/th&gt;
&lt;th&gt;信号位&lt;/th&gt;
&lt;th&gt;信号名&lt;/th&gt;
&lt;th&gt;信号描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[218:88]&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;占位，全为0，传递到composer时会忽略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;87&lt;/td&gt;
&lt;td&gt;resp_meta_providers_1_valid_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[86:85]&lt;/td&gt;
&lt;td&gt;resp_meta_providers_1_bits_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;84&lt;/td&gt;
&lt;td&gt;resp_meta_providers_0_valid_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[83:82]&lt;/td&gt;
&lt;td&gt;resp_meta_providers_0_bits_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[81:79]&lt;/td&gt;
&lt;td&gt;resp_meta_providerResps_1_r_ctr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;78&lt;/td&gt;
&lt;td&gt;resp_meta_providerResps_1_r_u&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;77&lt;/td&gt;
&lt;td&gt;resp_meta_providerResps_1_r_unconf&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[76:74]&lt;/td&gt;
&lt;td&gt;resp_meta_providerResps_0_r_ctr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;73&lt;/td&gt;
&lt;td&gt;resp_meta_providerResps_0_r_u&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;72&lt;/td&gt;
&lt;td&gt;resp_meta_providerResps_0_r_unconf&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;71&lt;/td&gt;
&lt;td&gt;resp_meta_altUsed_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;70&lt;/td&gt;
&lt;td&gt;resp_meta_altUsed_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;69&lt;/td&gt;
&lt;td&gt;resp_meta_altDiffers_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;68&lt;/td&gt;
&lt;td&gt;resp_meta_altDiffers_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[67:66]&lt;/td&gt;
&lt;td&gt;resp_meta_basecnts_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[65:64]&lt;/td&gt;
&lt;td&gt;resp_meta_basecnts_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[63:60]&lt;/td&gt;
&lt;td&gt;resp_meta_allocates_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[59:56]&lt;/td&gt;
&lt;td&gt;resp_meta_allocates_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;55&lt;/td&gt;
&lt;td&gt;resp_meta_takens_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;54&lt;/td&gt;
&lt;td&gt;resp_meta_takens_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;53&lt;/td&gt;
&lt;td&gt;resp_meta_scMeta_tageTakens_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;52&lt;/td&gt;
&lt;td&gt;resp_meta_scMeta_tageTakens_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;51&lt;/td&gt;
&lt;td&gt;resp_meta_scMeta_scUsed_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;resp_meta_scMeta_scUsed_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;49&lt;/td&gt;
&lt;td&gt;resp_meta_scMeta_scPreds_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;48&lt;/td&gt;
&lt;td&gt;resp_meta_scMeta_scPreds_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[47:42]&lt;/td&gt;
&lt;td&gt;r_1_3&lt;/td&gt;
&lt;td&gt;scMeta(预测时的状态)中第2路的第4个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[41:36]&lt;/td&gt;
&lt;td&gt;r_1_2&lt;/td&gt;
&lt;td&gt;scMeta中第2路的第3个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[35:30]&lt;/td&gt;
&lt;td&gt;r_1_1&lt;/td&gt;
&lt;td&gt;scMeta中第2路的第2个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[29:24]&lt;/td&gt;
&lt;td&gt;r_1_0&lt;/td&gt;
&lt;td&gt;scMeta中第2路的第1个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[23:18]&lt;/td&gt;
&lt;td&gt;r_3&lt;/td&gt;
&lt;td&gt;scMeta中第1路的第4个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[17:12]&lt;/td&gt;
&lt;td&gt;r_2&lt;/td&gt;
&lt;td&gt;scMeta中第1路的第3个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[11:6]&lt;/td&gt;
&lt;td&gt;r_1&lt;/td&gt;
&lt;td&gt;scMeta中第1路的第2个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[5:0]&lt;/td&gt;
&lt;td&gt;r_0&lt;/td&gt;
&lt;td&gt;scMeta中第1路的第1个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;io_update_bits_meta&#34;&gt;io_update_bits_meta&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;信号类型&lt;/th&gt;
&lt;th&gt;信号位&lt;/th&gt;
&lt;th&gt;信号名&lt;/th&gt;
&lt;th&gt;信号描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[218:94]&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;FTB, ITAGE, RAS 模块传给 FTQ 的 META 信息，忽略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[93:6]&lt;/td&gt;
&lt;td&gt;io_out_last_stage_meta[87:0] 偏移 6bit 后的结果&lt;/td&gt;
&lt;td&gt;TAGE 输出给 FTQ 的 META&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[5:0]&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;uFTB 输出给 FTQ 的 META&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
    
  </channel>
</rss>
