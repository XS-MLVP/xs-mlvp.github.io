<!doctype html>
<html itemscope itemtype="http://schema.org/WebPage" lang="en" class="no-js">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="canonical" type="text/html" href="https://open-verify.cc/xs-bpu/en/docs/modules/">
<link rel="alternate" type="application/rss&#43;xml" href="https://open-verify.cc/xs-bpu/en/docs/modules/index.xml">
<meta name="robots" content="noindex, nofollow">


<link rel="shortcut icon" href="/xs-bpu/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/xs-bpu/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/android-192x192.png" sizes="192x192">

<title>Submodule Documentation | OpenVerify Courses</title>
<meta name="description" content="This section of the documentation will provide a detailed introduction to each module of the Xiangshan Branch Prediction Unit, including the BPU top-level and five sub-predictors.">
<meta property="og:url" content="https://open-verify.cc/xs-bpu/en/docs/modules/">
  <meta property="og:site_name" content="OpenVerify Courses">
  <meta property="og:title" content="Submodule Documentation">
  <meta property="og:description" content="This section of the documentation will provide a detailed introduction to each module of the Xiangshan Branch Prediction Unit, including the BPU top-level and five sub-predictors.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="website">

  <meta itemprop="name" content="Submodule Documentation">
  <meta itemprop="description" content="This section of the documentation will provide a detailed introduction to each module of the Xiangshan Branch Prediction Unit, including the BPU top-level and five sub-predictors.">
  <meta itemprop="dateModified" content="2025-05-06T12:03:58+08:00">
  <meta itemprop="wordCount" content="117">
  <meta itemprop="keywords" content="Xiangshan,BPU,Sub-Predictors">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Submodule Documentation">
  <meta name="twitter:description" content="This section of the documentation will provide a detailed introduction to each module of the Xiangshan Branch Prediction Unit, including the BPU top-level and five sub-predictors.">
<link rel="preload" href="/xs-bpu/scss/main.min.48c25d0a5a23a1e8cae94d6c5e7622061e5345cf098171b1d6ee41d8e309e6c8.css" as="style" integrity="sha256-SMJdClojoejK6U1sXnYiBh5TRc8JgXGx1u5B2OMJ5sg=" crossorigin="anonymous">
<link href="/xs-bpu/scss/main.min.48c25d0a5a23a1e8cae94d6c5e7622061e5345cf098171b1d6ee41d8e309e6c8.css" rel="stylesheet" integrity="sha256-SMJdClojoejK6U1sXnYiBh5TRc8JgXGx1u5B2OMJ5sg=" crossorigin="anonymous">
<script
  src="https://code.jquery.com/jquery-3.7.1.min.js"
  integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g=="
  crossorigin="anonymous"></script>
<script defer
  src="https://unpkg.com/lunr@2.3.9/lunr.min.js"
  integrity="sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli"
  crossorigin="anonymous"></script>

    <script>
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?6aacb1c7ca0a3ef4e3aa84c1eaa237dd";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
    </script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z2ZY6ZE84"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-4Z2ZY6ZE84');
    </script>


  </head>
  <body class="td-section">
    <header>
      <nav class="td-navbar js-navbar-scroll" data-bs-theme="dark">
<div class="container-fluid flex-column flex-md-row">
  <a class="navbar-brand" href="/xs-bpu/en/"><span class="navbar-brand__logo navbar-logo"><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" style="enable-background:new 0 0 500 500"><g><path style="fill:#fff" d="M116.8525 421.9722c-5.7041.0-10.3442-4.3127-10.3442-9.6129V88.183c0-5.3002 4.6401-9.6117 10.3442-9.6117H320.858c3.0347.0 9.3959.5498 11.7506 2.6302l.3545.3442 58.905 63.2912c2.3101 2.491 2.9202 8.4928 2.9202 11.3184v256.2039c0 5.3002-4.6407 9.6129-10.3436 9.6129H116.8525z"/><g><g><g><path style="fill:#767676" d="M384.4445 423.2066H116.852c-6.3839.0-11.5786-4.8658-11.5786-10.8474V88.1831c0-5.9804 5.1947-10.8461 11.5786-10.8461h204.0062c.377.0 9.2786.0329 12.568 2.9389l.3947.3833 58.9508 63.337c3.2135 3.4652 3.2514 11.7924 3.2514 12.1593v256.2036C396.0231 418.3408 390.8284 423.2066 384.4445 423.2066zM116.5079 411.9189c.0848.0278.1999.0531.3441.0531h267.5925c.1442.0.2581-.0253.3441-.0531V156.1556c-.0076-.9033-.3593-3.7347-.7034-5.0037l-57.6527-61.9416c-1.4651-.3176-4.4533-.6389-5.5742-.6389H116.852c-.143.0-.2594.024-.3441.0531V411.9189zm267.4533-261.149zM327.0321 89.371v.0013V89.371z"/></g></g></g><g><g><path style="fill:#5b7fc0" d="M189.0874 210.1754l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4473C177.5953 212.627 183.0601 210.1742 189.0874 210.1754zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 234.1722 197.0804 232.033z"/><path style="opacity:.3;fill:#fff" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/><g><defs><path id="SVGID_1_" d="M194.7376 237.6875c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 234.2399 196.1861 236.239 194.7376 237.6875z"/></defs><clipPath id="SVGID_2_"><use xlink:href="#SVGID_1_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_2_);fill:#fff" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/><path style="opacity:.13;clip-path:url(#SVGID_2_);fill:#020202" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/></g><g><defs><path id="SVGID_3_" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/></defs><clipPath id="SVGID_4_"><use xlink:href="#SVGID_3_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_4_);fill:#5b7fc0" d="M172.6595 215.6045c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8475-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 209.1953 176.6171 211.647 172.6595 215.6045z"/></g></g><rect x="198.8952" y="225.1043" style="fill:#5b7fc0" width="122.6266" height="13.8671"/></g><g><path style="fill:#d95140" d="M189.0874 155.7611l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.0249 2.454-11.4897 6.4116-15.4473C177.5953 158.2128 183.0601 155.7599 189.0874 155.7611zm7.993 21.8577c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.2508 181.7667 197.0816 179.758 197.0804 177.6188z"/><path style="opacity:.3;fill:#fff" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/><g><defs><path id="SVGID_5_" d="M194.7376 183.2733c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 179.8256 196.1861 181.8248 194.7376 183.2733z"/></defs><clipPath id="SVGID_6_"><use xlink:href="#SVGID_5_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_6_);fill:#fff" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/><path style="opacity:.13;clip-path:url(#SVGID_6_);fill:#020202" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/></g><g><defs><path id="SVGID_7_" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/></defs><clipPath id="SVGID_8_"><use xlink:href="#SVGID_7_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_8_);fill:#d95140" d="M172.6595 161.1903c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 154.7811 176.6171 157.2327 172.6595 161.1903z"/></g><rect x="198.8952" y="170.69" style="fill:#d95140" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#56a55c" d="M189.5379 264.6147l.0012-.0012c7.7751.0012 15.0294 4.1862 18.932 10.9235 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032-5.8394.0-11.3281-2.2733-15.458-6.4032-4.13-4.13-6.4032-9.6186-6.4056-15.4628.0012-6.0249 2.454-11.4897 6.4116-15.4472C178.0458 267.0663 183.5105 264.6135 189.5379 264.6147zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6538 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.7013 290.6202 197.5321 288.6115 197.5309 286.4723z"/><path style="opacity:.3;fill:#fff" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/><g><defs><path id="SVGID_9_" d="M195.1881 292.1268c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9941 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.5344 288.6792 196.6366 290.6783 195.1881 292.1268z"/></defs><clipPath id="SVGID_10_"><use xlink:href="#SVGID_9_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_10_);fill:#fff" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/><path style="opacity:.13;clip-path:url(#SVGID_10_);fill:#020202" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/></g><g><defs><path id="SVGID_11_" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/></defs><clipPath id="SVGID_12_"><use xlink:href="#SVGID_11_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_12_);fill:#56a55c" d="M173.11 270.0439c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7325-11.1497-10.9151-18.926-10.9151C182.5311 263.6346 177.0676 266.0863 173.11 270.0439z"/></g></g><rect x="199.3456" y="279.5436" style="fill:#56a55c" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#f1bc42" d="M189.0874 318.7208l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3305-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4472C177.5953 321.1724 183.0601 318.7196 189.0874 318.7208zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 342.7176 197.0804 340.5784z"/><path style="opacity:.3;fill:#fff" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/><g><defs><path id="SVGID_13_" d="M194.7376 346.2329c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 342.7853 196.1861 344.7844 194.7376 346.2329z"/></defs><clipPath id="SVGID_14_"><use xlink:href="#SVGID_13_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_14_);fill:#fff" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/><path style="opacity:.13;clip-path:url(#SVGID_14_);fill:#020202" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/></g><g><defs><path id="SVGID_15_" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/></defs><clipPath id="SVGID_16_"><use xlink:href="#SVGID_15_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_16_);fill:#f1bc42" d="M172.6595 324.15c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8474-1.0151-7.6327-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 317.7407 176.6171 320.1924 172.6595 324.15z"/></g></g><rect x="198.8952" y="333.6497" style="fill:#f1bc42" width="122.6266" height="13.8671"/></g></g></svg></span><span class="navbar-brand__name">OpenVerify Courses</span></a>
  <div class="td-navbar-nav-scroll ms-md-auto" id="main_navbar">
    <ul class="navbar-nav">
      <li class="nav-item dropdown d-none d-lg-block">
        <div class="dropdown">
  <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">English</a>
  <ul class="dropdown-menu">
    <li><a class="dropdown-item" href="/xs-bpu/docs/modules/">中文</a></li>
    </ul>
</div></li>
      </ul>
  </div>
  <div class="d-none d-lg-block">
    <div class="td-search td-search--offline">
  <div class="td-search__icon"></div>
  <input
    type="search"
    class="td-search__input form-control"
    placeholder="Search this site…"
    aria-label="Search this site…"
    autocomplete="off"
    
    data-offline-search-index-json-src="/xs-bpu/offline-search-index.cae33942e63f62947f4246798e40a87d.json"
    data-offline-search-base-href="/"
    data-offline-search-max-results="10"
  >
</div>
  </div>
</div>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 ps-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
This is the multi-page printable view of this section.
<a href="#" onclick="print();return false;">Click here to print</a>.
</p><p>
<a href="/xs-bpu/en/docs/modules/">Return to the regular view of this page</a>.
</p>
</div>



<h1 class="title">Submodule Documentation</h1>
<div class="lead">This section of the documentation will provide a detailed introduction to each module of the Xiangshan Branch Prediction Unit, including the BPU top-level and five sub-predictors.</div>




    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-d9a3cc14150e992a3c357adaaac1c94d">BPU Top Module</a></li>


    
  
    
    
	
<li>2: <a href="#pg-e6d1611b25352acdff178100e9b3296d">uFTB Branch Predictor</a></li>


    
  
    
    
	
<li>3: <a href="#pg-acd2cf0c1c9c53099412da29a7437546">TAGE-SC Branch Predictor</a></li>


    
  
    
    
	
<li>4: <a href="#pg-6632ee4bf977f3fe507ff8cc02deba52">FTB Branch Predictor</a></li>


    
  
    
    
	
<li>5: <a href="#pg-dfa5c2dea93e89d4c1a93d678a387d97">ITTAGE Branch Predictor</a></li>


    
  
    
    
	
<li>6: <a href="#pg-8ab5cccc33deee27c69e7976949364c2">RAS Branch Predictor</a></li>


    
  

    </ul>


<div class="content">
      <p>This section of the documentation will provide a detailed introduction to each module of the Xiangshan Branch Prediction Unit, including the BPU top-level and five sub-predictors.</p>
<p>In each module&rsquo;s documentation, we will provide a detailed explanation of the module&rsquo;s role in the Xiangshan Branch Prediction Unit, as well as the module&rsquo;s algorithm principles, structure, and timing.</p>
<p>Students responsible for verifying a specific module should read the corresponding documentation thoroughly and understand it in conjunction with the code. Other documents can also be read to help you understand the overall functionality of the Xiangshan Branch Prediction Unit. During the understanding process, you may need to constantly review the basic design concepts and interface signals described in previous documents.</p>

</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d9a3cc14150e992a3c357adaaac1c94d">1 - BPU Top Module</h1>
    
	<p>The overall function and structure of the BPU top level have been roughly described in previous documents. For those verifying the BPU top level, a more detailed description might be needed. Due to the many functions of the BPU top level, this section divides the BPU into several major functional points for further description. However, since there are too many details at the BPU top level, further details need to be understood by referring to the code.</p>
<h2 id="generator-maintenance-method">Generator Maintenance Method</h2>
<p>From the basic design documents of Xiangshan, we know that the BPU top level maintains various variables in the s0 cycle through generators, such as PC, branch history, etc. The core concept is to decide which pipeline level&rsquo;s result to adopt through the redirection signal of the prediction result.</p>
<p>There are a total of 6 generators in the BPU top level:</p>
<ul>
<li><strong>npcGen</strong> maintains the PC</li>
<li><strong>ghistPtrGen</strong> maintains the global history pointer</li>
<li><strong>ghvBitWriteGens</strong> maintains global history write data</li>
<li><strong>foledGhGen</strong> maintains the folded history</li>
<li><strong>lastBrNumOHGen</strong> maintains the position of the last effective branch instruction in the previous cycle</li>
<li><strong>aheadFhObGen</strong> maintains the oldest position of the branch history</li>
</ul>
<p>Except for <code>npcGen</code>, the rest of the generators will be introduced in this document. In this section, we will focus on the method of generating the next prediction for the generators.</p>
<p>In the code, you can see generators defined in a similar way:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Scala" data-lang="Scala"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">npcGen</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">PhyPriorityMuxGenerator</span><span style="color:#ce5c00;font-weight:bold">[</span><span style="color:#204a87;font-weight:bold">UInt</span><span style="color:#ce5c00;font-weight:bold">]</span>
</span></span></code></pre></div><p>Next, the code registers the data sources for the generators through multiple statements:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Scala" data-lang="Scala"><span style="display:flex;"><span><span style="color:#000">npcGen</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">register</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">true</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">B</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">reg</span><span style="color:#a40000">，</span> <span style="color:#ce5c00;font-weight:bold">...)</span>
</span></span><span style="display:flex;"><span><span style="color:#000">npcGen</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">register</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">s1_valid</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">s1_target</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#ce5c00;font-weight:bold">...)</span>
</span></span><span style="display:flex;"><span><span style="color:#000">npcGen</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">register</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">s2_redirect</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">s2_target</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#ce5c00;font-weight:bold">...)</span>
</span></span><span style="display:flex;"><span><span style="color:#000">npcGen</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">register</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">s3_redirect</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">s3_target</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#ce5c00;font-weight:bold">...)</span>
</span></span><span style="display:flex;"><span><span style="color:#000">npcGen</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">register</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">do_redirect</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">valid</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">do_redirect</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">bits</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">cfiUpdate</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">target</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#ce5c00;font-weight:bold">...)</span>
</span></span></code></pre></div><p>Each line is called a registration. In a registration, the first signal parameter is the data valid signal, and the second signal parameter contains the specific data. The priority of the generator is also determined in the order of registration; the later the registration, the higher the priority. Therefore, the priority at the same time, from low to high, is as follows:</p>
<ul>
<li>s0 blocked data</li>
<li>Data updated based on s1 prediction results</li>
<li>Data updated based on s2 prediction results</li>
<li>Data updated based on s3 prediction results</li>
<li>Data in external redirection of BPU</li>
</ul>
<p>In this way, when the redirection of the prediction result is valid, we can avoid using the earlier pipeline level&rsquo;s prediction result and adopt the corrected prediction result. This allows us to handle external redirection requests with the highest priority.</p>
<p>We can conclude the method by which all generators generate s0 signals: <strong>Among all data valid signals, if only one is valid, the corresponding data is selected; if multiple data valid signals are valid, the data with the highest priority is selected</strong>.</p>
<h2 id="global-branch-history">Global Branch History</h2>
<p>We know that the global branch history is maintained at the BPU top level, and the maintenance strategy is consistent with the PC maintenance strategy. That is, after the prediction result is generated at each stage of the pipeline, the global branch history is updated based on the corresponding signals.</p>
<p>The top level defines two sets of signals to maintain the global branch history:</p>
<ul>
<li><strong>ghv</strong> stores the global branch history (maximum length 256)</li>
<li><strong>ghist_ptr</strong> global branch history pointer, pointing to the current position of the global branch history</li>
</ul>
<p>Similar to <code>s0_pc</code>, <code>s1_pc</code>, <code>s2_pc</code>, the BPU top level also maintains signals for each stage of the global history pointer: <code>s0_ghist_ptr</code>, <code>s1_ghist_ptr</code>, <code>s2_ghist_ptr</code>. However, the content in <code>ghv</code> is fixed in position, and we only use <code>ghist_ptr</code> to locate where the current global branch history starts.</p>
<h3 id="calculating-the-current-global-branch-history-with-ghist_ptr">Calculating the Current Global Branch History with ghist_ptr</h3>
<p>The use of <code>ghist_ptr</code> is only visible at the BPU top level. What we pass to the sub-predictors is the global branch history after the data in the global history register is shifted based on <code>ghist_ptr</code>. In the global branch history obtained by the sub-predictor, the least significant bit corresponds to the newest bit of the global branch history, and the most significant bit corresponds to the oldest bit.</p>
<p>So how is the shifting done? First, let&rsquo;s see how the global history is stored in <code>ghv</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Plain" data-lang="Plain"><span style="display:flex;"><span>|===== ghist =====&gt;| =======&gt;|
</span></span><span style="display:flex;"><span>n                  ^         0
</span></span><span style="display:flex;"><span>                   ghist_ptr
</span></span></code></pre></div><p>As shown in the figure above, the sequence represents the entire <code>ghv</code> register, and <code>ghist_ptr</code> points to a position in <code>ghv</code>. This position represents the newest bit of the global branch history. When a new global history record needs to be added, <code>ghist_ptr</code> is first decremented by 1, and then this bit is written to the position it points to. When <code>ghist_ptr</code> is decremented to 0, it will loop back to point to the highest position, thereby overwriting the previously written global branch history.</p>
<p>No matter what, starting from the position pointed to by <code>ghist_ptr</code>, the pointer increases and the history gets older. Therefore, when we need to calculate the current global branch history, we only need to circularly right-shift the <code>ghv</code> register by <code>ghist_ptr positions</code>.</p>
<h3 id="updating-global-branch-history">Updating Global Branch History</h3>
<p>The strategy for updating the global branch history is consistent with the strategy for updating the <code>pc</code>. At each pipeline stage, a <strong>pointer for the current stage and an update description of <code>ghv</code></strong> are generated based on the prediction result of the current stage, and all are sent to the relevant generator for processing.</p>
<p>The update strategy for the global branch history is consistent with the <code>pc</code> update strategy, requiring the generation of a <strong>current stage pointer and <code>ghv</code> update instructions</strong> based on the current stage&rsquo;s prediction results at each pipeline stage. These instructions are ultimately sent to the relevant generators for processing.</p>
<p>The update description of <code>ghv</code> is some information used to guide the update of the <code>ghv</code> register. Xiangshan BPU maintains two pieces of information to fulfill this duty:</p>
<ul>
<li><code>ghv_wdata</code> the data that needs to be written into ghv</li>
<li><code>ghv_wens</code> the write bit mask</li>
</ul>
<p>For the final update, only the bits identified by <code>ghv_wens</code> need to be written with the corresponding bits of <code>ghv_wdata</code>.</p>
<p><strong>Therefore, each pipeline stage needs to generate three sets of information: <code>ghist_ptr</code>, <code>ghv_wdata</code>, <code>ghv_wens</code></strong>.</p>
<p>Specifically, the prediction result can contain up to two branch instructions. We only need to set these pieces of information according to the actual situation. Here are some examples:</p>
<ul>
<li>Only the first slot is valid, and the conditional branch instruction in it is predicted as not taken. Then the next position of <code>ghv_wens</code> is set to 0, the corresponding position of <code>ghv_wens</code> is set to 1, and <code>ghist_ptr</code> is decremented by one.</li>
<li>Both slots contain conditional branch instructions, the first is predicted as not taken, and the second is predicted as taken. At this time, <code>ghist_ptr</code> should be decremented by two, and the other two pieces of information should indicate writing 01 to <code>ghv</code>.</li>
</ul>
<p>Here, only one piece of <code>ghv_wdata</code> information is maintained in the generator (maintained by the <code>ghvBitWriteGens</code> generator), and <code>ghv_wens</code> is not maintained by the generator. This is because a small trick is used here, where the final output of the generator&rsquo;s <code>ghv_wdata</code> is the result of the selected stage, and <code>ghv_wens</code> is used by performing a bitwise OR operation on <code>ghv_wens</code> of all stages.</p>
<p>This consideration is based on:</p>
<ul>
<li>If the later pipeline stage is valid, the global history pointer is restored to an older position, even if the history of newer positions is modified by the earlier pipeline&rsquo;s <code>ghv_wens</code>.</li>
<li>If the earlier pipeline stage is valid, the global history pointer continues to update to newer positions, and the later pipeline will not set <code>ghv_wens</code> due to the ineffective redirect.</li>
</ul>
<h2 id="branch-folded-history">Branch Folded History</h2>
<p>The branch folded history passed to the predictor is also maintained by the BPU top level. To shorten the update delay of the folded history, the BPU maintains many variables to support the fast update of the branch folded history. We will focus on this strategy and introduce the function of each variable.</p>
<p>Before we start, let&rsquo;s first look at how the branch folded history is defined and its structure.</p>
<h3 id="branch-folded-history-1">Branch Folded History</h3>
<p>If you have checked the BPU global interface documentation, you will know that the sub-predictor receives an array of bit vectors of different lengths, representing various lengths of folded history, and these folded histories are compressed from the global branch history.</p>
<p>For the global branch history, we have a register that stores the global branch history with a length of 256. For example, suppose the length of the global branch history is 15 bits, and after shifting, we get a branch history like this: the least significant bit is the newest history record, and the most significant bit is the oldest history record.</p>
<p>At this time, if we need to generate a 6-bit folded history from these 15 bits, we will use an XOR strategy for compression. The specific process is as follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Plain" data-lang="Plain"><span style="display:flex;"><span>    h[5]         h[4]       h[3]    h[2]   h[1]   h[0]
</span></span><span style="display:flex;"><span>    h[11]        h[10]      h[9]    h[8]   h[7]   h[6]
</span></span><span style="display:flex;"><span>^                                   h[14]  h[13]  h[12]
</span></span><span style="display:flex;"><span>---------------------------------------------------------------
</span></span><span style="display:flex;"><span>    h[5]^h[11]   h[4]^h[10]         ...           h[0]^h[6]^h[12]
</span></span></code></pre></div><p>That is, after arranging it as shown above, perform an XOR operation on the values at each position, and the result is the folded history of length 6.</p>
<h3 id="method-for-updating-branch-folded-history">Method for Updating Branch Folded History</h3>
<p>Now we want to update this branch folded history. When we insert a new history into the global branch history, it is inserted from the least significant bit, meaning the original h[0] becomes h[1]. If we want to obtain the folded history at this time, we only need to perform the XOR operation again. But such efficiency is too low, because the XOR operation may become particularly long. We can explore the impact of one update on the branch folded history.</p>
<p>In the example above, before inserting a new history, the 6-bit folded history is generated in the following arrangement:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Plain" data-lang="Plain"><span style="display:flex;"><span>h[5]   h[4]   h[3]  h[2]  h[1]  h[0]
</span></span><span style="display:flex;"><span>h[11]  h[10]  h[9]  h[8]  h[7]  h[6]
</span></span><span style="display:flex;"><span>                    h[14] h[13] h[12]
</span></span></code></pre></div><p>After inserting a new history, it becomes like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Plain" data-lang="Plain"><span style="display:flex;"><span>h[4]   h[3]   h[2]  h[1]  h[0]  h[new]
</span></span><span style="display:flex;"><span>h[10]  h[9]   h[8]  h[7]  h[6]  h[5]
</span></span><span style="display:flex;"><span>           (h[14])  h[13] h[12] h[11]
</span></span></code></pre></div><p>We can notice some patterns:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Plain" data-lang="Plain"><span style="display:flex;"><span>Before insertion:
</span></span><span style="display:flex;"><span>h[5]   {h[4]   h[3]  h[2]  h[1]  h[0] }
</span></span><span style="display:flex;"><span>h[11]  {h[10]  h[9]  h[8]  h[7]  h[6] }
</span></span><span style="display:flex;"><span>       {             h[14] h[13] h[12]}
</span></span><span style="display:flex;"><span>After insertion:
</span></span><span style="display:flex;"><span>{h[4]   h[3]   h[2]  h[1]  h[0] } h[new]
</span></span><span style="display:flex;"><span>{h[10]  h[9]   h[8]  h[7]  h[6] } h[5]
</span></span><span style="display:flex;"><span>{           (h[14])  h[13] h[12]} h[11]
</span></span></code></pre></div><p>The content in the curly braces has undergone a complete left shift, with h[5] and h[11] moving from the most significant bit to the least significant bit. So, in the compressed history, isn&rsquo;t this just a typical cyclic left shift that we often encounter!</p>
<p>However, only two bits have changed: one is the newly inserted h[new], and the other is the discarded h[14]. h[new] must be in the first position, and the discarded position is fixed. <strong>Therefore, to complete an update, we only need to know the value of the newly inserted history and the oldest bit of the previous history</strong>. After the cyclic shift, modifying these two positions according to the actual situation will give us the updated folded history.</p>
<h3 id="implementation-of-update-method">Implementation of Update Method</h3>
<p>To achieve this update in the top-level BPU, two additional variables are maintained:</p>
<ul>
<li><strong>ahead_fh_oldest_bits</strong>: the oldest bit of the global branch history, with additional bits stored before it</li>
<li><strong>last_br_num_oh</strong>: the slot number of the last effective branch instruction in the previous prediction</li>
</ul>
<p>An optimization in the timing of operations occurs here because the global history pointer can only be updated based on the branch outcome when the pipeline-level prediction result is available. Updating the oldest bit after updating the global history pointer would increase the latency. Therefore, we maintain the branch outcome and update the oldest bit when it is needed in the next cycle.</p>
<p>The oldest bit also needs to be maintained further back because after updating using the branch outcome, the relatively newer bits will become the oldest bits.</p>
<p>Thus, there are three generators related to the folded history: <code>foldedGhGen</code>, <code>lastBrNumOhGen</code>, and <code>aheadFhObGen</code>.</p>
<p><strong>Information required for each update of the folded history</strong>：</p>
<ul>
<li>Folded history information before the update</li>
<li>Oldest bit of the global branch history (ahead_fh_oldest_bits)</li>
<li>Last prediction&rsquo;s branch outcome (last_br_num_oh)</li>
<li>Whether there is a branch instruction in this update</li>
<li>The branch outcome of this update: the slot number of the last effective branch instruction</li>
</ul>
<p>For each update of the folded history, the true oldest bit needs to be determined based on <code>last_br_num_oh</code> and <code>ahead_fh_oldest_bits</code>. Then, based on the oldest bit and the branch outcome of this update, several bits are modified, and finally, a cyclic left shift completes the update operation.</p>
<h2 id="pipeline-control-method">Pipeline Control Method</h2>
<p>Pipeline control is the core function of the BPU, with complex logic. All pipeline control signals in the top-level BPU are as follows:</p>
<ul>
<li><strong>s1_valid, s2_valid, s3_valid</strong>: indicate the corresponding pipeline data is valid</li>
<li><strong>s1_ready, s2_ready, s3_ready</strong>: indicate the corresponding pipeline is ready to continue the prediction of the previous pipeline stage</li>
<li><strong>s1_component_ready, s2_component_ready, s3_component_ready</strong>: indicate the readiness of the corresponding pipeline sub-predictor</li>
<li><strong>s0_fire, s1_fire, s2_fire, s3_fire</strong>: successful handshake signals, indicating that the pipeline data is valid and has been successfully passed to the next pipeline</li>
<li><strong>s1_flush, s2_flush, s3_flush</strong>: indicate whether the current pipeline needs flushing</li>
<li><strong>s2_redirect, s3_redirect</strong>: indicate whether the current pipeline needs to redirect due to a different prediction result</li>
</ul>
<h3 id="valid-ready-与-fire">valid, ready 与 fire</h3>
<p>We will introduce the purpose of each signal step by step. First, let&rsquo;s look at the <code>fire</code> signal, which indicates a successful handshake in the pipeline, meaning that the data has been successfully passed to the next pipeline. This signifies the end of the current cycle and the end of the prediction for this pipeline stage, with the prediction for the next pipeline stage about to begin in the next cycle.</p>
<p>This requires two conditions:</p>
<ol>
<li><code>valid</code>: The data in the current pipeline stage is valid.</li>
<li><code>ready</code>: Indicates whether the next pipeline stage in the BPU top level and the predictor are ready.</li>
</ol>
<p>When these two signals are high simultaneously, the <code>fire</code> signal is valid, indicating a successful handshake. If we isolate a single prediction, the timing should look like this (in reality, most of the time, each pipeline is valid continuously):</p>

<figure>
    <img src="1.png" width="400px"/> 
</figure>

<p>Of the four sets of signals mentioned earlier, <code>component_ready</code> is generated by the predictor, while the rest are maintained by the BPU top level, with only the fire set of signals exposed to the sub-predictor.</p>
<p>Next, let&rsquo;s take s2 as an example to see how each signal is maintained.</p>
<p><strong>ready</strong> <strong>Signal</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Scala" data-lang="Scala"><span style="display:flex;"><span><span style="color:#000">s2_ready</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">s2_fire</span> <span style="color:#ce5c00;font-weight:bold">||</span> <span style="color:#ce5c00;font-weight:bold">!</span><span style="color:#000">s2_valid</span>
</span></span></code></pre></div><p>This assignment statement is a combinational circuit assignment, meaning that <code>s2_ready</code> is directly related to <code>s2_fire</code> and <code>s2_valid</code> for this cycle, with two possible situations:</p>
<ul>
<li>If <code>s2_valid</code> is invalid for this cycle, indicating that the s2 pipeline stage is empty and can accept new data, then <code>s2_ready</code> is valid.</li>
<li>If <code>s2_valid</code> is valid for this cycle, indicating that the s2 pipeline stage has data that has not been passed to the next stage yet, but if <code>s2_fire</code>, then the data will be passed in the next cycle. In this case, <code>s2_ready</code> is valid, indicating that the data can flow into the next stage.</li>
</ul>
<p><strong>valid Signal</strong></p>
<p>Maintaining ·s2_valid· is relatively simple, as it is only related to <code>s1_fire</code> and <code>s2_ready</code> signals. The relationship is as follows:</p>
<ul>
<li>When <code>s1_fire</code> is valid, indicating that data is coming in and <code>s2_valid</code> will be valid in the next cycle.</li>
<li>When <code>s2_fire</code> is valid, indicating that data is flowing out and <code>s2_valid</code> will be invalid in the next cycle.</li>
</ul>
<p><strong>fire Signal</strong></p>
<p>The fire signal is somewhat special, but for intermediate pipeline stages, its maintenance is straightforward. For example,</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Scala" data-lang="Scala"><span style="display:flex;"><span><span style="color:#000">s2_fire</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">s2_valid</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000">s3_components_ready</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000">s3_ready</span>
</span></span></code></pre></div><p>This simply requires considering the <code>valid</code> of the current pipeline stage and the <code>ready</code> of the next pipeline stage.</p>
<p>However, for s0_fire, since there is no valid signal, it is directly set to <code>s1_components_ready &amp;&amp; s1_ready</code>.</p>
<p>For s3_fire, as there is no ready signal for the next stage, it is directly set to <code>s3_valid</code>.</p>
<h3 id="incorporating-flush-and-redirect">Incorporating Flush and Redirect</h3>
<p>When there is a different prediction result in the pipeline, a redirection signal is generated, and the pipeline needs to be flushed. <code>flush</code> and <code>redirect</code> handle these two tasks. <code>redirect</code> indicates whether the current pipeline stage needs redirection, while <code>flush</code> indicates whether the current pipeline stage needs flushing.</p>
<p><strong>redirect Signal</strong></p>
<p>The generation of <code>s2_redirect</code> is as follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Scala" data-lang="Scala"><span style="display:flex;"><span><span style="color:#000">s2_redirect</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">s2_fire</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000">s2_redirect_s1_last_pred</span>
</span></span></code></pre></div><p>This means that when <code>s2_fire</code> is valid and the prediction result of s2 is different from the prediction result saved from s1, this signal is valid. Later, this signal will be connected to the input of the sub-predictor and the output of the BPU prediction result, guiding the sub-predictor and FTQ to restore their states.</p>
<p><strong>flush Signal</strong></p>
<p>The flush signal is used to guide the flushing of the pipeline. For example, when s3_redirect is valid, it means that the incorrect prediction result has entered the pipeline, and both s1 and s2 are now predicting based on the wrong result. Therefore, the pipeline needs to be flushed to stop the previous stages and wait for new prediction results to enter.</p>
<p>Specifically, the relationship between them is:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Scala" data-lang="Scala"><span style="display:flex;"><span> <span style="color:#000">s2_flush</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">s3_flush</span> <span style="color:#ce5c00;font-weight:bold">||</span> <span style="color:#000">s3_redirect</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">s1_flush</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">s2_flush</span> <span style="color:#ce5c00;font-weight:bold">||</span> <span style="color:#000">s2_redirect</span>
</span></span></code></pre></div><p>This means that if a pipeline stage needs redirection, all previous stages will be flushed. The purpose of flush is to guide the valid signal. If the valid signal is valid in this cycle but the fire signal is not, it means that the incorrect data has not been taken by the next pipeline stage. In this case, when flush is valid, valid will immediately become invalid in the next cycle, avoiding storing incorrect data in the pipeline for a long time.</p>
<p>However, the effect of flush on the valid signal varies depending on each pipeline stage. For example:</p>
<ul>
<li>For the s1 pipeline stage, although flush is valid, if <code>s0_fire</code> is valid, indicating that new data is flowing in, valid will remain valid in the next cycle.</li>
<li>For the s2 pipeline stage, if flush is valid, valid will definitely be invalid in the next cycle (because s1 is also flushed), indicating that valid can be directly set to invalid. However, there is a special case where <code>s2_redirect</code> occurs but <code>s2_flush</code> is not set to valid. In this case, if <code>s1_fire</code> occurs, the incorrect prediction result of s1 may also flow in. In this case, <code>s2_valid</code> needs to be determined based on the <code>s1_flush</code> signal.</li>
</ul>
<p>The use of flush is complex, and more detailed details need to be understood by referring to the code.</p>
<h2 id="redirect-recovery-logic">Redirect Recovery Logic</h2>
<p>When the redirect request from FTQ to BPU takes effect, it indicates that all stages of the pipeline have incorrect predictions, and all stages should be flushed. This can be achieved by setting <code>s3_flush</code> to be valid. Therefore, we have:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Scala" data-lang="Scala"><span style="display:flex;"><span> <span style="color:#000">s3_flush</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">redirect_req</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">valid</span>
</span></span></code></pre></div><p>In the BPU, the redirect request is delayed by one cycle before being officially used. Therefore, the response of <code>s1_valid</code> to the <code>flush</code> signal needs to be changed. When the redirect request (before delay) is valid, <code>s1_valid</code> in the next cycle is immediately set to invalid, without the need to refer to the <code>s0_fire</code> signal.</p>
<p>At this point, generators such as <code>npcGen</code> also need to directly use the data from the redirect request to generate, which is equivalent to redirecting the BPU&rsquo;s state to the state before the error occurred. However, it is important to note that the default redirect level in BPU is <code>flushAfter</code>, which means that the redirect request corresponds to a predicted erroneous instruction, and the BPU assumes that although this instruction was predicted incorrectly, it has been corrected and executed by the backend. Therefore, the next prediction can start directly from the next instruction.</p>
<p>Therefore, when recovering from a redirect, it is necessary not only to restore the information from the redirect interface, but also to update the execution status of this predicted erroneous instruction in the history.</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e6d1611b25352acdff178100e9b3296d">2 - uFTB Branch Predictor</h1>
    
	<h2 id="introduction-to-uftb">Introduction to uFTB</h2>
<p>uFTB is the first predictor among all the predictors in Xiangshan, and it serves as the cornerstone for other predictors to generate prediction results. uFTB works in the s1 stage. It can generate prediction results within the current cycle after obtaining s1_pc and output them in the s1 channel, without modifying other channels. It provides the position of the branch instruction and the target of the instruction. Subsequent predictors will further predict based on this result.</p>
<p>Its essence is an FTB item cache, which stores FTB items, and the basic prediction result will be directly generated from the read-out FTB item.</p>
<p>Therefore, before you start reading the document, make sure you understand the FTB items and their meanings, as well as the specific details of the prediction result interface.</p>
<h2 id="functionality-of-uftb">Functionality of uFTB</h2>
<ul>
<li><strong>Cache FTB items and generate one-cycle prediction results</strong>: uFTB maintains a small FTB item cache. After receiving PC, it reads out the FTB item corresponding to the PC within one cycle and generates an s1 stage prediction result from the FTB item.</li>
<li><strong>Maintain two-bit saturating counters to provide basic conditional branch results</strong>: uFTB maintains two-bit saturating counters for each line of the FTB item cache. The direction prediction result is reflected in the prediction result output of uFTB.</li>
<li><strong>Update the FTB cache and two-bit saturating counters based on update requests</strong></li>
</ul>
<h2 id="uftb-cache-structure">uFTB Cache Structure</h2>
<p>As mentioned above, uFTB is essentially a small cache that stores FTB items. Its approximate structure is shown in the figure below.</p>

<figure>
    <img src="1.png" width="400px"/> 
</figure>

<p>In the current version of Xiangshan, uFTB has a total of 32 cache lines, each cache line is called <code>FauFTBWay</code>, and one FTB item can be stored in each cache line.</p>
<p><strong>When s1 pipeline is valid</strong>, uFTB will use <code>s1_pc</code> to determine which item of the uFTB cache to read out. The cache is indexed based on the tag field in PC, which is defined as pc[16:1], i.e., taking 16 bits from PC as an identifier to match a certain line in the cache.</p>
<p>Each line in the cache, i.e., the data request interface in <code>FauFTBWay</code>, has three items:</p>
<ul>
<li><strong>req_tag</strong>: Input tag identifier extracted from pc</li>
<li><strong>resp</strong>: Output the FTB item stored in this line</li>
<li><strong>resp_hit</strong>: Output indicates whether the FTB item in this line matches req_tag
uFTB connects the tag to the data request interface of each line in the cache and selects the hit FTB item based on the <code>resp_hit</code> signal. Subsequent steps will generate a complete prediction result based on this FTB item.</li>
</ul>
<h2 id="two-bit-saturating-counters">Two-Bit Saturating Counters</h2>
<p>uFTB maintains two-bit saturating counters for each line of the FTB item cache. As we know, an FTB item can store up to two conditional branch instructions, so each line&rsquo;s two-bit saturating counters also have two, responsible for providing rough prediction results for the conditional branch instructions in them.</p>
<p>When indexing the FTB item, uFTB also indexes the corresponding two-bit saturating counters.</p>
<p>When the prediction result is generated, it will be based on the FTB item and the contents of the two two-bit saturating counters corresponding to it.</p>
<h2 id="prediction-result-generation">Prediction Result Generation</h2>
<p>After indexing the corresponding FTB item and two two-bit saturating counters based on s1_pc, uFTB needs to generate a prediction result based on them. The prediction result generated by uFTB will be outputted through the s1 channel when s1 pipeline is valid, and will not be modified for s2 and s3 channels.</p>
<p><strong>The signal generation method in the s1 prediction result can refer to the following list:</strong></p>
<ul>
<li><strong>hit</strong>Whether the FTB item hits
<ul>
<li>Generation method: <code>resp_hit</code> signal in <code>FauFTBWay</code>, one of them is valid</li>
</ul>
</li>
<li><strong>slot_valids</strong>: Slot valid bit, indicating whether each slot in the ftb item is valid</li>
<li><strong>targets</strong>: Jump target address corresponding to each slot</li>
<li><strong>offsets</strong>: The offset of each instruction in the slot relative to the starting address of the prediction block</li>
<li><strong>is_jal</strong>: Whether the prediction block contains a jal instruction</li>
<li><strong>is_jalr</strong>: Whether the prediction block contains a jalr instruction</li>
<li><strong>is_call</strong>: Whether the prediction block contains a call instruction</li>
<li><strong>is_ret</strong>: Whether the prediction block contains a ret instruction</li>
<li><strong>last_may_be_rvi_call</strong>: Signal indicating that the last slot in the prediction block may be an RVI type call instruction</li>
<li><strong>is_br_sharing</strong>: The signal stored in the last slot (tailSlot) indicates a conditional branch instruction.
<ul>
<li>Generation: Exported from the corresponding field in the FTB entry.</li>
</ul>
</li>
<li><strong>fallThroughErr</strong>: The <code>pftAddr</code> recorded in the FTB entry is incorrect.
<ul>
<li>Generation: Compare whether the end address represented by <code>pftAddr</code> is greater than the start address of the predicted block. If it is smaller, an error has occurred, and this signal is set to valid. This situation may occur when the PC indexes an incorrect FTB entry.</li>
</ul>
</li>
<li><strong>fallThroughAddr</strong>: The end address of the predicted block.
<ul>
<li>Generation: If <code>fallThroughErr</code> is invalid, it is generated based on <code>pftAddr</code>. Otherwise, it is set to the start address + prediction width.</li>
</ul>
</li>
<li><strong>br_taken_mask</strong>: Branch prediction result, with each branch (slot) corresponding to a bit indicating whether the branch is predicted as taken.
<ul>
<li>Generation: Generated based on the <code>always_taken</code> field in the FTB entry and the result indicated by the two-bit saturating counter.</li>
</ul>
</li>
<li><strong>jalr_target</strong>: The jump target of the jalr in this predicted block.
-Generation: From the jump target in the tailSlot of the FTB entry.</li>
</ul>
<h2 id="uftb-update">uFTB Update</h2>
<p>The update of uFTB involves updating the FTB entry cache and the two-bit saturating counter, with the update content obtained through the update interface.</p>
<p>In the uFTB predictor, the reading and writing of the cache and the two-bit saturating counter do not conflict, so we do not need to consider timing conflicts between reading and updating and can consider them as two independent parts.</p>
<h3 id="ftb-cache-update">FTB Cache Update</h3>
<p>The update process of the FTB cache is simple. The update channel has already specified the PC and the newly generated FTB entry, so it only needs to be written to the specified position in the cache.</p>
<p>FTB cache updating requires two cycles:</p>
<ul>
<li>In the first cycle, calculate the following based on the signals in the update:
<ul>
<li><strong>Which row in the cache corresponds to the update request</strong> The PC extracted from the update request is sent to the update request channel of FauFTBWay, and the hit signal returned by each row is calculated.</li>
</ul>
</li>
<li>In the second cycle, update according to the position calculated in the first cycle. If no row is hit, uFTB will use a <strong>pseudo-LRU replacement algorithm</strong> to select the row to be written.
Specifically, the ftb_entry signal group in the update channel contains the complete information of the new FTB entry, which is sent to the cache row that needs to be updated.</li>
</ul>
<h3 id="two-bit-saturating-counter-update">Two-Bit Saturating Counter Update</h3>
<p>The update of the two-bit saturating counter needs to be combined with the actual execution of the subsequent program and the branch instruction information recorded in the FTB entry, which can be obtained from the update channel.</p>
<p>The update of the two-bit saturating counter also requires two cycles:</p>
<ul>
<li>In the first cycle, calculate which two-bit saturating counter corresponding to the conditional branch instruction in the slot needs to be updated, which needs to meet the following conditions:
<ul>
<li>The current branch instruction slot is valid and contains a conditional branch instruction.</li>
<li>The current branch instruction slot is not marked as always_taken. (Because after being marked as always_taken, the result of the two-bit saturating counter will not be used.)</li>
<li>The current branch instruction slot is not after the branch instruction slot where an actual jump occurred.</li>
</ul>
</li>
<li>In the second cycle, update the saturating counter based on the mask generated in the first cycle and the <code>br_taken_mask</code> information in the update channel.</li>
</ul>
<h2 id="interface-list">Interface List</h2>
<table>
  <thead>
      <tr>
          <th>信号类型</th>
          <th>信号位</th>
          <th>信号名</th>
          <th>信号描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>input</td>
          <td></td>
          <td>clock</td>
          <td>输入时钟</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>reset</td>
          <td>复位信号</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[35:0]</td>
          <td>io_reset_vector</td>
          <td>用于reset时，reset s1_pc_dup_0 提供的值</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_s0_pc_0</td>
          <td>输入位s0_pc 的 第0个复制</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_s0_pc_1</td>
          <td>同上 第1个</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_s0_pc_2</td>
          <td>同上 第2个</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_s0_pc_3</td>
          <td>同上 第3个</td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_pc_0</td>
          <td>输出s1_pc 的 第0个复制</td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_pc_1</td>
          <td>同上 第1个</td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_pc_2</td>
          <td>同上 第2个</td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_pc_3</td>
          <td>同上 第3个</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_0_br_taken_mask_0</td>
          <td>solt 0 是否被预测为 always taken</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_0_br_taken_mask_1</td>
          <td>solt 1 是否被预测为 always taken</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_0_slot_valids_0</td>
          <td>solt 0 是否启用</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_0_slot_valids_1</td>
          <td>solt 1 是否启用</td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_full_pred_0_targets_0</td>
          <td>solt 0 对应的跳转目标地址</td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_full_pred_0_targets_1</td>
          <td>solt 1 对应的跳转目标地址</td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s1_full_pred_0_offsets_0</td>
          <td>solt 0 中分支指令相对于地址块起始pc的偏移</td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s1_full_pred_0_offsets_1</td>
          <td>solt 1 中分支指令相对于地址块起始pc的偏移</td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_full_pred_0_fallThroughAddr</td>
          <td>预测块的结束地址</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_0_is_br_sharing</td>
          <td>solt 1（无条件跳转）是否被共享为有条件跳转指令</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_0_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_1_br_taken_mask_0</td>
          <td>类似 io_out_s1_pc_1 io_out_s1_full_pred_0的复制</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_1_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_1_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_1_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_full_pred_1_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_full_pred_1_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s1_full_pred_1_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s1_full_pred_1_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_full_pred_1_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_1_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_1_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_2_br_taken_mask_0</td>
          <td>同上</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_2_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_2_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_2_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_full_pred_2_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_full_pred_2_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s1_full_pred_2_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s1_full_pred_2_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_full_pred_2_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_2_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_2_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_3_br_taken_mask_0</td>
          <td>同上</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_3_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_3_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_3_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_full_pred_3_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_full_pred_3_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s1_full_pred_3_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s1_full_pred_3_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s1_full_pred_3_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_3_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_3_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s1_full_pred_3_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[222:0]</td>
          <td>io_out_last_stage_meta</td>
          <td>输出最后阶段的元信息 io_out_last_stage_meta = {213&rsquo;h0, resp_meta_pred_way_r_1, resp_meta_hit_r_1}</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_ctrl_ubtb_enable</td>
          <td>控制ubtb是否启用</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s0_fire_0</td>
          <td>输入s0_fire_0，与 io_out_s1_pc_0 &lt;= io_in_bits_s0_pc_0 的时钟门控相关</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s0_fire_1</td>
          <td>输入s0_fire_1</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s0_fire_2</td>
          <td>输入s0_fire_2</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s0_fire_3</td>
          <td>输入s0_fire_3</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s1_fire_0</td>
          <td>输入s1_fire_0</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s2_fire_0</td>
          <td>输入s2_fire_0</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_valid</td>
          <td>更新有效性</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_update_bits_pc</td>
          <td>传回的预测块pc（用于指示更新的预测块）</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_update_bits_ftb_entry_brSlots_0_offset</td>
          <td>solt 0 中分支指令相对于地址块起始pc的偏移</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[11:0]</td>
          <td>io_update_bits_ftb_entry_brSlots_0_lower</td>
          <td>跳转目标地址的低位</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[1:0]</td>
          <td>io_update_bits_ftb_entry_brSlots_0_tarStat</td>
          <td>跳转后的 pc 高位是否进退位</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_brSlots_0_valid</td>
          <td>是否启用</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_update_bits_ftb_entry_tailSlot_offset</td>
          <td>solt 1 中分支指令相对于地址块起始pc的偏移</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[19:0]</td>
          <td>io_update_bits_ftb_entry_tailSlot_lower</td>
          <td>跳转目标地址的低位</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[1:0]</td>
          <td>io_update_bits_ftb_entry_tailSlot_tarStat</td>
          <td>跳转后的 pc 高位是否进退位</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_tailSlot_sharing</td>
          <td>无条件跳转指令槽中存储条件分支指令</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_tailSlot_valid</td>
          <td>是否启用</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_update_bits_ftb_entry_pftAddr</td>
          <td>Partial Fallthrough Addr 如果预测块中没有跳转，那么程序将会顺序执行到达的地址，预测块的结束地址。</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_carry</td>
          <td>pc+pft时是否产生进位</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_always_taken_0</td>
          <td>是否预测为总是跳转</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_always_taken_1</td>
          <td>是否预测为总是跳转</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_br_taken_mask_0</td>
          <td>是否跳转</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_br_taken_mask_1</td>
          <td>是否跳转</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-acd2cf0c1c9c53099412da29a7437546">3 - TAGE-SC Branch Predictor</h1>
    
	<h2 id="introduction">Introduction</h2>
<p>TAGE-SC is the <strong>primary predictor</strong> for conditional branches in the Kunming Lake architecture, classified as an Accurate Predictor (APD). TAGE-SC can be seen as two relatively independent components: the prediction part TAGE and the verification part SC.</p>
<p>The Tagged Geometric History Length Predictor (TAGE) utilizes <strong>multiple prediction tables with different history lengths</strong> to exploit <strong>extensive branch history information</strong>. TAGE predicts whether a branch instruction will be taken or not taken. It consists of a base prediction table and multiple history tables. It first predicts using multiple history tables. If there is no prediction, it uses the prediction from the base table.
The Statistical Corrector (SC) is a statistical corrector. SC references the prediction results of TAGE and <strong>statistical bias results</strong>. Based on these two results, it <strong>corrects</strong> the final prediction result.</p>
<p>In Kunming Lake, each prediction block can have up to 2 branch instructions, so TAGE can predict <strong>up to 2 conditional branch instructions simultaneously</strong>. When accessing the various history tables in TAGE, the starting address of the prediction block is used as the PC, and two prediction results are retrieved based on the <strong>same global history</strong>.</p>
<h2 id="tage-branch-predictor-in-kunming-lake">TAGE Branch Predictor in Kunming Lake</h2>
<h3 id="basic-functionality">Basic Functionality</h3>
<p><img src="tage.PNG" alt="img"></p>
<p>The core idea of the TAGE predictor is to provide prediction results with different history lengths and select the most appropriate result for feedback. In the TAGE predictor, there are a total of <strong>1+N</strong> history record tables, where N is a configurable option. In Kunming Lake, N=4.</p>
<p>The base predictor based on the T0 table is the <strong>baseline predictor</strong>. During prediction, it directly looks up the &ldquo;2-bit saturated counter representing the jump history information&rdquo; corresponding to the address in the T0 table, and then makes a prediction based on the history information. The T0 table has only 2 bits per entry, so the history states it can record are limited.</p>
<p>For tables other than T0, we use <strong>Tn</strong> to represent them. During table lookup, in addition to the PC, it is also necessary to use the <strong>global jump history information H</strong> for the lookup. When a match is found, the prediction is made based on the &ldquo;3-bit saturated predictor&rdquo; to jump or not to jump. The higher the value of n for the Tn table, the longer the history information it uses, i.e., x&lt;y.</p>
<p>For each prediction, TAGE selects the table entry with the <strong>longest global jump history</strong> among all the hit Tn entries.</p>
<ol>
<li>If the table entry exists and the prediction result confidence is high, it is used as the final prediction result.</li>
<li>If the confidence is low, another internal counter is used to determine whether to select that entry or T0 as the final prediction.</li>
</ol>
<p>To save space, when retrieving the Tn table, the input jump history information H needs to be <strong>compressed</strong>, a process also known as <strong>history folding</strong>.</p>
<p>The table entries of each prediction table include the following elements:</p>
<ol>
<li>T0 table indexed directly by PC
<ol>
<li>2-bit pred <strong>unsigned</strong> saturated counter (indicating prediction direction and confidence level)</li>
</ol>
</li>
<li>Tn table indexed by XOR of PC and folded global history
<ol>
<li>1-bit valid bit</li>
<li>3-bit pred <strong>unsigned</strong> saturated counter</li>
<li>8-bit tag (used for verifying whether the hit is intentional, not coincidental)</li>
<li>1-bit useful bit for controlling expiration
For a prediction block, all tables may generate prediction results, requiring a selection process. Typically, the higher the Tn table number, the higher its priority.</li>
</ol>
</li>
</ol>
<h3 id="pipeline">Pipeline</h3>
<p>TAGE contains two pipeline stages: the first stage calculates the index, and the second stage reads the results from the SRAM table.</p>
<ol>
<li>Stage 0 (s0): Input to the first pipeline stage, usually the pc and folded history.
<strong>First pipeline stage operation</strong>: Calculate the index. Output to s1 via registers.</li>
<li>Stage 1 (s1): Input to the second pipeline stage, consisting of the index and other calculated data from the first stage.
<strong>Second pipeline stage operation</strong>: Memory access to SRAM, reading the prediction result. Output to s2 via registers.</li>
<li>Stage 2 (s2): Actual prediction result. TAGE uses 2 stages for prediction, with the prediction result ready for use in the third stage after 2 stages.</li>
</ol>
<h3 id="data-structures">Data Structures</h3>
<ol>
<li>
<p>In Kunming Lake&rsquo;s implementation, the T0 and Tn table structures are as follows:</p>
<ol>
<li>
<table>
  <thead>
      <tr>
          <th><strong>预测器</strong></th>
          <th><strong>作用</strong></th>
          <th><strong>表项构成</strong></th>
          <th><strong>项数</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>基准预测器T0</td>
          <td>用于在其他预测器的预测结果都无效时输出预测结果</td>
          <td>2 bit ctr 饱和计数器最高位决定跳转方向</td>
          <td>2路各2048项，每路对于一条分支指令</td>
      </tr>
      <tr>
          <td>预测表T1-T4</td>
          <td>对每个预测块的输入，所有Tn表都进行预测，在所有预测有效的结果中，选择历史记录最长的结果作为最后预测结果。历史记录长度由输入的H决定</td>
          <td>1 bit valid 有效位 3 bit ctr 饱和计数器8 bit tag 校验命中1 bit us 作为usefulness计数器</td>
          <td>4096项、奇数项对应第一条分支指令，偶数项对应第二条分支指令</td>
      </tr>
  </tbody>
</table>
</li>
</ol>
</li>
</ol>
<p>For each table Tn, the length of its input &ldquo;global branch history data H&rdquo; varies during querying. Assuming the total prediction history length is S, Tn and Tn+1 may use the low x, low y bits of S (<strong>the lower bits are the newer history</strong>) as query inputs. Generally, the larger the n of table Tn, the longer the history information used, i.e., x&lt;y.</p>
<p>During the query of table Tn, since the historical data H is &ldquo;compressed,&rdquo; it may lead to a situation where the result of one PC1^H1 matches another PC2^H2 (similar to a Hash collision), resulting in indexing into invalid data (predicting PC1 indexes to predicted PC2&rsquo;s data). Therefore, TAGE provides a tag identifier for each table, using an 8-bit tag in the Kunming Lake implementation to reduce the probability of collisions. The calculation method and index method for tags are different; <strong>only when the tag calculation is the same, the query result is valid</strong>.</p>
<p>In the Tn table entry, in addition to the saturation counter ctr and tag, there is also a 1-bit <strong>usefulness counter</strong>. When this counter is 0, it is a weak entry, indicating that the entry can be reallocated for other uses; when it is not 0, it is a strong entry, indicating that the entry cannot be reallocated for other uses.</p>
<p>To <strong>try to avoid</strong> the situation where all table entries are 1 and no new table entries can be allocated, TAGE expects to use the counter bankTickCtrs to clear all usefulness to 0.</p>
<h3 id="retrieval-method-for-t0-and-tn-tables">Retrieval Method for T0 and Tn Tables</h3>
<ul>
<li>For table T0, indexing is done using the PC[11:1] bits to index 2048 table entries, so for T0, there is no possibility of not finding a match.</li>
<li>For table Tn, in addition to PC[11:1], retrieval also requires searching based on the global branch history. In Kunming Lake, the top-level branch predictor maintains a 256-bit global history record GH, which can fold the GH&rsquo;s most recent n bits of history information based on the required number of bits x for the sub-predictor. That is, n is divided into ceil(x/n) units of length x, and then XOR is performed bitwise. This folded history is denoted as FH (Folded History), and the specific process can be found in the [Branch Folding History section](../00_bpu_top/#Branch Folding History). When the TAGE predictor searches for a table entry in Tn, it uses the index and tag, calculated as follows:</li>
</ul>
<table>
  <thead>
      <tr>
          <th><strong>Calculation Formula</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>index = FH ^ ((pc&raquo;1)低位)</td>
      </tr>
      <tr>
          <td>tag = FH1 ^ FH2 ^ ((pc&raquo;1)低位)</td>
      </tr>
  </tbody>
</table>
<p>Where FH, FH1, FH2 represent the folded global branch history according to certain rules. For Tn, FH, FH1, and FH2 each have their own folding bit numbers, which may not be the same. In the Kunming Lake implementation, the configurations of the T0 and Tn tables are as follows:</p>
<table>
  <thead>
      <tr>
          <th><strong>表名称</strong></th>
          <th><strong>FH长度</strong></th>
          <th><strong>FH1长度</strong></th>
          <th><strong>FH2长度</strong></th>
          <th><strong>最近历史长度（用到GH中的位数）</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>T1</td>
          <td>8比特</td>
          <td>8比特</td>
          <td>7比特</td>
          <td>低8位，即把最新8位历史，折叠成FH、FH1、FH2</td>
      </tr>
      <tr>
          <td>T2</td>
          <td>11比特</td>
          <td>8比特</td>
          <td>7比特</td>
          <td>低13位，即把最新13位历史，折叠成FH、FH1、FH2</td>
      </tr>
      <tr>
          <td>T3</td>
          <td>11比特</td>
          <td>8比特</td>
          <td>7比特</td>
          <td>低32位，即把最新32位历史，折叠成FH、FH1、FH2</td>
      </tr>
      <tr>
          <td>T4</td>
          <td>11比特</td>
          <td>8比特</td>
          <td>7比特</td>
          <td>低119位，即把最新119位历史，折叠成FH、FH1、FH2</td>
      </tr>
  </tbody>
</table>
<p>Note: pc&raquo;1 is used because RISC-C extension is used, with 2-byte alignment, and PC itself is already aligned to 1 byte, so only 1 bit is used.</p>
<h3 id="alternative-predictor">Alternative Predictor</h3>
<p>Since the Tn table uses saturation counters for prediction, there may be situations where the output result is &ldquo;not confident.&rdquo; For example, in Kunming Lake, for a 3-bit saturation counter, both 100 and 011 indicate a <strong>weak prediction</strong>. To provide more choices as references for this state, the TAGE predictor also provides an &ldquo;alternative predictor&rdquo; mechanism, which determines whether to select the prediction result of Tn or T0 when the Tn table predicts with low confidence.</p>
<p>In the Kunming Lake implementation, the &ldquo;alternative predictor&rdquo; is implemented based on the register group <strong>useAltOnNaCtrs</strong>. It consists of two paths of 128 <strong>4-bit saturation counters</strong> each, initialized to <strong>0b1000</strong>. When TAGE makes a prediction, it uses <strong>PC(7,1)</strong> to index the corresponding saturation counter. If the value of this counter is greater than or equal to the preset value and the prediction result of Tn is not confident, it selects the result of T0; otherwise, it selects the result of Tn.</p>
<h3 id="prediction-process">Prediction Process</h3>
<p>In summary, the prediction steps of the TAGE predictor in Kunming Lake are as follows:</p>
<ol>
<li><strong>Parallel</strong> indexing of T0 and Tn tables, selecting which table to use based on the hit result:
<ol>
<li>If a match to the tag of a Tn table is found, the potential prediction result is given by the saturation counter of the longest history Tn table.</li>
<li>If no match to a Tn table is found, the final prediction result is given by the saturation counter of the T0 table.</li>
</ol>
</li>
<li>If the potential prediction result of the matched Tn table is a weak prediction (100,011), and the value of the corresponding 4-bit counter in the alternative prediction for PC is greater than or equal to a threshold, the result of the T0 table is used as the final result; otherwise, the prediction result of the Tn table is used as the final prediction result.</li>
</ol>
<h3 id="training-process">Training Process</h3>
<p>Since the prediction process of TAGE involves many counters and tags, they need to be updated according to certain rules, a process known as training. This training process occurs in the BPU&rsquo;s update stage, where the PC, branch history, and prediction correctness information are input. The training process for branch prediction in Kunming Lake is divided into several steps based on different conditions:</p>
<ol>
<li>Update when <strong>T0</strong> is the final prediction result: If a jump occurs (i.e., taken), increment the ctr saturation counter indexed by the pc; otherwise, decrement it.</li>
<li>When <strong>only T0</strong> is hit, the following operations are performed:
<ol>
<li>If T0 is <strong>predicted correctly</strong>, no additional update is performed.</li>
<li>If T0 is <strong>predicted incorrectly</strong>, attempt to randomly allocate a new table entry in a Tn table. To allocate a new table entry, the original entry&rsquo;s usefulness at the corresponding index must be 0. The new entry is initialized as a weak prediction with usefulness 0, and its tag is set to the newly calculated tag.</li>
</ol>
</li>
<li>When <strong>both T0 and Tn are hit</strong>, the following operations are performed:
<ol>
<li><strong>Tn</strong> is always updated: If a jump occurs, increment the ctr saturation counter indexed by the pc; otherwise, decrement it. It is important to note that &ldquo;hit&rdquo; means that the tag of the indexed entry matches the calculated tag.</li>
<li>If <strong>T0 and Tn produce the same result</strong>:
<ol>
<li>If <strong>predicted correctly</strong>, no additional update is performed.</li>
<li>If <strong>predicted incorrectly</strong>, attempt to allocate a new table entry in a table with a longer history than Tn. To allocate a new entry, the usefulness of the original entry at the corresponding index must be 0. The new entry is initialized as a weak prediction with usefulness 0, and its tag is set to the tag calculated using the new history information.</li>
</ol>
</li>
<li>If <strong>T0 and Tn produce different results</strong>:
<ol>
<li>If <strong>Tn is correct</strong>, the entry&rsquo;s usefulness is incremented.
<ol>
<li>If the result is still a <strong>weak prediction</strong>, the counter in the alternative prediction for T0 is decremented.</li>
</ol>
</li>
<li>If <strong>Tn is incorrect</strong>, the entry&rsquo;s usefulness is decremented, and a new entry is allocated in a table with a longer history than Tn, as in 3.2.2.
<ol>
<li>If the result is still a <strong>weak prediction</strong>, the counter in the alternative prediction for T0 is incremented.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>When a new table <strong>needs to be allocated</strong>, dynamic reset of the usefulness flag is performed.
<ol>
<li>Using a 7-bit bankTickCtrs register and calculating:
<ol>
<li>The number of allocatable tables <strong>a</strong> (with a longer history length than the current and corresponding index usefulness is 0)</li>
<li>The number of unallocatable tables <strong>b</strong> (with a longer history length than the current and corresponding index usefulness is not 0)</li>
</ol>
</li>
<li><strong>Update</strong> bankTickCtrs += Δ (saturated counter), Δ = b - a,</li>
<li>When bankTickCtrs reaches its <strong>maximum</strong> value, <strong>reset all usefulness to 0</strong>.</li>
</ol>
</li>
</ol>
<h2 id="kunming-lake-sc-branch-predictor">Kunming Lake SC Branch Predictor</h2>
<h3 id="basic-function-introduction">Basic Function Introduction</h3>
<p>The SC (Statistics counter) branch predictor is a branch predictor based on historical statistical information. Similar to TAGE, SC typically has multiple tables Tn, each corresponding to different lengths of historical jump statistics. The difference is that in SC, when predicting based on the PC, each table Tn is accessed, and then SC adds up each hit table entry to calculate the total &ldquo;saturated counter&rdquo; jump information, and finally determines whether to jump based on the total jump information. Generally, SC uses &ldquo;signed saturated counters&rdquo;, where a counter value greater than 0 indicates a jump, and less than 0 indicates no jump. The larger the absolute value of the counter, the higher the prediction confidence.</p>
<p>In the SC predictor, SC is also composed of multiple tables (e.g., T1, T2, T3, T4), but with fewer basic prediction tables T0 compared to the TAGE predictor. The Tn tables in SC have 6-bit signed saturated counters. The indexing method for SC tables is as follows:</p>
<table>
  <thead>
      <tr>
          <th><strong>Calculation Method</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Index = (FH) ^ ((pc&raquo;1)低位)</td>
      </tr>
  </tbody>
</table>
<p>For each table, the number of entries and the folded history length used are as follows:</p>
<table>
  <thead>
      <tr>
          <th>Table</th>
          <th>Number of Entries</th>
          <th>FH Length</th>
          <th>Folded History Range</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>T1</td>
          <td>512</td>
          <td>0</td>
          <td>不折叠</td>
      </tr>
      <tr>
          <td>T2</td>
          <td>512</td>
          <td>4</td>
          <td>把历史信息的低4位，折叠成FH</td>
      </tr>
      <tr>
          <td>T3</td>
          <td>512</td>
          <td>8</td>
          <td>把历史信息的低10位，折叠成FH</td>
      </tr>
      <tr>
          <td>T4</td>
          <td>512</td>
          <td>8</td>
          <td>把历史信息的低16位，折叠成FH</td>
      </tr>
  </tbody>
</table>
<p>The formula for calculating the total statistical prediction result is as follows:</p>

<div class="math">$$scCtrSum=\sum_{i=0}^{i<4}( (ctr_{sc} << 1) +1)$$</div><p>Where ctr_sc represents the signed saturated counter for each table. Left-shifting and adding one is for weight adjustment. The accumulated scCtrSum is the final prediction result of SC. If this value is greater than zero, the prediction is a jump; if it is less than zero, the prediction is no jump. The larger the absolute value, the higher the prediction confidence.</p>
<p>Typical data conversion results are as follows (extended to 9 bits to prevent overflow during calculation):</p>
<ol>
<li>All are 6b100000 (strong no-jump), resulting in 9b100000100, with a value of -252.</li>
<li>All are 6b011111 (strong jump), resulting in 9b011111100, with a value of 252.</li>
<li>All are 6b000000 (weak jump), resulting in 9b000000100, with a value of 4.</li>
<li>All are 6b111111 (weak no-jump), resulting in 9b111111100, with a value of -4.</li>
</ol>
<h3 id="prediction-process-1">Prediction Process</h3>
<ol>
<li>Calculate the index of table Tn using the PC and historical information.</li>
<li>Query the index to obtain the saturation counters for all tables.</li>
<li>Sum up all the saturation counters obtained from all tables to get the final prediction result (take a jump for values greater than 0, no jump for values less than 0).</li>
</ol>
<h3 id="training-process-1">Training Process</h3>
<p>Update the saturation counters during the update phase.</p>
<ol>
<li>If the real instruction corresponding to PC jumps, increment the saturation counters corresponding to all tables.</li>
<li>If the real instruction corresponding to PC does not jump, decrement the saturation counters corresponding to all tables.</li>
</ol>
<h2 id="kunming-lake-tage-sc-branch-predictor">Kunming Lake TAGE-SC Branch Predictor</h2>
<h3 id="why-sc-is-needed-with-tage">Why SC is Needed with TAGE</h3>
<p>In some applications, some branch behaviors have a weak correlation with branch history or paths, showing a statistical prediction bias. For these branches, using counters to capture statistical biases is more effective than history-based branch prediction.</p>
<p>TAGE is very effective in predicting branches that are highly correlated with history, but it performs poorly for branches with statistical biases. For example, branches that have a small bias in one direction but are not strongly correlated with historical paths. To avoid this problem, an SC predictor can be added to the traditional TAGE predictor.</p>
<h3 id="tage-sc-functionality">TAGE-SC Functionality</h3>
<p>In the Kunming Lake TAGE-SC predictor, both the TAGE and SC prediction results P1 and P2 are obtained simultaneously, and then their results are accumulated P = P1 + P2. If the absolute value of P is greater than the 8-bit threshold sc_bank_thres, the predictor result P is used; otherwise, P1 is used as the final prediction result.</p>
<p>For dynamic adaptation, the threshold sc_thres needs to be dynamically changed. Therefore, in the implementation, TAGE-SC uses a 5-bit sc_bank_ctr counter to adjust the threshold sc_bank_thres. Additionally, since Kunming Lake supports the simultaneous prediction of 2 branch instructions, the threshold register and corresponding control counter are also duplicated.</p>
<h3 id="pipeline-1">Pipeline</h3>
<p>The TAGE-SC predictor contains 3 pipeline stages, where the 2-stage pipeline of TAGE has been introduced, and the pipeline of the SC part is as follows:</p>
<ol>
<li>
<p>Stage 0: Read PC and folded history into s0.
<strong>First Stage</strong>: Calculate the index from pc and FH to obtain s0_idx.</p>
</li>
<li>
<p>Stage 1: Read s0_idx from s0.
<strong>Second Stage</strong>: Find the counter data corresponding to s1_idx in SCTable and output to s1_scResps.</p>
</li>
<li>
<p>Stage 2: Read s1_scResps from s1.
<strong>Third Stage</strong>: Select whether to invert the prediction result based on s2_scResps and output to s2_disagree.</p>
</li>
<li>
<p>Stage 3: Read the result from s2_disagree as s3_disagree.</p>
</li>
</ol>
<h3 id="prediction-process-2">Prediction Process</h3>
<p>In TAGE-SC prediction, the prediction result P1 of TAGE is represented by tage_ctr, and the prediction result P2 of SC is represented by scCtrSum. The prediction is divided into four steps:</p>
<ol>
<li>
<p>Execute the SC predictor to get the prediction result scCtrSum.</p>
</li>
<li>
<p>Simultaneously obtain the prediction result tage_ctr of the TAGE predictor.</p>
<ol>
<li>
<p>Since the prediction result of TAGE is an unsigned saturation counter, and the prediction result of SC is a signed saturation counter, if they are added together, data conversion is required.</p>
</li>
<li>
<p>Kunming Lake adopts a conversion for the result of TAGE. The converted result is represented by tageCtrCentered, and the specific conversion process is as follows:</p>

<div class="math">$$tageCtrCentered=((((ctr_{tage} -4)<<1)+1)<<3) $$</div></li>
<li>
<p>Conversion of a 3-bit unsigned saturation counter to an 8-bit signed saturation counter result is illustrated as follows:</p>
<ul>
<li>
<p>3b100 Weak jump =&gt; 8b00001000 = 8</p>
</li>
<li>
<p>3b011 Weak non-jump =&gt; 8b11111000 = -8</p>
</li>
<li>
<p>3b111 Strong jump =&gt; 8b00111000 = 56</p>
</li>
<li>
<p>3b000 Strong non-jump =&gt; 8b11001000 = -56</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Add the prediction results of TAGE and SC to get the final prediction result P, represented by totalSum.</p>
</li>
</ol>

<div class="math">$$totalSum = scCtrSum + tageCtrCentered$$</div><ol start="4">
<li>
<p>Determine the final prediction direction based on <code>totalSum</code> and <code>sc_bank_thres</code></p>
<ol>
<li>Jump if totalSum &gt; 0 and its absolute value exceeds the threshold: If scCtrSum &gt; sc_bank_thres - tageCtrCentered, it can also be understood as totalSum &gt; sc_bank_thres. The above expression can reduce the maximum bit width (ensuring no overflow requires 10 bits to become 9 bits).</li>
<li>No jump if totalSum &lt; 0 and its absolute value exceeds the threshold: If scCtrSum &lt; -sc_bank_thres - tageCtrCentered, it can also be understood as |totalSum| &gt; sc_bank_thres.</li>
</ol>
</li>
</ol>
<h3 id="training-process-2">Training Process</h3>
<p>After combining TAGE and SC, TAGE-SC adds an sc_bank_ctr counter to control the threshold sc_bank_thres. Therefore, during training, in addition to the training of TAGE and SC themselves, the newly added counter needs to be updated.</p>
<p>During the update phase, the specific update process is as follows:</p>
<ol>
<li>TAGE-SC uses the prediction result P (i.e., the prediction result after TAGE + SC). If |totalSum| is in the range [sc_bank_thres -4, sc_bank_thres -2], update the threshold-related register group.
<ol>
<li>Update sc_bank_ctr, the saturation counter: If the prediction is correct, sc_bank_ctr +=1; if the prediction is incorrect, sc_bank_ctr -=1.</li>
<li>Update sc_bank_thres, limited saturation operation: If the updated value of sc_bank_ctr reaches 0b11111 and sc_bank_thres &lt;= 31, then sc_bank_thres +=2; if the updated value of sc_bank_ctr is 0 and sc_bank_thres &gt;=6, then sc_bank_thres -=2. For all other cases, thres remains unchanged.</li>
<li>After the update judgment of sc_bank_thres is completed, another judgment is made on sc_bank_ctr. If the updated sc_bank_ctr is 0b11111 or 0, thres_ctr is reset to the initial value 0b10000.</li>
</ol>
</li>
<li>TAGE-SC uses the prediction result P1 (i.e., the prediction result of TAGE) and does not perform any operations.</li>
</ol>
<h2 id="interface-list">Interface List</h2>
<h3 id="tagesc">TageSC</h3>
<table>
  <thead>
      <tr>
          <th>信号类型</th>
          <th>信号宽度</th>
          <th>信号名</th>
          <th>信号描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>clock</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>reset</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[35:0]</td>
          <td>io_reset_vector</td>
          <td>用于reset时，reset s1_pc_dup_0 提供的值</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[40:0]</td>
          <td>io_in_bits_s0_pc_0</td>
          <td>复制的s0_pc的dup数组的第1个，给顶层BPU的PC</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[40:0]</td>
          <td>io_in_bits_s0_pc_1</td>
          <td>复制的s0_pc第2个，给Tage的PC</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[40:0]</td>
          <td>io_in_bits_s0_pc_3</td>
          <td>复制的s0_pc的第4个，给SC的PC</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[10:0]</td>
          <td>io_in_bits_folded_hist_1_hist_17_folded_hist</td>
          <td>TageTable 2 用到的11bits 折叠历史 从多长历史范围折叠到11bit见前文所述的表 注意TageTable下标+1，此处 T2 是前文 T3</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[10:0]</td>
          <td>io_in_bits_folded_hist_1_hist_16_folded_hist</td>
          <td>TageTable 3 用到的11bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[6:0]</td>
          <td>io_in_bits_folded_hist_1_hist_15_folded_hist</td>
          <td>TageTable 1 用到的7bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[7:0]</td>
          <td>io_in_bits_folded_hist_1_hist_14_folded_hist</td>
          <td>TageTable 0 用到的8bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[6:0]</td>
          <td>io_in_bits_folded_hist_1_hist_9_folded_hist</td>
          <td>TageTable 2 用到的7bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[7:0]</td>
          <td>io_in_bits_folded_hist_1_hist_8_folded_hist</td>
          <td>TageTable 3 用到的8bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[6:0]</td>
          <td>io_in_bits_folded_hist_1_hist_7_folded_hist</td>
          <td>TageTable 0 用到的7bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[6:0]</td>
          <td>io_in_bits_folded_hist_1_hist_5_folded_hist</td>
          <td>TageTable 3 用到的7bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[7:0]</td>
          <td>io_in_bits_folded_hist_1_hist_4_folded_hist</td>
          <td>TageTable 1 用到的8bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[7:0]</td>
          <td>io_in_bits_folded_hist_1_hist_3_folded_hist</td>
          <td>TageTable 2 用到的8bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[10:0]</td>
          <td>io_in_bits_folded_hist_1_hist_1_folded_hist</td>
          <td>TageTable 1 用到的11bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[3:0]</td>
          <td>io_in_bits_folded_hist_3_hist_12_folded_hist</td>
          <td>SCTable 1 用到的 4bit 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[7:0]</td>
          <td>io_in_bits_folded_hist_3_hist_11_folded_hist</td>
          <td>SCTable 2 用到的 8bit 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[7:0]</td>
          <td>io_in_bits_folded_hist_3_hist_2_folded_hist</td>
          <td>SCTable 3 用到的 8bit 折叠历史</td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s2_full_pred_0_br_taken_mask_0</td>
          <td>io_out_s2_full_pred_{i}<em>br_taken_mask</em>{j} Tage 在 s2流水级输出的，复制4份 预测块中第 j 条分支指令TAGE预测结果  这里不该叫mask吧</td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s2_full_pred_0_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s2_full_pred_1_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s2_full_pred_1_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s2_full_pred_2_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s2_full_pred_2_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s2_full_pred_3_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s2_full_pred_3_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s3_full_pred_0_br_taken_mask_0</td>
          <td>io_out_s3_full_pred_{i}<em>br_taken_mask</em>{j} Tage 在 s3流水级输出的，复制4份 预测块中第 j 条分支指令SC预测结果</td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s3_full_pred_0_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s3_full_pred_1_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s3_full_pred_1_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s3_full_pred_2_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s3_full_pred_2_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s3_full_pred_3_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_out_s3_full_pred_3_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>*[222:0]</td>
          <td>io_out_last_stage_meta</td>
          <td>见附表</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_ctrl_tage_enable</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_ctrl_sc_enable</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_s0_fire_0</td>
          <td>s0 阶段流水线控制 相同信号复制多份，0给BPU，1给Tage，3给SC</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_s0_fire_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_s0_fire_3</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_s1_fire_0</td>
          <td>s1 阶段流水线控制</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_s1_fire_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_s1_fire_2</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_s1_fire_3</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_s2_fire_0</td>
          <td>s2 阶段流水线控制</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_s2_fire_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_s2_fire_2</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_s2_fire_3</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>*</td>
          <td>io_s1_ready</td>
          <td>tage的所有表，可以执行读取结果的操作</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_update_valid</td>
          <td>从FTQ发向BPU的后端执行结果（更新信号）是否有效</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[40:0]</td>
          <td>io_update_bits_pc</td>
          <td>（后端执行过的）预测块的PC</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[10:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_17_folded_hist</td>
          <td>TageTable 2 用到的11bits 折叠历史 预测时使用的分支历史结果，没有更新，转了一圈回来了</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[10:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_16_folded_hist</td>
          <td>TageTable 3 用到的11bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[6:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_15_folded_hist</td>
          <td>TageTable 1 用到的7bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[7:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_14_folded_hist</td>
          <td>TageTable 0 用到的8bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[3:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_12_folded_hist</td>
          <td>SCTable 1 用到的 4bit 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[7:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_11_folded_hist</td>
          <td>SCTable 2 用到的 8bit 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[6:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_9_folded_hist</td>
          <td>TageTable 2 用到的7bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[7:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_8_folded_hist</td>
          <td>TageTable 3 用到的8bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[6:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_7_folded_hist</td>
          <td>TageTable 0 用到的7bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[6:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_5_folded_hist</td>
          <td>TageTable 3 用到的7bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[7:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_4_folded_hist</td>
          <td>TageTable 1 用到的8bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[7:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_3_folded_hist</td>
          <td>TageTable 2 用到的8bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[7:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_2_folded_hist</td>
          <td>SCTable 3 用到的 8bit 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[10:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_1_folded_hist</td>
          <td>TageTable 1 用到的11bits 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_update_bits_ftb_entry_brSlots_0_valid</td>
          <td>FTB 表项的第一个slot是否有效（存储了跳转指令）</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_update_bits_ftb_entry_tailSlot_sharing</td>
          <td>FTB 表项的最后一个slot是否存储了条件分支而非无条件跳转</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_update_bits_ftb_entry_tailSlot_valid</td>
          <td>FTB 表项的最后一个slot是否有效</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_update_bits_ftb_entry_always_taken_0</td>
          <td>历史上slot 0 指令总是跳转</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_update_bits_ftb_entry_always_taken_1</td>
          <td>历史上slot 1 指令总是跳转</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_update_bits_br_taken_mask_0</td>
          <td>solt 0 是否 taken</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_update_bits_br_taken_mask_1</td>
          <td>solt 1 是否 taken</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_update_bits_mispred_mask_0</td>
          <td>solt 0 是否预测正确</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*</td>
          <td>io_update_bits_mispred_mask_1</td>
          <td>solt 1 是否预测正确</td>
      </tr>
      <tr>
          <td>input</td>
          <td>*[222:0]</td>
          <td>io_update_bits_meta</td>
          <td>见附表</td>
      </tr>
  </tbody>
</table>
<h3 id="io_out_last_stage_meta">io_out_last_stage_meta</h3>
<p>需要设计参与优化！</p>
<table>
  <thead>
      <tr>
          <th>信号类型</th>
          <th>信号位</th>
          <th>信号名</th>
          <th>信号描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>output</td>
          <td>[218:88]</td>
          <td>0</td>
          <td>占位，全为0，传递到composer时会忽略</td>
      </tr>
      <tr>
          <td></td>
          <td>87</td>
          <td>resp_meta_providers_1_valid_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>[86:85]</td>
          <td>resp_meta_providers_1_bits_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>84</td>
          <td>resp_meta_providers_0_valid_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>[83:82]</td>
          <td>resp_meta_providers_0_bits_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>[81:79]</td>
          <td>resp_meta_providerResps_1_r_ctr</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>78</td>
          <td>resp_meta_providerResps_1_r_u</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>77</td>
          <td>resp_meta_providerResps_1_r_unconf</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>[76:74]</td>
          <td>resp_meta_providerResps_0_r_ctr</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>73</td>
          <td>resp_meta_providerResps_0_r_u</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>72</td>
          <td>resp_meta_providerResps_0_r_unconf</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>71</td>
          <td>resp_meta_altUsed_1_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>70</td>
          <td>resp_meta_altUsed_0_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>69</td>
          <td>resp_meta_altDiffers_1_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>68</td>
          <td>resp_meta_altDiffers_0_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>[67:66]</td>
          <td>resp_meta_basecnts_1_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>[65:64]</td>
          <td>resp_meta_basecnts_0_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>[63:60]</td>
          <td>resp_meta_allocates_1_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>[59:56]</td>
          <td>resp_meta_allocates_0_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>55</td>
          <td>resp_meta_takens_1_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>54</td>
          <td>resp_meta_takens_0_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>53</td>
          <td>resp_meta_scMeta_tageTakens_1_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>52</td>
          <td>resp_meta_scMeta_tageTakens_0_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>51</td>
          <td>resp_meta_scMeta_scUsed_1_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>50</td>
          <td>resp_meta_scMeta_scUsed_0_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>49</td>
          <td>resp_meta_scMeta_scPreds_1_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>48</td>
          <td>resp_meta_scMeta_scPreds_0_r</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>[47:42]</td>
          <td>r_1_3</td>
          <td>scMeta(预测时的状态)中第2路的第4个sc_ctr的值</td>
      </tr>
      <tr>
          <td></td>
          <td>[41:36]</td>
          <td>r_1_2</td>
          <td>scMeta中第2路的第3个sc_ctr的值</td>
      </tr>
      <tr>
          <td></td>
          <td>[35:30]</td>
          <td>r_1_1</td>
          <td>scMeta中第2路的第2个sc_ctr的值</td>
      </tr>
      <tr>
          <td></td>
          <td>[29:24]</td>
          <td>r_1_0</td>
          <td>scMeta中第2路的第1个sc_ctr的值</td>
      </tr>
      <tr>
          <td></td>
          <td>[23:18]</td>
          <td>r_3</td>
          <td>scMeta中第1路的第4个sc_ctr的值</td>
      </tr>
      <tr>
          <td></td>
          <td>[17:12]</td>
          <td>r_2</td>
          <td>scMeta中第1路的第3个sc_ctr的值</td>
      </tr>
      <tr>
          <td></td>
          <td>[11:6]</td>
          <td>r_1</td>
          <td>scMeta中第1路的第2个sc_ctr的值</td>
      </tr>
      <tr>
          <td></td>
          <td>[5:0]</td>
          <td>r_0</td>
          <td>scMeta中第1路的第1个sc_ctr的值</td>
      </tr>
  </tbody>
</table>
<h3 id="io_update_bits_meta">io_update_bits_meta</h3>
<table>
  <thead>
      <tr>
          <th>信号类型</th>
          <th>信号位</th>
          <th>信号名</th>
          <th>信号描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>input</td>
          <td>[218:94]</td>
          <td></td>
          <td>FTB, ITAGE, RAS 模块传给 FTQ 的 META 信息，忽略</td>
      </tr>
      <tr>
          <td></td>
          <td>[93:6]</td>
          <td>io_out_last_stage_meta[87:0] 偏移 6bit 后的结果</td>
          <td>TAGE 输出给 FTQ 的 META</td>
      </tr>
      <tr>
          <td></td>
          <td>[5:0]</td>
          <td></td>
          <td>uFTB 输出给 FTQ 的 META</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6632ee4bf977f3fe507ff8cc02deba52">4 - FTB Branch Predictor</h1>
    
	<h2 id="introduction-to-ftb">Introduction to FTB</h2>
<p>FTB is the third sub-predictor of the Xiangshan BPU, and it can also get the outputs of uFTB and TAGE-SC together. In the input interface of FTB, the s1 channel contains the basic prediction results of uFTB, and the s2 and s3 channels are filled with only one group of signals, <code>br_taken_mask</code>, by TAGE-SC, without the basic prediction results generated by the FTB entry. The function of FTB is to provide basic prediction results for the s2 and s3 channels.</p>
<p>In terms of functionality and structure, FTB is similar to uFTB. The main difference is that FTB can accommodate more FTB entries, and the prediction results of FTB are output in the s2 and s3 channels. Due to its large capacity, the readout speed of FTB is slower than that of uFTB, and it cannot be placed in the first cycle to generate prediction results. However, the large capacity enables it to obtain more accurate prediction results.</p>
<h2 id="function-of-uftb">Function of uFTB</h2>
<ul>
<li><strong>Cache more FTB entries and provide basic prediction results for the s2 and s3 channels</strong>. The FTB predictor is essentially a storage with a large capacity. It reads the corresponding FTB entry based on the current predicted PC and outputs it in the s2 stage. At the same time, this FTB entry will be saved for one more cycle to generate the s3 stage prediction result. One thing to note is to consider the <code>br_taken_mask</code> field inputted by the previous predictor to avoid losing it during generation.</li>
<li><strong>Update FTB entries based on update requests.</strong></li>
</ul>
<h2 id="ftb-storage-structure">FTB Storage Structure</h2>
<p>FTB entries in the FTB predictor are placed in a dedicated storage structure called <code>FTBBank</code>. Before further examining the structure of <code>FTBBank</code>, let&rsquo;s first see how <code>FTBBank</code> is used.</p>
<h3 id="ftb-read-request">FTB Read Request</h3>
<p>The read request interface of <code>FTBBank</code> is as follows:</p>
<ul>
<li><strong>req_pc</strong> Requested PC
<ul>
<li>Interface type: Flipped(DecoupledIO(UInt(VAddrBits.W)))</li>
</ul>
</li>
<li><strong>read_resp</strong> Read out FTB entry
<ul>
<li>Interface type: FTBEntry</li>
</ul>
</li>
<li><strong>read_hits</strong> Which way (row) is hit
<ul>
<li>Interface type: Valid(UInt(log2Ceil(numWays).W))</li>
</ul>
</li>
</ul>
<p>Among, <code>req_pc</code> interface is Decoupled, meaning it contains valid and ready signals. FTB needs to get the PC before the s1 stage starts, so <code>s0_pc</code> is sent to the <code>req_pc</code> interface, <code>s0_fire</code> signal is connected to the valid signal of <code>req_pc</code>, and the <code>ready</code> signal is connected to the pipeline control signal <code>s1_ready</code>.</p>
<p>When <code>s0_fire</code> enters the s1 stage, in the next cycle, when <code>s0_fire</code> is at the same time as <code>s1_fire</code>, FTBBank has already outputted the readout FTB entry to the <code>read_resp</code> interface, and calculated <code>read_hits</code>. However, at this time, because the readout has wasted too much delay, it cannot be outputted in the s1 stage. Therefore, this readout result is saved in an internal register. It will be read out from the register in the s2 and s3 stages to generate the prediction result.</p>
<h3 id="ftbbank">FTBBank</h3>
<p>FTBBank defines a storage to store all FTB entries. The storage adopts a group-associative structure, with 512 groups (Sets) in total, each group has 4 ways, and can store up to 2048 FTB entries. Besides storing FTB entries, it also stores the tag corresponding to each FTB entry for matching.</p>
<p>Specifically, the tag is defined as <code>pc[29:10]</code>, which takes 20 bits from the PC to identify the FTB entry. The PC is divided as follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Plain" data-lang="Plain"><span style="display:flex;"><span>  pc: | ... |&lt;-- tag(20 bits) --&gt;|&lt;-- idx(9 bits) --&gt;|&lt;-- instOffset(1 bit) --&gt;|
</span></span></code></pre></div><p>When reading, provide the group number (idx) to the storage, read out all ways in that group, and then check if there is a way whose tag matches the current tag. If there is a match, it means a hit, and the readout FTB entry is sent out through the <code>read_resp</code> interface, and the hit way number is sent out through the <code>read_hits</code> interface.</p>
<h2 id="generation-of-prediction-results">Generation of Prediction Results</h2>
<p>As mentioned earlier, for the FTB predictor, it needs to provide basic prediction results derived from FTB entries to the s2 and s3 channels. The FTB entries have been read and saved in the s1 stage. In the s2 and s3 stages, they only need to be read out to generate the prediction results. However, one thing to note is to preserve the <code>br_taken_mask</code> field generated by TAGE-SC in the s2 and s3 prediction results, which provides precise prediction results for conditional branch instructions. For the s1 channel, the FTB predictor does not make any changes.</p>
<p><strong>The generation of signals in the s2 and s3 prediction results can refer to the following list:</strong></p>
<ul>
<li><strong>hit</strong> Whether the FTB entry is hit
<ul>
<li>Generation method: The <code>read_hits</code> signal valid bit from <code>FTBBank</code> is valid.</li>
</ul>
</li>
<li><strong>slot_valids</strong> Slot valid bit, indicating whether each slot in the ftb entry is valid</li>
<li><strong>targets</strong> Jump target address corresponding to each slot</li>
<li><strong>offsets</strong> Instruction offset relative to the start address of the predicted block in each slot</li>
<li><strong>is_jal</strong> Whether the predicted block contains a jal instruction</li>
<li><strong>is_jalr</strong> Whether the predicted block contains a jalr instruction</li>
<li><strong>is_call</strong> Whether the predicted block contains a call instruction</li>
<li><strong>is_ret</strong> Whether the predicted block contains a ret instruction</li>
<li><strong>last_may_be_rvi_call</strong> Signal indicating that the end of the predicted block may be an RVI type call instruction</li>
<li>**is_br_sharing Whether the last slot (tailSlot) stores a conditional branch instruction signal
<ul>
<li>Generation method**: Export from the corresponding field in the FTB entry</li>
</ul>
</li>
<li><strong>fallThroughErr</strong> Error in the <code>pftAddr</code> recorded in the FTB entry
<ul>
<li>Generation method: Compare whether the address represented by <code>pftAddr</code> is greater than the start address of the predicted block. If it is less than, it indicates an error, and this signal is set to valid. This situation may occur when the PC indexes an incorrect FTB entry.</li>
</ul>
</li>
<li><strong>fallThroughAddr</strong> End address of the predicted block
<ul>
<li>Generation method: If <code>fallThroughErr</code> is invalid, it is generated according to <code>pftAddr</code>. Otherwise, it is set to the start address + prediction width.</li>
</ul>
</li>
<li><strong>br_taken_mask</strong> Branch prediction result, each branch (slot) corresponds to a bit, indicating whether the branch is predicted as taken
<ul>
<li>Generation method: Generated based on the <code>always_taken</code> field in the FTB entry and the indication result of the two-bit saturation counter.</li>
</ul>
</li>
<li><strong>jalr_target</strong> Jump target of jalr in this predicted block
<ul>
<li>Generation method: Jump target in the tailSlot of the FTB entry.</li>
</ul>
</li>
</ul>
<h3 id="ftb-meta">FTB meta</h3>
<p>In the third cycle of prediction, the FTB predictor outputs some auxiliary information of this prediction to <code>last_stage_meta</code> and also sends the read FTB entry to the <code>last_stage_ftrb_entry</code> interface.</p>
<p>The FTB meta contains two pieces of information, <code>hit</code> and <code>writeWay</code>, indicating whether the prediction hits and in which way it is read. Subsequently, the update channel generates the update information for this prediction, and these two pieces of information are also sent to guide the writing of the updated FTB entry.</p>
<h2 id="ftb-update">FTB Update</h2>
<p>In the update channel, the pc and the new FTB entry are already specified for us, along with the <code>hit</code> and <code>writeWay</code> in the meta information. If <code>hit</code> in the meta is valid, it means that the FTB entry corresponding to this pc was stored in the memory, and we only need to write it to the corresponding way.</p>
<p>If it is invalid, it means that there was no storage before, but we do not know whether it is stored now. It is possible that before this update request, the FTB entry corresponding to this pc was written by another update request. Therefore, we still need to send a read request to FTBBank to check if there is a corresponding FTB entry. If it exists, it can be directly written to this position in the next cycle, otherwise, FTBBank will be notified to allocate a new position.</p>
<p>Therefore, the number of cycles required for updating FTB entries depends on the hit situation.</p>
<p>Let&rsquo;s first look at how FTBBank handles updates.</p>
<h3 id="ftbbank-update">FTBBank Update</h3>
<p>FTBBank&rsquo;s update interface is divided into two parts, the update read interface and the update write interface.</p>
<ul>
<li><strong>u_req_pc</strong>: Update read request pc
<ul>
<li><code>Flipped(DecoupledIO(UInt(VAddrBits.W)))</code></li>
</ul>
</li>
<li><strong>update_hits</strong>: Hit information read out
<ul>
<li><code>Valid(UInt(log2Ceil(numWays).W))</code></li>
</ul>
</li>
<li><strong>update_access</strong>: There is an update request but the meta information indicates a miss
<ul>
<li><code>Bool()</code></li>
</ul>
</li>
<li><strong>update_pc</strong>: Update write request pc
<ul>
<li><code>UInt(VAddrBits.W))</code></li>
</ul>
</li>
<li><strong>update_write_data</strong>: Data to be written in the update request, write when valid
<ul>
<li><code>Flipped(Valid(new FTBEntryWithTag))</code></li>
</ul>
</li>
<li><strong>update_write_way</strong>: Way index to write in the update request
<ul>
<li><code>UInt(log2Ceil(numWays).W))</code></li>
</ul>
</li>
<li><strong>update_write_alloc</strong>: Whether a new FTB entry needs to be allocated (missed before)
<ul>
<li><code>Bool()</code></li>
</ul>
</li>
</ul>
<p><strong>For the update read interface</strong>, FTBBank obtains the update read request through <code>u_req_pc</code> signal. This request has a higher priority than the read request during prediction. In the next cycle, FTBBank will output the hit information through the <code>update_hits</code> interface. <code>update_access</code> is only used for some internal status judgments of FTBBank.</p>
<p><strong>For the update write interface</strong>, FTBBank obtains the pc of the update write request through the <code>update_pc</code> signal, and when <code>update_write_data</code> is valid, it writes the data into the corresponding position specified by <code>update_write_way</code>. If <code>update_write_alloc</code> is valid, it means that it cannot be directly written to the position specified in the request, but a new position needs to be allocated.</p>
<p><strong>The allocation strategy is as follows</strong>:</p>
<ul>
<li>If all ways are filled, use the pseudo LRU replacement algorithm to select the way to replace</li>
<li>If there is an empty way, select the empty way.</li>
</ul>
<h3 id="update-request-timing">Update Request Timing</h3>
<ul>
<li><strong>Meta hit is valid</strong>: If hit in the update request meta is valid, then we only need to specify the address and data to be written according to the information in the update request, and the writing only takes one cycle.</li>
<li><strong>Meta hit is invalid</strong>: In this case, after receiving the update request, we connect the pc in the request to the read port of FTBBank. The read port will return the result in the next cycle. Due to timing issues, we save this result and use it in the next cycle. Depending on the hit status in the result, we decide whether to set <code>update_write_alloc</code> and send a write request. The entire update process takes three cycles.</li>
</ul>
<h2 id="interface-list">Interface List</h2>
<table>
  <thead>
      <tr>
          <th>信号类型</th>
          <th>信号位</th>
          <th>信号名</th>
          <th>信号描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>input</td>
          <td></td>
          <td>clock</td>
          <td>输入时钟</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>reset</td>
          <td>复位信号</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[35:0]</td>
          <td>io_reset_vector</td>
          <td>用于reset时，reset s1_pc_dup_0 提供的值</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_s0_pc_0</td>
          <td>输入位s0_pc 的 第0个复制</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_s0_pc_1</td>
          <td>同上 第1个</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_s0_pc_2</td>
          <td>同上 第2个</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_s0_pc_3</td>
          <td>同上 第3个</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_0_br_taken_mask_0</td>
          <td>预测结果输入</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_0_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_1_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_1_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_3_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_3_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_0_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_0_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_1_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_1_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_3_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_3_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_0_br_taken_mask_0</td>
          <td>s2 阶段输出的完整预测结果</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_0_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_0_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_0_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_0_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_0_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_0_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_0_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_0_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_0_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_0_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_0_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_1_br_taken_mask_0</td>
          <td>同上</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_1_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_1_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_1_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_1_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_1_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_1_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_1_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_1_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_1_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_1_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_1_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_br_taken_mask_0</td>
          <td>同上</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_2_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_2_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_2_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_2_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_2_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_2_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_is_jalr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_is_call</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_is_ret</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_last_may_be_rvi_call</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_3_br_taken_mask_0</td>
          <td>同上</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_3_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_3_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_3_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_3_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_3_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_3_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_3_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_3_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_3_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_3_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_3_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_3_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_0_br_taken_mask_0</td>
          <td>s3 阶段输出的完整预测结果</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_0_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_0_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_0_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_0_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_0_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_0_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_0_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_0_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_0_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_0_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_1_br_taken_mask_0</td>
          <td>同上</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_1_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_1_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_1_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_1_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_1_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_1_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_1_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_1_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_1_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_1_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_br_taken_mask_0</td>
          <td>同上</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_2_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_2_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_2_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_2_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_is_jalr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_is_call</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_is_ret</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_3_br_taken_mask_0</td>
          <td>同上</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_3_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_3_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_3_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_3_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_3_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_3_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s3_full_pred_3_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s3_full_pred_3_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_3_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_3_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_3_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_3_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[222:0]</td>
          <td>io_out_last_stage_meta</td>
          <td>最后一个阶段输出的 meta 信息</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_valid</td>
          <td>最后一个阶段输出的 FTB 项</td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_last_stage_ftb_entry_brSlots_0_offset</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[11:0]</td>
          <td>io_out_last_stage_ftb_entry_brSlots_0_lower</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[1:0]</td>
          <td>io_out_last_stage_ftb_entry_brSlots_0_tarStat</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_brSlots_0_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_brSlots_0_valid</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_last_stage_ftb_entry_tailSlot_offset</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[19:0]</td>
          <td>io_out_last_stage_ftb_entry_tailSlot_lower</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[1:0]</td>
          <td>io_out_last_stage_ftb_entry_tailSlot_tarStat</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_tailSlot_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_tailSlot_valid</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_last_stage_ftb_entry_pftAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_carry</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_isCall</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_isRet</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_isJalr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_last_may_be_rvi_call</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_always_taken_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_always_taken_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_ctrl_btb_enable</td>
          <td>使能信号</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s0_fire_0</td>
          <td>s0 阶段流水线控制信号</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s0_fire_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s0_fire_2</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s0_fire_3</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_s1_ready</td>
          <td>s1 阶段流水线控制信号</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s1_fire_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s1_fire_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s1_fire_2</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s1_fire_3</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s2_fire_0</td>
          <td>s2 阶段流水线控制信号</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s2_fire_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s2_fire_2</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s2_fire_3</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_valid</td>
          <td>更新有效性</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_update_bits_pc</td>
          <td>传回的预测块pc（用于指示更新的预测块）</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_valid</td>
          <td>是否启用</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_update_bits_ftb_entry_brSlots_0_offset</td>
          <td>solt 0 中分支指令相对于地址块起始pc的偏移</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[11:0]</td>
          <td>io_update_bits_ftb_entry_brSlots_0_lower</td>
          <td>跳转目标地址的低位</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[1:0]</td>
          <td>io_update_bits_ftb_entry_brSlots_0_tarStat</td>
          <td>跳转后的 pc 高位是否进退位</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_brSlots_0_sharing</td>
          <td>无条件跳转指令槽中存储条件分支指令</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_brSlots_0_valid</td>
          <td>是否启用</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_update_bits_ftb_entry_tailSlot_offset</td>
          <td>solt 1 中分支指令相对于地址块起始pc的偏移</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[19:0]</td>
          <td>io_update_bits_ftb_entry_tailSlot_lower</td>
          <td>跳转目标地址的低位</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[1:0]</td>
          <td>io_update_bits_ftb_entry_tailSlot_tarStat</td>
          <td>跳转后的 pc 高位是否进退位</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_tailSlot_sharing</td>
          <td>无条件跳转指令槽中存储条件分支指令</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_tailSlot_valid</td>
          <td>是否启用</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_update_bits_ftb_entry_pftAddr</td>
          <td>Partial Fallthrough Addr 如果预测块中没有跳转，那么程序将会顺序执行到达的地址，预测块的结束地址。</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_carry</td>
          <td>pc+pft时是否产生进位</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_isCall</td>
          <td>是否是函数调用</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_isRet</td>
          <td>是否是函数返回</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_isJalr</td>
          <td>是否是 jalr 指令</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_last_may_be_rvi_call</td>
          <td>最后一个指令槽存储的可能是 rvi 的 call 指令</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_always_taken_0</td>
          <td>是否预测为总是跳转</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_always_taken_1</td>
          <td>是否预测为总是跳转</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_old_entry</td>
          <td>是否是旧的 FTB 项</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[222:0]</td>
          <td>io_update_bits_meta</td>
          <td>meta 信息</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-dfa5c2dea93e89d4c1a93d678a387d97">5 - ITTAGE Branch Predictor</h1>
    
	<h2 id="function-introduction">Function Introduction</h2>
<p>For general conditional branch instructions, only predicting whether to jump (taken) or not (not taken) is needed. However, for <strong>indirect jumps</strong>, such as call/jump instructions, it is necessary to predict <strong>where to jump to</strong> (Target). In order to make TAGE support predicting jump addresses, ITTAGE (Indirect Target TAGE) was introduced.</p>
<p>The <strong>main difference</strong> between ITTAGE and TAGE is that in the T0 and Tn tables, Target PC data is added. During prediction, ITTAGE selects the Target from the matched, longest history entry as the prediction result, and uses a 2-bit saturating counter to decide whether to output this result or choose an alternative prediction result. For TAGE predictor details, please refer to <a href="../02_tage_sc/">TAGE-SC Branch Predictor</a>.</p>
<h2 id="kunming-lake-ittage-branch-predictor">Kunming Lake ITTAGE Branch Predictor</h2>
<p>In the BPU design of Kunming Lake, prediction is performed in a cascaded manner with multiple predictors, so the implementation of the subpredictor differs from the original predictor, mainly in the default prediction result.</p>
<h3 id="basic-functionality">Basic Functionality</h3>
<p>ITTAGE&rsquo;s basic functionality is similar to the TAGE branch predictor, but with the following differences:</p>
<ol>
<li>The Target is added as a jump target address item in the entry to predict the jump target address.</li>
<li>The saturating counter ctr no longer provides the prediction direction, but instead decides whether to output the result (just the prediction information).</li>
<li>Since there is only one indirect jump instruction in each branch prediction block, ITTAGE only considers one instruction.</li>
</ol>
<h3 id="pipeline">Pipeline</h3>
<p>ITTAGE <strong>contains three pipeline stages</strong>, the first stage calculates the index, and the second stage reads the result from the SRAM table using the index.</p>
<ol>
<li>Cycle 0, s0: Input of the first pipeline stage, generally pc and folded history.</li>
</ol>
<p><strong>Operation of the first pipeline stage</strong>：Calculate the index. Output through registers to s1.</p>
<ol>
<li>Cycle 1, s1: Input of the second pipeline stage, the index and other data calculated in the first stage.</li>
</ol>
<p><strong>Operation of the second pipeline stage</strong>：Access SRAM, read prediction information. Output through registers to s2.</p>
<ol>
<li>Cycle 2, s2: Input of the third pipeline stage, the original prediction information read from SRAM in the second stage.</li>
</ol>
<p><strong>Operation of the third pipeline stage</strong>：Process the original prediction information, decide whether to output the prediction result.</p>
<ol>
<li>Cycle 3, s3: Prediction result ready, the prediction result can now be used.</li>
</ol>
<h3 id="data-structure">Data Structure</h3>
<p>In the Kunming Lake implementation, the table structure of T0 and Tn is as follows:</p>
<table>
  <thead>
      <tr>
          <th><strong>预测器</strong></th>
          <th><strong>作用</strong></th>
          <th><strong>表项构成</strong></th>
          <th><strong>项数</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>基准预测器T0</td>
          <td>用于在其他预测器的预测结果都无效时输出预测结果</td>
          <td>虚表，不存在。 直接将上级预测器FTB 的预测结果作为表项结果</td>
          <td>虚表，不存在。 直接将上级预测器FTB结果作为索引到的结果</td>
      </tr>
      <tr>
          <td>预测表T1-T2</td>
          <td>对每个预测块的输入，所有Tn表都进行预测，在所有预测有效的结果中，选择历史记录最长的结果作为 原始预测信息。历史记录长度由输入的H决定</td>
          <td>target：41 bitsvalid 1bittag 9bitsctr 2bitsus: 1bit（usefulness计数器）</td>
          <td>256项</td>
      </tr>
      <tr>
          <td>预测表T3-T5</td>
          <td>512项</td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="t0tntable-retrieval-method">T0，TnTable Retrieval Method</h3>
<p>The retrieval method is consistent with the TAGE branch predictor, only differing in the configuration options of each table.</p>
<table>
  <thead>
      <tr>
          <th><strong>表名称</strong></th>
          <th><strong>FH长度</strong></th>
          <th><strong>FH1长度</strong></th>
          <th><strong>FH2长度</strong></th>
          <th><strong>最近历史长度（用到GH中的位数）</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>T1</td>
          <td>4比特</td>
          <td>4比特</td>
          <td>4比特</td>
          <td>低4位，即把最新4位历史，折叠成FH、FH1、FH2</td>
      </tr>
      <tr>
          <td>T2</td>
          <td>8比特</td>
          <td>8比特</td>
          <td>8比特</td>
          <td>低8位，即把最新8位历史，折叠成FH、FH1、FH2</td>
      </tr>
      <tr>
          <td>T3</td>
          <td>9比特</td>
          <td>9比特</td>
          <td>8比特</td>
          <td>低13位，即把最新13位历史，折叠成FH、FH1、FH2</td>
      </tr>
      <tr>
          <td>T4</td>
          <td>9比特</td>
          <td>9比特</td>
          <td>8比特</td>
          <td>低16位，即把最新16位历史，折叠成FH、FH1、FH2</td>
      </tr>
      <tr>
          <td>T5</td>
          <td>9比特</td>
          <td>9比特</td>
          <td>8比特</td>
          <td>低32位，即把最新32位历史，折叠成FH、FH1、FH2</td>
      </tr>
  </tbody>
</table>
<p>Other processes (<strong>computation method</strong> and <strong>computation formula</strong>) are similar to the <a href="../02_tage_sc/#MZk7dpG3woapSUx3XO9ceJShn0e">TAGE-SC branch predictor</a>.</p>
<h3 id="alternate-predictor">Alternate Predictor</h3>
<p>When the prediction result given by the Tn table has insufficient &ldquo;prediction confidence,&rdquo; the prediction result needs to be jumped to become an &ldquo;alternate predictor.&rdquo; This process is similar to TAGE. For details, please refer to the corresponding part of TAGE. Unlike TAGE, ITTAGE&rsquo;s ctr does not give the prediction direction but only determines whether to output the result (prediction confidence). When ctr is 2b00, it is considered weak confidence. Choose the alternate prediction result:</p>
<ol>
<li><strong>If multiple tables are hit</strong>, output the Target from the second-longest history table entry.</li>
<li>Otherwise, output the T0 Target (FTB Target).</li>
</ol>
<h3 id="prediction-process">Prediction Process</h3>
<p>The prediction process is similar to TAGE, but ITTAGE has an additional step to decide whether to output the prediction result based on ctr. The specific process is as follows:</p>
<ol>
<li>When the ctr of the ITTAGE table entry is not 2b00, output Target.</li>
<li>When the ctr of the ITTAGE table entry is 2b00, output the alternate prediction result:
<ol>
<li>If there is a second-longest history (the second table is also hit), output the Target of the second-longest.</li>
<li>Otherwise, output the FTB Target.</li>
</ol>
</li>
<li>When the ITTAGE table entry is not hit, output the T0 Target (FTB Target).</li>
</ol>
<h3 id="training-process">Training Process</h3>
<p>This process is similar to TAGE, with the following differences:</p>
<ol>
<li>Table entry updates (original prediction data):
<ol>
<li>ctr:
<ol>
<li>If the predicted address matches the actual address, increment the ctr counter of the corresponding provider table entry by 1.</li>
<li>If the predicted address does not match the actual address, decrement the ctr counter of the corresponding provider table entry by 1.</li>
<li>In ITTAGE, it is determined based on ctr whether to adopt the jump target result of this prediction. If multiple tables are hit and the ctr of the longest history table is 0, adopt the alternate prediction logic (the second-longest history table or T0). Always update the longest history table during updates, and also update the alternate prediction table if the alternate prediction is adopted.</li>
</ol>
</li>
<li>target:
<ol>
<li>When the ctr of the table entry to be updated is 0 during this prediction, directly store the actual final jump result in the target, overwriting it.</li>
<li>When applying for a new table entry, directly store the actual final jump result in the target.</li>
<li>Otherwise, do not modify the target.</li>
</ol>
</li>
<li>usefulness:
<ol>
<li>When the provider&rsquo;s prediction is correct but the alternate prediction is incorrect, set the provider&rsquo;s usefulness to 1.</li>
<li>If the alternate prediction has weak confidence and is correct, set the provider&rsquo;s usefulness to 1. If the alternate prediction has weak confidence and is incorrect, set the provider&rsquo;s usefulness to 0.</li>
</ol>
</li>
<li>New table entry:
<ol>
<li>Each time the prediction from the longest history table with confidence is incorrect (not due to using the alternate prediction), try to randomly apply for a table entry from a longer history table. The condition for application is that the usefulness of the corresponding entry is 0.</li>
<li>If all longer entries are not 0, the allocation fails.</li>
</ol>
</li>
</ol>
</li>
<li>Reset useful bit:
<ol>
<li>Each time a prediction error occurs and a new table entry is applied for, if the allocation fails, increment tickCtr (an 8-bit saturated counter used to reset all usefulness). If successful, decrement tickCtr.</li>
<li>When tickCtr reaches its maximum value, set all usefulness in ITTAGE to 0 and reset tickCtr to 0.</li>
</ol>
</li>
</ol>
<h2 id="interface-list">Interface List</h2>
<table>
  <thead>
      <tr>
          <th>接口类型</th>
          <th>位宽</th>
          <th>信号名</th>
          <th>备注</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>input</td>
          <td></td>
          <td>clock</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>reset</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_s0_pc_3</td>
          <td>用于预测的PC</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[7:0]</td>
          <td>io_in_bits_folded_hist_3_hist_14_folded_hist</td>
          <td>T2 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[8:0]</td>
          <td>io_in_bits_folded_hist_3_hist_13_folded_hist</td>
          <td>T3 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_in_bits_folded_hist_3_hist_12_folded_hist</td>
          <td>T1 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[8:0]</td>
          <td>io_in_bits_folded_hist_3_hist_10_folded_hist</td>
          <td>T5 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[8:0]</td>
          <td>io_in_bits_folded_hist_3_hist_6_folded_hist</td>
          <td>T4 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[7:0]</td>
          <td>io_in_bits_folded_hist_3_hist_4_folded_hist</td>
          <td>T3 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[7:0]</td>
          <td>io_in_bits_folded_hist_3_hist_3_folded_hist</td>
          <td>T5 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[7:0]</td>
          <td>io_in_bits_folded_hist_3_hist_2_folded_hist</td>
          <td>T4 折叠历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_0_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_1_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_3_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_0_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_1_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_2_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_3_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[222:0]</td>
          <td>io_out_last_stage_meta</td>
          <td>[100:0] 有效，是ITTAGE的Meta信息</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s0_fire_3</td>
          <td>s0阶段使能信号</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s1_fire_3</td>
          <td>s1阶段使能信号</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s2_fire_0</td>
          <td>s2阶段使能信号，相同</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s2_fire_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s2_fire_2</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_s2_fire_3</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_valid</td>
          <td>是否进行更新</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_update_bits_pc</td>
          <td>待更新的预测块pc索引</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[7:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_14_folded_hist</td>
          <td>T2 更新时传入的历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[8:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_13_folded_hist</td>
          <td>T3 更新时传入的历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_12_folded_hist</td>
          <td>T1 更新时传入的历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[8:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_10_folded_hist</td>
          <td>T5 更新时传入的历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[8:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_6_folded_hist</td>
          <td>T4 更新时传入的历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[7:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_4_folded_hist</td>
          <td>T3 更新时传入的历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[7:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_3_folded_hist</td>
          <td>T5 更新时传入的历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[7:0]</td>
          <td>io_update_bits_spec_info_folded_hist_hist_2_folded_hist</td>
          <td>T4 更新时传入的历史</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_update_bits_ftb_entry_tailSlot_offset</td>
          <td>待更新的FTB项offset</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_tailSlot_sharing</td>
          <td>待更新的FTB项是否是有条件跳转</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_tailSlot_valid</td>
          <td>待更新的tailSlot是否启用</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_isRet</td>
          <td>tailSlot是否是Ret指令</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_ftb_entry_isJalr</td>
          <td>tailSlot是否是Jalr指令</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_cfi_idx_valid</td>
          <td>控制流指令在预测块中的索引.valid信号</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_update_bits_cfi_idx_bits</td>
          <td>控制流指令在预测块中的索引</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_jmp_taken</td>
          <td>预测块内无条件跳转指令被触发</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_update_bits_mispred_mask_2</td>
          <td>是否预测错误</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[222:0]</td>
          <td>io_update_bits_meta</td>
          <td>预测时传出 meta 信息的[222:25] 即{25h0, _ubtb_io_out_last_stage_meta[5:0] ,_tage_io_out_last_stage_meta[87:0] ,_ftb_io_out_last_stage_meta[2:0], _ittage_io_out_last_stage_meta[100:0]}</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_update_bits_full_target</td>
          <td>预测块的跳转目标（下一个预测块的起始地址）</td>
      </tr>
  </tbody>
</table>
<h3 id="pass-through-signals-that-do-not-have-an-impact">Pass-through signals that do not have an impact</h3>
<details>
    <summary> These signals do not have an impact and are not important</summary>
    <table>
  <thead>
      <tr>
          <th>接口类型</th>
          <th>位宽</th>
          <th>信号名</th>
          <th>备注</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_0_br_taken_mask_0</td>
          <td>从FTB输入 完全透传到输出 包括jalr_target</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_0_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_0_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_0_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_0_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_0_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_0_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_0_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_0_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_0_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_0_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_0_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_1_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_1_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_1_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_1_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_1_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_1_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_1_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_1_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_1_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_1_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_1_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_1_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_is_jalr</td>
          <td>RAS 模块使用的信息，透传</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_is_call</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_is_ret</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_last_may_be_rvi_call</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_is_br_sharing</td>
          <td>从FTB输入 完全透传到输出 包括jalr_target  fallThroughErr  表示 FTB项 中记录的 pftAddr 有误 生成方式：比较 pftAddr 代表的预测块结束地址是否大于预测块的起始地址，如果小于，则代表出现错误，此信号置为有效。这种情况可能会发生在 pc 索引到错误的 FTB 项的情况。 FTQ使用这个变量，与ITTAGE无关</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_2_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_3_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_3_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_3_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_3_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_3_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_3_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_3_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_3_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_3_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s2_full_pred_3_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_3_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_3_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s2_full_pred_3_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_0_br_taken_mask_0</td>
          <td>除了 jalr_target 可能被修改，其他都是透传</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_0_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_0_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_0_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_0_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_0_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_0_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_0_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_0_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_0_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_1_br_taken_mask_0</td>
          <td>同上</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_1_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_1_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_1_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_1_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_1_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_1_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_1_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_1_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_1_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_br_taken_mask_0</td>
          <td>同上</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_is_jalr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_is_call</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_is_ret</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_2_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_3_br_taken_mask_0</td>
          <td>同上</td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_3_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_3_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_3_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_3_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_3_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_3_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_3_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[40:0]</td>
          <td>io_in_bits_resp_in_0_s3_full_pred_3_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_3_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_3_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_s3_full_pred_3_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_valid</td>
          <td>透传到output，不做修改 来源是FTB</td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_brSlots_0_offset</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[11:0]</td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_brSlots_0_lower</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[1:0]</td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_brSlots_0_tarStat</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_brSlots_0_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_brSlots_0_valid</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_tailSlot_offset</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[19:0]</td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_tailSlot_lower</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[1:0]</td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_tailSlot_tarStat</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_tailSlot_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_tailSlot_valid</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td>[3:0]</td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_pftAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_carry</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_isCall</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_isRet</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_isJalr</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_last_may_be_rvi_call</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_always_taken_0</td>
          <td></td>
      </tr>
      <tr>
          <td>input</td>
          <td></td>
          <td>io_in_bits_resp_in_0_last_stage_ftb_entry_always_taken_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_0_br_taken_mask_0</td>
          <td>完全透传传入值 prefix: io_in_bits_resp_in_</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_0_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_0_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_0_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_0_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_0_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_0_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_0_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_0_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_0_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_0_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_0_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_1_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_1_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_1_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_1_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_1_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_1_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_1_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_1_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_1_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_1_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_1_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_1_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_2_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_2_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_2_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_2_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_2_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_2_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_is_jalr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_is_call</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_is_ret</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_last_may_be_rvi_call</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_2_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_3_br_taken_mask_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_3_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_3_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_3_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_3_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_3_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_3_jalr_target</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_3_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s2_full_pred_3_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s2_full_pred_3_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_3_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_3_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s2_full_pred_3_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_0_br_taken_mask_0</td>
          <td>见对应prefix的输入</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_0_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_0_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_0_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_0_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_0_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_0_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_0_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_0_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_0_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_1_br_taken_mask_0</td>
          <td>见对应prefix的输入</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_1_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_1_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_1_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_1_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_1_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_1_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_1_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_1_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_1_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_br_taken_mask_0</td>
          <td>见对应prefix的输入</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_2_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_2_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_2_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_is_jalr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_is_call</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_is_ret</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_2_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_3_br_taken_mask_0</td>
          <td>见对应prefix的输入</td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_3_br_taken_mask_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_3_slot_valids_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_3_slot_valids_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_3_targets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_3_targets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s3_full_pred_3_offsets_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_s3_full_pred_3_offsets_1</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[40:0]</td>
          <td>io_out_s3_full_pred_3_fallThroughAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_3_fallThroughErr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_3_is_br_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_s3_full_pred_3_hit</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_valid</td>
          <td>完全透传传入的值</td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_last_stage_ftb_entry_brSlots_0_offset</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[11:0]</td>
          <td>io_out_last_stage_ftb_entry_brSlots_0_lower</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[1:0]</td>
          <td>io_out_last_stage_ftb_entry_brSlots_0_tarStat</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_brSlots_0_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_brSlots_0_valid</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_last_stage_ftb_entry_tailSlot_offset</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[19:0]</td>
          <td>io_out_last_stage_ftb_entry_tailSlot_lower</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[1:0]</td>
          <td>io_out_last_stage_ftb_entry_tailSlot_tarStat</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_tailSlot_sharing</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_tailSlot_valid</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td>[3:0]</td>
          <td>io_out_last_stage_ftb_entry_pftAddr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_carry</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_isCall</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_isRet</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_isJalr</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_last_may_be_rvi_call</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_always_taken_0</td>
          <td></td>
      </tr>
      <tr>
          <td>output</td>
          <td></td>
          <td>io_out_last_stage_ftb_entry_always_taken_1</td>
          <td></td>
      </tr>
  </tbody>
</table>
</details>
<h2 id="other-meta-information-can-be-found-in-the-corresponding-sub-predictor-documentation">Other Meta information can be found in the corresponding sub-predictor documentation</h2>
<p>_ubtb_io_out_last_stage_meta</p>
<p>_tage_io_out_last_stage_meta</p>
<p>_ftb_io_out_last_stage_meta</p>
<h2 id="ittage_io_out_last_stage_meta1000">ittage_io_out_last_stage_meta[100:0]</h2>
<table>
  <thead>
      <tr>
          <th>位宽</th>
          <th>信号名</th>
          <th>备注</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>100</td>
          <td>s3_provided</td>
          <td>是否有结果</td>
      </tr>
      <tr>
          <td>[99:97]</td>
          <td>s3_provider</td>
          <td>提供结果的表项</td>
      </tr>
      <tr>
          <td>96</td>
          <td>s3_altProvided</td>
          <td>是否有替代预测表项</td>
      </tr>
      <tr>
          <td>[95:93]</td>
          <td>s3_altProvider</td>
          <td>提供结果的替代预测表项</td>
      </tr>
      <tr>
          <td>92</td>
          <td>resp_meta_altDiffers</td>
          <td>替代预测是否是弱信心的（FTB不算）</td>
      </tr>
      <tr>
          <td>91</td>
          <td>s3_providerU</td>
          <td>主预测的useful bit</td>
      </tr>
      <tr>
          <td>[90:89]</td>
          <td>s3_providerCtr</td>
          <td>主预测给出的置信度</td>
      </tr>
      <tr>
          <td>[88:87]</td>
          <td>s3_altProviderCtr</td>
          <td>替代预测给出的置信度</td>
      </tr>
      <tr>
          <td>86</td>
          <td>resp_meta_allocate_valid_r</td>
          <td>有空余的表项可供申请</td>
      </tr>
      <tr>
          <td>[85:83]</td>
          <td>resp_meta_allocate_bits_r</td>
          <td>申请哪个表中的表项</td>
      </tr>
      <tr>
          <td>82</td>
          <td>s3_tageTaken_dup_3</td>
          <td>在不使用FTB的情况下始为true，使用FTB也为true</td>
      </tr>
      <tr>
          <td>[81:41]</td>
          <td>s3_providerTarget</td>
          <td>主预测给出的跳转地址</td>
      </tr>
      <tr>
          <td>[40:0]</td>
          <td>s3_altProviderTarget</td>
          <td>替代预测给出的跳转地址</td>
      </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8ab5cccc33deee27c69e7976949364c2">6 - RAS Branch Predictor</h1>
    
	<h2 id="ras介绍">RAS介绍</h2>
<p>RAS stands for &ldquo;Return Address Stack.&rdquo; It helps determine branch behavior in programs by tracking return addresses. As previously mentioned, there are many branches in a program: if/else, switch/case, while/for loop, iteration, call/return, etc. The RAS branch predictor specifically targets call/return types.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000">function</span> <span style="color:#000">_add</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">){</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span> <span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#0000cf;font-weight:bold">0</span> <span style="color:#a40000">?</span> <span style="color:#000">a</span> <span style="color:#000;font-weight:bold">:</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">)</span>  <span style="color:#ce5c00;font-weight:bold">+</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">b</span> <span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#a40000">?</span> <span style="color:#000">b</span> <span style="color:#000;font-weight:bold">:</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000">function</span> <span style="color:#000">add</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">){</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000">a</span> <span style="color:#ce5c00;font-weight:bold">+</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000">function</span> <span style="color:#000">sub</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">){</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000">a</span> <span style="color:#ce5c00;font-weight:bold">-</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000">function</span> <span style="color:#000">main</span><span style="color:#000;font-weight:bold">(){</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">a</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">b</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">2</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">c</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">add</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">d</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">sub</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre></div><p>As shown above, the main function calls add and sub, and add calls the function _add. In this process, each call&rsquo;s jump address and return address are fixed, and the return address can be obtained at the time of the call. The function call process is a &ldquo;stack push and pop&rdquo; process, so branch prediction can be performed using a &ldquo;stack&rdquo; structure: each time a call instruction is encountered, the current PC+4 (compressed instructions and regular instructions have different offsets) is pushed onto the stack; when a return instruction is encountered, a pop operation is performed, and the address obtained is the target jump address. In the block-based BPU, RAS cannot know whether the current block is a call or ret, so it relies on other predictors, using the results of previous predictors for RAS operations.</p>
<p>Specifically, in Xiangshan&rsquo;s RAS predictor, at the s2 stage, it needs to determine whether the previous stage&rsquo;s s2 output predicts a call or ret (i.e., the input signal io.s2_full_pred.hit_taken_on_call/ret is valid). If it&rsquo;s a call, it pushes the subsequent instruction address onto the stack; if it&rsquo;s a ret, it pops the address from the stack as the prediction result. Because in the BPU predictor, the result obtained at the s3 stage is assumed to be better than the s2 stage, the RAS predictor needs to check at the s3 stage. If the previous stage&rsquo;s s3 prediction result is inconsistent with s2, the s3 result is taken, and it needs to determine whether to cancel or complete the stack operations of the previous s2 stage as needed. For example, if the s2 stage predicted a call instruction and performed a push operation, but s3 predicted a regular branch instruction with no need for any operation, the push must be canceled; if s2 predicted a regular branch instruction and s3 predicted a call, a push operation must be performed to complete.</p>
<h2 id="ras-stack-operations">RAS Stack Operations</h2>
<p>In RAS design, function return addresses are predicted using a stack. Ideally, this section assumes that RAS can be backed up at any time, with the stack top pointer represented by sp and the predicted address represented by paddr. The basic RAS operations are as follows:</p>
<ol>
<li>
<h3 id="push">PUSH</h3>
</li>
</ol>
<p>Since predictions can be wrong, the current stack state needs to be backed up (often referred to as a &ldquo;snapshot&rdquo; in software; this term is also used in subsequent content). When encountering a call instruction, get the return address of the call instruction addr = current pc + 4 (if it&rsquo;s a compressed instruction, addr = pc+2), then push onto the stack: sp = addr; sp += 1.</p>
<ol start="2">
<li>
<h3 id="pop">POP</h3>
</li>
</ol>
<p>For the same reason, take a snapshot of the current stack, marked as s. When encountering a ret instruction, the predicted jump address is paddr = sp, then pop: sp = sp - 1. Take a snapshot of the current stack, marked as s.</p>
<ol start="3">
<li>
<h3 id="redirect-operation">Redirect Operation</h3>
</li>
</ol>
<p>Since the BPU predicts program branches, there are &ldquo;correct predictions&rdquo; and &ldquo;wrong predictions.&rdquo; When the CPU backend detects a branch prediction error, it performs a redirect operation, informing the BPU where the prediction was wrong and what the correct result is. During redirection, the RAS module receives the correct branch and the RAS stack information at the time of prediction. Depending on the type of correct branch instruction, the following snapshot recovery situations arise:</p>
<p>(1) The previously predicted instruction is actually a call instruction, and the push operation is executed based on the addr address provided in the redirect.
(2) The previously predicted instruction is actually a ret instruction, and the pop operation is executed.</p>
<ol start="4">
<li>
<h3 id="commit-operation">Commit Operation</h3>
</li>
</ol>
<p>The commit operation is when the backend informs the frontend that the previous prediction was correct. Ideally, the RAS predictor doesn&rsquo;t need to perform any operations at this time.</p>
<h2 id="implementation-of-ras-in-kunming-lake">Implementation of RAS in Kunming Lake</h2>
<p>In actual circuit design, an infinitely large stack is impossible, and constant backups are not feasible. Therefore, in Kunming Lake&rsquo;s RAS implementation, the problems and solutions are as follows:</p>
<h3 id="how-to-obtain-ras-stack-snapshots-for-each-prediction"><strong>How to obtain RAS stack snapshots for each prediction?</strong></h3>
<p>To achieve the function of taking snapshots of the RAS stack, Kunming Lake adopts a <strong>linked representation</strong> based on a circular array. The design is as follows:</p>
<image src="Linked_RAS.png" width="800px">
<p>As shown above, a circular array is used for data management. The circular array has a starting address marked as BOS and a tail pointer marked as TOSW. The data between them are valid, and the data outside are free. Within the valid data, a linked structure represents the &ldquo;RAS stack,&rdquo; where each stack element records the number of its previous data. When performing stack operations, the corresponding previous element can be obtained through this number. The RAS stack&rsquo;s bottom pointer shares the BOS. In the initial state S in the figure, the RAS stack elements are 0, 1, 3, 5. Element 5 records the position of its previous element 3, and element 3 records the position of its previous element 1. When a push operation is needed, the RAS stack top pointer TOSR = TOSW, the new element is stored at the new TOSR position 7, and the position of its previous element 5 is recorded in the new element, then TOSW is moved back (TOSW = TOSW+1). When a pop operation is performed, the RAS stack top pointer TOSR moves to the previous element&rsquo;s position 3 based on the index saved in the stack top element. Therefore, under the condition that the stack does not overflow, the above RAS stack always allocates new data on the array through TOSW during normal Push/Pop operations, so all process states and intermediate data are saved. So, to restore to the state S, it only needs to reset the corresponding stack pointers. Therefore, in each prediction, the corresponding stack pointers (BOS, TOSR, TOSW) also need to be saved in the prediction result for later restoration in case of redirection. The advantage of this structure is that it can save complete process data, but frequent push operations can lead to large space resource consumption.</p>
<h3 id="chain-ra-storage-space-waste"><strong>Chain RA storage space waste?</strong></h3>
<p>Since the prediction result is correct after commit, the stack will not roll back. When the RAS predictor receives the commit message of the prediction block &ldquo;P,&rdquo; it will no longer receive the redirect message of block P, so the snapshot taken during the push operation for block P will not be used again. Therefore, the RAS stack elements can be categorized, with uncommitted elements stored in a &ldquo;linked&rdquo; structure and committed elements stored in a regular stack structure (the original RAS stack is split into two parts: the uncommitted part stored in a snapshot-saving linked structure and the committed part stored in a regular stack structure). The optimized RAS structure is shown below:</p>
<image src="RAS_Arch.png" width="800px">
<p>As shown above, based on the normal call/ret predictions and commit call/ret, the original RAS stack can be split into two independent stacks, called the &ldquo;speculative stack&rdquo; (spec_stack, linked structure) and the &ldquo;commit stack&rdquo; (commit_stack, regular structure). Due to the change in stack structure, the specific Pop/Push operations are as follows:</p>
<ol>
<li>Encounter normal call and ret:
(1) The call predicted by the prediction block is correct, and a push operation is performed on the spec_stack, specifically the linked stack Push process mentioned above.</li>
</ol>
<p>(2) The ret predicted by the prediction block is correct, and the stack top of the spec_stack is used as the prediction value, then a pop operation is performed. If the spec_stack is empty, the stack top element of the commit_stack is used as the prediction result (no pop operation is performed).</p>
<ol start="2">
<li>Commit operation:
(1) The FTQ execution result is call correct, and a regular push operation is performed on the commit_stack.</li>
</ol>
<p>(2) The FTQ execution result is ret correct, and a regular pop operation is performed on the commit_stack.</p>
<ol start="3">
<li>Redirect operation:
(1) Obtain the stack pointers (BOS, TOSR, TOSW, ssp) from the redirect message during the previous prediction and cover the current pointer values to complete the speculative stack rollback.</li>
</ol>
<p>(2) This operation does not affect the commit stack.</p>
<h3 id="how-to-handle-when-the-s3-prediction-result-is-inconsistent-with-s2-at-the-input-end"><strong>How to handle when the S3 prediction result is inconsistent with S2 at the input end?</strong></h3>
<p>Since the S3 result is assumed to be better than S2, the RAS stack needs to be repaired again in case of inconsistency. The specific inconsistency and corresponding repair operations are shown in the table below:</p>
<table>
  <thead>
      <tr>
          <th>S2 Pred. Res.</th>
          <th>S3 Pred. Res.</th>
          <th>Repair Operation</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>push</td>
          <td>keep</td>
          <td>pop</td>
      </tr>
      <tr>
          <td>keep</td>
          <td>pop</td>
          <td>pop</td>
      </tr>
      <tr>
          <td>pop</td>
          <td>keep</td>
          <td>push</td>
      </tr>
      <tr>
          <td>keep</td>
          <td>push</td>
          <td>push</td>
      </tr>
  </tbody>
</table>
<p>S2 and S3 operations do not exist, pop/push or push/pop scenarios (Why not exist?)</p>
<h2 id="other-optimizations">Other Optimizations</h2>
<ol>
<li>Each element in the RAS stack has a counter, which is used to save repeated values (for recursive calls). For example, when the address pushed for the first time is 0xff00, and the address pushed for the second time is also 0xff00, only the counter of the top element of the stack needs to be incremented, and there is no need to actually push the address onto the stack.</li>
</ol>
<h2 id="interface-description">Interface Description</h2>
<p>In the RAS predictor, the core component is the <strong>RASStack</strong>, with the following interface:</p>
<table>
  <thead>
      <tr>
          <th><strong>接口名称</strong></th>
          <th><strong>功能描述</strong></th>
          <th><strong>接口名称</strong></th>
          <th><strong>功能描述</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>in.spec_push_valid</td>
          <td>预测有Call指令，Spec压栈</td>
          <td>in.s2_fire</td>
          <td>s2信号有效</td>
      </tr>
      <tr>
          <td>in.spec_pop_valid</td>
          <td>预测有Ret指令，Spec出栈</td>
          <td>in.s3_fire</td>
          <td>s3信号有效</td>
      </tr>
      <tr>
          <td>in.spec_push_addr</td>
          <td>Ret地址</td>
          <td>in.s3_cancel</td>
          <td>s3和s2的预测结果不一样，需要撤销s2的操作</td>
      </tr>
      <tr>
          <td>out.spec_pop_addr</td>
          <td>RAS的栈顶数据</td>
          <td>in.s3_meta</td>
          <td>s3需要的s2时的现场信息</td>
      </tr>
      <tr>
          <td>out.ssp</td>
          <td>commit栈顶指针</td>
          <td>in.s3_missed_pop</td>
          <td>s3判断需要再次进行pop</td>
      </tr>
      <tr>
          <td>out.sctr</td>
          <td>commit栈顶重复元素计数器</td>
          <td>in.s3_missed_push</td>
          <td>s3判断需要再次进行push</td>
      </tr>
      <tr>
          <td>out.nsp</td>
          <td>commit栈顶，会被ssp覆盖</td>
          <td>in.s3_pushAddr</td>
          <td>需要再次push时的地址</td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>out.TOSR</td>
          <td>spec栈栈顶指针</td>
          <td>in.redirect_valid</td>
          <td>需要重定向</td>
      </tr>
      <tr>
          <td>out.TOSW</td>
          <td>spec栈数据分配指针</td>
          <td>in.redirect_isCall</td>
          <td>真实执行情况是Call</td>
      </tr>
      <tr>
          <td>out.BOS</td>
          <td>spec栈栈低指针</td>
          <td>in.redirect_isRet</td>
          <td>真实执行情况是Return</td>
      </tr>
      <tr>
          <td>in.commit_push_valid</td>
          <td>push操作正确</td>
          <td>in.redirect_meta_ssp</td>
          <td>之前预测时的现场信息ssp</td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>in.commit_pop_valid</td>
          <td>FTQ执行结果为Call正确</td>
          <td>in.redirect_meta_sctr</td>
          <td>之前预测时的现场信息sctr</td>
      </tr>
      <tr>
          <td>in.commit_push_addr</td>
          <td>更新信息中的Ret地址</td>
          <td>in.redirect_meta_TOSW</td>
          <td>之前预测时的现场信息TOSW</td>
      </tr>
      <tr>
          <td>in.commit_meta_TOSW</td>
          <td>更新信息中的TOSW</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>in.redirect_meta_TOSR</td>
          <td>之前预测时的现场信息TOSR</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>in.commit_meta_TOSR</td>
          <td>更新信息中的TOSR</td>
          <td>in.redirect_meta_NOS</td>
          <td>之前预测时的现场信息NOS</td>
      </tr>
      <tr>
          <td>in.commit_meta_ssp</td>
          <td>更新信息中的现场信息SSP</td>
          <td>in.redirect_callAddr</td>
          <td>重定向地址</td>
      </tr>
      <tr>
          <td>in.commit_meta_sctr</td>
          <td>更新信息中的现场信息SCTR</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>The relationship between the RASStack module and the BasePredictor interface is as follows:</p>
<table>
  <thead>
      <tr>
          <th><strong>stack接口</strong></th>
          <th><strong>转换过程</strong></th>
          <th><strong>描述</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>s.spec_push_valid</td>
          <td>io.s2_fire(2) &amp;&amp; s2_full_pred.hit_taken_on_call &amp;&amp; !io.s3_redirect(2)</td>
          <td>s2输入有效，且上级预测为call跳转</td>
      </tr>
      <tr>
          <td>s.spec_pop_valid</td>
          <td>io.s2_fire(2) &amp;&amp; s2_full_pred.hit_taken_on_ret  &amp;&amp; !io.s3_redirect(2)</td>
          <td>s2输入有效，且上级预测为ret跳转</td>
      </tr>
      <tr>
          <td>s.spec_push_addr</td>
          <td>s2_full_pred.fallThroughAddr + Mux(s2_full_pred.last_may_be_rvi_call, 2.U, 0.U)</td>
          <td>上级预测器s2预测的fallThroughAddr（即PC+2），判断是否压缩指令是否需要 +2</td>
      </tr>
      <tr>
          <td>s.redirect_isCall</td>
          <td>redirect.bits.level === 0.U &amp;&amp; recover_cfi.pd.isCall</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>s.redirect_isRet</td>
          <td>redirect.bits.level === 0.U &amp;&amp; recover_cfi.pd.isRet</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>s.redirect_meta_*</td>
          <td>redirect.bits.cfiUpdate.*</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>s.commit_push_valid</td>
          <td>io.update.is_call_taken</td>
          <td>call指令预测正确</td>
      </tr>
      <tr>
          <td>s.commit_push_valid</td>
          <td>io.update.is_ret_taken</td>
          <td>ret指令预测正确</td>
      </tr>
      <tr>
          <td>s.commit_push_addr</td>
          <td>update.ftb_entry.getFallThrough(update.pc) + Mux(update.ftb_entry.last_may_be_rvi_call, 2.U, 0.U)</td>
          <td>根据是否为压缩指令，进行地址+2或者+0</td>
      </tr>
      <tr>
          <td>s.commit_meta_*</td>
          <td>io.update.bits.meta.asTypeOf(new RASMeta)</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>io.out.last_stage_spec_info.*</td>
          <td>s3_meta.*</td>
          <td>s3_meta = RegEnable(s2_meta, io.s2_fire(2))由s2_meta延迟一怕得到</td>
      </tr>
      <tr>
          <td>io.out.last_stage_meta</td>
          <td>s3_meta</td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>io.out.s2.full_pred.*.jalr_target</td>
          <td>:=stack.spec_pop_addr</td>
          <td>预测地址（栈顶地址，只预测ret）</td>
      </tr>
      <tr>
          <td>io.out.s3.full_pred.*.jalr_target</td>
          <td>:=RegEnable(stack.spec_pop_addr, io.s2_fire(2))</td>
          <td>由s2延迟一拍得到</td>
      </tr>
      <tr>
          <td>io.out.s2/3.full_pred.targets.last</td>
          <td>:=Mux(s2/3_is_jalr, s2/3_jalr_target, s2/3_last_target_in)</td>
          <td>如果时call执行，更新targets.last的结果</td>
      </tr>
  </tbody>
</table>
<h2 id="timing-description">Timing Description</h2>
<p>In RAS, there are only 2 stages, S2 and S3.</p>
<p><strong>Main tasks in S2</strong></p>
<ol>
<li>Based on the S2 prediction result of the previous predictor, complete the prediction through the push/pop process and obtain the result spec_pop_addr.</li>
<li>Perform update operations based on commit signal.</li>
</ol>
<p><strong>Main tasks in S3</strong></p>
<ol>
<li>
<p>Based on the prediction result in the previous predictor S3 and the operations in S2, determine whether to undo the Pop/Push operation. The predictor assumes that the S3 prediction result is better than S2. If S2 and S3 predictions are inconsistent, the RAS predictor accepts the S3 result for stack operation.</p>
</li>
<li>
<p>The prediction process in S3 is the same as in S2, but the data is different.</p>
</li>
<li>
<p>Perform redirection operations (redirection information obtained from the previous cycle).</p>
</li>
</ol>
<p>Since the RASStack appears to complete its tasks within a cycle, data bypassing is needed inside the stack to cache data for processing.</p>

</div>



    
	
  



          </main>
        </div>
      </div>
      <footer class="td-footer row d-print-none">
  <div class="container-fluid">
    <div class="row mx-md-2">
      <div class="td-footer__left col-6 col-sm-4 order-sm-1">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="User mailing list" aria-label="User mailing list">
    <a target="_blank" rel="noopener" href="https://example.org/mail" aria-label="User mailing list">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__right col-6 col-sm-4 order-sm-3">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="GitHub" aria-label="GitHub">
    <a target="_blank" rel="noopener" href="https://github.com/google/docsy" aria-label="GitHub">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2">
        <span class="td-footer__copyright">&copy;
    2025
    <span class="td-footer__authors">BOSC</span></span><span class="td-footer__all_rights_reserved">All Rights Reserved</span><span class="ms-2"><a href="https://policies.google.com/privacy" target="_blank" rel="noopener">Privacy Policy</a></span>
      </div>
    </div>
  </div>
</footer>

    </div>
    <script src="/xs-bpu/js/main.min.8bdc707530d61dee3a6fd659f8a422c05d2e2319377a8710175451ca21fa83b0.js" integrity="sha256-i9xwdTDWHe46b9ZZ&#43;KQiwF0uIxk3eocQF1RRyiH6g7A=" crossorigin="anonymous"></script>
<script defer src="/xs-bpu/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js" integrity="sha256-c0eKfUgHaYrtfjVesj&#43;YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin="anonymous"></script>
<script src='/xs-bpu/js/tabpane-persist.js'></script>

  </body>
</html>
