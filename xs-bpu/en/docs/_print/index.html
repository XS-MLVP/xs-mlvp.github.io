<!doctype html>
<html itemscope itemtype="http://schema.org/WebPage" lang="en" class="no-js">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="canonical" type="text/html" href="https://xs-mlvp.github.io/xs-bpu/en/docs/">
<link rel="alternate" type="application/rss&#43;xml" href="https://xs-mlvp.github.io/xs-bpu/en/docs/index.xml">
<meta name="robots" content="noindex, nofollow">


<link rel="shortcut icon" href="/xs-bpu/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/xs-bpu/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/xs-bpu/favicons/android-192x192.png" sizes="192x192">

<title>Branch Predictor and Kunming Lake Microarchitecture Implementation | OpenVerify Courses</title>
<meta name="description" content="Quickly join the open verification platform trial">
<meta property="og:title" content="Branch Predictor and Kunming Lake Microarchitecture Implementation" />
<meta property="og:description" content="Quickly join the open verification platform trial" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://xs-mlvp.github.io/xs-bpu/en/docs/" />
<meta itemprop="name" content="Branch Predictor and Kunming Lake Microarchitecture Implementation">
<meta itemprop="description" content="Quickly join the open verification platform trial"><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Branch Predictor and Kunming Lake Microarchitecture Implementation"/>
<meta name="twitter:description" content="Quickly join the open verification platform trial"/>




<link rel="preload" href="/xs-bpu/scss/main.min.5081230fda7a265fa5fc10130b5bca4f0868fd0e77a3fa6ae4f2d28669ce5899.css" as="style">
<link href="/xs-bpu/scss/main.min.5081230fda7a265fa5fc10130b5bca4f0868fd0e77a3fa6ae4f2d28669ce5899.css" rel="stylesheet" integrity="">

<script
  src="https://code.jquery.com/jquery-3.6.3.min.js"
  integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ=="
  crossorigin="anonymous"></script>
<script defer
  src="https://unpkg.com/lunr@2.3.9/lunr.min.js"
  integrity="sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli"
  crossorigin="anonymous"></script>

    <script>
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?6aacb1c7ca0a3ef4e3aa84c1eaa237dd";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
    </script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z2ZY6ZE84"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-4Z2ZY6ZE84');
    </script>


  </head>
  <body class="td-section">
    <header>
      <nav class="td-navbar navbar-dark js-navbar-scroll">
<div class="container-fluid flex-column flex-md-row">
  <a class="navbar-brand" href="/xs-bpu/en/"><span class="navbar-brand__logo navbar-logo"><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" style="enable-background:new 0 0 500 500"><g><path style="fill:#fff" d="M116.8525 421.9722c-5.7041.0-10.3442-4.3127-10.3442-9.6129V88.183c0-5.3002 4.6401-9.6117 10.3442-9.6117H320.858c3.0347.0 9.3959.5498 11.7506 2.6302l.3545.3442 58.905 63.2912c2.3101 2.491 2.9202 8.4928 2.9202 11.3184v256.2039c0 5.3002-4.6407 9.6129-10.3436 9.6129H116.8525z"/><g><g><g><path style="fill:#767676" d="M384.4445 423.2066H116.852c-6.3839.0-11.5786-4.8658-11.5786-10.8474V88.1831c0-5.9804 5.1947-10.8461 11.5786-10.8461h204.0062c.377.0 9.2786.0329 12.568 2.9389l.3947.3833 58.9508 63.337c3.2135 3.4652 3.2514 11.7924 3.2514 12.1593v256.2036C396.0231 418.3408 390.8284 423.2066 384.4445 423.2066zM116.5079 411.9189c.0848.0278.1999.0531.3441.0531h267.5925c.1442.0.2581-.0253.3441-.0531V156.1556c-.0076-.9033-.3593-3.7347-.7034-5.0037l-57.6527-61.9416c-1.4651-.3176-4.4533-.6389-5.5742-.6389H116.852c-.143.0-.2594.024-.3441.0531V411.9189zm267.4533-261.149zM327.0321 89.371v.0013V89.371z"/></g></g></g><g><g><path style="fill:#5b7fc0" d="M189.0874 210.1754l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4473C177.5953 212.627 183.0601 210.1742 189.0874 210.1754zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 234.1722 197.0804 232.033z"/><path style="opacity:.3;fill:#fff" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/><g><defs><path id="SVGID_1_" d="M194.7376 237.6875c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 234.2399 196.1861 236.239 194.7376 237.6875z"/></defs><clipPath id="SVGID_2_"><use xlink:href="#SVGID_1_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_2_);fill:#fff" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/><path style="opacity:.13;clip-path:url(#SVGID_2_);fill:#020202" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/></g><g><defs><path id="SVGID_3_" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/></defs><clipPath id="SVGID_4_"><use xlink:href="#SVGID_3_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_4_);fill:#5b7fc0" d="M172.6595 215.6045c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8475-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 209.1953 176.6171 211.647 172.6595 215.6045z"/></g></g><rect x="198.8952" y="225.1043" style="fill:#5b7fc0" width="122.6266" height="13.8671"/></g><g><path style="fill:#d95140" d="M189.0874 155.7611l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.0249 2.454-11.4897 6.4116-15.4473C177.5953 158.2128 183.0601 155.7599 189.0874 155.7611zm7.993 21.8577c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.2508 181.7667 197.0816 179.758 197.0804 177.6188z"/><path style="opacity:.3;fill:#fff" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/><g><defs><path id="SVGID_5_" d="M194.7376 183.2733c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 179.8256 196.1861 181.8248 194.7376 183.2733z"/></defs><clipPath id="SVGID_6_"><use xlink:href="#SVGID_5_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_6_);fill:#fff" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/><path style="opacity:.13;clip-path:url(#SVGID_6_);fill:#020202" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/></g><g><defs><path id="SVGID_7_" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/></defs><clipPath id="SVGID_8_"><use xlink:href="#SVGID_7_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_8_);fill:#d95140" d="M172.6595 161.1903c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 154.7811 176.6171 157.2327 172.6595 161.1903z"/></g><rect x="198.8952" y="170.69" style="fill:#d95140" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#56a55c" d="M189.5379 264.6147l.0012-.0012c7.7751.0012 15.0294 4.1862 18.932 10.9235 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032-5.8394.0-11.3281-2.2733-15.458-6.4032-4.13-4.13-6.4032-9.6186-6.4056-15.4628.0012-6.0249 2.454-11.4897 6.4116-15.4472C178.0458 267.0663 183.5105 264.6135 189.5379 264.6147zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6538 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.7013 290.6202 197.5321 288.6115 197.5309 286.4723z"/><path style="opacity:.3;fill:#fff" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/><g><defs><path id="SVGID_9_" d="M195.1881 292.1268c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9941 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.5344 288.6792 196.6366 290.6783 195.1881 292.1268z"/></defs><clipPath id="SVGID_10_"><use xlink:href="#SVGID_9_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_10_);fill:#fff" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/><path style="opacity:.13;clip-path:url(#SVGID_10_);fill:#020202" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/></g><g><defs><path id="SVGID_11_" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/></defs><clipPath id="SVGID_12_"><use xlink:href="#SVGID_11_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_12_);fill:#56a55c" d="M173.11 270.0439c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7325-11.1497-10.9151-18.926-10.9151C182.5311 263.6346 177.0676 266.0863 173.11 270.0439z"/></g></g><rect x="199.3456" y="279.5436" style="fill:#56a55c" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#f1bc42" d="M189.0874 318.7208l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3305-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4472C177.5953 321.1724 183.0601 318.7196 189.0874 318.7208zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 342.7176 197.0804 340.5784z"/><path style="opacity:.3;fill:#fff" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/><g><defs><path id="SVGID_13_" d="M194.7376 346.2329c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 342.7853 196.1861 344.7844 194.7376 346.2329z"/></defs><clipPath id="SVGID_14_"><use xlink:href="#SVGID_13_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_14_);fill:#fff" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/><path style="opacity:.13;clip-path:url(#SVGID_14_);fill:#020202" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/></g><g><defs><path id="SVGID_15_" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/></defs><clipPath id="SVGID_16_"><use xlink:href="#SVGID_15_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_16_);fill:#f1bc42" d="M172.6595 324.15c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8474-1.0151-7.6327-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 317.7407 176.6171 320.1924 172.6595 324.15z"/></g></g><rect x="198.8952" y="333.6497" style="fill:#f1bc42" width="122.6266" height="13.8671"/></g></g></svg></span><span class="navbar-brand__name">OpenVerify Courses</span></a>
  <div class="td-navbar-nav-scroll ms-md-auto" id="main_navbar">
    <ul class="navbar-nav">
      <li class="nav-item dropdown d-none d-lg-block">
        <div class="dropdown">
  <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">English</a>
  <ul class="dropdown-menu">
    <li><a class="dropdown-item" href="/xs-bpu/docs/">中文</a></li>
    </ul>
</div></li>
      </ul>
  </div>
  <div class="d-none d-lg-block">
    <div class="td-search td-search--offline">
  <div class="td-search__icon"></div>
  <input
    type="search"
    class="td-search__input form-control"
    placeholder="Search this site…"
    aria-label="Search this site…"
    autocomplete="off"
    
    data-offline-search-index-json-src="/xs-bpu/offline-search-index.91289d6d4e1ea19901c407f53cb9dc9e.json"
    data-offline-search-base-href="/"
    data-offline-search-max-results="10"
  >
</div>
  </div>
</div>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 ps-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
This is the multi-page printable view of this section.
<a href="#" onclick="print();return false;">Click here to print</a>.
</p><p>
<a href="/xs-bpu/en/docs/">Return to the regular view of this page</a>.
</p>
</div>



<h1 class="title">Branch Predictor and Kunming Lake Microarchitecture Implementation</h1>





    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-60a985e164b2bc20af6e01e35f5b2af0">Basic Design of Shanshan Branch Prediction Unit (BPU)</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>1.1: <a href="#pg-fe21ea780ba57fbb564bd5b9d0edb476">What is Branch Prediction</a></li>


    
  
    
    
	
<li>1.2: <a href="#pg-d61a51e555575e837489cec4d799e293">Basic of the Xiangshan Branch Prediction Unit (BPU)</a></li>


    
  
    
    
	
<li>1.3: <a href="#pg-5ba037ce5b0684d09c2046d64d401ab7">Introduction to the Xiangshan Branch Prediction Unit Structure</a></li>


    
  
    
    
	
<li>1.4: <a href="#pg-4be070861f535b0326baa1f87f4937e4">Introduction to the Timing of Xiangshan Branch Prediction Unit</a></li>


    
  

    </ul>
    
  
    
    
	
<li>2: <a href="#pg-c22356018b29ab5cabc57259ce4bff98">Important Structures and Interface Documentation</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>2.1: <a href="#pg-82ca2994e72c69cffbb84db4c9379254">FTB Item and Complete Prediction Result Interface</a></li>


    
  
    
    
	
<li>2.2: <a href="#pg-31e8ba09abfd18f2000562cd1e9c5357">Redirection and Update Interfaces</a></li>


    
  
    
    
	
<li>2.3: <a href="#pg-356688b245f87b5c6a87c8d73ece8cd7">BPU Global Interface</a></li>


    
  
    
    
	
<li>2.4: <a href="#pg-9ec9b2e73fd778d6c722398e3805b765">Base Predictor Class and Sub Predictor Interface</a></li>


    
  

    </ul>
    
  
    
    
	
<li>3: <a href="#pg-852cfdb3008ca23f8bcaeceaff2ecfe8">Submodule Documentation</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>3.1: <a href="#pg-d9a3cc14150e992a3c357adaaac1c94d">BPU Top Module</a></li>


    
  
    
    
	
<li>3.2: <a href="#pg-e6d1611b25352acdff178100e9b3296d">uFTB Branch Predictor</a></li>


    
  
    
    
	
<li>3.3: <a href="#pg-acd2cf0c1c9c53099412da29a7437546">TAGE-SC Branch Predictor</a></li>


    
  
    
    
	
<li>3.4: <a href="#pg-6632ee4bf977f3fe507ff8cc02deba52">FTB Branch Predictor</a></li>


    
  
    
    
	
<li>3.5: <a href="#pg-dfa5c2dea93e89d4c1a93d678a387d97">ITTAGE Branch Predictor</a></li>


    
  
    
    
	
<li>3.6: <a href="#pg-8ab5cccc33deee27c69e7976949364c2">RAS Branch Predictor</a></li>


    
  

    </ul>
    
  
    
    
	
<li>4: <a href="#pg-0d502bffe5d3814d3a2b8b0dc801ebcc">Feature List</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>4.1: <a href="#pg-3bdbfd3a06696b3b719281b018d22240">BPU Top Feature List</a></li>


    
  
    
    
	
<li>4.2: <a href="#pg-4c5f88e228be33ede010163fdda3986d">uFTB Feature List</a></li>


    
  
    
    
	
<li>4.3: <a href="#pg-d041069efc990462d9eb15082e47df69">FTB Feature List</a></li>


    
  
    
    
	
<li>4.4: <a href="#pg-68c7ba0b5bb8da4bd19e6f7957d9e15c">TAGE-SC Feature List</a></li>


    
  
    
    
	
<li>4.5: <a href="#pg-c333c9631e4a9b4b84765548c49a916e">ITTAGE Feature List</a></li>


    
  
    
    
	
<li>4.6: <a href="#pg-1132c27c26acab41c5da9b539026d07d">RAS Feature List</a></li>


    
  

    </ul>
    
  

    </ul>


<div class="content">
      

<div class="pageinfo pageinfo-primary">
<p>In processor microarchitecture, what is branch prediction? Why is it important? How can it be functionally and performance verified? Through this issue of Open Validation Learning, you will have a deep understanding of the BPU (Branch Prediction Unit) section in the high-performance Kunming Lake microarchitecture.</p>

</div>


</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-60a985e164b2bc20af6e01e35f5b2af0">1 - Basic Design of Shanshan Branch Prediction Unit (BPU)</h1>
    <div class="lead">This document introduces the basic design principles of the Shanshan branch prediction unit. By reading this document, you can understand the approximate workflow of the Shanshan BPU without needing to know specific signal names and code details.</div>
	<p>In processor design, a well-designed branch predictor (BPU) is a key component for improving processor performance. It is responsible for guiding the processor&rsquo;s fetch, determining where the next instruction should be fetched and executed. The BPU is the starting point of an instruction&rsquo;s lifecycle, so exploring a high-performance processor from the BPU is a good starting point.</p>
<p>This is also true for Shanshan, a high-performance processor with out-of-order six-issue execution, which naturally requires a branch prediction unit with high accuracy and efficiency. The design of a branch prediction unit often needs to consider many factors, such as timing, complexity of structure, silicon area occupation, prediction accuracy, and speed of recovery from prediction errors. The branch prediction unit of the Shanshan processor has achieved a good balance among these factors through many clever designs, giving it high branch prediction efficiency and accuracy, providing a basic guarantee for the supply of instructions to the backend.</p>
<p>In this section, we will introduce the basic design of the Shanshan prediction unit. By reading this section, you can learn the following:</p>


<div class="pageinfo pageinfo-primary">
<ul>
<li>Basic concepts of branch prediction</li>
<li>Basic prediction unit of the Shanshan branch prediction unit - branch prediction block</li>
<li>External interfaces of the Shanshan branch prediction unit</li>
<li>Basic structure of the Shanshan branch prediction unit</li>
<li>Basic timing of the Shanshan branch prediction unit</li>
</ul>

</div>

<p>Anyone participating in the BPU crowdsourcing verification work should read this section first to have a basic understanding of the Shanshan branch prediction unit.</p>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-fe21ea780ba57fbb564bd5b9d0edb476">1.1 - What is Branch Prediction</h1>
    <div class="lead">The branch prediction unit, as the name suggests, needs to perform a basic task—branch prediction. Before delving into the branch prediction unit, it is necessary to understand what branch prediction is.</div>
	<h2 id="why-do-we-need-branch-prediction">Why Do We Need Branch Prediction?</h2>
<p>There are mainly two reasons for branch prediction: one is that <strong>the program&rsquo;s execution flow contains branch instructions</strong>, and the other is that <strong>high-performance processors use pipeline design</strong>.</p>
<h3 id="programs-execution-flow-contains-branch-instructions">Program&rsquo;s Execution Flow Contains Branch Instructions</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">int</span> <span style="color:#000">x</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">10</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">int</span> <span style="color:#000">y</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">20</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">int</span> <span style="color:#000">result</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">x</span> <span style="color:#ce5c00;font-weight:bold">&gt;=</span> <span style="color:#000">y</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">result</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">x</span> <span style="color:#ce5c00;font-weight:bold">+</span> <span style="color:#000">y</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span> <span style="color:#204a87;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">result</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">x</span> <span style="color:#ce5c00;font-weight:bold">-</span> <span style="color:#000">y</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre></div><p>The above is a piece of C code. It first defines three variables x, y, and result, and then assigns a value to result based on the comparison of x and y. It can be observed that the program assigns values to variables in sequence in the first three lines. However, in the 5th line, due to the presence of the if instruction, the program branches, jumping directly from the 5th line to the 8th line to continue execution, which causes a <strong>branch</strong> in the program&rsquo;s execution.</p>
<p>After translating into RISC-V assembly code, the code is as follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#000">li</span>  <span style="color:#000">a0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">10</span>               <span style="color:#8f5902;font-style:italic"># x = 10
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000">li</span>  <span style="color:#000">a1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">20</span>               <span style="color:#8f5902;font-style:italic"># y = 20
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000">li</span>  <span style="color:#000">a2</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#0000cf;font-weight:bold">0</span>                <span style="color:#8f5902;font-style:italic"># result = 0
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#000">blt</span> <span style="color:#000">a0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">a1</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">else_branch</span>  <span style="color:#8f5902;font-style:italic"># Jump to else_branch if x &lt; y
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000">add</span> <span style="color:#000">a2</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">a0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">a1</span>           <span style="color:#8f5902;font-style:italic"># Execute result = x + y
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#000">j</span> <span style="color:#000">end</span>                    <span style="color:#8f5902;font-style:italic"># Jump to end
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#f57900">else_branch:</span>
</span></span><span style="display:flex;"><span><span style="color:#000">sub</span> <span style="color:#000">a2</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">a0</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">a1</span>           <span style="color:#8f5902;font-style:italic"># Execute result = x - y
</span></span></span><span style="display:flex;"><span><span style="color:#8f5902;font-style:italic"></span><span style="color:#f57900">end:</span>
</span></span></code></pre></div><p>It can be seen that the program still maintains the previous branching behavior. In the first three lines of the code, instructions are executed in sequence. Then, in the 5th line of the program, a special instruction blt appears, which we call a branch instruction. It will determine whether to execute the next instruction based on the relationship between x and y, and the appearance of this instruction causes a branch in the program&rsquo;s execution.</p>
<h3 id="high-performance-processors-use-pipeline-design">High-performance Processors Use Pipeline Design</h3>

<figure>
    <img src="f4669877-a9f9-4f5d-9fe3-8ba976973513.png" width="400px"/> 
</figure>

<p>Therefore, the concept of <strong>branch prediction</strong> arises. If we can accurately predict the address of the next instruction before the execution result is generated, the processor can continue to run efficiently.</p>
<h2 id="feasibility-of-branch-prediction">Feasibility of Branch Prediction</h2>
<p>Why can branch prediction be done? Let&rsquo;s look at an example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">data</span> <span style="color:#ce5c00;font-weight:bold">&gt;=</span> <span style="color:#0000cf;font-weight:bold">128</span><span style="color:#000;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">sum</span> <span style="color:#ce5c00;font-weight:bold">+=</span> <span style="color:#000">data</span><span style="color:#000;font-weight:bold">;</span>
</span></span></code></pre></div><p>Assuming that this instruction will be executed repeatedly, and data is incremented from 0, i.e., data = 0, 1, 2, 3 &hellip; 128, 129&hellip;, let&rsquo;s analyze the behavior of executing this instruction each time.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Plain" data-lang="Plain"><span style="display:flex;"><span>T = branch taken
</span></span><span style="display:flex;"><span>N = branch not taken
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>data   = 0, 1, 2, 3, s, ... 126, 127, 128, 129, 130, ... 250, 251, 252, ...
</span></span><span style="display:flex;"><span>branch = N  N  N  N  N  ...   N    N    T    T    T  ...   T    T    T  ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       = NNNNNNNNNNNN ... NNNNNNNTTTTTTTTT ... TTTTTTTTTT  (easy to predict)
</span></span></code></pre></div><p>It can be seen that in the first 128 times, the branch is always Not Taken (the condition is not met), but after 128 times, the branch is always Taken (the condition is met). If we predict whether it is Taken based on whether it was Taken last time, we will only make one prediction error throughout the prediction process.</p>
<p>The occurrence of the above phenomenon is due to a basic fact—<strong>whether a branch instruction jumps is related to the past jumping behavior of that instruction</strong>. By summarizing the past jumping rules, we can make a relatively accurate prediction for this jump, which also makes branch prediction possible.</p>
<p>In fact, the jump of branch instructions is also related to factors such as the jumping situation of other branch instructions. Fully exploiting effective information to produce accurate prediction results is one of the main tasks of branch prediction.</p>
<h2 id="basic-types-of-branch-prediction">Basic Types of Branch Prediction</h2>
<p>In RISC-V, branch instructions include two types:</p>
<ol>
<li><strong>Conditional Branch Instructions (beq, bne, blt, bge, bltu, bgeu)</strong> For these instructions, whether to jump is determined by the condition in the instruction, and the jump target can be obtained from the instruction. Therefore, we need to predict whether the instruction will jump.</li>
<li><strong>Unconditional Jump Instructions (jal, jalr)</strong> For these instructions, the jump is always executed when encountered, but the jump target may be specified by a register. Therefore, we need to predict the jump target of the instruction.</li>
</ol>
<p>Fortunately, due to the concise design of the RISC-V architecture, we do not need to handle conditional jump instructions. Every jump instruction we need to predict is unconditional, which is also convenient for our design.</p>
<p>From the above analysis, we can summarize the two basic types of branch prediction—<strong>direction prediction</strong> and <strong>target address prediction</strong>.</p>
<h3 id="direction-prediction-of-branch-instructions">Direction Prediction of Branch Instructions</h3>
<p>Direction prediction of branch instructions corresponds to conditional branch instructions in RISC-V instructions. We need to predict whether it needs to jump, which is called direction prediction.</p>
<h4 id="two-bit-saturation-counters">Two-Bit Saturation Counters</h4>
<p>Direction prediction has a very simple and efficient prediction method called two-bit saturation counter. The basic idea can be seen in the figure below.</p>

<figure>
    <img src="c7e5cf3e-8131-430b-a728-659fb7775f53.png" width="700px"/> 
</figure>

<p>The two-bit saturating counter is regarded as a state machine, and we maintain such a state machine for each branch instruction. When a branch instruction is taken, the corresponding state in the diagram moves to the right; otherwise, it moves to the left. So, the next time we encounter this branch instruction, we first look up its two-bit saturating counter. If the state is more biased to the right, we predict it to be taken; otherwise, we predict it not to be taken.</p>
<p>Of course, it&rsquo;s impractical to maintain a two-bit saturating counter for each branch instruction. Therefore, in practice, we usually use part of the PC or a hash method to index the two-bit saturating counter, as shown in the diagram below.</p>

<figure>
    <img src="e2cf0e6d-f050-4aff-bee3-c72a2b9004e1.png" width="700px"/> 
</figure>

<h4 id="branch-history">Branch History</h4>
<p>Branch history is a very commonly used data in branch prediction and the basis of most branch prediction algorithms because it directly shows the past jumping behavior of instructions.</p>
<p>There are two basic types of branch history:</p>
<ul>
<li><strong>Local Branch History</strong> Maintain a set of registers for each branch instruction, recording the historical jumping behavior of that instruction.
<ul>
<li>For example: 0101000000101 (0 means not taken, 1 means taken)</li>
</ul>
</li>
<li><strong>全Global Branch History</strong> All instructions share a set of registers, recording the branching behavior during program execution.
<ul>
<li>
<p>For example:</p>
<pre tabindex="0"><code>    beg a0, a1, label1          not taken  record 0
    bne a1, a2, label2          not taken  record 0
-&gt;  beq a2, a3, label4          taken      record 1
</code></pre><p>After executing these three different branch instructions, the global branch history becomes 001.</p>
</li>
</ul>
</li>
</ul>
<h3 id="branch-target-address-prediction">Branch Target Address Prediction</h3>
<p>In the RISC-V architecture, branch target address prediction refers to predicting the target address of unconditional jump instructions (e.g., jal, jalr). Since these instructions always perform a jump operation, we need to predict their target address.</p>
<h4 id="branch-target-buffer-btb">Branch Target Buffer (BTB)</h4>
<p>BTB is a common method for predicting target addresses. Its core idea is to use a cache to store the target addresses of past unconditional jump instructions. When encountering the same unconditional jump instruction again, the BTB can be checked to see if there is a record for that instruction. If so, the recorded target address is used as the predicted target address for the current execution.</p>
<p>The diagram below illustrates this:</p>

<figure>
    <img src="540d418a-2760-4724-aad4-502bd0775185.png" width="500px"/> 
</figure>

<h3 id="predicting-instruction-types">Predicting Instruction Types</h3>
<p>As we know, in branch prediction, for conditional branch instructions, we need to predict their direction, and for unconditional jump instructions, we need to predict their target. However, there is a problem: when we get a PC that needs to be predicted, we don&rsquo;t know whether the corresponding instruction is a normal instruction or a branch instruction. Therefore, we cannot predict it.</p>
<p>How to solve this? One way is to predict the behavior of the instruction after fetching it. But fetching from ICache or Memory may take several cycles, which is a major drawback of this method.</p>
<p>A better way is to directly predict the type of instruction. After getting a PC, we can directly predict whether this instruction is a branch instruction and predict its behavior. In this way, we don&rsquo;t have to wait for fetching to complete, and the predicted result can also guide the CPU to fetch from the correct location.</p>
<p>The method of type prediction can be similar to BTB, where a field in the cache contains the type of instruction for use in the next prediction.</p>
<h2 id="general-steps-of-branch-prediction">General Steps of Branch Prediction</h2>
<p>Through the introduction in this section, we can summarize the general steps of branch prediction:</p>
<ol>
<li>Get the PC.</li>
<li>Predict whether it is a branch instruction.
<ol>
<li>If it is a conditional branch instruction, predict its direction and target.</li>
<li>If it is an unconditional jump instruction, predict its target.</li>
</ol>
</li>
</ol>
<p>Note that since predicting the type of instruction is required in prediction, and we haven&rsquo;t obtained the specific content of the instruction, predicting the target of a conditional branch instruction also becomes our task.</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d61a51e555575e837489cec4d799e293">1.2 - Basic of the Xiangshan Branch Prediction Unit (BPU)</h1>
    <div class="lead">This section introduces the basic ideas and working principles of the Xiangshan Branch Prediction Unit (BPU), including the use of branch prediction block concepts, multiple predictors, multiple pipeline structures, and the role of the Fetch Target Queue (FTQ), explaining the main interfaces of BPU for external interaction.</div>
	<h2 id="branch-prediction-block-concept">Branch Prediction Block Concept</h2>
<p>For a general branch predictor, it usually predicts the relevant information of an instruction corresponding to a given PC, such as whether it is a conditional branch instruction or a jump instruction. For conditional branch instructions, it predicts whether it will jump, while for jump instructions, it predicts the jump target. However, predicting instructions one by one is inefficient, leading to slow instruction supply in the frontend.</p>
<p>In contrast, the prediction method used in Xiangshan is to predict a block of instructions each time. That is to say, <strong>given a PC, Xiangshan will predict a branch prediction block starting from this PC, including the situation of several subsequent instructions, such as whether there is a branch instruction, the position of the branch instruction, whether there is a jump, and the jump target.</strong></p>
<p>This prediction method can predict multiple instructions at once and send the prediction results to the fetch unit (IFU) to guide the IFU to fetch instructions. In addition, since the IFU needs to consider the performance of cache lines, it can fetch multiple instructions at once based on the prediction block, thereby improving throughput efficiency.</p>
<p>After the prediction block is generated, <strong>the branch prediction block will also generate the PC to which it jumps after executing this prediction block, and then the BPU will continue to generate the next branch prediction block based on this PC.</strong></p>
<p>Here&rsquo;s a simple example:</p>

<figure>
    <img src="1.png" width="700px"/> 
</figure>

<p>As shown in the above figure, when the PC reaches 0x20000118, the BPU goes through the following steps:</p>
<ol>
<li>The BPU learns that the PC is 0x20000118.</li>
<li>The BPU generates a branch prediction block starting from 0x20000118, with the following approximate contents:
<ol>
<li>In the next several instructions,</li>
<li>The third instruction is a conditional branch instruction.</li>
<li>For this conditional branch instruction, it predicts that it will be taken.</li>
<li>The address to which it jumps is 0x20000110.</li>
</ol>
</li>
<li>The BPU sets the PC to 0x20000110 and continues to generate the next branch prediction block.</li>
</ol>
<p>This is the basic prediction process of the Shanshan BPU using branch prediction blocks.</p>
<h2 id="multiple-predictors-multiple-pipeline-structure">Multiple Predictors, Multiple Pipeline Structure</h2>

<figure>
    <img src="2.png" width="500px"/> 
</figure>

<p>The figure below shows the overall architecture of the Xiangshan BPU, where we need to focus on two main aspects:</p>
<h3 id="multiple-predictors">Multiple Predictors</h3>
<ol>
<li>To ensure prediction accuracy, Xiangshan BPU uses multiple predictors, and these predictors collectively generate the BPU&rsquo;s prediction results. For example, FTB generates basic prediction results for subsequent predictors to use, while TAGE produces more accurate prediction results for conditional branch instructions, and so on.</li>
</ol>
<h3 id="multiple-pipelines">Multiple Pipelines</h3>
<ol>
<li>To meet the requirements of high performance, Xiangshan BPU adopts a pipeline design. Various predictors are at different pipeline levels. Among them, the uFTB (also known as uBTB in the figure) predictor is at the first pipeline level, capable of generating prediction results in one cycle. The other predictors need 2-3 cycles to generate prediction results. Although the prediction time is longer, the prediction results are relatively more accurate.</li>
</ol>
<p>However, if it takes three cycles to get the prediction result and start predicting based on the new result, this design inevitably leads to performance loss. Because of this, it takes three clock cycles to complete one prediction.</p>
<p>To be able to get the prediction results of some predictors in the first and second cycles, we set up three prediction result channels and output the prediction results of the three pipeline levels simultaneously, as shown in the figure below.</p>

<figure>
    <img src="3.png" width="600px"/> 
</figure>

<h2 id="fetch-target-queue-ftq">Fetch Target Queue (FTQ)</h2>
<h3 id="storing-branch-prediction-results">Storing Branch Prediction Results</h3>
<p>Although the BPU can provide prediction results in the form of branch prediction blocks and the IFU can fetch multiple instructions at once, there is still a performance gap between them. In general, the BPU generates prediction results faster.</p>
<p>Therefore, a Fetch Target Queue (FTQ) is added between the BPU and the IFU as a buffer. The FTQ is essentially a queue used to store individual data items. The prediction results generated by the BPU are first stored in the FTQ, and then fetched by the IFU from the FTQ, as shown in the figure below.</p>

<figure>
    <img src="4.png" width="400px"/> 
</figure>

<p>Whenever the BPU generates a prediction block, the prediction block is placed at the head of the FTQ. When the IFU is idle, it will fetch the next prediction block from the tail of the FTQ. The diagram below illustrates this process.</p>

<figure>
    <img src="5.png" width="600px"/> 
</figure>

<p>In Xiangshan, the FTQ&rsquo;s functionality goes far beyond this. Referring to the FTQ&rsquo;s external interface in the figure above, it is also responsible for sending prefetch information to the ICache, storing various training information of the BPU, analyzing redirection information and update information sent from the fetch module and the backend execution module, sending update requests to the BPU, and even updating the basic data structure of the FTB predictor in the FTQ.</p>
<h3 id="bpu-prediction-result-redirection">BPU Prediction Result Redirection</h3>
<p>As mentioned earlier, the Xiangshan branch prediction results have three channels, which simultaneously output the prediction results of stages s1, s2, and s3. How does the FTQ use the prediction results of the three stages?</p>
<p>Let&rsquo;s start from exploring the timing of the pipeline, as shown in the figure below.</p>

<figure>
    <img src="6.png" width="400px"/> 
</figure>

<ul>
<li>In the first cycle, a new PC 0x4 is fetched, and the predictor (called uFTB) that can produce a prediction result within one cycle outputs its prediction result at the s1 interface, indicating the next PC as 0xf, with no output from other interfaces yet.</li>
<li>In the second cycle, the PC is set to 0xf, and uFTB also generates a prediction result of 0xf, which is sent out from the s1 channel. At the same time, the two-cycle predictor generates the prediction result for the previous address 0x4, which is sent out from the s2 channel.</li>
</ul>
<p>However, a problem arises here: in the second cycle, the prediction result generated by s2 is 0x4, but the prediction result for 0x4 has already been output by s1 in the previous cycle and placed in an entry in the FTQ. In other words, the prediction result generated by s2 has already been generated by s1. The difference is that the result from s2 is generated by the two-cycle predictor, making it more accurate.</p>
<p>Therefore, what we need to do is not to place a new FTQ entry based on the prediction result from s2 but to <strong>compare the prediction results from s2 and the previous cycle&rsquo;s s1 prediction results. If there is a difference, then overwrite the FTQ entry placed by the previous stage&rsquo;s s1 interface.</strong></p>
<p>So we add two additional signal lines to the s2 and s3 channels, which we call redirect signals. If this signal is valid, it indicates that there is a difference between the prediction result of this stage and the previous prediction result, and it is necessary to overwrite an FTQ entry from before. The structure is shown in the diagram below.</p>

<figure>
    <img src="7.png" width="600px"/> 
</figure>

<p>At the time corresponding to the second cycle of the pipeline in the structural diagram, the s1 channel has already placed a branch prediction block result with an address of 0x4 into the FTQ. At this time, the s2 prediction result is generated, and the BPU finds that the s2 prediction result is different from s1, so the redirect interface for this cycle is set to valid. The FTQ will use the s2 channel&rsquo;s prediction result to overwrite the FTQ entry previously storing the 0x4 prediction result.</p>
<p>At this time, although the s1 channel has also generated a branch prediction block with 0xf as the head, it is obviously an incorrect prediction result generated by s1 based on the PC of the first cycle. Therefore, at this time, the s1 result can be directly discarded.</p>
<p>In the third cycle, s1 starts a new round of prediction with the correct prediction result indicated by s2, the new PC 0x8. After that, if no prediction errors are detected by the s2 and s3 channels, the pipeline will continue to run at full capacity.</p>
<h3 id="bpu-redirect-requests">BPU Redirect Requests</h3>
<p>No matter how accurate a branch predictor is, it is not always correct. This inaccuracy can lead to incorrect instructions being filled in the subsequent pipeline. Therefore, there needs to be a mechanism to correct this, and this mechanism is redirection. When an instruction is executed by the backend execution module, the true behavior of this instruction is determined. At this time, if the backend execution module detects a branch prediction error, it will issue a <strong>redirect request</strong> to restore the processor&rsquo;s state to the state before executing the incorrect instruction. For us, we only need to pay attention to how the BPU and FTQ restore the state when redirecting.</p>
<p>In addition to redirect requests from the backend, the Shan Mountain processor will perform a simple analysis of the instruction after it is fetched by the IFU to detect the most basic prediction errors. The specific process is as follows: after the FTQ sends a fetch request to the IFU, it will wait for the IFU to return the pre-decoded information (pre-decoding is the IFU&rsquo;s simple decoding of the instruction, such as whether it is a jump instruction, what is the target of the jump). The FTQ will write the pre-decoded information back to a field in the corresponding entry in the FTQ and will also analyze the pre-decoded information. If a prediction error is detected, it will generate an IFU redirect request.</p>
<p>Redirect requests from the backend execution module do not need to be generated by the FTQ but are directly sent from the backend to the FTQ for processing. The FTQ will forward the generated IFU redirect request and the backend redirect request to the BPU&rsquo;s redirect interface. If both are valid in the same cycle, the FTQ will choose to forward the backend redirect request.</p>
<p>The BPU with the added redirect interface is shown in the diagram below.</p>

<figure>
    <img src="8.png" width="700px"/> 
</figure>

<h3 id="bpu-update-requests">BPU Update Requests</h3>
<p>The current BPU already has the ability to correct errors, but there is still a problem: the data in the BPU cannot be updated. If it is impossible to obtain information such as the location, type, whether a jump occurred, and the jump address of the instruction, the BPU will not be trained and the accuracy will be greatly reduced.</p>
<p>To obtain this information, we still need to rely on the Fetch Target Queue (FTQ) because it can not only interact with the IFU to obtain instruction-related information but also interact with the backend to obtain execution-related information. Therefore, there will be an update request channel directly connecting the FTQ to the BPU.</p>

<figure>
    <img src="9.png" width="700px"/> 
</figure>

<p><strong>When the backend completes the execution of an entry in the FTQ, the entry is marked as committed. Next, the FTQ forwards the update information of this entry to the BPU through the Update channel.</strong></p>
<h2 id="summary">Summary</h2>
<p>Through this section, we have learned about all the main interfaces required for BPU external interaction and the role of FTQ in BPU. With the BPU equipped with prediction result interfaces, redirect interfaces, and update interfaces, it can already support all external interactions of the BPU. Next, we will delve deeper into the internals of the BPU.</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5ba037ce5b0684d09c2046d64d401ab7">1.3 - Introduction to the Xiangshan Branch Prediction Unit Structure</h1>
    <div class="lead">This section introduces the structure of the Xiangshan Branch Prediction Unit (BPU), including the integration of multiple predictors and multiple pipeline schemes, as well as the organization structure and interface design of internal sub-predictors, demonstrating how the BPU interacts with the Composer, and explaining the connection methods between sub-predictors.</div>
	<h2 id="how-does-the-bpu-integrate-internal-sub-predictors">How Does the BPU Integrate Internal Sub-predictors?</h2>
<p>We already know that the Xiangshan BPU adopts multiple predictors and multiple pipeline schemes. To adapt to multiple pipelines, the BPU uses a three-channel result output interface. But how does it adapt to multiple predictors? This requires us to further explore the internal structure of the BPU.</p>

<figure>
    <img src="1.png" width="600px"/> 
</figure>

<p>The above figure is the BPU architecture diagram from the Xiangshan documentation. Currently, we only need to focus on one piece of information: all internal sub-predictors are encapsulated in a structure called <code>Composer</code>. The BPU only needs to interact with <code>Composer</code>.</p>
<p>What is <code>Composer</code>? Let&rsquo;s first look at their definition in the Xiangshan code.</p>

<figure>
    <img src="2.png" width="700px"/> 
</figure>

<p>It can be seen that <code>Composer</code> and the five sub-predictors have a common characteristic: they all inherit from the <code>BasePredictor</code> base class. And the interface has been defined in the <code>BasePredictor</code> class. In other words, <code>Composer</code> and <strong>the five sub-predictors all have the same interface</strong>! The top-level BPU can directly regard <code>Composer</code> as a sub-predictor, without worrying about how the internal sub-predictors are connected.</p>
<h2 id="sub-predictor-interface">Sub-predictor Interface</h2>
<p>Next, we will look at what the sub-predictor interface looks like. This interface will involve the interaction between <code>Composer</code> and the top-level BPU, as well as the interaction between each sub-predictor and <code>Composer</code>.</p>
<p>Let&rsquo;s take <code>Composer</code> as an example to illustrate the structure of the sub-predictor interface.</p>

<figure>
    <img src="3.png" width="400px"/> 
</figure>

<p>As shown in the above figure, the three-channel prediction results of <code>Composer</code> are directly output to the outside of the BPU. There is also a set of three-channel prediction results connected from the inside of the BPU to <code>Composer</code>. However, since the prediction results are generated by <code>Composer</code>, the BPU will pass an empty prediction result to <code>Composer</code>. The significance of this is to make the sub-predictor act as a &ldquo;processor.&rdquo; The sub-predictor will process the input prediction results and then output the processed prediction results.</p>
<p>Next, the top-level BPU will provide the information needed for prediction to the pipeline. First is the <strong>PC</strong> and <strong>branch history records</strong> (including global history and global folding history). Next, the BPU will connect some pipeline control signals between <code>Composer</code> and the <strong>pipeline control signals</strong>. Finally, the BPU will directly connect the externally input <strong>redirect request interface</strong> and <strong>update interface</strong> to <code>Composer</code>.</p>
<p>In the end, a simple definition of the sub-predictor interface can be given (for detailed definitions, please refer to the interface documentation):</p>
<ul>
<li><strong>in</strong>
<ul>
<li><strong>(s1, s2, s3)</strong> Prediction information input</li>
<li><strong>s0_pc</strong>         PC to be predicted</li>
<li><strong>ghist</strong>         Global branch history</li>
<li><strong>folded_hist</strong> Global folding history</li>
</ul>
</li>
<li><strong>out  (s1, s2, s3)</strong> Prediction information output</li>
<li><strong>流水线控制信号</strong>
<ul>
<li><strong>s0_fire, s1_fire, s2_fire, s3_fire</strong> Whether the corresponding pipeline stage is working</li>
<li><strong>s2_redirect, s3_redirect</strong>              Redirect signals when a prediction error is discovered in the subsequent pipeline stage</li>
<li><strong>s1_ready, s2_ready, s3_ready</strong>    Whether the sub-predictor corresponding pipeline stage is ready</li>
</ul>
</li>
<li><strong>update</strong>        Update request</li>
<li><strong>redirect</strong>      Redirect request</li>
</ul>
<h2 id="connection-between-sub-predictors">Connection Between Sub-predictors</h2>
<p>We now know that the interfaces between each sub-predictor and <code>Composer</code> are the same, and we also know how <code>Composer</code> is connected to the top-level BPU. This section will explain how sub-predictors are connected within <code>Composer</code>.</p>

<figure>
    <img src="4.png" width="400px"/> 
</figure>

<p>The above figure shows the connection structure of sub-predictors in <code>Composer</code>. It can be seen that after the three-channel prediction results are input into <code>Composer</code>, they are first processed by <code>uFTB</code> and then output. They are then successively processed by <code>TAGE-SC</code>, <code>FTB</code>, <code>ITTAGE</code>, and <code>RAS</code>, and finally connected to the prediction result output of <code>Composer</code>, which is then directly connected to the outside of the BPU by <code>Composer</code>.</p>
<p>For other signals, because the interfaces between <code>Composer</code> and each sub-predictor are the same, they are directly connected to the corresponding interfaces of each predictor by <code>Composer</code>, without much additional processing.</p>
<h3 id="prediction-result-interface-connection">Prediction Result Interface Connection</h3>
<p>For sub-predictors, the connection of their prediction result is that the prediction result output of one predictor is the input of the next predictor. However, it should be noted that this connection is a combinational circuit connection and is not affected by timing.</p>

<figure>
    <img src="5.png" width="400px"/> 
</figure>

<p>As shown in the above figure, taking the s1 channel as an example, from input to the output of the last predictor, it is all modified by combinational circuits, unaffected by timing. Registers only exist between the s1, s2, and s3 channels.</p>
<p>Therefore, increasing the number of sub-predictors will not increase the number of cycles required for prediction, but will only increase the delay required for prediction per cycle.</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-4be070861f535b0326baa1f87f4937e4">1.4 - Introduction to the Timing of Xiangshan Branch Prediction Unit</h1>
    <div class="lead">The timing design of the three-stage pipeline is the essence of the Xiangshan BPU. This section will introduce how the prediction result redirection signal is generated, how a new PC is generated based on the prediction result, and how the prediction results of the three channels are handled.</div>
	<h2 id="single-cycle-prediction-without-bubble">Single-Cycle Prediction without Bubble</h2>

<figure>
    <img src="1.png" width="500px"/> 
</figure>

<p><code>uFTB</code> is the only predictor in Xiangshan BPU that can generate prediction results in a single cycle. The figure below shows the prediction process of <code>uFTB</code>. The <code>s0_pc</code> is sent from the top level of BPU, and when the s1 stage is active, the <code>s1_pc</code> retains the value of <code>s0_pc</code> from the previous cycle. This means that the value of <code>s0_pc</code> will move down the pipeline.</p>
<p>When the s1 stage is active, <code>uFTB</code> receives the <code>s1_fire</code> signal from the current cycle and generates a prediction result based on the <code>s1_pc</code> address in this cycle, which can obtain the new PC value in the prediction result.</p>

<figure>
    <img src="2.png" width="500px"/> 
</figure>

<p>As shown in the figure, the top level of BPU analyzes the next PC value position based on the prediction result channel s1 and sends it to <code>npc_Gen</code> (new PC generator) for generating the s0_pc of the next cycle.</p>
<p>In the next cycle, <code>uFTB</code> gets the new PC value and starts generating the prediction block for the new PC value. Therefore, with only the s1 stage, the prediction block can be generated at a rate of one block per cycle.</p>
<h2 id="prediction-result-redirection">Prediction Result Redirection</h2>
<p>However, except for <code>uFTB</code>, other predictors require 2-3 cycles to generate prediction results. How to utilize their prediction results? And how to generate the prediction result redirection signal?</p>

<figure>
    <img src="3.png" width="500px"/> 
</figure>

<p>As shown in the figure, a <code>Predirector 2</code> that takes two cycles to generate a prediction result can output its prediction result to the s2 prediction result channel in the s2 stage. After the top level of BPU receives the prediction result, it analyzes the jump target address <code>target</code> of the prediction block and connects it to <code>npc_Gen</code>.</p>
<p>At this point, the signal connected to <code>npc_Gen</code> contains both the old PC prediction result generated by s2 and the new PC prediction result generated by s1. How to choose which one to use for the new PC?</p>
<p>As mentioned earlier, BPU compares the prediction result of s2 with the prediction result of s1 from the previous cycle. If the prediction results are different, it indicates that s1 has made a wrong prediction, and naturally, the prediction result of the current cycle generated based on the wrong prediction result of the previous cycle is also wrong. Therefore, if the prediction result is incorrect in the current cycle, <code>npc_Gen</code> will use the <code>target</code> provided by s2 as the new <code>s0_pc</code>.</p>
<p>This process is shown in the pipeline structure diagram as follows:</p>

<figure>
    <img src="4.png" width="500px"/> 
</figure>

<p>The Diff comparator compares the prediction results of the s1 stage with those of the previous cycle to generate a diff signal, guiding <code>npc_Gen</code> to generate the next PC. At the same time, the diff signal indicates that the prediction result of the s1 stage is incorrect and can be used directly by BPU to redirect the prediction result channel of the s2 stage in the FTQ, instructing the FTQ to overwrite the previous prediction result.</p>
<p>The diff signal is also sent to each predictor through the s2_redirect interface to guide the predictors to update their states.</p>
<p>Furthermore, when the prediction result redirection of the s2 stage occurs, indicating that the prediction result of the s1 channel is incorrect, the s2 stage cannot continue to predict and needs to invalidate the <code>s2_fire</code> signal of the predictor pipeline and wait for the corrected prediction result to flow in.</p>
<p>The prediction result redirection of the s3 stage is similar to this. Its pipeline structure diagram is as follows. The specific processing process is left for you to analyze.</p>

<figure>
    <img src="5.png" width="500px"/> 
</figure>

<h2 id="redirection-requests-and-other-information-generation">Redirection Requests and Other Information Generation</h2>

<figure>
    <img src="6.png" width="500px"/> 
</figure>

<p>Only when the prediction information of all three stages is incorrect will an external redirection request occur. At this time, <code>npc_Gen</code> will receive the PC address from the redirection request. Since when a redirection request occurs, we assume that all three stages have predicted incorrectly, so all three stages&rsquo; <code>fire</code> signals need to be invalidated. Then, <code>npc_Gen</code> uses the PC that needs to be restored from the redirection request to restart the prediction.</p>
<p>Other information, such as the generation of the global history and the PC, follows the same principle and is maintained based on the prediction information of each stage. The global history generates a new branch history based on the prediction results of each stage.</p>
<h2 id="pipeline-control-signals">Pipeline Control Signals</h2>
<p>After learning about the specific process of the pipeline, you should understand the pipeline control signals in the predictor interface, as follows:</p>
<ul>
<li><strong>s0_fire, s1_fire, s2_fire, s3_fire</strong> Indicate whether each stage of the pipeline is working.</li>
<li><strong>s2_redirect, s3_redirect</strong>           Indicate whether a prediction result redirection has occurred.</li>
<li><strong>s1_ready, s2_ready, s3_ready</strong>    Sent from the predictor to the top level of BPU, indicating whether each stage of the pipeline is ready.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>By now, you should understand the basic design principles, external interaction logic, internal structure, timing, etc., of the Xiangshan Branch Prediction Unit, and have a rough understanding of the working principle of BPU. Xiangshan&rsquo;s BPU is no longer mysterious to you.</p>
<p>Next, you can read the <code>Important Structures and Interfaces Document</code> and combine it with the source code of Xiangshan BPU to form a more detailed understanding of BPU. When you clearly understand the working principle and signal details of BPU, you can start your verification work!</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c22356018b29ab5cabc57259ce4bff98">2 - Important Structures and Interface Documentation</h1>
    <div class="lead">This document will describe the important structures and external interfaces in the BPU, with a description granularity that delves into the code level. By reading this document, you can understand the role of each signal in the Xiangshan branch prediction unit, comprehend the specific implementation methods of various requests, and gain a functional understanding in conjunction with the code.</div>
	<p>This document will describe the important structures and external interfaces in the BPU, with a description granularity that delves into the code level. The structures described in the document will be consistent with the Chisel version of the Xiangshan branch prediction unit code, and the signal structures and names also come from the Chisel version code.</p>
<p>This document is intended for those who have already understood the basic design of the Xiangshan branch prediction unit and want to delve into the signal details. You can selectively read according to the content needed for verification or refer to it at any time.</p>
<p>Among them, the FTB entry and the full prediction result interface involve the way the BPU generates prediction results, which is recommended for every reader to read.</p>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-82ca2994e72c69cffbb84db4c9379254">2.1 - FTB Item and Complete Prediction Result Interface</h1>
    <div class="lead">The basic prediction unit of BPU is the branch prediction block, but what is the structure of a branch prediction block? Why can a branch prediction block guide the execution of so many subsequent instructions? This section will describe the core data structure for generating branch prediction blocks—the FTB item, and the complete prediction result structure generated from the FTB item.</div>
	<h2 id="ftb-item">FTB item</h2>
<p>The FTB item is the core data structure of branch prediction blocks in Xiangshan. It stores the information needed to generate a branch prediction block. When BPU performs predictions, the initial branch prediction block is first generated from a read-out FTB item. Then, this branch prediction block is passed to subsequent predictors, which read and modify the information to generate the final prediction result.</p>
<p>Therefore, to understand the structure of a branch prediction block, we first need to understand the structure of an FTB item. An FTB item corresponds to a branch prediction block, and its general structure is as follows:</p>

<figure>
    <img src="1.png" width="750px"/> 
</figure>

<p>First, it is necessary to clarify one piece of information: whether it is a branch prediction block or an FTB item, the number of instructions they can contain is set to a specific limit (16 RVC instructions in the current version of Xiangshan), called the <strong>maximum prediction length</strong>. This means that if we need to record the position of an instruction within the branch prediction block, we can use a fixed-length bit vector to specify the offset of this instruction relative to the starting address of the prediction block.</p>
<p>The determinant of the branch prediction block&rsquo;s execution process is the information about the branch instructions. The other instructions are considered ordinary instructions and do not affect the program&rsquo;s execution flow. Therefore, in a branch prediction block, we only need to record the positions of the branch instructions, while the positions of ordinary instructions are not our concern.</p>
<p>Therefore, the FTB item defines two types of <strong>branch instruction slots</strong>—<code>brSlots</code> and <code>tailSlot</code>, used to store the branch instructions within the branch prediction block. In the current version of Xiangshan, <code>brSlots</code> contains only one slot, while <code>tailSlot</code> is a separate slot, totaling two slots.</p>
<p>Within the instructions of the maximum prediction length, if a branch instruction appears, the FTB item will record it in the corresponding slot and mark the slot as valid. If too many branch instructions appear, reaching the capacity limit of the FTB item, the excess branch instructions will be handed over to the next FTB item for storage. In each slot, we record the offset of a branch instruction relative to the starting address of the prediction block and information such as its jump target address.</p>
<h3 id="the-unique-tailslot">The Unique tailSlot</h3>
<p>In RISC-V, branch instructions are mainly divided into two types: conditional branches and unconditional jumps. Therefore, <strong>for a branch prediction block, it will contain at most one unconditional jump instruction</strong>. Because once this instruction is executed, the program&rsquo;s execution flow will change, and subsequent instructions will no longer be executed. Hence, we define a type of slot called <code>tailSlot</code> specifically for storing this unconditional jump instruction. As for conditional branch instructions, they are stored in <code>brSlots</code>.</p>
<p>As its name suggests, <code>tailSlot</code> is located in the last slot of the entire prediction block. This is also because once the unconditional jump instruction is filled, the program will definitely jump, and subsequent instructions will be handled by other prediction blocks, so we do not need to care about the subsequent instructions. However, among the instructions before the unconditional jump instruction, we need to care about whether there are conditional branch instructions, because conditional branch instructions may or may not jump. Therefore, we need to record the relevant information of the conditional branch instructions.</p>
<h3 id="tailslot-sharing">tailSlot Sharing</h3>
<p>Consider a situation: if no unconditional jump instructions appear from the starting PC of the prediction block to the maximum prediction length, but two conditional branch instructions appear instead, the <code>tailSlot</code> will be idle, and the second conditional branch instruction cannot be stored, causing space waste.</p>
<p>To solve this problem, Xiangshan adopts a method of setting a <code>sharing</code> mark. We can directly store the second branch instruction into the <code>tailSlot</code> and set the sharing mark to true, indicating that the second conditional branch instruction shares the tailSlot of the unconditional jump instruction. This way, the space of the <code>tailSlot</code> is effectively utilized.</p>
<p>The <code>isCall</code>, <code>isRet</code>, and <code>isJalr</code> fields in the prediction block serve the <code>tailSlot</code>. If the tailSlot records an unconditional jump instruction, these fields will further indicate the type of the jump instruction. There is also a field in the FTB item called <code>always_taken</code>, which records whether each conditional branch instruction stored in each slot is always predicted to jump. If so, subsequent predictors can directly adopt this prediction result.</p>
<p>Through the FTB item, we can know the instruction situation in a branch prediction block, including the position and type of branch instructions. This information will be handed over to subsequent predictors, which will predict more accurate jump targets, whether to jump, and other information.</p>
<h2 id="complete-structure-of-ftb-item-ftbentry">Complete Structure of FTB Item (FTBEntry)</h2>
<p>Interface Definition: <code>src/main/scala/xiangshan/frontend/FTB.scala</code></p>
<p>This section describes the complete structural definition of the FTB item, containing the following signals:</p>
<ul>
<li><strong>valid</strong>: Whether the FTB entry is valid.
<ul>
<li>Interface Type: <code>Bool</code></li>
</ul>
</li>
<li><strong>brSlots</strong>: Conditional branch instruction slots.
<ul>
<li>Interface Type: <code>Vec(numBrSlot, new FtbSlot(BR_OFFSET_LEN))</code> （see FtbSlot for interface list）</li>
</ul>
</li>
<li><strong>tailSlot</strong>: Unconditional jump instruction slot.
<ul>
<li>Interface Type: <code>new FtbSlot(JMP_OFFSET_LEN, Some(BR_OFFSET_LEN))</code> （see FtbSlot for interface list）</li>
</ul>
</li>
<li><strong>pftAddr</strong>: Unconditional jump instruction slot
<ul>
<li>Interface Type: <code>UInt(log2Up(PredictWidth).W)</code></li>
</ul>
</li>
<li><strong>carry</strong>: Unconditional jump instruction slot.
<ul>
<li>Interface Type: <code>Bool()</code></li>
</ul>
</li>
<li><strong>isCall</strong>: The instruction in the unconditional jump instruction slot is a call instruction.
<ul>
<li>Interface Type: <code>Bool()</code></li>
</ul>
</li>
<li><strong>isRet</strong>: The instruction in the unconditional jump instruction slot is a ret instruction.
<ul>
<li>Interface Type: <code>Bool()</code></li>
</ul>
</li>
<li><strong>isJalr</strong>: The instruction in the unconditional jump instruction slot is a jalr instruction.
<ul>
<li>Interface Type: <code>Bool()</code></li>
</ul>
</li>
<li><strong>last_may_be_rvi_call</strong>:  The instruction in the unconditional jump instruction slot may be an RVI type call instruction signal.
<ul>
<li>Interface Type: <code>Bool()</code></li>
</ul>
</li>
<li><strong>always_taken</strong>: Whether each branch instruction in the prediction block is always predicted as Taken.
<ul>
<li>Interface Type: <code>Vec(numBr, Bool())</code></li>
</ul>
</li>
</ul>
<p><strong>Explanation: pftAddr and carry</strong></p>
<p>Here, <code>pftAddr</code> stands for Partial Fallthrough Address. Fallthrough Address means that if there is no jump in the prediction block, the program will sequentially execute to the address reached. In other words, if the offset of an unconditional jump instruction is 5, then the offset corresponding to the Fallthrough Address is 6. This signal is mainly used to get the return address of the program after a function call, and this concept can be understood as the end address of the prediction block.</p>
<p>Partial means part of the address, which is determined by the address representation method. Here, the address representation method is as follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Plain" data-lang="Plain"><span style="display:flex;"><span>  pc: | ... |&lt;-- log(predictWidth) --&gt;|&lt;-- log(instBytes) --&gt;|
</span></span><span style="display:flex;"><span>           ^                         ^
</span></span><span style="display:flex;"><span>           |                         |
</span></span><span style="display:flex;"><span>           carryPos                  instOffsetBits
</span></span></code></pre></div><p><code>pftAddr</code> only records the middle offset part (the part with a length of log(predictWidth)), and a complete PC can be generated by combining it with the current PC. However, a carry might occur, so a <code>carry</code> bit is recorded separately. carryPos is the position in the instruction address within the prediction block where a carry might occur.</p>
<p>Additionally, <code>last_may_be_rvi_call</code> is an auxiliary signal for this address, indicating that the instruction in the unconditional jump instruction slot is an RVI type call instruction. Since pftAddr assumes the instruction length as the compressed instruction length by default when calculating, the end address is increased by only 2 bytes. If the actual call instruction is not a compressed instruction, it will lead to an incorrect return address calculation. RAS will correct this error based on this signal.</p>
<h2 id="branch-prediction-slot-ftbslot">Branch Prediction Slot (FTBSlot)</h2>
<p>Interface Definition: <code>src/main/scala/xiangshan/frontend/FTB.scala</code></p>
<p>This interface defines the slot in the FTB entry:</p>
<ul>
<li><strong>offset</strong>: The offset of the instruction in the slot relative to the start address of the prediction block.
<ul>
<li>Interface Type: UInt(log2Ceil(PredictWidth).W)</li>
</ul>
</li>
<li><strong>lower</strong>: The lower bits of the jump target address.
<ul>
<li>Interface Type: UInt(offsetLen.W)</li>
<li>Note: The lower is set to 12 or 20 bits because the addressing capability of branch instructions is 12 bits, while the addressing capability of jump instructions is 20 bits.</li>
</ul>
</li>
<li><strong>tarStat</strong>: Whether the high bits of the PC after the jump are incremented or decremented.
<ul>
<li>Interface Type: UInt(TAR_STAT_SZ.W) (TAR_STAT_SZ = 2)</li>
<li>Note: The jump target address is calculated from the high bits of the current PC, the tarStat, and the lower field. The lower field directly stores the lower bits of the jump target address. The high bits of the current PC are adjusted according to the tarStat, then concatenated with the lower to get the actual jump target address. The tarStat can take three values: 0 - no increment or decrement, 1 - increment, 2 - decrement.</li>
</ul>
</li>
<li><strong>sharing</strong>: Indicates that a conditional branch instruction is stored in an unconditional jump instruction slot.
<ul>
<li>Interface Type: Bool()</li>
</ul>
</li>
<li><strong>valid</strong>: Indicates whether the slot is valid.
<ul>
<li>Interface Type: Bool()</li>
</ul>
</li>
</ul>
<h2 id="full-branch-prediction">Full Branch Prediction</h2>
<ul>
<li>Interface Definition: <code>src/main/scala/xiangshan/frontend/FrontendBundle.scala</code></li>
</ul>
<p>This interface defines the complete branch prediction results, included in the prediction results of each pipeline stage.</p>
<p>The full branch prediction result interface is similar to the FTB entry and is initially generated from the FTB entry. Two slots are split into individual signals: <code>slot_valids</code>, <code>targets</code>, <code>offsets</code>, <code>is_br_sharing</code>, etc. Additionally, several fields are added such as <code>br_taken_mask</code>, <code>jalr_target</code> to facilitate the provision of precise prediction results by subsequent predictors. The <code>hit</code> indicates whether an FTB entry is hit, i.e., the PC in the current prediction round indexed to an FTB entry.</p>
<p><strong>Full Interface List：</strong></p>
<ul>
<li><strong>hit</strong>: Indicates whether the FTB entry is hit.</li>
<li>Interface Type: <code>Bool()</code></li>
<li><strong>slot_valids</strong>: Indicates whether each slot in the FTB entry is valid.</li>
<li>Interface Type: <code>Vec(totalSlot, Bool())</code></li>
<li><strong>targets</strong>: The jump target address corresponding to each slot.</li>
<li>Interface Type: <code>Vec(totalSlot, UInt(VAddrBits.W))</code></li>
<li><strong>offsets</strong>: The offset of the instruction in each slot relative to the start address of the prediction block.</li>
<li>Interface Type: <code>Vec(totalSlot, UInt(log2Ceil(PredictWidth).W))</code></li>
<li><strong>fallThroughAddr</strong>: The end address of the prediction block.</li>
<li>Interface Type: <code>UInt(VAddrBits.W)</code></li>
<li><strong>fallThroughErr</strong>: Indicates that the pftAddr recorded in the FTB entry is incorrect.</li>
<li>Interface Type: <code>Bool()</code></li>
<li><strong>is_jal</strong>: Indicates that the prediction block contains a jal instruction.</li>
<li>Interface Type: <code>Bool()</code></li>
<li><strong>is_jalr</strong>: Indicates that the prediction block contains a jalr instruction.</li>
<li>Interface Type: <code>Bool()</code></li>
<li><strong>is_call</strong>: Indicates that the prediction block contains a call instruction.</li>
<li>Interface Type: <code>Bool()</code></li>
<li><strong>is_ret</strong>: Indicates that the prediction block contains a ret instruction.</li>
<li>Interface Type: <code>Bool()</code></li>
<li><strong>last_may_be_rvi_call</strong>: Indicates that the instruction in the unconditional jump instruction slot might be an RVI type call instruction.</li>
<li>Interface Type: <code>Bool()</code></li>
<li><strong>is_br_sharing</strong>: Indicates that the last slot (tailSlot) stores a conditional branch instruction.</li>
<li>Interface Type: <code>Bool()</code></li>
<li><strong>br_taken_mask</strong>: The branch prediction result, with each bit corresponding to a branch (slot), indicating whether the branch is predicted to be taken.</li>
<li>Interface Type: <code>Vec(numBr, Bool())</code></li>
<li><strong>jalr_target</strong>: The jump target of the jalr instruction in the prediction block.</li>
<li>Interface Type: <code>UInt(VAddrBits.W)</code></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-31e8ba09abfd18f2000562cd1e9c5357">2.2 - Redirection and Update Interfaces</h1>
    <div class="lead">Redirection and update requests are the two main types of information sent from the FTQ to the BPU. This section details the specific structure of these request interfaces.</div>
	<h2 id="branch-prediction-redirectionbranchpredictionredirect"><strong>Branch Prediction Redirection（BranchPredictionRedirect）</strong></h2>
<p><strong>Interface Definition：</strong><code>src/main/scala/xiangshan/frontend/FrontendBundle.scala</code></p>
<p><strong>Interface Type：</strong><code>BranchPredictionRedirect</code></p>
<p>This interface defines the redirection requests from the branch prediction unit, mainly used to redirect the state of the branch predictor.</p>
<p>The <code>BranchPredictionRedirect</code> interface inherits from the <code>Redirect</code> interface and includes many signals, only a subset of which are used by the BPU redirection. The documented structure contains only the interfaces used by the BPU.</p>
<p>Redirection requests have two sources: those generated by comparing IFU pre-decode information and those generated during the backend execution process.</p>
<p><strong>In redirection requests, the key information is <code>cfiUpdate</code>, which corresponds to a control flow instruction. This information pertains to an instruction where the BPU made a prediction error</strong>. For example, if the BPU indicates that the third instruction in the prediction block is a normal instruction with no jump, but the pre-decode shows it is an unconditional jump instruction, a prediction error has occurred. In this case, the FTQ generates a redirection request. The <code>cfiUpdate</code> in the redirection request corresponds to this unconditional jump instruction.</p>
<p>The information in <code>cfiUpdate</code> can be broadly classified into three types:</p>
<ol>
<li><strong>Information about the corresponding instruction and its execution status</strong>. This includes the slot (shift) and PC of the instruction in the prediction block, the type-related information of the instruction (pd), and the execution status, such as jump target and whether it jumps.</li>
<li><strong>History maintenance related information</strong>. The redirection request contains branch history information corresponding to the prediction block of the instruction to help the BPU restore branch history. folded_hist represents the global folded history, histPtr represents the global history pointer, and other information assists in maintaining branch history. For detailed information, refer to the BPU Top-Level Module.</li>
<li><strong>RAS maintenance related information</strong>. For detailed meaning, refer to the RAS sub-predictor documentation.</li>
</ol>
<p>The meaning of <code>level</code> is whether the redirection includes this instruction. If not included, the redirection request receiver will assume the instruction has been executed, and the next prediction will start from the next instruction. The <code>BPU</code> top-level will default to not including this instruction, and upon receiving a redirection request, it will include the execution status of this instruction in the branch history.</p>
<p><strong>The detailed signal list for the redirection interface is as follows:</strong></p>
<ul>
<li>
<p><strong>level</strong>: Indicates whether the redirection request includes the current position. Low means redirection after this position, high means redirection at this position.</p>
<ul>
<li>Interface Type: <code>UInt(1.W)</code></li>
</ul>
</li>
<li>
<p><strong>cfiUpdate</strong>: Control flow instruction update information</p>
<ul>
<li>
<p>Interface Type: <code>CfiUpdateInfo</code></p>
</li>
<li>
<p>Interface List</p>
<ul>
<li><strong>pc</strong>: The PC of the instruction corresponding to the redirection request
<ul>
<li>Interface Type: <code>UInt(VaddrBits.W)</code></li>
</ul>
</li>
<li><strong>pd</strong>: Pre-decode information of the redirection instruction
<ul>
<li><strong>isRVC</strong>: Whether it is a compressed instruction
<ul>
<li>Interface Type: <code>Bool</code></li>
</ul>
</li>
<li><strong>isCall</strong>: Whether it is a function call
<ul>
<li>Interface Type: <code>Bool</code></li>
</ul>
</li>
<li><strong>isRet</strong>: Whether it is a function return
<ul>
<li>Interface Type: <code>Bool</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>target</strong>: Target address of the redirection request instruction
<ul>
<li>Interface Type: <code>UInt(VaddrBits.W)</code></li>
</ul>
</li>
<li><strong>taken</strong>: Whether the redirection request instruction is taken
<ul>
<li>Interface Type: <code>Bool</code></li>
</ul>
</li>
<li><strong>shift</strong>: Slot in which the redirection request instruction is located, 0 if it is a normal instruction.
<ul>
<li>Interface Type: <code>UInt((log2Ceil(numBr)+1).W)</code></li>
</ul>
</li>
<li><strong>addIntoHist</strong>: Whether to include the execution information of the redirection request instruction in the branch history.
<ul>
<li>Interface Type: <code>Bool</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>folded_hist</strong>: Folded history corresponding to the redirection request
<ul>
<li>Interface Type: <code>AllFoldedHistories(foldedGHistInfos)</code></li>
</ul>
</li>
<li><strong>afhob</strong>: Oldest bit of the branch history corresponding to the redirection request instruction
<ul>
<li>Interface Type: <code>AllAheadFoldedHistoryOldestBits(foldedGHistInfos)</code></li>
</ul>
</li>
<li><strong>lastBrNumOH</strong>: Last branch position corresponding to the redirection request
<ul>
<li>Interface Type: <code>UInt((numBr+1).W)</code></li>
</ul>
</li>
<li><strong>histPtr</strong>: Global history pointer to be restored by the redirection request
<ul>
<li>Interface Type: <code>CGHPtr</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>ssp</strong>: RAS speculative stack top pointer at the commit stack position corresponding to the redirection request instruction
<ul>
<li>Interface Type: <code>UInt(log2Up(RasSize).W)</code></li>
</ul>
</li>
<li><strong>sctr</strong>: RAS speculative stack top recursion counter corresponding to the redirection request instruction
<ul>
<li>Interface Type: <code>UInt(log2Up(RasCtrSize).W)</code></li>
</ul>
</li>
<li><strong>TOSW</strong>: RAS speculative stack (queue) write pointer corresponding to the redirection request instruction
<ul>
<li>Interface Type: <code>CGHPtr</code></li>
</ul>
</li>
<li><strong>TOSR</strong>: RAS speculative stack (queue) read pointer corresponding to the redirection request instruction
<ul>
<li>Interface Type: <code>CGHPtr</code></li>
</ul>
</li>
<li><strong>NOS</strong>: RAS stack top counter corresponding to the redirection request instruction
<ul>
<li>Interface Type: <code>CGHPtr</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="branch-prediction-updatebranchpredictionupdate"><strong>Branch Prediction Update（BranchPredictionUpdate）</strong></h2>
<p>Interface Definition: <code>src/main/scala/xiangshan/frontend/FrontendBundle.scala</code></p>
<p>This interface defines the update requests for the branch predictor, mainly used to update the state of the branch predictor. The document lists only the interfaces used in the BPU.</p>
<p>Update requests correspond to each branch prediction block. When a branch prediction block in the FTQ has been executed, the FTQ generates an update request for this prediction block to train the predictor. Thus, an important role of the update request is to feed back the actual execution status of the instructions to the BPU. Additionally, in the Xiangshan branch prediction unit, the update request is responsible for updating FTB entries.</p>
<p>The information in the update request can be broadly classified into four categories:</p>
<ul>
<li><strong>PC</strong>: Indicates the starting address of the prediction block, specifying which prediction block the update request corresponds to</li>
<li><strong>FTB Entry Update Information</strong>: The update channel contains an FTB entry structure (ftb_entry), outputs the newly generated FTB entry from the FTQ, and indicates whether it is the same as the old FTB entry (old_entry)</li>
<li><strong>Actual Execution Status Information of Instructions</strong>: The update channel indicates the execution status of branch and unconditional jump instructions in the prediction block, and provides the address and final target of control flow instructions (i.e., instructions that jump)</li>
<li><strong>Predictor-Related Data Corresponding to the Prediction Block</strong>: Contains spec_info and meta information (refer to the BPU Global Interface Documentation for details)</li>
</ul>
<p><strong>The interface list of the update request is as follows:</strong></p>
<ul>
<li><strong>pc</strong> PC of the update request (starting address of the prediction block)
<ul>
<li>Interface Type：<code>UInt(VAddrBits.W)</code></li>
</ul>
<hr>
</li>
<li><strong>ftb_entry</strong> Updated FTB entry
<ul>
<li>Interface Type：<code>new FTBEntry()</code></li>
<li>Interface List：See（<code>FTBEntry</code>）</li>
</ul>
</li>
<li><strong>old_entry</strong> Whether the updated FTB entry is the same as the old FTB entry
<ul>
<li>Interface Type：<code>Bool()</code></li>
</ul>
<hr>
</li>
<li><strong>br_taken_mask</strong> Mask indicating whether each slot instruction in the prediction block jumps
<ul>
<li>Interface Type：<code>Vec(numBr, Bool())</code></li>
</ul>
</li>
<li><strong>mispred_mask</strong> Mask indicating prediction errors in the prediction block. The first and second bits indicate whether the two conditional branch instructions were mispredicted, and the third bit indicates whether the unconditional jump instruction was mispredicted.
<ul>
<li>Interface Type：<code>Vec(numBr+1, Bool())</code></li>
</ul>
</li>
<li><strong>jmp_taken</strong> Unconditional jump instruction triggered in the prediction block
<ul>
<li>Interface Type：<code>Bool()</code></li>
</ul>
</li>
<li><strong>cfi_idx</strong> Index of the control flow instruction in the prediction block
<ul>
<li>Interface Type：<code>ValidUndirectioned(UInt(log2Ceil(PredictWidth).W))</code></li>
</ul>
</li>
<li><strong>full_target</strong> Jump target of the prediction block (starting address of the next prediction block)
<ul>
<li>Interface Type：<code>UInt(VAddrBits.W)</code></li>
</ul>
<hr>
</li>
<li><strong>spec_info</strong> Last stage speculative information corresponding to the prediction block
<ul>
<li>Interface Type：<code>new SpeculativeInfo</code></li>
<li>Interface List：（Only <code>foled_hist</code> is used）
<ul>
<li><strong>folded_hist</strong> Global folded history
<ul>
<li>Interface Type：<code>AllFolededHistories(foldedGHistInfos)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>meta</strong> Last stage meta information corresponding to the prediction block
<ul>
<li>Interface Type：<code>UInt(MaxMetaLength.W)</code></li>
</ul>
</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-356688b245f87b5c6a87c8d73ece8cd7">2.3 - BPU Global Interface</h1>
    <div class="lead">This section introduces the definition of the overall external interaction interface of the Xiangshan Branch Prediction Unit, including the presentation of global branch prediction results and single pipeline stage prediction results.</div>
	<h2 id="bpu-module-overall-external-interface-predirectio"><strong>BPU Module Overall External Interface (PredirectIO)</strong></h2>
<p>Interface definition: <code>src/main/scala/xiangshan/frontend/BPU.scala</code></p>
<p>PredirectIO is the overall external interface of the branch predictor (BPU). It mainly handles the interaction between the branch predictor (BPU) and the fetch target queue (FTQ), which includes the following parts:</p>
<ul>
<li><strong>bpu_to_ftq</strong>: Information sent from BPU to FTQ, mainly for sending branch prediction results from BPU to FTQ
<ul>
<li>Interface type： <code>BpuToFtqIO</code></li>
<li>Interface type：
<ul>
<li><strong>resp</strong>: Global branch prediction information sent from BPU to FTQ
<ul>
<li>Interface type：<code>DecoupledIO(new BpuToFtqBundle())</code>
<ul>
<li><code>BpuToFtqBundle</code> inherits from <code>BranchPredictionResp</code>，without additional signals</li>
</ul>
</li>
<li>Interface type：See  (<code>BranchPredictionResp</code>)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>ftq_to_bpu</strong>: Information sent from FTQ to BPU, mainly for handling redirect and update requests
<ul>
<li>Interface type： <code>FtqToBpuIO</code></li>
<li>Interface type：
<ul>
<li><strong>redirect</strong>: Redirect request sent from FTQ to BPU
<ul>
<li>Interface type： <code>Valid(new BranchPredictionRedirect)</code></li>
<li>Interface list：See （<code>BranchPredictionRedirect</code>）</li>
</ul>
</li>
<li><strong>update</strong>: Update request sent from FTQ to BPU
<ul>
<li>Interface type：<code>Valid(new BranchPredictionUpdate)</code></li>
<li>Interface list：See （<code>BranchPredictionUpdate</code>）</li>
</ul>
</li>
<li><strong>enq_ptr</strong>: FTQ pointer sent to BPU, indicating which FTQ entry to write to next
<ul>
<li>Interface type：<code>FtqPtr</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>ctrl</strong>: BPU control signals, mainly for enabling various predictors
<ul>
<li>Interface type：<code>BPUCtrl</code></li>
<li>Interface list：
<ul>
<li><strong>ubtb_enable</strong>: UBTB predictor enable
<ul>
<li>Interface type：<code>Bool()</code></li>
</ul>
</li>
<li><strong>btb_enable</strong>: BTB predictor enable
<ul>
<li>Interface type：<code>Bool()</code></li>
</ul>
</li>
<li><strong>bim_enable</strong>: BIM predictor enable
<ul>
<li>Interface type：<code>Bool()</code></li>
</ul>
</li>
<li><strong>tage_enable</strong>: TAGE predictor enable
<ul>
<li>Interface type：<code>Bool()</code></li>
</ul>
</li>
<li><strong>sc_enable</strong>: SC predictor enable
<ul>
<li>Interface type：<code>Bool()</code></li>
</ul>
</li>
<li><strong>ras_enable</strong>: RAS predictor enable
<ul>
<li>Interface type：<code>Bool()</code></li>
</ul>
</li>
<li><strong>loop_enable</strong>: LOOP predictor enable
<ul>
<li>Interface type：<code>Bool()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>reset_vector</strong>: Reset vector, which the BPU&rsquo;s PC will be reset to upon reset
<ul>
<li>Interface type：<code>UInt(PAddrBits.W)</code></li>
</ul>
</li>
</ul>
<h2 id="global-branch-prediction-information-branchpredictionresp"><strong>Global Branch Prediction Information (BranchPredictionResp)</strong></h2>
<p>Interface definition: <code>src/main/scala/xiangshan/frontend/FrontendBundle.scala</code></p>
<p>This interface defines all the prediction result information of the branch predictor, including the prediction results of each stage and the related information output by the last pipeline stage.</p>
<ul>
<li><strong>s1</strong> Branch prediction result of the s1 pipeline stage</li>
<li><strong>s2</strong> Branch prediction result of the s2 pipeline stage</li>
<li><strong>s3</strong> Branch prediction result of the s3 pipeline stage
<ul>
<li>Interface type：<code>BranchPredictionBundle</code></li>
<li>Interface type：See （<code>BranchPredictionBundle</code>）</li>
</ul>
</li>
<li><strong>last_stage_meta</strong> Metadata of the prediction result output by the last pipeline stage. It is a bit vector output by each predictor and combined by the Composer.
<ul>
<li>Interface type：<code>UInt(MaxMetaLength.W)</code></li>
</ul>
</li>
<li><strong>last_stage_spec_info</strong> Related information of the prediction result output by the last pipeline stage
<ul>
<li>Interface type：<code>Ftq_Redirect_SRAMEntry</code></li>
<li>Interface list：
<ul>
<li><strong>folded_hist</strong>  Global folded history
<ul>
<li>Interface type：<code>AllFoldedHistories(foldedGHistInfos)</code></li>
</ul>
</li>
<li><strong>afhob</strong> Global branch history oldest bit
<ul>
<li>Interface type：<code>AllAheadFoldedHistoryOldestBits(foldedGHistInfos)</code></li>
</ul>
</li>
<li><strong>lastBrNumOH</strong> Last branch position
<ul>
<li>Interface type：<code>UInt((numBr+1).W)</code></li>
</ul>
</li>
<li><strong>histPtr</strong> Global branch history pointer
<ul>
<li>Interface type：<code>CGHPtr</code></li>
</ul>
</li>
<li><strong>ssp</strong> RAS speculation stack pointer at commit stack position
<ul>
<li>Interface type：<code>UInt(log2Up(RasSize).W)</code></li>
</ul>
</li>
<li><strong>sctr</strong> RAS speculation stack recursion counter
<ul>
<li>Interface type：<code>UInt(log2Up(RasCtrSize).W)</code></li>
</ul>
</li>
<li><strong>TOSW</strong> RAS speculation stack (queue) write pointer
<ul>
<li>Interface type：<code>CGHPtr</code></li>
</ul>
</li>
<li><strong>TOSR</strong> RAS speculation stack (queue) read pointer
<ul>
<li>Interface type：<code>CGHPtr</code></li>
</ul>
</li>
<li><strong>NOS</strong> RAS stack top counter
<ul>
<li>Interface type：<code>CGHPtr</code></li>
</ul>
</li>
<li><strong>topAddr</strong> RAS stack top return address
<ul>
<li>Interface type：<code>UInt(VAddrBits.W)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>last_stage_ftb_entry</strong> FTB entry output by the last pipeline stage
<ul>
<li>Interface type：<code>FtqEntry</code></li>
<li>Interface list：See（<code>FtqEntry</code>）</li>
</ul>
</li>
</ul>
<h2 id="ftb-entry-output-by-the-last-pipeline-stage"><strong>FTB entry output by the last pipeline stage</strong></h2>
<p>Interface definition: <code>src/main/scala/xiangshan/frontend/FrontendBundle.scala</code></p>
<p>This interface defines the branch prediction result information output by each pipeline stage,</p>
<ul>
<li><strong>pc</strong> Starting PC of the predicted block
<ul>
<li>Interface type: <code>Vec(numDup, UInt(VAddrBits.W))</code> numDup is only for register replication, with identical signals</li>
</ul>
</li>
<li><strong>valid</strong> Whether the prediction result is valid
<ul>
<li>Interface type: <code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li><strong>hasRedirect</strong> Whether a redirect is needed
<ul>
<li>Interface description: Only the s2 and s3 stages will redirect, and the prediction result of this stage will override the previous pipeline stage&rsquo;s result when a redirect occurs</li>
<li>Interface type: <code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li><strong>ftq_idx</strong> FTQ pointer, pointing to the FTQ entry corresponding to the prediction information of this stage
<ul>
<li>Interface type: <code>new FtqPtr</code></li>
</ul>
</li>
<li><strong>full_pred</strong> Complete branch prediction result
<ul>
<li>Interface type: <code>Vec(numDup, new FullBranchPrediction)</code></li>
<li>Interface list: See (<code>FullBranchPrediction</code>)</li>
</ul>
</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9ec9b2e73fd778d6c722398e3805b765">2.4 - Base Predictor Class and Sub Predictor Interface</h1>
    <div class="lead">This document introduces the sub-predictor interface in the Xiangshan BPU, as well as the use of the sub-predictor base class. Reading this document can help you understand the external interactions of sub-predictors and the use of signals in the sub-predictor base class.</div>
	<p>In the Xiangshan branch prediction unit, all its sub-predictors and the class implementations of Composer are inherited from the sub-predictor base class (BasePredictor). The sub-predictor interface (BasePredictorIO) is also defined in the sub-predictor base class. Therefore, we can consider that Composer and all sub-predictors have the same interface.</p>
<p>In the understanding and verification of sub-prediction, our most direct external interaction occurs in the sub-predictor interface and some variables defined in the sub-predictor base class. Therefore, before verifying the sub-predictor, it is strongly recommended that you read and understand this section of the document.</p>
<p>The general content and usage of the sub-branch predictor interface have been introduced in the <code>Xiangshan Branch Prediction Unit (BPU) Basic Design</code> section. This document will focus on the signal details of the interface.</p>
<h2 id="sub-branch-predictor-interface-basepredictorio"><strong>Sub-Branch Predictor Interface (BasePredictorIO)</strong></h2>
<p>Interface Definition: <code>src/main/scala/xiangshan/frontend/BPU.scala</code></p>
<p>Each sub-branch predictor needs to implement this interface, which defines the input and output interfaces of the sub-branch predictor.</p>
<p>Note: Some signals are defined as <code>numDup</code> quantities, where each signal is exactly the same. Multiple identical signals are for other considerations.</p>
<p>The detailed signal list is as follows:</p>
<ul>
<li>
<p><strong>reset_vector</strong> Reset vector, when reset occurs, the BPU&rsquo;s pc will be reset to this value.</p>
<ul>
<li>Interface Type：<code>UInt(PAddrBits.W)</code></li>
</ul>
</li>
<li>
<p><strong>in</strong> Information sent from the BPU to the sub-branch predictor</p>
<ul>
<li>Interface Type：<code>DecoupledIO(new BasePredictorInput)</code></li>
<li>Signal List：
<ul>
<li><strong>s0_pc</strong> PC of the s0 pipeline stage
<ul>
<li>Interface Type：<code>Vec(numDup, UInt(VAddrBits.W))</code></li>
</ul>
</li>
<li><strong>folded_hist</strong> Global folded history information
<ul>
<li>Interface Type：<code>Vec(numDup, new AllFoldedHistories(foldedGHistInfos))</code></li>
<li>Signal List：See（<code>AllFoldedHistories</code>）</li>
</ul>
</li>
<li><strong>ghist</strong> Global branch history information
<ul>
<li>Interface Type：<code>UInt(HistoryLength.W)</code></li>
</ul>
</li>
<li><strong>resp_in</strong>  Global branch prediction information (including s1, s2, s3 prediction result information)
<ul>
<li>Interface Type：<code>BranchPredictionResp</code></li>
<li>Signal List：See（<code>BranchPredictionResp</code>）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>out</strong> Information sent from the sub-branch predictor to the BPU (including s1, s2, s3 prediction result information)</p>
<ul>
<li>Interface Type：<code>new BasePredictorOutput</code> 继承自 <code>BranchPredictionResp</code></li>
<li>Signal List：See（<code>BranchPredictionResp</code>）</li>
</ul>
</li>
<li>
<p><strong>ctrl</strong> BPU sub-predictor enable control signal, mainly used to control whether each predictor is enabled</p>
<ul>
<li>Interface Type：<code>BPUCtrl</code></li>
<li>Interface Type：
<ul>
<li><strong>ubtb_enable</strong>: UBTB predictor enable
<ul>
<li>Interface Type：<code>Bool()</code></li>
</ul>
</li>
<li><strong>btb_enable</strong>: BTB predictor enable
<ul>
<li>接Interface Type：<code>Bool()</code></li>
</ul>
</li>
<li><strong>bim_enable</strong>: BIM predictor enable
<ul>
<li>Interface Type：<code>Bool()</code></li>
</ul>
</li>
<li><strong>tage_enable</strong>: TAGE predictor enable
<ul>
<li>Interface Type：<code>Bool()</code></li>
</ul>
</li>
<li><strong>sc_enable</strong>: SC predictor enable
<ul>
<li>Interface Type：<code>Bool()</code></li>
</ul>
</li>
<li><strong>ras_enable</strong>: RAS predictor enable
<ul>
<li>Interface Type：<code>Bool()</code></li>
</ul>
</li>
<li><strong>loop_enable</strong>: LOOP predictor enable
<ul>
<li>Interface Type：<code>Bool()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>s0_fire</strong> s0 stage handshake success signal</p>
<ul>
<li>Interface Type：<code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li>
<p><strong>s1_fire</strong> s1 stage handshake success signal</p>
<ul>
<li>Interface Type：<code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li>
<p><strong>s2_fire</strong> s2 stage handshake success signal</p>
<ul>
<li>Interface Type：<code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li>
<p><strong>s3_fire</strong> s3 stage handshake success signal</p>
<ul>
<li>Interface Type：<code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li>
<p><strong>s2_redirect</strong> s2 stage redirection signal</p>
<ul>
<li>Interface Type：<code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li>
<p><strong>s3_redirect</strong> s3 stage redirection signal</p>
<ul>
<li>Interface Type：<code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li>
<p><strong>s1_ready</strong> s1 stage ready to receive information (Direction: output from the sub-predictor)</p>
<ul>
<li>Interface Type：<code>Bool()</code></li>
</ul>
</li>
<li>
<p><strong>s2_ready</strong> s2 stage ready to receive information (Direction: output from the sub-predictor)</p>
<ul>
<li>Interface Type：<code>Bool()</code></li>
</ul>
</li>
<li>
<p><strong>s3_ready</strong> s3 stage ready to receive information (Direction: output from the sub-predictor)</p>
<ul>
<li>Interface Type：<code>Bool()</code></li>
</ul>
</li>
<li>
<p><strong>update</strong> Update request forwarded from the BPU to the sub-branch predictor</p>
<ul>
<li>Interface Type：<code>Valid(new BranchPredictionUpdate)</code></li>
<li>Signal List：See（<code>BranchPredictionUpdate</code>）</li>
</ul>
</li>
<li>
<p><strong>redirect</strong> Redirect request forwarded from the BPU to the sub-branch predictor</p>
<ul>
<li>Interface Type：<code>Valid(new BranchPredictionRedirect)</code></li>
<li>Signal List：See（<code>BranchPredictionRedirect</code>）</li>
</ul>
</li>
</ul>
<p>The pipeline control signals will be further explained in the following content.</p>
<h3 id="global-folding-history-allfoldedhistories">Global Folding History (AllFoldedHistories)</h3>
<p><strong>Interface Definition：</strong><code>src/main/scala/xiangshan/frontend/FrontendBundle.scala</code></p>
<p><strong>Interface Type：</strong><code>AllFoldedHistories(foldedGHistInfos))</code></p>
<p>The interface information of the global folding history consists of only one <code>FoldedHistory</code> list.</p>
<ul>
<li><strong>hist</strong> List of folded histories
<ul>
<li>Interface Type：<code>MixedVec(gen.map{case (l, cl) =&gt; new FoldedHistory(l, cl, numBr)})</code></li>
</ul>
</li>
</ul>
<p>The interface information of <code>FoldedHistory</code> also has only one item.</p>
<ul>
<li><strong>folded_hist</strong> Single folded history, with a bit width equal to the compressed history length.
<ul>
<li>Interface Type：<code>UInt(compLen.W)</code></li>
</ul>
</li>
</ul>
<p>This means that the interface of the global folding history is actually a list that stores folded histories, where each item is a folded history of a specific length.</p>
<h2 id="base-predictor-class">Base Predictor Class</h2>
<p>The base predictor class defines several signals, which can be accessed in each sub-predictor, and several connections are made within it.</p>
<p>Most of the signals are relatively easy to understand. We need to pay particular attention to the pc of each pipeline, which also involves your understanding of pipeline control signals. Therefore, next, we will introduce the meanings of pipeline control signals that need to be paid attention to in sub-predictors, as well as the meanings of the s1_pc, s2_pc, s3_pc signals.</p>
<p>There are three groups of pipeline control signals:</p>
<ul>
<li>fire signals  (s0, s1, s2, s3)</li>
<li>redirect signals  (s2, s3)</li>
<li>ready signals  (s1, s2, s3)</li>
</ul>
<p>The pc signals in the base predictor class are divided into four groups, <code>s0_pc_dup</code>, <code>s1_pc_dup</code>, <code>s2_pc_dup</code>, <code>s3_pc_dup</code>. Each group of signals contains multiple pc signals, which are exactly the same and are duplicated for some other reasons. Therefore, we can simply consider them as <code>s0_pc</code>, <code>s1_pc</code>, <code>s2_pc</code>, <code>s3_pc</code>.</p>
<p>Their usage can be seen in the following diagram:</p>

<figure>
    <img src="1.png" width="700px"/> 
</figure>

<p>Their relationship with the pipeline control signals is as follows:</p>
<ul>
<li><code>s0_pc</code> is directly connected from the <code>in.s0_pc</code> in the input interface.</li>
<li>When <code>s0_fire</code> is active, the next cycle <code>s1_pc</code> will output the value of <code>s0_pc</code>.</li>
<li>When <code>s1_fire</code> is active, the next cycle <code>s2_pc</code> will output the value of <code>s1_pc</code>.</li>
<li>When <code>s2_fire</code> is active, the next cycle <code>s3_pc</code> will output the value of <code>s2_pc</code>.</li>
</ul>
<p>In other words, the <code>fire</code> signal affects whether the data of the next cycle is valid. For example, the <code>s0_fire</code> signal affects whether the data of the s1 pipeline is valid, and the <code>s1_fire</code> signal affects whether the data of the s2 pipeline is valid.</p>
<p>Whether the <code>fire</code> signal is valid depends on whether the data of this pipeline stage is valid and whether the next pipeline stage is ready. For example, the <code>s1_fire</code> signal is valid only if the data of the s1 stage is valid and the <code>s2_ready</code> signal from the sub-predictor output is valid. At this point, it can be considered that the data processing of the s1 stage is completed, the s2 stage is ready, and the data of the next cycle will be directly sent to the s2 stage.</p>
<p>Therefore, in the sub-predictor, taking the s1 stage as an example, <code>s1_ready</code> can block data from entering the s1 stage. When <code>s1_ready</code> is active, the data for the s1 stage will be valid in the next cycle. <strong>When <code>s1_fire</code> is active, it indicates that the data in the s1 stage is already valid and the predictor has generated the result for the s1 stage</strong>. The data will then be directly sent to the s2 stage in the next cycle.</p>
<p>The <code>redirect</code> signal is relatively clear. For example, in the s2 stage, when <code>s2_redirect</code> is valid, it indicates that when <code>s2_fire</code> is valid, the s2 prediction result is different from the s1 prediction result in the previous cycle.</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-852cfdb3008ca23f8bcaeceaff2ecfe8">3 - Submodule Documentation</h1>
    <div class="lead">This section of the documentation will provide a detailed introduction to each module of the Xiangshan Branch Prediction Unit, including the BPU top-level and five sub-predictors.</div>
	<p>This section of the documentation will provide a detailed introduction to each module of the Xiangshan Branch Prediction Unit, including the BPU top-level and five sub-predictors.</p>
<p>In each module&rsquo;s documentation, we will provide a detailed explanation of the module&rsquo;s role in the Xiangshan Branch Prediction Unit, as well as the module&rsquo;s algorithm principles, structure, and timing.</p>
<p>Students responsible for verifying a specific module should read the corresponding documentation thoroughly and understand it in conjunction with the code. Other documents can also be read to help you understand the overall functionality of the Xiangshan Branch Prediction Unit. During the understanding process, you may need to constantly review the basic design concepts and interface signals described in previous documents.</p>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d9a3cc14150e992a3c357adaaac1c94d">3.1 - BPU Top Module</h1>
    
	<p>The overall function and structure of the BPU top level have been roughly described in previous documents. For those verifying the BPU top level, a more detailed description might be needed. Due to the many functions of the BPU top level, this section divides the BPU into several major functional points for further description. However, since there are too many details at the BPU top level, further details need to be understood by referring to the code.</p>
<h2 id="generator-maintenance-method">Generator Maintenance Method</h2>
<p>From the basic design documents of Xiangshan, we know that the BPU top level maintains various variables in the s0 cycle through generators, such as PC, branch history, etc. The core concept is to decide which pipeline level&rsquo;s result to adopt through the redirection signal of the prediction result.</p>
<p>There are a total of 6 generators in the BPU top level:</p>
<ul>
<li><strong>npcGen</strong> maintains the PC</li>
<li><strong>ghistPtrGen</strong> maintains the global history pointer</li>
<li><strong>ghvBitWriteGens</strong> maintains global history write data</li>
<li><strong>foledGhGen</strong> maintains the folded history</li>
<li><strong>lastBrNumOHGen</strong> maintains the position of the last effective branch instruction in the previous cycle</li>
<li><strong>aheadFhObGen</strong> maintains the oldest position of the branch history</li>
</ul>
<p>Except for <code>npcGen</code>, the rest of the generators will be introduced in this document. In this section, we will focus on the method of generating the next prediction for the generators.</p>
<p>In the code, you can see generators defined in a similar way:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Scala" data-lang="Scala"><span style="display:flex;"><span><span style="color:#204a87;font-weight:bold">val</span> <span style="color:#000">npcGen</span> <span style="color:#204a87;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">PhyPriorityMuxGenerator</span><span style="color:#ce5c00;font-weight:bold">[</span><span style="color:#204a87;font-weight:bold">UInt</span><span style="color:#ce5c00;font-weight:bold">]</span>
</span></span></code></pre></div><p>Next, the code registers the data sources for the generators through multiple statements:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Scala" data-lang="Scala"><span style="display:flex;"><span><span style="color:#000">npcGen</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">register</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">true</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">B</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">reg</span><span style="color:#a40000">，</span> <span style="color:#ce5c00;font-weight:bold">...)</span>
</span></span><span style="display:flex;"><span><span style="color:#000">npcGen</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">register</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">s1_valid</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">s1_target</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#ce5c00;font-weight:bold">...)</span>
</span></span><span style="display:flex;"><span><span style="color:#000">npcGen</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">register</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">s2_redirect</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">s2_target</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#ce5c00;font-weight:bold">...)</span>
</span></span><span style="display:flex;"><span><span style="color:#000">npcGen</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">register</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">s3_redirect</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">s3_target</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#ce5c00;font-weight:bold">...)</span>
</span></span><span style="display:flex;"><span><span style="color:#000">npcGen</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">register</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">do_redirect</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">valid</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">do_redirect</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">bits</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">cfiUpdate</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">target</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#ce5c00;font-weight:bold">...)</span>
</span></span></code></pre></div><p>Each line is called a registration. In a registration, the first signal parameter is the data valid signal, and the second signal parameter contains the specific data. The priority of the generator is also determined in the order of registration; the later the registration, the higher the priority. Therefore, the priority at the same time, from low to high, is as follows:</p>
<ul>
<li>s0 blocked data</li>
<li>Data updated based on s1 prediction results</li>
<li>Data updated based on s2 prediction results</li>
<li>Data updated based on s3 prediction results</li>
<li>Data in external redirection of BPU</li>
</ul>
<p>In this way, when the redirection of the prediction result is valid, we can avoid using the earlier pipeline level&rsquo;s prediction result and adopt the corrected prediction result. This allows us to handle external redirection requests with the highest priority.</p>
<p>We can conclude the method by which all generators generate s0 signals: <strong>Among all data valid signals, if only one is valid, the corresponding data is selected; if multiple data valid signals are valid, the data with the highest priority is selected</strong>.</p>
<h2 id="global-branch-history">Global Branch History</h2>
<p>We know that the global branch history is maintained at the BPU top level, and the maintenance strategy is consistent with the PC maintenance strategy. That is, after the prediction result is generated at each stage of the pipeline, the global branch history is updated based on the corresponding signals.</p>
<p>The top level defines two sets of signals to maintain the global branch history:</p>
<ul>
<li><strong>ghv</strong> stores the global branch history (maximum length 256)</li>
<li><strong>ghist_ptr</strong> global branch history pointer, pointing to the current position of the global branch history</li>
</ul>
<p>Similar to <code>s0_pc</code>, <code>s1_pc</code>, <code>s2_pc</code>, the BPU top level also maintains signals for each stage of the global history pointer: <code>s0_ghist_ptr</code>, <code>s1_ghist_ptr</code>, <code>s2_ghist_ptr</code>. However, the content in <code>ghv</code> is fixed in position, and we only use <code>ghist_ptr</code> to locate where the current global branch history starts.</p>
<h3 id="calculating-the-current-global-branch-history-with-ghist_ptr">Calculating the Current Global Branch History with ghist_ptr</h3>
<p>The use of <code>ghist_ptr</code> is only visible at the BPU top level. What we pass to the sub-predictors is the global branch history after the data in the global history register is shifted based on <code>ghist_ptr</code>. In the global branch history obtained by the sub-predictor, the least significant bit corresponds to the newest bit of the global branch history, and the most significant bit corresponds to the oldest bit.</p>
<p>So how is the shifting done? First, let&rsquo;s see how the global history is stored in <code>ghv</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Plain" data-lang="Plain"><span style="display:flex;"><span>|===== ghist =====&gt;| =======&gt;|
</span></span><span style="display:flex;"><span>n                  ^         0
</span></span><span style="display:flex;"><span>                   ghist_ptr
</span></span></code></pre></div><p>As shown in the figure above, the sequence represents the entire <code>ghv</code> register, and <code>ghist_ptr</code> points to a position in <code>ghv</code>. This position represents the newest bit of the global branch history. When a new global history record needs to be added, <code>ghist_ptr</code> is first decremented by 1, and then this bit is written to the position it points to. When <code>ghist_ptr</code> is decremented to 0, it will loop back to point to the highest position, thereby overwriting the previously written global branch history.</p>
<p>No matter what, starting from the position pointed to by <code>ghist_ptr</code>, the pointer increases and the history gets older. Therefore, when we need to calculate the current global branch history, we only need to circularly right-shift the <code>ghv</code> register by <code>ghist_ptr positions</code>.</p>
<h3 id="updating-global-branch-history">Updating Global Branch History</h3>
<p>The strategy for updating the global branch history is consistent with the strategy for updating the <code>pc</code>. At each pipeline stage, a <strong>pointer for the current stage and an update description of <code>ghv</code></strong> are generated based on the prediction result of the current stage, and all are sent to the relevant generator for processing.</p>
<p>The update strategy for the global branch history is consistent with the <code>pc</code> update strategy, requiring the generation of a <strong>current stage pointer and <code>ghv</code> update instructions</strong> based on the current stage&rsquo;s prediction results at each pipeline stage. These instructions are ultimately sent to the relevant generators for processing.</p>
<p>The update description of <code>ghv</code> is some information used to guide the update of the <code>ghv</code> register. Xiangshan BPU maintains two pieces of information to fulfill this duty:</p>
<ul>
<li><code>ghv_wdata</code> the data that needs to be written into ghv</li>
<li><code>ghv_wens</code> the write bit mask</li>
</ul>
<p>For the final update, only the bits identified by <code>ghv_wens</code> need to be written with the corresponding bits of <code>ghv_wdata</code>.</p>
<p><strong>Therefore, each pipeline stage needs to generate three sets of information: <code>ghist_ptr</code>, <code>ghv_wdata</code>, <code>ghv_wens</code></strong>.</p>
<p>Specifically, the prediction result can contain up to two branch instructions. We only need to set these pieces of information according to the actual situation. Here are some examples:</p>
<ul>
<li>Only the first slot is valid, and the conditional branch instruction in it is predicted as not taken. Then the next position of <code>ghv_wens</code> is set to 0, the corresponding position of <code>ghv_wens</code> is set to 1, and <code>ghist_ptr</code> is decremented by one.</li>
<li>Both slots contain conditional branch instructions, the first is predicted as not taken, and the second is predicted as taken. At this time, <code>ghist_ptr</code> should be decremented by two, and the other two pieces of information should indicate writing 01 to <code>ghv</code>.</li>
</ul>
<p>Here, only one piece of <code>ghv_wdata</code> information is maintained in the generator (maintained by the <code>ghvBitWriteGens</code> generator), and <code>ghv_wens</code> is not maintained by the generator. This is because a small trick is used here, where the final output of the generator&rsquo;s <code>ghv_wdata</code> is the result of the selected stage, and <code>ghv_wens</code> is used by performing a bitwise OR operation on <code>ghv_wens</code> of all stages.</p>
<p>This consideration is based on:</p>
<ul>
<li>If the later pipeline stage is valid, the global history pointer is restored to an older position, even if the history of newer positions is modified by the earlier pipeline&rsquo;s <code>ghv_wens</code>.</li>
<li>If the earlier pipeline stage is valid, the global history pointer continues to update to newer positions, and the later pipeline will not set <code>ghv_wens</code> due to the ineffective redirect.</li>
</ul>
<h2 id="branch-folded-history">Branch Folded History</h2>
<p>The branch folded history passed to the predictor is also maintained by the BPU top level. To shorten the update delay of the folded history, the BPU maintains many variables to support the fast update of the branch folded history. We will focus on this strategy and introduce the function of each variable.</p>
<p>Before we start, let&rsquo;s first look at how the branch folded history is defined and its structure.</p>
<h3 id="branch-folded-history-1">Branch Folded History</h3>
<p>If you have checked the BPU global interface documentation, you will know that the sub-predictor receives an array of bit vectors of different lengths, representing various lengths of folded history, and these folded histories are compressed from the global branch history.</p>
<p>For the global branch history, we have a register that stores the global branch history with a length of 256. For example, suppose the length of the global branch history is 15 bits, and after shifting, we get a branch history like this: the least significant bit is the newest history record, and the most significant bit is the oldest history record.</p>
<p>At this time, if we need to generate a 6-bit folded history from these 15 bits, we will use an XOR strategy for compression. The specific process is as follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Plain" data-lang="Plain"><span style="display:flex;"><span>    h[5]         h[4]       h[3]    h[2]   h[1]   h[0]
</span></span><span style="display:flex;"><span>    h[11]        h[10]      h[9]    h[8]   h[7]   h[6]
</span></span><span style="display:flex;"><span>^                                   h[14]  h[13]  h[12]
</span></span><span style="display:flex;"><span>---------------------------------------------------------------
</span></span><span style="display:flex;"><span>    h[5]^h[11]   h[4]^h[10]         ...           h[0]^h[6]^h[12]
</span></span></code></pre></div><p>That is, after arranging it as shown above, perform an XOR operation on the values at each position, and the result is the folded history of length 6.</p>
<h3 id="method-for-updating-branch-folded-history">Method for Updating Branch Folded History</h3>
<p>Now we want to update this branch folded history. When we insert a new history into the global branch history, it is inserted from the least significant bit, meaning the original h[0] becomes h[1]. If we want to obtain the folded history at this time, we only need to perform the XOR operation again. But such efficiency is too low, because the XOR operation may become particularly long. We can explore the impact of one update on the branch folded history.</p>
<p>In the example above, before inserting a new history, the 6-bit folded history is generated in the following arrangement:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Plain" data-lang="Plain"><span style="display:flex;"><span>h[5]   h[4]   h[3]  h[2]  h[1]  h[0]
</span></span><span style="display:flex;"><span>h[11]  h[10]  h[9]  h[8]  h[7]  h[6]
</span></span><span style="display:flex;"><span>                    h[14] h[13] h[12]
</span></span></code></pre></div><p>After inserting a new history, it becomes like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Plain" data-lang="Plain"><span style="display:flex;"><span>h[4]   h[3]   h[2]  h[1]  h[0]  h[new]
</span></span><span style="display:flex;"><span>h[10]  h[9]   h[8]  h[7]  h[6]  h[5]
</span></span><span style="display:flex;"><span>           (h[14])  h[13] h[12] h[11]
</span></span></code></pre></div><p>We can notice some patterns:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Plain" data-lang="Plain"><span style="display:flex;"><span>Before insertion:
</span></span><span style="display:flex;"><span>h[5]   {h[4]   h[3]  h[2]  h[1]  h[0] }
</span></span><span style="display:flex;"><span>h[11]  {h[10]  h[9]  h[8]  h[7]  h[6] }
</span></span><span style="display:flex;"><span>       {             h[14] h[13] h[12]}
</span></span><span style="display:flex;"><span>After insertion:
</span></span><span style="display:flex;"><span>{h[4]   h[3]   h[2]  h[1]  h[0] } h[new]
</span></span><span style="display:flex;"><span>{h[10]  h[9]   h[8]  h[7]  h[6] } h[5]
</span></span><span style="display:flex;"><span>{           (h[14])  h[13] h[12]} h[11]
</span></span></code></pre></div><p>The content in the curly braces has undergone a complete left shift, with h[5] and h[11] moving from the most significant bit to the least significant bit. So, in the compressed history, isn&rsquo;t this just a typical cyclic left shift that we often encounter!</p>
<p>However, only two bits have changed: one is the newly inserted h[new], and the other is the discarded h[14]. h[new] must be in the first position, and the discarded position is fixed. <strong>Therefore, to complete an update, we only need to know the value of the newly inserted history and the oldest bit of the previous history</strong>. After the cyclic shift, modifying these two positions according to the actual situation will give us the updated folded history.</p>
<h3 id="implementation-of-update-method">Implementation of Update Method</h3>
<p>To achieve this update in the top-level BPU, two additional variables are maintained:</p>
<ul>
<li><strong>ahead_fh_oldest_bits</strong>: the oldest bit of the global branch history, with additional bits stored before it</li>
<li><strong>last_br_num_oh</strong>: the slot number of the last effective branch instruction in the previous prediction</li>
</ul>
<p>An optimization in the timing of operations occurs here because the global history pointer can only be updated based on the branch outcome when the pipeline-level prediction result is available. Updating the oldest bit after updating the global history pointer would increase the latency. Therefore, we maintain the branch outcome and update the oldest bit when it is needed in the next cycle.</p>
<p>The oldest bit also needs to be maintained further back because after updating using the branch outcome, the relatively newer bits will become the oldest bits.</p>
<p>Thus, there are three generators related to the folded history: <code>foldedGhGen</code>, <code>lastBrNumOhGen</code>, and <code>aheadFhObGen</code>.</p>
<p><strong>Information required for each update of the folded history</strong>：</p>
<ul>
<li>Folded history information before the update</li>
<li>Oldest bit of the global branch history (ahead_fh_oldest_bits)</li>
<li>Last prediction&rsquo;s branch outcome (last_br_num_oh)</li>
<li>Whether there is a branch instruction in this update</li>
<li>The branch outcome of this update: the slot number of the last effective branch instruction</li>
</ul>
<p>For each update of the folded history, the true oldest bit needs to be determined based on <code>last_br_num_oh</code> and <code>ahead_fh_oldest_bits</code>. Then, based on the oldest bit and the branch outcome of this update, several bits are modified, and finally, a cyclic left shift completes the update operation.</p>
<h2 id="pipeline-control-method">Pipeline Control Method</h2>
<p>Pipeline control is the core function of the BPU, with complex logic. All pipeline control signals in the top-level BPU are as follows:</p>
<ul>
<li><strong>s1_valid, s2_valid, s3_valid</strong>: indicate the corresponding pipeline data is valid</li>
<li><strong>s1_ready, s2_ready, s3_ready</strong>: indicate the corresponding pipeline is ready to continue the prediction of the previous pipeline stage</li>
<li><strong>s1_component_ready, s2_component_ready, s3_component_ready</strong>: indicate the readiness of the corresponding pipeline sub-predictor</li>
<li><strong>s0_fire, s1_fire, s2_fire, s3_fire</strong>: successful handshake signals, indicating that the pipeline data is valid and has been successfully passed to the next pipeline</li>
<li><strong>s1_flush, s2_flush, s3_flush</strong>: indicate whether the current pipeline needs flushing</li>
<li><strong>s2_redirect, s3_redirect</strong>: indicate whether the current pipeline needs to redirect due to a different prediction result</li>
</ul>
<h3 id="valid-ready-与-fire">valid, ready 与 fire</h3>
<p>We will introduce the purpose of each signal step by step. First, let&rsquo;s look at the <code>fire</code> signal, which indicates a successful handshake in the pipeline, meaning that the data has been successfully passed to the next pipeline. This signifies the end of the current cycle and the end of the prediction for this pipeline stage, with the prediction for the next pipeline stage about to begin in the next cycle.</p>
<p>This requires two conditions:</p>
<ol>
<li><code>valid</code>: The data in the current pipeline stage is valid.</li>
<li><code>ready</code>: Indicates whether the next pipeline stage in the BPU top level and the predictor are ready.</li>
</ol>
<p>When these two signals are high simultaneously, the <code>fire</code> signal is valid, indicating a successful handshake. If we isolate a single prediction, the timing should look like this (in reality, most of the time, each pipeline is valid continuously):</p>

<figure>
    <img src="1.png" width="400px"/> 
</figure>

<p>Of the four sets of signals mentioned earlier, <code>component_ready</code> is generated by the predictor, while the rest are maintained by the BPU top level, with only the fire set of signals exposed to the sub-predictor.</p>
<p>Next, let&rsquo;s take s2 as an example to see how each signal is maintained.</p>
<p><strong>ready</strong> <strong>Signal</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Scala" data-lang="Scala"><span style="display:flex;"><span><span style="color:#000">s2_ready</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">s2_fire</span> <span style="color:#ce5c00;font-weight:bold">||</span> <span style="color:#ce5c00;font-weight:bold">!</span><span style="color:#000">s2_valid</span>
</span></span></code></pre></div><p>This assignment statement is a combinational circuit assignment, meaning that <code>s2_ready</code> is directly related to <code>s2_fire</code> and <code>s2_valid</code> for this cycle, with two possible situations:</p>
<ul>
<li>If <code>s2_valid</code> is invalid for this cycle, indicating that the s2 pipeline stage is empty and can accept new data, then <code>s2_ready</code> is valid.</li>
<li>If <code>s2_valid</code> is valid for this cycle, indicating that the s2 pipeline stage has data that has not been passed to the next stage yet, but if <code>s2_fire</code>, then the data will be passed in the next cycle. In this case, <code>s2_ready</code> is valid, indicating that the data can flow into the next stage.</li>
</ul>
<p><strong>valid Signal</strong></p>
<p>Maintaining ·s2_valid· is relatively simple, as it is only related to <code>s1_fire</code> and <code>s2_ready</code> signals. The relationship is as follows:</p>
<ul>
<li>When <code>s1_fire</code> is valid, indicating that data is coming in and <code>s2_valid</code> will be valid in the next cycle.</li>
<li>When <code>s2_fire</code> is valid, indicating that data is flowing out and <code>s2_valid</code> will be invalid in the next cycle.</li>
</ul>
<p><strong>fire Signal</strong></p>
<p>The fire signal is somewhat special, but for intermediate pipeline stages, its maintenance is straightforward. For example,</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Scala" data-lang="Scala"><span style="display:flex;"><span><span style="color:#000">s2_fire</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">s2_valid</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000">s3_components_ready</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000">s3_ready</span>
</span></span></code></pre></div><p>This simply requires considering the <code>valid</code> of the current pipeline stage and the <code>ready</code> of the next pipeline stage.</p>
<p>However, for s0_fire, since there is no valid signal, it is directly set to <code>s1_components_ready &amp;&amp; s1_ready</code>.</p>
<p>For s3_fire, as there is no ready signal for the next stage, it is directly set to <code>s3_valid</code>.</p>
<h3 id="incorporating-flush-and-redirect">Incorporating Flush and Redirect</h3>
<p>When there is a different prediction result in the pipeline, a redirection signal is generated, and the pipeline needs to be flushed. <code>flush</code> and <code>redirect</code> handle these two tasks. <code>redirect</code> indicates whether the current pipeline stage needs redirection, while <code>flush</code> indicates whether the current pipeline stage needs flushing.</p>
<p><strong>redirect Signal</strong></p>
<p>The generation of <code>s2_redirect</code> is as follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Scala" data-lang="Scala"><span style="display:flex;"><span><span style="color:#000">s2_redirect</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">s2_fire</span> <span style="color:#ce5c00;font-weight:bold">&amp;&amp;</span> <span style="color:#000">s2_redirect_s1_last_pred</span>
</span></span></code></pre></div><p>This means that when <code>s2_fire</code> is valid and the prediction result of s2 is different from the prediction result saved from s1, this signal is valid. Later, this signal will be connected to the input of the sub-predictor and the output of the BPU prediction result, guiding the sub-predictor and FTQ to restore their states.</p>
<p><strong>flush Signal</strong></p>
<p>The flush signal is used to guide the flushing of the pipeline. For example, when s3_redirect is valid, it means that the incorrect prediction result has entered the pipeline, and both s1 and s2 are now predicting based on the wrong result. Therefore, the pipeline needs to be flushed to stop the previous stages and wait for new prediction results to enter.</p>
<p>Specifically, the relationship between them is:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Scala" data-lang="Scala"><span style="display:flex;"><span> <span style="color:#000">s2_flush</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">s3_flush</span> <span style="color:#ce5c00;font-weight:bold">||</span> <span style="color:#000">s3_redirect</span>
</span></span><span style="display:flex;"><span> <span style="color:#000">s1_flush</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">s2_flush</span> <span style="color:#ce5c00;font-weight:bold">||</span> <span style="color:#000">s2_redirect</span>
</span></span></code></pre></div><p>This means that if a pipeline stage needs redirection, all previous stages will be flushed. The purpose of flush is to guide the valid signal. If the valid signal is valid in this cycle but the fire signal is not, it means that the incorrect data has not been taken by the next pipeline stage. In this case, when flush is valid, valid will immediately become invalid in the next cycle, avoiding storing incorrect data in the pipeline for a long time.</p>
<p>However, the effect of flush on the valid signal varies depending on each pipeline stage. For example:</p>
<ul>
<li>For the s1 pipeline stage, although flush is valid, if <code>s0_fire</code> is valid, indicating that new data is flowing in, valid will remain valid in the next cycle.</li>
<li>For the s2 pipeline stage, if flush is valid, valid will definitely be invalid in the next cycle (because s1 is also flushed), indicating that valid can be directly set to invalid. However, there is a special case where <code>s2_redirect</code> occurs but <code>s2_flush</code> is not set to valid. In this case, if <code>s1_fire</code> occurs, the incorrect prediction result of s1 may also flow in. In this case, <code>s2_valid</code> needs to be determined based on the <code>s1_flush</code> signal.</li>
</ul>
<p>The use of flush is complex, and more detailed details need to be understood by referring to the code.</p>
<h2 id="redirect-recovery-logic">Redirect Recovery Logic</h2>
<p>When the redirect request from FTQ to BPU takes effect, it indicates that all stages of the pipeline have incorrect predictions, and all stages should be flushed. This can be achieved by setting <code>s3_flush</code> to be valid. Therefore, we have:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Scala" data-lang="Scala"><span style="display:flex;"><span> <span style="color:#000">s3_flush</span> <span style="color:#204a87;font-weight:bold">:</span><span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">redirect_req</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#000">valid</span>
</span></span></code></pre></div><p>In the BPU, the redirect request is delayed by one cycle before being officially used. Therefore, the response of <code>s1_valid</code> to the <code>flush</code> signal needs to be changed. When the redirect request (before delay) is valid, <code>s1_valid</code> in the next cycle is immediately set to invalid, without the need to refer to the <code>s0_fire</code> signal.</p>
<p>At this point, generators such as <code>npcGen</code> also need to directly use the data from the redirect request to generate, which is equivalent to redirecting the BPU&rsquo;s state to the state before the error occurred. However, it is important to note that the default redirect level in BPU is <code>flushAfter</code>, which means that the redirect request corresponds to a predicted erroneous instruction, and the BPU assumes that although this instruction was predicted incorrectly, it has been corrected and executed by the backend. Therefore, the next prediction can start directly from the next instruction.</p>
<p>Therefore, when recovering from a redirect, it is necessary not only to restore the information from the redirect interface, but also to update the execution status of this predicted erroneous instruction in the history.</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e6d1611b25352acdff178100e9b3296d">3.2 - uFTB Branch Predictor</h1>
    
	<h2 id="introduction-to-uftb">Introduction to uFTB</h2>
<p>uFTB is the first predictor among all the predictors in Xiangshan, and it serves as the cornerstone for other predictors to generate prediction results. uFTB works in the s1 stage. It can generate prediction results within the current cycle after obtaining s1_pc and output them in the s1 channel, without modifying other channels. It provides the position of the branch instruction and the target of the instruction. Subsequent predictors will further predict based on this result.</p>
<p>Its essence is an FTB item cache, which stores FTB items, and the basic prediction result will be directly generated from the read-out FTB item.</p>
<p>Therefore, before you start reading the document, make sure you understand the FTB items and their meanings, as well as the specific details of the prediction result interface.</p>
<h2 id="functionality-of-uftb">Functionality of uFTB</h2>
<ul>
<li><strong>Cache FTB items and generate one-cycle prediction results</strong>: uFTB maintains a small FTB item cache. After receiving PC, it reads out the FTB item corresponding to the PC within one cycle and generates an s1 stage prediction result from the FTB item.</li>
<li><strong>Maintain two-bit saturating counters to provide basic conditional branch results</strong>: uFTB maintains two-bit saturating counters for each line of the FTB item cache. The direction prediction result is reflected in the prediction result output of uFTB.</li>
<li><strong>Update the FTB cache and two-bit saturating counters based on update requests</strong></li>
</ul>
<h2 id="uftb-cache-structure">uFTB Cache Structure</h2>
<p>As mentioned above, uFTB is essentially a small cache that stores FTB items. Its approximate structure is shown in the figure below.</p>

<figure>
    <img src="1.png" width="400px"/> 
</figure>

<p>In the current version of Xiangshan, uFTB has a total of 32 cache lines, each cache line is called <code>FauFTBWay</code>, and one FTB item can be stored in each cache line.</p>
<p><strong>When s1 pipeline is valid</strong>, uFTB will use <code>s1_pc</code> to determine which item of the uFTB cache to read out. The cache is indexed based on the tag field in PC, which is defined as pc[16:1], i.e., taking 16 bits from PC as an identifier to match a certain line in the cache.</p>
<p>Each line in the cache, i.e., the data request interface in <code>FauFTBWay</code>, has three items:</p>
<ul>
<li><strong>req_tag</strong>: Input tag identifier extracted from pc</li>
<li><strong>resp</strong>: Output the FTB item stored in this line</li>
<li><strong>resp_hit</strong>: Output indicates whether the FTB item in this line matches req_tag
uFTB connects the tag to the data request interface of each line in the cache and selects the hit FTB item based on the <code>resp_hit</code> signal. Subsequent steps will generate a complete prediction result based on this FTB item.</li>
</ul>
<h2 id="two-bit-saturating-counters">Two-Bit Saturating Counters</h2>
<p>uFTB maintains two-bit saturating counters for each line of the FTB item cache. As we know, an FTB item can store up to two conditional branch instructions, so each line&rsquo;s two-bit saturating counters also have two, responsible for providing rough prediction results for the conditional branch instructions in them.</p>
<p>When indexing the FTB item, uFTB also indexes the corresponding two-bit saturating counters.</p>
<p>When the prediction result is generated, it will be based on the FTB item and the contents of the two two-bit saturating counters corresponding to it.</p>
<h2 id="prediction-result-generation">Prediction Result Generation</h2>
<p>After indexing the corresponding FTB item and two two-bit saturating counters based on s1_pc, uFTB needs to generate a prediction result based on them. The prediction result generated by uFTB will be outputted through the s1 channel when s1 pipeline is valid, and will not be modified for s2 and s3 channels.</p>
<p><strong>The signal generation method in the s1 prediction result can refer to the following list:</strong></p>
<ul>
<li><strong>hit</strong>Whether the FTB item hits
<ul>
<li>Generation method: <code>resp_hit</code> signal in <code>FauFTBWay</code>, one of them is valid</li>
</ul>
</li>
<li><strong>slot_valids</strong>: Slot valid bit, indicating whether each slot in the ftb item is valid</li>
<li><strong>targets</strong>: Jump target address corresponding to each slot</li>
<li><strong>offsets</strong>: The offset of each instruction in the slot relative to the starting address of the prediction block</li>
<li><strong>is_jal</strong>: Whether the prediction block contains a jal instruction</li>
<li><strong>is_jalr</strong>: Whether the prediction block contains a jalr instruction</li>
<li><strong>is_call</strong>: Whether the prediction block contains a call instruction</li>
<li><strong>is_ret</strong>: Whether the prediction block contains a ret instruction</li>
<li><strong>last_may_be_rvi_call</strong>: Signal indicating that the last slot in the prediction block may be an RVI type call instruction</li>
<li><strong>is_br_sharing</strong>: The signal stored in the last slot (tailSlot) indicates a conditional branch instruction.
<ul>
<li>Generation: Exported from the corresponding field in the FTB entry.</li>
</ul>
</li>
<li><strong>fallThroughErr</strong>: The <code>pftAddr</code> recorded in the FTB entry is incorrect.
<ul>
<li>Generation: Compare whether the end address represented by <code>pftAddr</code> is greater than the start address of the predicted block. If it is smaller, an error has occurred, and this signal is set to valid. This situation may occur when the PC indexes an incorrect FTB entry.</li>
</ul>
</li>
<li><strong>fallThroughAddr</strong>: The end address of the predicted block.
<ul>
<li>Generation: If <code>fallThroughErr</code> is invalid, it is generated based on <code>pftAddr</code>. Otherwise, it is set to the start address + prediction width.</li>
</ul>
</li>
<li><strong>br_taken_mask</strong>: Branch prediction result, with each branch (slot) corresponding to a bit indicating whether the branch is predicted as taken.
<ul>
<li>Generation: Generated based on the <code>always_taken</code> field in the FTB entry and the result indicated by the two-bit saturating counter.</li>
</ul>
</li>
<li><strong>jalr_target</strong>: The jump target of the jalr in this predicted block.
-Generation: From the jump target in the tailSlot of the FTB entry.</li>
</ul>
<h2 id="uftb-update">uFTB Update</h2>
<p>The update of uFTB involves updating the FTB entry cache and the two-bit saturating counter, with the update content obtained through the update interface.</p>
<p>In the uFTB predictor, the reading and writing of the cache and the two-bit saturating counter do not conflict, so we do not need to consider timing conflicts between reading and updating and can consider them as two independent parts.</p>
<h3 id="ftb-cache-update">FTB Cache Update</h3>
<p>The update process of the FTB cache is simple. The update channel has already specified the PC and the newly generated FTB entry, so it only needs to be written to the specified position in the cache.</p>
<p>FTB cache updating requires two cycles:</p>
<ul>
<li>In the first cycle, calculate the following based on the signals in the update:
<ul>
<li><strong>Which row in the cache corresponds to the update request</strong> The PC extracted from the update request is sent to the update request channel of FauFTBWay, and the hit signal returned by each row is calculated.</li>
</ul>
</li>
<li>In the second cycle, update according to the position calculated in the first cycle. If no row is hit, uFTB will use a <strong>pseudo-LRU replacement algorithm</strong> to select the row to be written.
Specifically, the ftb_entry signal group in the update channel contains the complete information of the new FTB entry, which is sent to the cache row that needs to be updated.</li>
</ul>
<h3 id="two-bit-saturating-counter-update">Two-Bit Saturating Counter Update</h3>
<p>The update of the two-bit saturating counter needs to be combined with the actual execution of the subsequent program and the branch instruction information recorded in the FTB entry, which can be obtained from the update channel.</p>
<p>The update of the two-bit saturating counter also requires two cycles:</p>
<ul>
<li>In the first cycle, calculate which two-bit saturating counter corresponding to the conditional branch instruction in the slot needs to be updated, which needs to meet the following conditions:
<ul>
<li>The current branch instruction slot is valid and contains a conditional branch instruction.</li>
<li>The current branch instruction slot is not marked as always_taken. (Because after being marked as always_taken, the result of the two-bit saturating counter will not be used.)</li>
<li>The current branch instruction slot is not after the branch instruction slot where an actual jump occurred.</li>
</ul>
</li>
<li>In the second cycle, update the saturating counter based on the mask generated in the first cycle and the <code>br_taken_mask</code> information in the update channel.</li>
</ul>
<h2 id="interface-list">Interface List</h2>
<table>
<thead>
<tr>
<th>信号类型</th>
<th>信号位</th>
<th>信号名</th>
<th>信号描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td></td>
<td>clock</td>
<td>输入时钟</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>reset</td>
<td>复位信号</td>
</tr>
<tr>
<td>input</td>
<td>[35:0]</td>
<td>io_reset_vector</td>
<td>用于reset时，reset s1_pc_dup_0 提供的值</td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_s0_pc_0</td>
<td>输入位s0_pc 的 第0个复制</td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_s0_pc_1</td>
<td>同上 第1个</td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_s0_pc_2</td>
<td>同上 第2个</td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_s0_pc_3</td>
<td>同上 第3个</td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_pc_0</td>
<td>输出s1_pc 的 第0个复制</td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_pc_1</td>
<td>同上 第1个</td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_pc_2</td>
<td>同上 第2个</td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_pc_3</td>
<td>同上 第3个</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_0_br_taken_mask_0</td>
<td>solt 0 是否被预测为 always taken</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_0_br_taken_mask_1</td>
<td>solt 1 是否被预测为 always taken</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_0_slot_valids_0</td>
<td>solt 0 是否启用</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_0_slot_valids_1</td>
<td>solt 1 是否启用</td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_full_pred_0_targets_0</td>
<td>solt 0 对应的跳转目标地址</td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_full_pred_0_targets_1</td>
<td>solt 1 对应的跳转目标地址</td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s1_full_pred_0_offsets_0</td>
<td>solt 0 中分支指令相对于地址块起始pc的偏移</td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s1_full_pred_0_offsets_1</td>
<td>solt 1 中分支指令相对于地址块起始pc的偏移</td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_full_pred_0_fallThroughAddr</td>
<td>预测块的结束地址</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_0_is_br_sharing</td>
<td>solt 1（无条件跳转）是否被共享为有条件跳转指令</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_0_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_1_br_taken_mask_0</td>
<td>类似 io_out_s1_pc_1 io_out_s1_full_pred_0的复制</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_1_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_1_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_1_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_full_pred_1_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_full_pred_1_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s1_full_pred_1_offsets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s1_full_pred_1_offsets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_full_pred_1_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_1_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_1_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_2_br_taken_mask_0</td>
<td>同上</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_2_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_2_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_2_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_full_pred_2_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_full_pred_2_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s1_full_pred_2_offsets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s1_full_pred_2_offsets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_full_pred_2_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_2_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_2_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_3_br_taken_mask_0</td>
<td>同上</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_3_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_3_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_3_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_full_pred_3_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_full_pred_3_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s1_full_pred_3_offsets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s1_full_pred_3_offsets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s1_full_pred_3_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_3_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_3_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s1_full_pred_3_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[222:0]</td>
<td>io_out_last_stage_meta</td>
<td>输出最后阶段的元信息 io_out_last_stage_meta = {213&rsquo;h0, resp_meta_pred_way_r_1, resp_meta_hit_r_1}</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_ctrl_ubtb_enable</td>
<td>控制ubtb是否启用</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s0_fire_0</td>
<td>输入s0_fire_0，与 io_out_s1_pc_0 &lt;= io_in_bits_s0_pc_0 的时钟门控相关</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s0_fire_1</td>
<td>输入s0_fire_1</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s0_fire_2</td>
<td>输入s0_fire_2</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s0_fire_3</td>
<td>输入s0_fire_3</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s1_fire_0</td>
<td>输入s1_fire_0</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s2_fire_0</td>
<td>输入s2_fire_0</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_valid</td>
<td>更新有效性</td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_update_bits_pc</td>
<td>传回的预测块pc（用于指示更新的预测块）</td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_update_bits_ftb_entry_brSlots_0_offset</td>
<td>solt 0 中分支指令相对于地址块起始pc的偏移</td>
</tr>
<tr>
<td>input</td>
<td>[11:0]</td>
<td>io_update_bits_ftb_entry_brSlots_0_lower</td>
<td>跳转目标地址的低位</td>
</tr>
<tr>
<td>input</td>
<td>[1:0]</td>
<td>io_update_bits_ftb_entry_brSlots_0_tarStat</td>
<td>跳转后的 pc 高位是否进退位</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_brSlots_0_valid</td>
<td>是否启用</td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_update_bits_ftb_entry_tailSlot_offset</td>
<td>solt 1 中分支指令相对于地址块起始pc的偏移</td>
</tr>
<tr>
<td>input</td>
<td>[19:0]</td>
<td>io_update_bits_ftb_entry_tailSlot_lower</td>
<td>跳转目标地址的低位</td>
</tr>
<tr>
<td>input</td>
<td>[1:0]</td>
<td>io_update_bits_ftb_entry_tailSlot_tarStat</td>
<td>跳转后的 pc 高位是否进退位</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_tailSlot_sharing</td>
<td>无条件跳转指令槽中存储条件分支指令</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_tailSlot_valid</td>
<td>是否启用</td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_update_bits_ftb_entry_pftAddr</td>
<td>Partial Fallthrough Addr 如果预测块中没有跳转，那么程序将会顺序执行到达的地址，预测块的结束地址。</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_carry</td>
<td>pc+pft时是否产生进位</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_always_taken_0</td>
<td>是否预测为总是跳转</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_always_taken_1</td>
<td>是否预测为总是跳转</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_br_taken_mask_0</td>
<td>是否跳转</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_br_taken_mask_1</td>
<td>是否跳转</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-acd2cf0c1c9c53099412da29a7437546">3.3 - TAGE-SC Branch Predictor</h1>
    
	<h2 id="introduction">Introduction</h2>
<p>TAGE-SC is the <strong>primary predictor</strong> for conditional branches in the Kunming Lake architecture, classified as an Accurate Predictor (APD). TAGE-SC can be seen as two relatively independent components: the prediction part TAGE and the verification part SC.</p>
<p>The Tagged Geometric History Length Predictor (TAGE) utilizes <strong>multiple prediction tables with different history lengths</strong> to exploit <strong>extensive branch history information</strong>. TAGE predicts whether a branch instruction will be taken or not taken. It consists of a base prediction table and multiple history tables. It first predicts using multiple history tables. If there is no prediction, it uses the prediction from the base table.
The Statistical Corrector (SC) is a statistical corrector. SC references the prediction results of TAGE and <strong>statistical bias results</strong>. Based on these two results, it <strong>corrects</strong> the final prediction result.</p>
<p>In Kunming Lake, each prediction block can have up to 2 branch instructions, so TAGE can predict <strong>up to 2 conditional branch instructions simultaneously</strong>. When accessing the various history tables in TAGE, the starting address of the prediction block is used as the PC, and two prediction results are retrieved based on the <strong>same global history</strong>.</p>
<h2 id="tage-branch-predictor-in-kunming-lake">TAGE Branch Predictor in Kunming Lake</h2>
<h3 id="basic-functionality">Basic Functionality</h3>
<p><img alt="img" src="tage.PNG"></p>
<p>The core idea of the TAGE predictor is to provide prediction results with different history lengths and select the most appropriate result for feedback. In the TAGE predictor, there are a total of <strong>1+N</strong> history record tables, where N is a configurable option. In Kunming Lake, N=4.</p>
<p>The base predictor based on the T0 table is the <strong>baseline predictor</strong>. During prediction, it directly looks up the &ldquo;2-bit saturated counter representing the jump history information&rdquo; corresponding to the address in the T0 table, and then makes a prediction based on the history information. The T0 table has only 2 bits per entry, so the history states it can record are limited.</p>
<p>For tables other than T0, we use <strong>Tn</strong> to represent them. During table lookup, in addition to the PC, it is also necessary to use the <strong>global jump history information H</strong> for the lookup. When a match is found, the prediction is made based on the &ldquo;3-bit saturated predictor&rdquo; to jump or not to jump. The higher the value of n for the Tn table, the longer the history information it uses, i.e., x&lt;y.</p>
<p>For each prediction, TAGE selects the table entry with the <strong>longest global jump history</strong> among all the hit Tn entries.</p>
<ol>
<li>If the table entry exists and the prediction result confidence is high, it is used as the final prediction result.</li>
<li>If the confidence is low, another internal counter is used to determine whether to select that entry or T0 as the final prediction.</li>
</ol>
<p>To save space, when retrieving the Tn table, the input jump history information H needs to be <strong>compressed</strong>, a process also known as <strong>history folding</strong>.</p>
<p>The table entries of each prediction table include the following elements:</p>
<ol>
<li>T0 table indexed directly by PC
<ol>
<li>2-bit pred <strong>unsigned</strong> saturated counter (indicating prediction direction and confidence level)</li>
</ol>
</li>
<li>Tn table indexed by XOR of PC and folded global history
<ol>
<li>1-bit valid bit</li>
<li>3-bit pred <strong>unsigned</strong> saturated counter</li>
<li>8-bit tag (used for verifying whether the hit is intentional, not coincidental)</li>
<li>1-bit useful bit for controlling expiration
For a prediction block, all tables may generate prediction results, requiring a selection process. Typically, the higher the Tn table number, the higher its priority.</li>
</ol>
</li>
</ol>
<h3 id="pipeline">Pipeline</h3>
<p>TAGE contains two pipeline stages: the first stage calculates the index, and the second stage reads the results from the SRAM table.</p>
<ol>
<li>Stage 0 (s0): Input to the first pipeline stage, usually the pc and folded history.
<strong>First pipeline stage operation</strong>: Calculate the index. Output to s1 via registers.</li>
<li>Stage 1 (s1): Input to the second pipeline stage, consisting of the index and other calculated data from the first stage.
<strong>Second pipeline stage operation</strong>: Memory access to SRAM, reading the prediction result. Output to s2 via registers.</li>
<li>Stage 2 (s2): Actual prediction result. TAGE uses 2 stages for prediction, with the prediction result ready for use in the third stage after 2 stages.</li>
</ol>
<h3 id="data-structures">Data Structures</h3>
<ol>
<li>
<p>In Kunming Lake&rsquo;s implementation, the T0 and Tn table structures are as follows:</p>
<ol>
<li>
<table>
<thead>
<tr>
<th><strong>预测器</strong></th>
<th><strong>作用</strong></th>
<th><strong>表项构成</strong></th>
<th><strong>项数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>基准预测器T0</td>
<td>用于在其他预测器的预测结果都无效时输出预测结果</td>
<td>2 bit ctr 饱和计数器最高位决定跳转方向</td>
<td>2路各2048项，每路对于一条分支指令</td>
</tr>
<tr>
<td>预测表T1-T4</td>
<td>对每个预测块的输入，所有Tn表都进行预测，在所有预测有效的结果中，选择历史记录最长的结果作为最后预测结果。历史记录长度由输入的H决定</td>
<td>1 bit valid 有效位 3 bit ctr 饱和计数器8 bit tag 校验命中1 bit us 作为usefulness计数器</td>
<td>4096项、奇数项对应第一条分支指令，偶数项对应第二条分支指令</td>
</tr>
</tbody>
</table>
</li>
</ol>
</li>
</ol>
<p>For each table Tn, the length of its input &ldquo;global branch history data H&rdquo; varies during querying. Assuming the total prediction history length is S, Tn and Tn+1 may use the low x, low y bits of S (<strong>the lower bits are the newer history</strong>) as query inputs. Generally, the larger the n of table Tn, the longer the history information used, i.e., x&lt;y.</p>
<p>During the query of table Tn, since the historical data H is &ldquo;compressed,&rdquo; it may lead to a situation where the result of one PC1^H1 matches another PC2^H2 (similar to a Hash collision), resulting in indexing into invalid data (predicting PC1 indexes to predicted PC2&rsquo;s data). Therefore, TAGE provides a tag identifier for each table, using an 8-bit tag in the Kunming Lake implementation to reduce the probability of collisions. The calculation method and index method for tags are different; <strong>only when the tag calculation is the same, the query result is valid</strong>.</p>
<p>In the Tn table entry, in addition to the saturation counter ctr and tag, there is also a 1-bit <strong>usefulness counter</strong>. When this counter is 0, it is a weak entry, indicating that the entry can be reallocated for other uses; when it is not 0, it is a strong entry, indicating that the entry cannot be reallocated for other uses.</p>
<p>To <strong>try to avoid</strong> the situation where all table entries are 1 and no new table entries can be allocated, TAGE expects to use the counter bankTickCtrs to clear all usefulness to 0.</p>
<h3 id="retrieval-method-for-t0-and-tn-tables">Retrieval Method for T0 and Tn Tables</h3>
<ul>
<li>For table T0, indexing is done using the PC[11:1] bits to index 2048 table entries, so for T0, there is no possibility of not finding a match.</li>
<li>For table Tn, in addition to PC[11:1], retrieval also requires searching based on the global branch history. In Kunming Lake, the top-level branch predictor maintains a 256-bit global history record GH, which can fold the GH&rsquo;s most recent n bits of history information based on the required number of bits x for the sub-predictor. That is, n is divided into ceil(x/n) units of length x, and then XOR is performed bitwise. This folded history is denoted as FH (Folded History), and the specific process can be found in the [Branch Folding History section](../00_bpu_top/#Branch Folding History). When the TAGE predictor searches for a table entry in Tn, it uses the index and tag, calculated as follows:</li>
</ul>
<table>
<thead>
<tr>
<th><strong>Calculation Formula</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>index = FH ^ ((pc&raquo;1)低位)</td>
</tr>
<tr>
<td>tag = FH1 ^ FH2 ^ ((pc&raquo;1)低位)</td>
</tr>
</tbody>
</table>
<p>Where FH, FH1, FH2 represent the folded global branch history according to certain rules. For Tn, FH, FH1, and FH2 each have their own folding bit numbers, which may not be the same. In the Kunming Lake implementation, the configurations of the T0 and Tn tables are as follows:</p>
<table>
<thead>
<tr>
<th><strong>表名称</strong></th>
<th><strong>FH长度</strong></th>
<th><strong>FH1长度</strong></th>
<th><strong>FH2长度</strong></th>
<th><strong>最近历史长度（用到GH中的位数）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td>8比特</td>
<td>8比特</td>
<td>7比特</td>
<td>低8位，即把最新8位历史，折叠成FH、FH1、FH2</td>
</tr>
<tr>
<td>T2</td>
<td>11比特</td>
<td>8比特</td>
<td>7比特</td>
<td>低13位，即把最新13位历史，折叠成FH、FH1、FH2</td>
</tr>
<tr>
<td>T3</td>
<td>11比特</td>
<td>8比特</td>
<td>7比特</td>
<td>低32位，即把最新32位历史，折叠成FH、FH1、FH2</td>
</tr>
<tr>
<td>T4</td>
<td>11比特</td>
<td>8比特</td>
<td>7比特</td>
<td>低119位，即把最新119位历史，折叠成FH、FH1、FH2</td>
</tr>
</tbody>
</table>
<p>Note: pc&raquo;1 is used because RISC-C extension is used, with 2-byte alignment, and PC itself is already aligned to 1 byte, so only 1 bit is used.</p>
<h3 id="alternative-predictor">Alternative Predictor</h3>
<p>Since the Tn table uses saturation counters for prediction, there may be situations where the output result is &ldquo;not confident.&rdquo; For example, in Kunming Lake, for a 3-bit saturation counter, both 100 and 011 indicate a <strong>weak prediction</strong>. To provide more choices as references for this state, the TAGE predictor also provides an &ldquo;alternative predictor&rdquo; mechanism, which determines whether to select the prediction result of Tn or T0 when the Tn table predicts with low confidence.</p>
<p>In the Kunming Lake implementation, the &ldquo;alternative predictor&rdquo; is implemented based on the register group <strong>useAltOnNaCtrs</strong>. It consists of two paths of 128 <strong>4-bit saturation counters</strong> each, initialized to <strong>0b1000</strong>. When TAGE makes a prediction, it uses <strong>PC(7,1)</strong> to index the corresponding saturation counter. If the value of this counter is greater than or equal to the preset value and the prediction result of Tn is not confident, it selects the result of T0; otherwise, it selects the result of Tn.</p>
<h3 id="prediction-process">Prediction Process</h3>
<p>In summary, the prediction steps of the TAGE predictor in Kunming Lake are as follows:</p>
<ol>
<li><strong>Parallel</strong> indexing of T0 and Tn tables, selecting which table to use based on the hit result:
<ol>
<li>If a match to the tag of a Tn table is found, the potential prediction result is given by the saturation counter of the longest history Tn table.</li>
<li>If no match to a Tn table is found, the final prediction result is given by the saturation counter of the T0 table.</li>
</ol>
</li>
<li>If the potential prediction result of the matched Tn table is a weak prediction (100,011), and the value of the corresponding 4-bit counter in the alternative prediction for PC is greater than or equal to a threshold, the result of the T0 table is used as the final result; otherwise, the prediction result of the Tn table is used as the final prediction result.</li>
</ol>
<h3 id="training-process">Training Process</h3>
<p>Since the prediction process of TAGE involves many counters and tags, they need to be updated according to certain rules, a process known as training. This training process occurs in the BPU&rsquo;s update stage, where the PC, branch history, and prediction correctness information are input. The training process for branch prediction in Kunming Lake is divided into several steps based on different conditions:</p>
<ol>
<li>Update when <strong>T0</strong> is the final prediction result: If a jump occurs (i.e., taken), increment the ctr saturation counter indexed by the pc; otherwise, decrement it.</li>
<li>When <strong>only T0</strong> is hit, the following operations are performed:
<ol>
<li>If T0 is <strong>predicted correctly</strong>, no additional update is performed.</li>
<li>If T0 is <strong>predicted incorrectly</strong>, attempt to randomly allocate a new table entry in a Tn table. To allocate a new table entry, the original entry&rsquo;s usefulness at the corresponding index must be 0. The new entry is initialized as a weak prediction with usefulness 0, and its tag is set to the newly calculated tag.</li>
</ol>
</li>
<li>When <strong>both T0 and Tn are hit</strong>, the following operations are performed:
<ol>
<li><strong>Tn</strong> is always updated: If a jump occurs, increment the ctr saturation counter indexed by the pc; otherwise, decrement it. It is important to note that &ldquo;hit&rdquo; means that the tag of the indexed entry matches the calculated tag.</li>
<li>If <strong>T0 and Tn produce the same result</strong>:
<ol>
<li>If <strong>predicted correctly</strong>, no additional update is performed.</li>
<li>If <strong>predicted incorrectly</strong>, attempt to allocate a new table entry in a table with a longer history than Tn. To allocate a new entry, the usefulness of the original entry at the corresponding index must be 0. The new entry is initialized as a weak prediction with usefulness 0, and its tag is set to the tag calculated using the new history information.</li>
</ol>
</li>
<li>If <strong>T0 and Tn produce different results</strong>:
<ol>
<li>If <strong>Tn is correct</strong>, the entry&rsquo;s usefulness is incremented.
<ol>
<li>If the result is still a <strong>weak prediction</strong>, the counter in the alternative prediction for T0 is decremented.</li>
</ol>
</li>
<li>If <strong>Tn is incorrect</strong>, the entry&rsquo;s usefulness is decremented, and a new entry is allocated in a table with a longer history than Tn, as in 3.2.2.
<ol>
<li>If the result is still a <strong>weak prediction</strong>, the counter in the alternative prediction for T0 is incremented.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>When a new table <strong>needs to be allocated</strong>, dynamic reset of the usefulness flag is performed.
<ol>
<li>Using a 7-bit bankTickCtrs register and calculating:
<ol>
<li>The number of allocatable tables <strong>a</strong> (with a longer history length than the current and corresponding index usefulness is 0)</li>
<li>The number of unallocatable tables <strong>b</strong> (with a longer history length than the current and corresponding index usefulness is not 0)</li>
</ol>
</li>
<li><strong>Update</strong> bankTickCtrs += Δ (saturated counter), Δ = b - a,</li>
<li>When bankTickCtrs reaches its <strong>maximum</strong> value, <strong>reset all usefulness to 0</strong>.</li>
</ol>
</li>
</ol>
<h2 id="kunming-lake-sc-branch-predictor">Kunming Lake SC Branch Predictor</h2>
<h3 id="basic-function-introduction">Basic Function Introduction</h3>
<p>The SC (Statistics counter) branch predictor is a branch predictor based on historical statistical information. Similar to TAGE, SC typically has multiple tables Tn, each corresponding to different lengths of historical jump statistics. The difference is that in SC, when predicting based on the PC, each table Tn is accessed, and then SC adds up each hit table entry to calculate the total &ldquo;saturated counter&rdquo; jump information, and finally determines whether to jump based on the total jump information. Generally, SC uses &ldquo;signed saturated counters&rdquo;, where a counter value greater than 0 indicates a jump, and less than 0 indicates no jump. The larger the absolute value of the counter, the higher the prediction confidence.</p>
<p>In the SC predictor, SC is also composed of multiple tables (e.g., T1, T2, T3, T4), but with fewer basic prediction tables T0 compared to the TAGE predictor. The Tn tables in SC have 6-bit signed saturated counters. The indexing method for SC tables is as follows:</p>
<table>
<thead>
<tr>
<th><strong>Calculation Method</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Index = (FH) ^ ((pc&raquo;1)低位)</td>
</tr>
</tbody>
</table>
<p>For each table, the number of entries and the folded history length used are as follows:</p>
<table>
<thead>
<tr>
<th>Table</th>
<th>Number of Entries</th>
<th>FH Length</th>
<th>Folded History Range</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td>512</td>
<td>0</td>
<td>不折叠</td>
</tr>
<tr>
<td>T2</td>
<td>512</td>
<td>4</td>
<td>把历史信息的低4位，折叠成FH</td>
</tr>
<tr>
<td>T3</td>
<td>512</td>
<td>8</td>
<td>把历史信息的低10位，折叠成FH</td>
</tr>
<tr>
<td>T4</td>
<td>512</td>
<td>8</td>
<td>把历史信息的低16位，折叠成FH</td>
</tr>
</tbody>
</table>
<p>The formula for calculating the total statistical prediction result is as follows:</p>

<div class="math">$$scCtrSum=\sum_{i=0}^{i<4}( (ctr_{sc} << 1) +1)$$</div><p>Where ctr_sc represents the signed saturated counter for each table. Left-shifting and adding one is for weight adjustment. The accumulated scCtrSum is the final prediction result of SC. If this value is greater than zero, the prediction is a jump; if it is less than zero, the prediction is no jump. The larger the absolute value, the higher the prediction confidence.</p>
<p>Typical data conversion results are as follows (extended to 9 bits to prevent overflow during calculation):</p>
<ol>
<li>All are 6b100000 (strong no-jump), resulting in 9b100000100, with a value of -252.</li>
<li>All are 6b011111 (strong jump), resulting in 9b011111100, with a value of 252.</li>
<li>All are 6b000000 (weak jump), resulting in 9b000000100, with a value of 4.</li>
<li>All are 6b111111 (weak no-jump), resulting in 9b111111100, with a value of -4.</li>
</ol>
<h3 id="prediction-process-1">Prediction Process</h3>
<ol>
<li>Calculate the index of table Tn using the PC and historical information.</li>
<li>Query the index to obtain the saturation counters for all tables.</li>
<li>Sum up all the saturation counters obtained from all tables to get the final prediction result (take a jump for values greater than 0, no jump for values less than 0).</li>
</ol>
<h3 id="training-process-1">Training Process</h3>
<p>Update the saturation counters during the update phase.</p>
<ol>
<li>If the real instruction corresponding to PC jumps, increment the saturation counters corresponding to all tables.</li>
<li>If the real instruction corresponding to PC does not jump, decrement the saturation counters corresponding to all tables.</li>
</ol>
<h2 id="kunming-lake-tage-sc-branch-predictor">Kunming Lake TAGE-SC Branch Predictor</h2>
<h3 id="why-sc-is-needed-with-tage">Why SC is Needed with TAGE</h3>
<p>In some applications, some branch behaviors have a weak correlation with branch history or paths, showing a statistical prediction bias. For these branches, using counters to capture statistical biases is more effective than history-based branch prediction.</p>
<p>TAGE is very effective in predicting branches that are highly correlated with history, but it performs poorly for branches with statistical biases. For example, branches that have a small bias in one direction but are not strongly correlated with historical paths. To avoid this problem, an SC predictor can be added to the traditional TAGE predictor.</p>
<h3 id="tage-sc-functionality">TAGE-SC Functionality</h3>
<p>In the Kunming Lake TAGE-SC predictor, both the TAGE and SC prediction results P1 and P2 are obtained simultaneously, and then their results are accumulated P = P1 + P2. If the absolute value of P is greater than the 8-bit threshold sc_bank_thres, the predictor result P is used; otherwise, P1 is used as the final prediction result.</p>
<p>For dynamic adaptation, the threshold sc_thres needs to be dynamically changed. Therefore, in the implementation, TAGE-SC uses a 5-bit sc_bank_ctr counter to adjust the threshold sc_bank_thres. Additionally, since Kunming Lake supports the simultaneous prediction of 2 branch instructions, the threshold register and corresponding control counter are also duplicated.</p>
<h3 id="pipeline-1">Pipeline</h3>
<p>The TAGE-SC predictor contains 3 pipeline stages, where the 2-stage pipeline of TAGE has been introduced, and the pipeline of the SC part is as follows:</p>
<ol>
<li>
<p>Stage 0: Read PC and folded history into s0.
<strong>First Stage</strong>: Calculate the index from pc and FH to obtain s0_idx.</p>
</li>
<li>
<p>Stage 1: Read s0_idx from s0.
<strong>Second Stage</strong>: Find the counter data corresponding to s1_idx in SCTable and output to s1_scResps.</p>
</li>
<li>
<p>Stage 2: Read s1_scResps from s1.
<strong>Third Stage</strong>: Select whether to invert the prediction result based on s2_scResps and output to s2_disagree.</p>
</li>
<li>
<p>Stage 3: Read the result from s2_disagree as s3_disagree.</p>
</li>
</ol>
<h3 id="prediction-process-2">Prediction Process</h3>
<p>In TAGE-SC prediction, the prediction result P1 of TAGE is represented by tage_ctr, and the prediction result P2 of SC is represented by scCtrSum. The prediction is divided into four steps:</p>
<ol>
<li>
<p>Execute the SC predictor to get the prediction result scCtrSum.</p>
</li>
<li>
<p>Simultaneously obtain the prediction result tage_ctr of the TAGE predictor.</p>
<ol>
<li>
<p>Since the prediction result of TAGE is an unsigned saturation counter, and the prediction result of SC is a signed saturation counter, if they are added together, data conversion is required.</p>
</li>
<li>
<p>Kunming Lake adopts a conversion for the result of TAGE. The converted result is represented by tageCtrCentered, and the specific conversion process is as follows:</p>

<div class="math">$$tageCtrCentered=((((ctr_{tage} -4)<<1)+1)<<3) $$</div></li>
<li>
<p>Conversion of a 3-bit unsigned saturation counter to an 8-bit signed saturation counter result is illustrated as follows:</p>
<ul>
<li>
<p>3b100 Weak jump =&gt; 8b00001000 = 8</p>
</li>
<li>
<p>3b011 Weak non-jump =&gt; 8b11111000 = -8</p>
</li>
<li>
<p>3b111 Strong jump =&gt; 8b00111000 = 56</p>
</li>
<li>
<p>3b000 Strong non-jump =&gt; 8b11001000 = -56</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Add the prediction results of TAGE and SC to get the final prediction result P, represented by totalSum.</p>
</li>
</ol>

<div class="math">$$totalSum = scCtrSum + tageCtrCentered$$</div><ol start="4">
<li>
<p>Determine the final prediction direction based on <code>totalSum</code> and <code>sc_bank_thres</code></p>
<ol>
<li>Jump if totalSum &gt; 0 and its absolute value exceeds the threshold: If scCtrSum &gt; sc_bank_thres - tageCtrCentered, it can also be understood as totalSum &gt; sc_bank_thres. The above expression can reduce the maximum bit width (ensuring no overflow requires 10 bits to become 9 bits).</li>
<li>No jump if totalSum &lt; 0 and its absolute value exceeds the threshold: If scCtrSum &lt; -sc_bank_thres - tageCtrCentered, it can also be understood as |totalSum| &gt; sc_bank_thres.</li>
</ol>
</li>
</ol>
<h3 id="training-process-2">Training Process</h3>
<p>After combining TAGE and SC, TAGE-SC adds an sc_bank_ctr counter to control the threshold sc_bank_thres. Therefore, during training, in addition to the training of TAGE and SC themselves, the newly added counter needs to be updated.</p>
<p>During the update phase, the specific update process is as follows:</p>
<ol>
<li>TAGE-SC uses the prediction result P (i.e., the prediction result after TAGE + SC). If |totalSum| is in the range [sc_bank_thres -4, sc_bank_thres -2], update the threshold-related register group.
<ol>
<li>Update sc_bank_ctr, the saturation counter: If the prediction is correct, sc_bank_ctr +=1; if the prediction is incorrect, sc_bank_ctr -=1.</li>
<li>Update sc_bank_thres, limited saturation operation: If the updated value of sc_bank_ctr reaches 0b11111 and sc_bank_thres &lt;= 31, then sc_bank_thres +=2; if the updated value of sc_bank_ctr is 0 and sc_bank_thres &gt;=6, then sc_bank_thres -=2. For all other cases, thres remains unchanged.</li>
<li>After the update judgment of sc_bank_thres is completed, another judgment is made on sc_bank_ctr. If the updated sc_bank_ctr is 0b11111 or 0, thres_ctr is reset to the initial value 0b10000.</li>
</ol>
</li>
<li>TAGE-SC uses the prediction result P1 (i.e., the prediction result of TAGE) and does not perform any operations.</li>
</ol>
<h2 id="interface-list">Interface List</h2>
<h3 id="tagesc">TageSC</h3>
<table>
<thead>
<tr>
<th>信号类型</th>
<th>信号宽度</th>
<th>信号名</th>
<th>信号描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td>*</td>
<td>clock</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>reset</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>*[35:0]</td>
<td>io_reset_vector</td>
<td>用于reset时，reset s1_pc_dup_0 提供的值</td>
</tr>
<tr>
<td>input</td>
<td>*[40:0]</td>
<td>io_in_bits_s0_pc_0</td>
<td>复制的s0_pc的dup数组的第1个，给顶层BPU的PC</td>
</tr>
<tr>
<td>input</td>
<td>*[40:0]</td>
<td>io_in_bits_s0_pc_1</td>
<td>复制的s0_pc第2个，给Tage的PC</td>
</tr>
<tr>
<td>input</td>
<td>*[40:0]</td>
<td>io_in_bits_s0_pc_3</td>
<td>复制的s0_pc的第4个，给SC的PC</td>
</tr>
<tr>
<td>input</td>
<td>*[10:0]</td>
<td>io_in_bits_folded_hist_1_hist_17_folded_hist</td>
<td>TageTable 2 用到的11bits 折叠历史 从多长历史范围折叠到11bit见前文所述的表 注意TageTable下标+1，此处 T2 是前文 T3</td>
</tr>
<tr>
<td>input</td>
<td>*[10:0]</td>
<td>io_in_bits_folded_hist_1_hist_16_folded_hist</td>
<td>TageTable 3 用到的11bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[6:0]</td>
<td>io_in_bits_folded_hist_1_hist_15_folded_hist</td>
<td>TageTable 1 用到的7bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[7:0]</td>
<td>io_in_bits_folded_hist_1_hist_14_folded_hist</td>
<td>TageTable 0 用到的8bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[6:0]</td>
<td>io_in_bits_folded_hist_1_hist_9_folded_hist</td>
<td>TageTable 2 用到的7bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[7:0]</td>
<td>io_in_bits_folded_hist_1_hist_8_folded_hist</td>
<td>TageTable 3 用到的8bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[6:0]</td>
<td>io_in_bits_folded_hist_1_hist_7_folded_hist</td>
<td>TageTable 0 用到的7bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[6:0]</td>
<td>io_in_bits_folded_hist_1_hist_5_folded_hist</td>
<td>TageTable 3 用到的7bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[7:0]</td>
<td>io_in_bits_folded_hist_1_hist_4_folded_hist</td>
<td>TageTable 1 用到的8bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[7:0]</td>
<td>io_in_bits_folded_hist_1_hist_3_folded_hist</td>
<td>TageTable 2 用到的8bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[10:0]</td>
<td>io_in_bits_folded_hist_1_hist_1_folded_hist</td>
<td>TageTable 1 用到的11bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[3:0]</td>
<td>io_in_bits_folded_hist_3_hist_12_folded_hist</td>
<td>SCTable 1 用到的 4bit 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[7:0]</td>
<td>io_in_bits_folded_hist_3_hist_11_folded_hist</td>
<td>SCTable 2 用到的 8bit 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[7:0]</td>
<td>io_in_bits_folded_hist_3_hist_2_folded_hist</td>
<td>SCTable 3 用到的 8bit 折叠历史</td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s2_full_pred_0_br_taken_mask_0</td>
<td>io_out_s2_full_pred_{i}<em>br_taken_mask</em>{j} Tage 在 s2流水级输出的，复制4份 预测块中第 j 条分支指令TAGE预测结果  这里不该叫mask吧</td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s2_full_pred_0_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s2_full_pred_1_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s2_full_pred_1_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s2_full_pred_2_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s2_full_pred_2_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s2_full_pred_3_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s2_full_pred_3_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s3_full_pred_0_br_taken_mask_0</td>
<td>io_out_s3_full_pred_{i}<em>br_taken_mask</em>{j} Tage 在 s3流水级输出的，复制4份 预测块中第 j 条分支指令SC预测结果</td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s3_full_pred_0_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s3_full_pred_1_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s3_full_pred_1_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s3_full_pred_2_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s3_full_pred_2_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s3_full_pred_3_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_out_s3_full_pred_3_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>*[222:0]</td>
<td>io_out_last_stage_meta</td>
<td>见附表</td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_ctrl_tage_enable</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_ctrl_sc_enable</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_s0_fire_0</td>
<td>s0 阶段流水线控制 相同信号复制多份，0给BPU，1给Tage，3给SC</td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_s0_fire_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_s0_fire_3</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_s1_fire_0</td>
<td>s1 阶段流水线控制</td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_s1_fire_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_s1_fire_2</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_s1_fire_3</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_s2_fire_0</td>
<td>s2 阶段流水线控制</td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_s2_fire_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_s2_fire_2</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_s2_fire_3</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>*</td>
<td>io_s1_ready</td>
<td>tage的所有表，可以执行读取结果的操作</td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_update_valid</td>
<td>从FTQ发向BPU的后端执行结果（更新信号）是否有效</td>
</tr>
<tr>
<td>input</td>
<td>*[40:0]</td>
<td>io_update_bits_pc</td>
<td>（后端执行过的）预测块的PC</td>
</tr>
<tr>
<td>input</td>
<td>*[10:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_17_folded_hist</td>
<td>TageTable 2 用到的11bits 折叠历史 预测时使用的分支历史结果，没有更新，转了一圈回来了</td>
</tr>
<tr>
<td>input</td>
<td>*[10:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_16_folded_hist</td>
<td>TageTable 3 用到的11bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[6:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_15_folded_hist</td>
<td>TageTable 1 用到的7bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[7:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_14_folded_hist</td>
<td>TageTable 0 用到的8bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[3:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_12_folded_hist</td>
<td>SCTable 1 用到的 4bit 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[7:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_11_folded_hist</td>
<td>SCTable 2 用到的 8bit 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[6:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_9_folded_hist</td>
<td>TageTable 2 用到的7bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[7:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_8_folded_hist</td>
<td>TageTable 3 用到的8bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[6:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_7_folded_hist</td>
<td>TageTable 0 用到的7bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[6:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_5_folded_hist</td>
<td>TageTable 3 用到的7bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[7:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_4_folded_hist</td>
<td>TageTable 1 用到的8bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[7:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_3_folded_hist</td>
<td>TageTable 2 用到的8bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[7:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_2_folded_hist</td>
<td>SCTable 3 用到的 8bit 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*[10:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_1_folded_hist</td>
<td>TageTable 1 用到的11bits 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_update_bits_ftb_entry_brSlots_0_valid</td>
<td>FTB 表项的第一个slot是否有效（存储了跳转指令）</td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_update_bits_ftb_entry_tailSlot_sharing</td>
<td>FTB 表项的最后一个slot是否存储了条件分支而非无条件跳转</td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_update_bits_ftb_entry_tailSlot_valid</td>
<td>FTB 表项的最后一个slot是否有效</td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_update_bits_ftb_entry_always_taken_0</td>
<td>历史上slot 0 指令总是跳转</td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_update_bits_ftb_entry_always_taken_1</td>
<td>历史上slot 1 指令总是跳转</td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_update_bits_br_taken_mask_0</td>
<td>solt 0 是否 taken</td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_update_bits_br_taken_mask_1</td>
<td>solt 1 是否 taken</td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_update_bits_mispred_mask_0</td>
<td>solt 0 是否预测正确</td>
</tr>
<tr>
<td>input</td>
<td>*</td>
<td>io_update_bits_mispred_mask_1</td>
<td>solt 1 是否预测正确</td>
</tr>
<tr>
<td>input</td>
<td>*[222:0]</td>
<td>io_update_bits_meta</td>
<td>见附表</td>
</tr>
</tbody>
</table>
<h3 id="io_out_last_stage_meta">io_out_last_stage_meta</h3>
<p>需要设计参与优化！</p>
<table>
<thead>
<tr>
<th>信号类型</th>
<th>信号位</th>
<th>信号名</th>
<th>信号描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>output</td>
<td>[218:88]</td>
<td>0</td>
<td>占位，全为0，传递到composer时会忽略</td>
</tr>
<tr>
<td></td>
<td>87</td>
<td>resp_meta_providers_1_valid_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[86:85]</td>
<td>resp_meta_providers_1_bits_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>84</td>
<td>resp_meta_providers_0_valid_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[83:82]</td>
<td>resp_meta_providers_0_bits_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[81:79]</td>
<td>resp_meta_providerResps_1_r_ctr</td>
<td></td>
</tr>
<tr>
<td></td>
<td>78</td>
<td>resp_meta_providerResps_1_r_u</td>
<td></td>
</tr>
<tr>
<td></td>
<td>77</td>
<td>resp_meta_providerResps_1_r_unconf</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[76:74]</td>
<td>resp_meta_providerResps_0_r_ctr</td>
<td></td>
</tr>
<tr>
<td></td>
<td>73</td>
<td>resp_meta_providerResps_0_r_u</td>
<td></td>
</tr>
<tr>
<td></td>
<td>72</td>
<td>resp_meta_providerResps_0_r_unconf</td>
<td></td>
</tr>
<tr>
<td></td>
<td>71</td>
<td>resp_meta_altUsed_1_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>70</td>
<td>resp_meta_altUsed_0_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>69</td>
<td>resp_meta_altDiffers_1_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>68</td>
<td>resp_meta_altDiffers_0_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[67:66]</td>
<td>resp_meta_basecnts_1_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[65:64]</td>
<td>resp_meta_basecnts_0_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[63:60]</td>
<td>resp_meta_allocates_1_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[59:56]</td>
<td>resp_meta_allocates_0_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>55</td>
<td>resp_meta_takens_1_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>54</td>
<td>resp_meta_takens_0_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>53</td>
<td>resp_meta_scMeta_tageTakens_1_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>52</td>
<td>resp_meta_scMeta_tageTakens_0_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>51</td>
<td>resp_meta_scMeta_scUsed_1_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>50</td>
<td>resp_meta_scMeta_scUsed_0_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>49</td>
<td>resp_meta_scMeta_scPreds_1_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>48</td>
<td>resp_meta_scMeta_scPreds_0_r</td>
<td></td>
</tr>
<tr>
<td></td>
<td>[47:42]</td>
<td>r_1_3</td>
<td>scMeta(预测时的状态)中第2路的第4个sc_ctr的值</td>
</tr>
<tr>
<td></td>
<td>[41:36]</td>
<td>r_1_2</td>
<td>scMeta中第2路的第3个sc_ctr的值</td>
</tr>
<tr>
<td></td>
<td>[35:30]</td>
<td>r_1_1</td>
<td>scMeta中第2路的第2个sc_ctr的值</td>
</tr>
<tr>
<td></td>
<td>[29:24]</td>
<td>r_1_0</td>
<td>scMeta中第2路的第1个sc_ctr的值</td>
</tr>
<tr>
<td></td>
<td>[23:18]</td>
<td>r_3</td>
<td>scMeta中第1路的第4个sc_ctr的值</td>
</tr>
<tr>
<td></td>
<td>[17:12]</td>
<td>r_2</td>
<td>scMeta中第1路的第3个sc_ctr的值</td>
</tr>
<tr>
<td></td>
<td>[11:6]</td>
<td>r_1</td>
<td>scMeta中第1路的第2个sc_ctr的值</td>
</tr>
<tr>
<td></td>
<td>[5:0]</td>
<td>r_0</td>
<td>scMeta中第1路的第1个sc_ctr的值</td>
</tr>
</tbody>
</table>
<h3 id="io_update_bits_meta">io_update_bits_meta</h3>
<table>
<thead>
<tr>
<th>信号类型</th>
<th>信号位</th>
<th>信号名</th>
<th>信号描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td>[218:94]</td>
<td></td>
<td>FTB, ITAGE, RAS 模块传给 FTQ 的 META 信息，忽略</td>
</tr>
<tr>
<td></td>
<td>[93:6]</td>
<td>io_out_last_stage_meta[87:0] 偏移 6bit 后的结果</td>
<td>TAGE 输出给 FTQ 的 META</td>
</tr>
<tr>
<td></td>
<td>[5:0]</td>
<td></td>
<td>uFTB 输出给 FTQ 的 META</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6632ee4bf977f3fe507ff8cc02deba52">3.4 - FTB Branch Predictor</h1>
    
	<h2 id="introduction-to-ftb">Introduction to FTB</h2>
<p>FTB is the third sub-predictor of the Xiangshan BPU, and it can also get the outputs of uFTB and TAGE-SC together. In the input interface of FTB, the s1 channel contains the basic prediction results of uFTB, and the s2 and s3 channels are filled with only one group of signals, <code>br_taken_mask</code>, by TAGE-SC, without the basic prediction results generated by the FTB entry. The function of FTB is to provide basic prediction results for the s2 and s3 channels.</p>
<p>In terms of functionality and structure, FTB is similar to uFTB. The main difference is that FTB can accommodate more FTB entries, and the prediction results of FTB are output in the s2 and s3 channels. Due to its large capacity, the readout speed of FTB is slower than that of uFTB, and it cannot be placed in the first cycle to generate prediction results. However, the large capacity enables it to obtain more accurate prediction results.</p>
<h2 id="function-of-uftb">Function of uFTB</h2>
<ul>
<li><strong>Cache more FTB entries and provide basic prediction results for the s2 and s3 channels</strong>. The FTB predictor is essentially a storage with a large capacity. It reads the corresponding FTB entry based on the current predicted PC and outputs it in the s2 stage. At the same time, this FTB entry will be saved for one more cycle to generate the s3 stage prediction result. One thing to note is to consider the <code>br_taken_mask</code> field inputted by the previous predictor to avoid losing it during generation.</li>
<li><strong>Update FTB entries based on update requests.</strong></li>
</ul>
<h2 id="ftb-storage-structure">FTB Storage Structure</h2>
<p>FTB entries in the FTB predictor are placed in a dedicated storage structure called <code>FTBBank</code>. Before further examining the structure of <code>FTBBank</code>, let&rsquo;s first see how <code>FTBBank</code> is used.</p>
<h3 id="ftb-read-request">FTB Read Request</h3>
<p>The read request interface of <code>FTBBank</code> is as follows:</p>
<ul>
<li><strong>req_pc</strong> Requested PC
<ul>
<li>Interface type: Flipped(DecoupledIO(UInt(VAddrBits.W)))</li>
</ul>
</li>
<li><strong>read_resp</strong> Read out FTB entry
<ul>
<li>Interface type: FTBEntry</li>
</ul>
</li>
<li><strong>read_hits</strong> Which way (row) is hit
<ul>
<li>Interface type: Valid(UInt(log2Ceil(numWays).W))</li>
</ul>
</li>
</ul>
<p>Among, <code>req_pc</code> interface is Decoupled, meaning it contains valid and ready signals. FTB needs to get the PC before the s1 stage starts, so <code>s0_pc</code> is sent to the <code>req_pc</code> interface, <code>s0_fire</code> signal is connected to the valid signal of <code>req_pc</code>, and the <code>ready</code> signal is connected to the pipeline control signal <code>s1_ready</code>.</p>
<p>When <code>s0_fire</code> enters the s1 stage, in the next cycle, when <code>s0_fire</code> is at the same time as <code>s1_fire</code>, FTBBank has already outputted the readout FTB entry to the <code>read_resp</code> interface, and calculated <code>read_hits</code>. However, at this time, because the readout has wasted too much delay, it cannot be outputted in the s1 stage. Therefore, this readout result is saved in an internal register. It will be read out from the register in the s2 and s3 stages to generate the prediction result.</p>
<h3 id="ftbbank">FTBBank</h3>
<p>FTBBank defines a storage to store all FTB entries. The storage adopts a group-associative structure, with 512 groups (Sets) in total, each group has 4 ways, and can store up to 2048 FTB entries. Besides storing FTB entries, it also stores the tag corresponding to each FTB entry for matching.</p>
<p>Specifically, the tag is defined as <code>pc[29:10]</code>, which takes 20 bits from the PC to identify the FTB entry. The PC is divided as follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Plain" data-lang="Plain"><span style="display:flex;"><span>  pc: | ... |&lt;-- tag(20 bits) --&gt;|&lt;-- idx(9 bits) --&gt;|&lt;-- instOffset(1 bit) --&gt;|
</span></span></code></pre></div><p>When reading, provide the group number (idx) to the storage, read out all ways in that group, and then check if there is a way whose tag matches the current tag. If there is a match, it means a hit, and the readout FTB entry is sent out through the <code>read_resp</code> interface, and the hit way number is sent out through the <code>read_hits</code> interface.</p>
<h2 id="generation-of-prediction-results">Generation of Prediction Results</h2>
<p>As mentioned earlier, for the FTB predictor, it needs to provide basic prediction results derived from FTB entries to the s2 and s3 channels. The FTB entries have been read and saved in the s1 stage. In the s2 and s3 stages, they only need to be read out to generate the prediction results. However, one thing to note is to preserve the <code>br_taken_mask</code> field generated by TAGE-SC in the s2 and s3 prediction results, which provides precise prediction results for conditional branch instructions. For the s1 channel, the FTB predictor does not make any changes.</p>
<p><strong>The generation of signals in the s2 and s3 prediction results can refer to the following list:</strong></p>
<ul>
<li><strong>hit</strong> Whether the FTB entry is hit
<ul>
<li>Generation method: The <code>read_hits</code> signal valid bit from <code>FTBBank</code> is valid.</li>
</ul>
</li>
<li><strong>slot_valids</strong> Slot valid bit, indicating whether each slot in the ftb entry is valid</li>
<li><strong>targets</strong> Jump target address corresponding to each slot</li>
<li><strong>offsets</strong> Instruction offset relative to the start address of the predicted block in each slot</li>
<li><strong>is_jal</strong> Whether the predicted block contains a jal instruction</li>
<li><strong>is_jalr</strong> Whether the predicted block contains a jalr instruction</li>
<li><strong>is_call</strong> Whether the predicted block contains a call instruction</li>
<li><strong>is_ret</strong> Whether the predicted block contains a ret instruction</li>
<li><strong>last_may_be_rvi_call</strong> Signal indicating that the end of the predicted block may be an RVI type call instruction</li>
<li>**is_br_sharing Whether the last slot (tailSlot) stores a conditional branch instruction signal
<ul>
<li>Generation method**: Export from the corresponding field in the FTB entry</li>
</ul>
</li>
<li><strong>fallThroughErr</strong> Error in the <code>pftAddr</code> recorded in the FTB entry
<ul>
<li>Generation method: Compare whether the address represented by <code>pftAddr</code> is greater than the start address of the predicted block. If it is less than, it indicates an error, and this signal is set to valid. This situation may occur when the PC indexes an incorrect FTB entry.</li>
</ul>
</li>
<li><strong>fallThroughAddr</strong> End address of the predicted block
<ul>
<li>Generation method: If <code>fallThroughErr</code> is invalid, it is generated according to <code>pftAddr</code>. Otherwise, it is set to the start address + prediction width.</li>
</ul>
</li>
<li><strong>br_taken_mask</strong> Branch prediction result, each branch (slot) corresponds to a bit, indicating whether the branch is predicted as taken
<ul>
<li>Generation method: Generated based on the <code>always_taken</code> field in the FTB entry and the indication result of the two-bit saturation counter.</li>
</ul>
</li>
<li><strong>jalr_target</strong> Jump target of jalr in this predicted block
<ul>
<li>Generation method: Jump target in the tailSlot of the FTB entry.</li>
</ul>
</li>
</ul>
<h3 id="ftb-meta">FTB meta</h3>
<p>In the third cycle of prediction, the FTB predictor outputs some auxiliary information of this prediction to <code>last_stage_meta</code> and also sends the read FTB entry to the <code>last_stage_ftrb_entry</code> interface.</p>
<p>The FTB meta contains two pieces of information, <code>hit</code> and <code>writeWay</code>, indicating whether the prediction hits and in which way it is read. Subsequently, the update channel generates the update information for this prediction, and these two pieces of information are also sent to guide the writing of the updated FTB entry.</p>
<h2 id="ftb-update">FTB Update</h2>
<p>In the update channel, the pc and the new FTB entry are already specified for us, along with the <code>hit</code> and <code>writeWay</code> in the meta information. If <code>hit</code> in the meta is valid, it means that the FTB entry corresponding to this pc was stored in the memory, and we only need to write it to the corresponding way.</p>
<p>If it is invalid, it means that there was no storage before, but we do not know whether it is stored now. It is possible that before this update request, the FTB entry corresponding to this pc was written by another update request. Therefore, we still need to send a read request to FTBBank to check if there is a corresponding FTB entry. If it exists, it can be directly written to this position in the next cycle, otherwise, FTBBank will be notified to allocate a new position.</p>
<p>Therefore, the number of cycles required for updating FTB entries depends on the hit situation.</p>
<p>Let&rsquo;s first look at how FTBBank handles updates.</p>
<h3 id="ftbbank-update">FTBBank Update</h3>
<p>FTBBank&rsquo;s update interface is divided into two parts, the update read interface and the update write interface.</p>
<ul>
<li><strong>u_req_pc</strong>: Update read request pc
<ul>
<li><code>Flipped(DecoupledIO(UInt(VAddrBits.W)))</code></li>
</ul>
</li>
<li><strong>update_hits</strong>: Hit information read out
<ul>
<li><code>Valid(UInt(log2Ceil(numWays).W))</code></li>
</ul>
</li>
<li><strong>update_access</strong>: There is an update request but the meta information indicates a miss
<ul>
<li><code>Bool()</code></li>
</ul>
</li>
<li><strong>update_pc</strong>: Update write request pc
<ul>
<li><code>UInt(VAddrBits.W))</code></li>
</ul>
</li>
<li><strong>update_write_data</strong>: Data to be written in the update request, write when valid
<ul>
<li><code>Flipped(Valid(new FTBEntryWithTag))</code></li>
</ul>
</li>
<li><strong>update_write_way</strong>: Way index to write in the update request
<ul>
<li><code>UInt(log2Ceil(numWays).W))</code></li>
</ul>
</li>
<li><strong>update_write_alloc</strong>: Whether a new FTB entry needs to be allocated (missed before)
<ul>
<li><code>Bool()</code></li>
</ul>
</li>
</ul>
<p><strong>For the update read interface</strong>, FTBBank obtains the update read request through <code>u_req_pc</code> signal. This request has a higher priority than the read request during prediction. In the next cycle, FTBBank will output the hit information through the <code>update_hits</code> interface. <code>update_access</code> is only used for some internal status judgments of FTBBank.</p>
<p><strong>For the update write interface</strong>, FTBBank obtains the pc of the update write request through the <code>update_pc</code> signal, and when <code>update_write_data</code> is valid, it writes the data into the corresponding position specified by <code>update_write_way</code>. If <code>update_write_alloc</code> is valid, it means that it cannot be directly written to the position specified in the request, but a new position needs to be allocated.</p>
<p><strong>The allocation strategy is as follows</strong>:</p>
<ul>
<li>If all ways are filled, use the pseudo LRU replacement algorithm to select the way to replace</li>
<li>If there is an empty way, select the empty way.</li>
</ul>
<h3 id="update-request-timing">Update Request Timing</h3>
<ul>
<li><strong>Meta hit is valid</strong>: If hit in the update request meta is valid, then we only need to specify the address and data to be written according to the information in the update request, and the writing only takes one cycle.</li>
<li><strong>Meta hit is invalid</strong>: In this case, after receiving the update request, we connect the pc in the request to the read port of FTBBank. The read port will return the result in the next cycle. Due to timing issues, we save this result and use it in the next cycle. Depending on the hit status in the result, we decide whether to set <code>update_write_alloc</code> and send a write request. The entire update process takes three cycles.</li>
</ul>
<h2 id="interface-list">Interface List</h2>
<table>
<thead>
<tr>
<th>信号类型</th>
<th>信号位</th>
<th>信号名</th>
<th>信号描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td></td>
<td>clock</td>
<td>输入时钟</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>reset</td>
<td>复位信号</td>
</tr>
<tr>
<td>input</td>
<td>[35:0]</td>
<td>io_reset_vector</td>
<td>用于reset时，reset s1_pc_dup_0 提供的值</td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_s0_pc_0</td>
<td>输入位s0_pc 的 第0个复制</td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_s0_pc_1</td>
<td>同上 第1个</td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_s0_pc_2</td>
<td>同上 第2个</td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_s0_pc_3</td>
<td>同上 第3个</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_0_br_taken_mask_0</td>
<td>预测结果输入</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_0_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_1_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_1_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_3_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_3_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_0_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_0_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_1_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_1_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_3_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_3_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_0_br_taken_mask_0</td>
<td>s2 阶段输出的完整预测结果</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_0_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_0_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_0_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_0_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_0_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_0_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_0_offsets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_0_offsets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_0_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_0_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_0_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_1_br_taken_mask_0</td>
<td>同上</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_1_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_1_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_1_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_1_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_1_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_1_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_1_offsets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_1_offsets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_1_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_1_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_1_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_br_taken_mask_0</td>
<td>同上</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_2_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_2_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_2_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_2_offsets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_2_offsets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_2_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_is_jalr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_is_call</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_is_ret</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_last_may_be_rvi_call</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_3_br_taken_mask_0</td>
<td>同上</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_3_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_3_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_3_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_3_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_3_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_3_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_3_offsets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_3_offsets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_3_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_3_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_3_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_3_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_0_br_taken_mask_0</td>
<td>s3 阶段输出的完整预测结果</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_0_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_0_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_0_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_0_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_0_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_0_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_0_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_0_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_0_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_0_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_1_br_taken_mask_0</td>
<td>同上</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_1_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_1_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_1_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_1_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_1_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_1_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_1_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_1_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_1_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_1_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_br_taken_mask_0</td>
<td>同上</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_2_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_2_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_2_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_2_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_is_jalr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_is_call</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_is_ret</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_3_br_taken_mask_0</td>
<td>同上</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_3_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_3_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_3_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_3_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_3_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_3_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s3_full_pred_3_offsets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s3_full_pred_3_offsets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_3_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_3_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_3_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_3_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[222:0]</td>
<td>io_out_last_stage_meta</td>
<td>最后一个阶段输出的 meta 信息</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_valid</td>
<td>最后一个阶段输出的 FTB 项</td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_last_stage_ftb_entry_brSlots_0_offset</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[11:0]</td>
<td>io_out_last_stage_ftb_entry_brSlots_0_lower</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[1:0]</td>
<td>io_out_last_stage_ftb_entry_brSlots_0_tarStat</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_brSlots_0_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_brSlots_0_valid</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_last_stage_ftb_entry_tailSlot_offset</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[19:0]</td>
<td>io_out_last_stage_ftb_entry_tailSlot_lower</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[1:0]</td>
<td>io_out_last_stage_ftb_entry_tailSlot_tarStat</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_tailSlot_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_tailSlot_valid</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_last_stage_ftb_entry_pftAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_carry</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_isCall</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_isRet</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_isJalr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_last_may_be_rvi_call</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_always_taken_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_always_taken_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_ctrl_btb_enable</td>
<td>使能信号</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s0_fire_0</td>
<td>s0 阶段流水线控制信号</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s0_fire_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s0_fire_2</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s0_fire_3</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_s1_ready</td>
<td>s1 阶段流水线控制信号</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s1_fire_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s1_fire_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s1_fire_2</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s1_fire_3</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s2_fire_0</td>
<td>s2 阶段流水线控制信号</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s2_fire_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s2_fire_2</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s2_fire_3</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_valid</td>
<td>更新有效性</td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_update_bits_pc</td>
<td>传回的预测块pc（用于指示更新的预测块）</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_valid</td>
<td>是否启用</td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_update_bits_ftb_entry_brSlots_0_offset</td>
<td>solt 0 中分支指令相对于地址块起始pc的偏移</td>
</tr>
<tr>
<td>input</td>
<td>[11:0]</td>
<td>io_update_bits_ftb_entry_brSlots_0_lower</td>
<td>跳转目标地址的低位</td>
</tr>
<tr>
<td>input</td>
<td>[1:0]</td>
<td>io_update_bits_ftb_entry_brSlots_0_tarStat</td>
<td>跳转后的 pc 高位是否进退位</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_brSlots_0_sharing</td>
<td>无条件跳转指令槽中存储条件分支指令</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_brSlots_0_valid</td>
<td>是否启用</td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_update_bits_ftb_entry_tailSlot_offset</td>
<td>solt 1 中分支指令相对于地址块起始pc的偏移</td>
</tr>
<tr>
<td>input</td>
<td>[19:0]</td>
<td>io_update_bits_ftb_entry_tailSlot_lower</td>
<td>跳转目标地址的低位</td>
</tr>
<tr>
<td>input</td>
<td>[1:0]</td>
<td>io_update_bits_ftb_entry_tailSlot_tarStat</td>
<td>跳转后的 pc 高位是否进退位</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_tailSlot_sharing</td>
<td>无条件跳转指令槽中存储条件分支指令</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_tailSlot_valid</td>
<td>是否启用</td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_update_bits_ftb_entry_pftAddr</td>
<td>Partial Fallthrough Addr 如果预测块中没有跳转，那么程序将会顺序执行到达的地址，预测块的结束地址。</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_carry</td>
<td>pc+pft时是否产生进位</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_isCall</td>
<td>是否是函数调用</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_isRet</td>
<td>是否是函数返回</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_isJalr</td>
<td>是否是 jalr 指令</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_last_may_be_rvi_call</td>
<td>最后一个指令槽存储的可能是 rvi 的 call 指令</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_always_taken_0</td>
<td>是否预测为总是跳转</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_always_taken_1</td>
<td>是否预测为总是跳转</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_old_entry</td>
<td>是否是旧的 FTB 项</td>
</tr>
<tr>
<td>input</td>
<td>[222:0]</td>
<td>io_update_bits_meta</td>
<td>meta 信息</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-dfa5c2dea93e89d4c1a93d678a387d97">3.5 - ITTAGE Branch Predictor</h1>
    
	<h2 id="function-introduction">Function Introduction</h2>
<p>For general conditional branch instructions, only predicting whether to jump (taken) or not (not taken) is needed. However, for <strong>indirect jumps</strong>, such as call/jump instructions, it is necessary to predict <strong>where to jump to</strong> (Target). In order to make TAGE support predicting jump addresses, ITTAGE (Indirect Target TAGE) was introduced.</p>
<p>The <strong>main difference</strong> between ITTAGE and TAGE is that in the T0 and Tn tables, Target PC data is added. During prediction, ITTAGE selects the Target from the matched, longest history entry as the prediction result, and uses a 2-bit saturating counter to decide whether to output this result or choose an alternative prediction result. For TAGE predictor details, please refer to <a href="../02_tage_sc/">TAGE-SC Branch Predictor</a>.</p>
<h2 id="kunming-lake-ittage-branch-predictor">Kunming Lake ITTAGE Branch Predictor</h2>
<p>In the BPU design of Kunming Lake, prediction is performed in a cascaded manner with multiple predictors, so the implementation of the subpredictor differs from the original predictor, mainly in the default prediction result.</p>
<h3 id="basic-functionality">Basic Functionality</h3>
<p>ITTAGE&rsquo;s basic functionality is similar to the TAGE branch predictor, but with the following differences:</p>
<ol>
<li>The Target is added as a jump target address item in the entry to predict the jump target address.</li>
<li>The saturating counter ctr no longer provides the prediction direction, but instead decides whether to output the result (just the prediction information).</li>
<li>Since there is only one indirect jump instruction in each branch prediction block, ITTAGE only considers one instruction.</li>
</ol>
<h3 id="pipeline">Pipeline</h3>
<p>ITTAGE <strong>contains three pipeline stages</strong>, the first stage calculates the index, and the second stage reads the result from the SRAM table using the index.</p>
<ol>
<li>Cycle 0, s0: Input of the first pipeline stage, generally pc and folded history.</li>
</ol>
<p><strong>Operation of the first pipeline stage</strong>：Calculate the index. Output through registers to s1.</p>
<ol>
<li>Cycle 1, s1: Input of the second pipeline stage, the index and other data calculated in the first stage.</li>
</ol>
<p><strong>Operation of the second pipeline stage</strong>：Access SRAM, read prediction information. Output through registers to s2.</p>
<ol>
<li>Cycle 2, s2: Input of the third pipeline stage, the original prediction information read from SRAM in the second stage.</li>
</ol>
<p><strong>Operation of the third pipeline stage</strong>：Process the original prediction information, decide whether to output the prediction result.</p>
<ol>
<li>Cycle 3, s3: Prediction result ready, the prediction result can now be used.</li>
</ol>
<h3 id="data-structure">Data Structure</h3>
<p>In the Kunming Lake implementation, the table structure of T0 and Tn is as follows:</p>
<table>
<thead>
<tr>
<th><strong>预测器</strong></th>
<th><strong>作用</strong></th>
<th><strong>表项构成</strong></th>
<th><strong>项数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>基准预测器T0</td>
<td>用于在其他预测器的预测结果都无效时输出预测结果</td>
<td>虚表，不存在。 直接将上级预测器FTB 的预测结果作为表项结果</td>
<td>虚表，不存在。 直接将上级预测器FTB结果作为索引到的结果</td>
</tr>
<tr>
<td>预测表T1-T2</td>
<td>对每个预测块的输入，所有Tn表都进行预测，在所有预测有效的结果中，选择历史记录最长的结果作为 原始预测信息。历史记录长度由输入的H决定</td>
<td>target：41 bitsvalid 1bittag 9bitsctr 2bitsus: 1bit（usefulness计数器）</td>
<td>256项</td>
</tr>
<tr>
<td>预测表T3-T5</td>
<td>512项</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="t0tntable-retrieval-method">T0，TnTable Retrieval Method</h3>
<p>The retrieval method is consistent with the TAGE branch predictor, only differing in the configuration options of each table.</p>
<table>
<thead>
<tr>
<th><strong>表名称</strong></th>
<th><strong>FH长度</strong></th>
<th><strong>FH1长度</strong></th>
<th><strong>FH2长度</strong></th>
<th><strong>最近历史长度（用到GH中的位数）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td>4比特</td>
<td>4比特</td>
<td>4比特</td>
<td>低4位，即把最新4位历史，折叠成FH、FH1、FH2</td>
</tr>
<tr>
<td>T2</td>
<td>8比特</td>
<td>8比特</td>
<td>8比特</td>
<td>低8位，即把最新8位历史，折叠成FH、FH1、FH2</td>
</tr>
<tr>
<td>T3</td>
<td>9比特</td>
<td>9比特</td>
<td>8比特</td>
<td>低13位，即把最新13位历史，折叠成FH、FH1、FH2</td>
</tr>
<tr>
<td>T4</td>
<td>9比特</td>
<td>9比特</td>
<td>8比特</td>
<td>低16位，即把最新16位历史，折叠成FH、FH1、FH2</td>
</tr>
<tr>
<td>T5</td>
<td>9比特</td>
<td>9比特</td>
<td>8比特</td>
<td>低32位，即把最新32位历史，折叠成FH、FH1、FH2</td>
</tr>
</tbody>
</table>
<p>Other processes (<strong>computation method</strong> and <strong>computation formula</strong>) are similar to the <a href="../02_tage_sc/#MZk7dpG3woapSUx3XO9ceJShn0e">TAGE-SC branch predictor</a>.</p>
<h3 id="alternate-predictor">Alternate Predictor</h3>
<p>When the prediction result given by the Tn table has insufficient &ldquo;prediction confidence,&rdquo; the prediction result needs to be jumped to become an &ldquo;alternate predictor.&rdquo; This process is similar to TAGE. For details, please refer to the corresponding part of TAGE. Unlike TAGE, ITTAGE&rsquo;s ctr does not give the prediction direction but only determines whether to output the result (prediction confidence). When ctr is 2b00, it is considered weak confidence. Choose the alternate prediction result:</p>
<ol>
<li><strong>If multiple tables are hit</strong>, output the Target from the second-longest history table entry.</li>
<li>Otherwise, output the T0 Target (FTB Target).</li>
</ol>
<h3 id="prediction-process">Prediction Process</h3>
<p>The prediction process is similar to TAGE, but ITTAGE has an additional step to decide whether to output the prediction result based on ctr. The specific process is as follows:</p>
<ol>
<li>When the ctr of the ITTAGE table entry is not 2b00, output Target.</li>
<li>When the ctr of the ITTAGE table entry is 2b00, output the alternate prediction result:
<ol>
<li>If there is a second-longest history (the second table is also hit), output the Target of the second-longest.</li>
<li>Otherwise, output the FTB Target.</li>
</ol>
</li>
<li>When the ITTAGE table entry is not hit, output the T0 Target (FTB Target).</li>
</ol>
<h3 id="training-process">Training Process</h3>
<p>This process is similar to TAGE, with the following differences:</p>
<ol>
<li>Table entry updates (original prediction data):
<ol>
<li>ctr:
<ol>
<li>If the predicted address matches the actual address, increment the ctr counter of the corresponding provider table entry by 1.</li>
<li>If the predicted address does not match the actual address, decrement the ctr counter of the corresponding provider table entry by 1.</li>
<li>In ITTAGE, it is determined based on ctr whether to adopt the jump target result of this prediction. If multiple tables are hit and the ctr of the longest history table is 0, adopt the alternate prediction logic (the second-longest history table or T0). Always update the longest history table during updates, and also update the alternate prediction table if the alternate prediction is adopted.</li>
</ol>
</li>
<li>target:
<ol>
<li>When the ctr of the table entry to be updated is 0 during this prediction, directly store the actual final jump result in the target, overwriting it.</li>
<li>When applying for a new table entry, directly store the actual final jump result in the target.</li>
<li>Otherwise, do not modify the target.</li>
</ol>
</li>
<li>usefulness:
<ol>
<li>When the provider&rsquo;s prediction is correct but the alternate prediction is incorrect, set the provider&rsquo;s usefulness to 1.</li>
<li>If the alternate prediction has weak confidence and is correct, set the provider&rsquo;s usefulness to 1. If the alternate prediction has weak confidence and is incorrect, set the provider&rsquo;s usefulness to 0.</li>
</ol>
</li>
<li>New table entry:
<ol>
<li>Each time the prediction from the longest history table with confidence is incorrect (not due to using the alternate prediction), try to randomly apply for a table entry from a longer history table. The condition for application is that the usefulness of the corresponding entry is 0.</li>
<li>If all longer entries are not 0, the allocation fails.</li>
</ol>
</li>
</ol>
</li>
<li>Reset useful bit:
<ol>
<li>Each time a prediction error occurs and a new table entry is applied for, if the allocation fails, increment tickCtr (an 8-bit saturated counter used to reset all usefulness). If successful, decrement tickCtr.</li>
<li>When tickCtr reaches its maximum value, set all usefulness in ITTAGE to 0 and reset tickCtr to 0.</li>
</ol>
</li>
</ol>
<h2 id="interface-list">Interface List</h2>
<table>
<thead>
<tr>
<th>接口类型</th>
<th>位宽</th>
<th>信号名</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td></td>
<td>clock</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>reset</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_s0_pc_3</td>
<td>用于预测的PC</td>
</tr>
<tr>
<td>input</td>
<td>[7:0]</td>
<td>io_in_bits_folded_hist_3_hist_14_folded_hist</td>
<td>T2 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>[8:0]</td>
<td>io_in_bits_folded_hist_3_hist_13_folded_hist</td>
<td>T3 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_in_bits_folded_hist_3_hist_12_folded_hist</td>
<td>T1 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>[8:0]</td>
<td>io_in_bits_folded_hist_3_hist_10_folded_hist</td>
<td>T5 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>[8:0]</td>
<td>io_in_bits_folded_hist_3_hist_6_folded_hist</td>
<td>T4 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>[7:0]</td>
<td>io_in_bits_folded_hist_3_hist_4_folded_hist</td>
<td>T3 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>[7:0]</td>
<td>io_in_bits_folded_hist_3_hist_3_folded_hist</td>
<td>T5 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>[7:0]</td>
<td>io_in_bits_folded_hist_3_hist_2_folded_hist</td>
<td>T4 折叠历史</td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_0_jalr_target</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_1_jalr_target</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_jalr_target</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_3_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_0_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_1_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_2_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_3_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[222:0]</td>
<td>io_out_last_stage_meta</td>
<td>[100:0] 有效，是ITTAGE的Meta信息</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s0_fire_3</td>
<td>s0阶段使能信号</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s1_fire_3</td>
<td>s1阶段使能信号</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s2_fire_0</td>
<td>s2阶段使能信号，相同</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s2_fire_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s2_fire_2</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_s2_fire_3</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_valid</td>
<td>是否进行更新</td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_update_bits_pc</td>
<td>待更新的预测块pc索引</td>
</tr>
<tr>
<td>input</td>
<td>[7:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_14_folded_hist</td>
<td>T2 更新时传入的历史</td>
</tr>
<tr>
<td>input</td>
<td>[8:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_13_folded_hist</td>
<td>T3 更新时传入的历史</td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_12_folded_hist</td>
<td>T1 更新时传入的历史</td>
</tr>
<tr>
<td>input</td>
<td>[8:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_10_folded_hist</td>
<td>T5 更新时传入的历史</td>
</tr>
<tr>
<td>input</td>
<td>[8:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_6_folded_hist</td>
<td>T4 更新时传入的历史</td>
</tr>
<tr>
<td>input</td>
<td>[7:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_4_folded_hist</td>
<td>T3 更新时传入的历史</td>
</tr>
<tr>
<td>input</td>
<td>[7:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_3_folded_hist</td>
<td>T5 更新时传入的历史</td>
</tr>
<tr>
<td>input</td>
<td>[7:0]</td>
<td>io_update_bits_spec_info_folded_hist_hist_2_folded_hist</td>
<td>T4 更新时传入的历史</td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_update_bits_ftb_entry_tailSlot_offset</td>
<td>待更新的FTB项offset</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_tailSlot_sharing</td>
<td>待更新的FTB项是否是有条件跳转</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_tailSlot_valid</td>
<td>待更新的tailSlot是否启用</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_isRet</td>
<td>tailSlot是否是Ret指令</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_ftb_entry_isJalr</td>
<td>tailSlot是否是Jalr指令</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_cfi_idx_valid</td>
<td>控制流指令在预测块中的索引.valid信号</td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_update_bits_cfi_idx_bits</td>
<td>控制流指令在预测块中的索引</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_jmp_taken</td>
<td>预测块内无条件跳转指令被触发</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_update_bits_mispred_mask_2</td>
<td>是否预测错误</td>
</tr>
<tr>
<td>input</td>
<td>[222:0]</td>
<td>io_update_bits_meta</td>
<td>预测时传出 meta 信息的[222:25] 即{25h0, _ubtb_io_out_last_stage_meta[5:0] ,_tage_io_out_last_stage_meta[87:0] ,_ftb_io_out_last_stage_meta[2:0], _ittage_io_out_last_stage_meta[100:0]}</td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_update_bits_full_target</td>
<td>预测块的跳转目标（下一个预测块的起始地址）</td>
</tr>
</tbody>
</table>
<h3 id="pass-through-signals-that-do-not-have-an-impact">Pass-through signals that do not have an impact</h3>
<details>
    <summary> These signals do not have an impact and are not important</summary>
    <table>
<thead>
<tr>
<th>接口类型</th>
<th>位宽</th>
<th>信号名</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_0_br_taken_mask_0</td>
<td>从FTB输入 完全透传到输出 包括jalr_target</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_0_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_0_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_0_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_0_targets_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_0_targets_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_0_jalr_target</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_0_offsets_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_0_offsets_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_0_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_0_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_0_hit</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_1_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_1_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_1_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_1_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_1_targets_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_1_targets_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_1_jalr_target</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_1_offsets_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_1_offsets_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_1_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_1_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_1_hit</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_targets_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_targets_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_jalr_target</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_offsets_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_offsets_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_is_jalr</td>
<td>RAS 模块使用的信息，透传</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_is_call</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_is_ret</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_last_may_be_rvi_call</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_is_br_sharing</td>
<td>从FTB输入 完全透传到输出 包括jalr_target  fallThroughErr  表示 FTB项 中记录的 pftAddr 有误 生成方式：比较 pftAddr 代表的预测块结束地址是否大于预测块的起始地址，如果小于，则代表出现错误，此信号置为有效。这种情况可能会发生在 pc 索引到错误的 FTB 项的情况。 FTQ使用这个变量，与ITTAGE无关</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_2_hit</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_3_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_3_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_3_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_3_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_3_targets_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_3_targets_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_3_jalr_target</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_3_offsets_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_3_offsets_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s2_full_pred_3_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_3_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_3_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s2_full_pred_3_hit</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_0_br_taken_mask_0</td>
<td>除了 jalr_target 可能被修改，其他都是透传</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_0_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_0_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_0_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_0_targets_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_0_targets_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_0_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_0_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_0_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_0_hit</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_1_br_taken_mask_0</td>
<td>同上</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_1_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_1_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_1_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_1_targets_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_1_targets_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_1_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_1_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_1_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_1_hit</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_br_taken_mask_0</td>
<td>同上</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_targets_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_targets_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_is_jalr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_is_call</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_is_ret</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_2_hit</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_3_br_taken_mask_0</td>
<td>同上</td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_3_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_3_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_3_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_3_targets_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_3_targets_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_3_offsets_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_3_offsets_1</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[40:0]</td>
<td>io_in_bits_resp_in_0_s3_full_pred_3_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_3_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_3_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_s3_full_pred_3_hit</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_valid</td>
<td>透传到output，不做修改 来源是FTB</td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_brSlots_0_offset</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[11:0]</td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_brSlots_0_lower</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[1:0]</td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_brSlots_0_tarStat</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_brSlots_0_sharing</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_brSlots_0_valid</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_tailSlot_offset</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[19:0]</td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_tailSlot_lower</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[1:0]</td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_tailSlot_tarStat</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_tailSlot_sharing</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_tailSlot_valid</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>[3:0]</td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_pftAddr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_carry</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_isCall</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_isRet</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_isJalr</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_last_may_be_rvi_call</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_always_taken_0</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td></td>
<td>io_in_bits_resp_in_0_last_stage_ftb_entry_always_taken_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_0_br_taken_mask_0</td>
<td>完全透传传入值 prefix: io_in_bits_resp_in_</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_0_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_0_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_0_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_0_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_0_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_0_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_0_offsets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_0_offsets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_0_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_0_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_0_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_1_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_1_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_1_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_1_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_1_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_1_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_1_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_1_offsets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_1_offsets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_1_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_1_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_1_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_2_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_2_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_2_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_2_offsets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_2_offsets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_2_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_is_jalr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_is_call</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_is_ret</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_last_may_be_rvi_call</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_2_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_3_br_taken_mask_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_3_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_3_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_3_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_3_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_3_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_3_jalr_target</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_3_offsets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s2_full_pred_3_offsets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s2_full_pred_3_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_3_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_3_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s2_full_pred_3_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_0_br_taken_mask_0</td>
<td>见对应prefix的输入</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_0_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_0_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_0_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_0_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_0_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_0_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_0_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_0_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_0_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_1_br_taken_mask_0</td>
<td>见对应prefix的输入</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_1_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_1_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_1_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_1_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_1_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_1_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_1_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_1_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_1_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_br_taken_mask_0</td>
<td>见对应prefix的输入</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_2_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_2_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_2_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_is_jalr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_is_call</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_is_ret</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_2_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_3_br_taken_mask_0</td>
<td>见对应prefix的输入</td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_3_br_taken_mask_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_3_slot_valids_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_3_slot_valids_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_3_targets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_3_targets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s3_full_pred_3_offsets_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_s3_full_pred_3_offsets_1</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[40:0]</td>
<td>io_out_s3_full_pred_3_fallThroughAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_3_fallThroughErr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_3_is_br_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_s3_full_pred_3_hit</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_valid</td>
<td>完全透传传入的值</td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_last_stage_ftb_entry_brSlots_0_offset</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[11:0]</td>
<td>io_out_last_stage_ftb_entry_brSlots_0_lower</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[1:0]</td>
<td>io_out_last_stage_ftb_entry_brSlots_0_tarStat</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_brSlots_0_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_brSlots_0_valid</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_last_stage_ftb_entry_tailSlot_offset</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[19:0]</td>
<td>io_out_last_stage_ftb_entry_tailSlot_lower</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[1:0]</td>
<td>io_out_last_stage_ftb_entry_tailSlot_tarStat</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_tailSlot_sharing</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_tailSlot_valid</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td>[3:0]</td>
<td>io_out_last_stage_ftb_entry_pftAddr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_carry</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_isCall</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_isRet</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_isJalr</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_last_may_be_rvi_call</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_always_taken_0</td>
<td></td>
</tr>
<tr>
<td>output</td>
<td></td>
<td>io_out_last_stage_ftb_entry_always_taken_1</td>
<td></td>
</tr>
</tbody>
</table>
</details>
<h2 id="other-meta-information-can-be-found-in-the-corresponding-sub-predictor-documentation">Other Meta information can be found in the corresponding sub-predictor documentation</h2>
<p>_ubtb_io_out_last_stage_meta</p>
<p>_tage_io_out_last_stage_meta</p>
<p>_ftb_io_out_last_stage_meta</p>
<h2 id="ittage_io_out_last_stage_meta1000">ittage_io_out_last_stage_meta[100:0]</h2>
<table>
<thead>
<tr>
<th>位宽</th>
<th>信号名</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>s3_provided</td>
<td>是否有结果</td>
</tr>
<tr>
<td>[99:97]</td>
<td>s3_provider</td>
<td>提供结果的表项</td>
</tr>
<tr>
<td>96</td>
<td>s3_altProvided</td>
<td>是否有替代预测表项</td>
</tr>
<tr>
<td>[95:93]</td>
<td>s3_altProvider</td>
<td>提供结果的替代预测表项</td>
</tr>
<tr>
<td>92</td>
<td>resp_meta_altDiffers</td>
<td>替代预测是否是弱信心的（FTB不算）</td>
</tr>
<tr>
<td>91</td>
<td>s3_providerU</td>
<td>主预测的useful bit</td>
</tr>
<tr>
<td>[90:89]</td>
<td>s3_providerCtr</td>
<td>主预测给出的置信度</td>
</tr>
<tr>
<td>[88:87]</td>
<td>s3_altProviderCtr</td>
<td>替代预测给出的置信度</td>
</tr>
<tr>
<td>86</td>
<td>resp_meta_allocate_valid_r</td>
<td>有空余的表项可供申请</td>
</tr>
<tr>
<td>[85:83]</td>
<td>resp_meta_allocate_bits_r</td>
<td>申请哪个表中的表项</td>
</tr>
<tr>
<td>82</td>
<td>s3_tageTaken_dup_3</td>
<td>在不使用FTB的情况下始为true，使用FTB也为true</td>
</tr>
<tr>
<td>[81:41]</td>
<td>s3_providerTarget</td>
<td>主预测给出的跳转地址</td>
</tr>
<tr>
<td>[40:0]</td>
<td>s3_altProviderTarget</td>
<td>替代预测给出的跳转地址</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8ab5cccc33deee27c69e7976949364c2">3.6 - RAS Branch Predictor</h1>
    
	<h2 id="ras介绍">RAS介绍</h2>
<p>RAS stands for &ldquo;Return Address Stack.&rdquo; It helps determine branch behavior in programs by tracking return addresses. As previously mentioned, there are many branches in a program: if/else, switch/case, while/for loop, iteration, call/return, etc. The RAS branch predictor specifically targets call/return types.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000">function</span> <span style="color:#000">_add</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">){</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span> <span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#0000cf;font-weight:bold">0</span> <span style="color:#a40000">?</span> <span style="color:#000">a</span> <span style="color:#000;font-weight:bold">:</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">)</span>  <span style="color:#ce5c00;font-weight:bold">+</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">b</span> <span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#a40000">?</span> <span style="color:#000">b</span> <span style="color:#000;font-weight:bold">:</span> <span style="color:#0000cf;font-weight:bold">0</span><span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000">function</span> <span style="color:#000">add</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">){</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000">a</span> <span style="color:#ce5c00;font-weight:bold">+</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000">function</span> <span style="color:#000">sub</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">){</span>
</span></span><span style="display:flex;"><span>    <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000">a</span> <span style="color:#ce5c00;font-weight:bold">-</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000">function</span> <span style="color:#000">main</span><span style="color:#000;font-weight:bold">(){</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">a</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">1</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">b</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#0000cf;font-weight:bold">2</span><span style="color:#000;font-weight:bold">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">c</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">add</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000">d</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">sub</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">b</span><span style="color:#000;font-weight:bold">);</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">}</span>
</span></span></code></pre></div><p>As shown above, the main function calls add and sub, and add calls the function _add. In this process, each call&rsquo;s jump address and return address are fixed, and the return address can be obtained at the time of the call. The function call process is a &ldquo;stack push and pop&rdquo; process, so branch prediction can be performed using a &ldquo;stack&rdquo; structure: each time a call instruction is encountered, the current PC+4 (compressed instructions and regular instructions have different offsets) is pushed onto the stack; when a return instruction is encountered, a pop operation is performed, and the address obtained is the target jump address. In the block-based BPU, RAS cannot know whether the current block is a call or ret, so it relies on other predictors, using the results of previous predictors for RAS operations.</p>
<p>Specifically, in Xiangshan&rsquo;s RAS predictor, at the s2 stage, it needs to determine whether the previous stage&rsquo;s s2 output predicts a call or ret (i.e., the input signal io.s2_full_pred.hit_taken_on_call/ret is valid). If it&rsquo;s a call, it pushes the subsequent instruction address onto the stack; if it&rsquo;s a ret, it pops the address from the stack as the prediction result. Because in the BPU predictor, the result obtained at the s3 stage is assumed to be better than the s2 stage, the RAS predictor needs to check at the s3 stage. If the previous stage&rsquo;s s3 prediction result is inconsistent with s2, the s3 result is taken, and it needs to determine whether to cancel or complete the stack operations of the previous s2 stage as needed. For example, if the s2 stage predicted a call instruction and performed a push operation, but s3 predicted a regular branch instruction with no need for any operation, the push must be canceled; if s2 predicted a regular branch instruction and s3 predicted a call, a push operation must be performed to complete.</p>
<h2 id="ras-stack-operations">RAS Stack Operations</h2>
<p>In RAS design, function return addresses are predicted using a stack. Ideally, this section assumes that RAS can be backed up at any time, with the stack top pointer represented by sp and the predicted address represented by paddr. The basic RAS operations are as follows:</p>
<ol>
<li>
<h3 id="push">PUSH</h3>
</li>
</ol>
<p>Since predictions can be wrong, the current stack state needs to be backed up (often referred to as a &ldquo;snapshot&rdquo; in software; this term is also used in subsequent content). When encountering a call instruction, get the return address of the call instruction addr = current pc + 4 (if it&rsquo;s a compressed instruction, addr = pc+2), then push onto the stack: sp = addr; sp += 1.</p>
<ol start="2">
<li>
<h3 id="pop">POP</h3>
</li>
</ol>
<p>For the same reason, take a snapshot of the current stack, marked as s. When encountering a ret instruction, the predicted jump address is paddr = sp, then pop: sp = sp - 1. Take a snapshot of the current stack, marked as s.</p>
<ol start="3">
<li>
<h3 id="redirect-operation">Redirect Operation</h3>
</li>
</ol>
<p>Since the BPU predicts program branches, there are &ldquo;correct predictions&rdquo; and &ldquo;wrong predictions.&rdquo; When the CPU backend detects a branch prediction error, it performs a redirect operation, informing the BPU where the prediction was wrong and what the correct result is. During redirection, the RAS module receives the correct branch and the RAS stack information at the time of prediction. Depending on the type of correct branch instruction, the following snapshot recovery situations arise:</p>
<p>(1) The previously predicted instruction is actually a call instruction, and the push operation is executed based on the addr address provided in the redirect.
(2) The previously predicted instruction is actually a ret instruction, and the pop operation is executed.</p>
<ol start="4">
<li>
<h3 id="commit-operation">Commit Operation</h3>
</li>
</ol>
<p>The commit operation is when the backend informs the frontend that the previous prediction was correct. Ideally, the RAS predictor doesn&rsquo;t need to perform any operations at this time.</p>
<h2 id="implementation-of-ras-in-kunming-lake">Implementation of RAS in Kunming Lake</h2>
<p>In actual circuit design, an infinitely large stack is impossible, and constant backups are not feasible. Therefore, in Kunming Lake&rsquo;s RAS implementation, the problems and solutions are as follows:</p>
<h3 id="how-to-obtain-ras-stack-snapshots-for-each-prediction"><strong>How to obtain RAS stack snapshots for each prediction?</strong></h3>
<p>To achieve the function of taking snapshots of the RAS stack, Kunming Lake adopts a <strong>linked representation</strong> based on a circular array. The design is as follows:</p>
<image src="Linked_RAS.png" width="800px">
<p>As shown above, a circular array is used for data management. The circular array has a starting address marked as BOS and a tail pointer marked as TOSW. The data between them are valid, and the data outside are free. Within the valid data, a linked structure represents the &ldquo;RAS stack,&rdquo; where each stack element records the number of its previous data. When performing stack operations, the corresponding previous element can be obtained through this number. The RAS stack&rsquo;s bottom pointer shares the BOS. In the initial state S in the figure, the RAS stack elements are 0, 1, 3, 5. Element 5 records the position of its previous element 3, and element 3 records the position of its previous element 1. When a push operation is needed, the RAS stack top pointer TOSR = TOSW, the new element is stored at the new TOSR position 7, and the position of its previous element 5 is recorded in the new element, then TOSW is moved back (TOSW = TOSW+1). When a pop operation is performed, the RAS stack top pointer TOSR moves to the previous element&rsquo;s position 3 based on the index saved in the stack top element. Therefore, under the condition that the stack does not overflow, the above RAS stack always allocates new data on the array through TOSW during normal Push/Pop operations, so all process states and intermediate data are saved. So, to restore to the state S, it only needs to reset the corresponding stack pointers. Therefore, in each prediction, the corresponding stack pointers (BOS, TOSR, TOSW) also need to be saved in the prediction result for later restoration in case of redirection. The advantage of this structure is that it can save complete process data, but frequent push operations can lead to large space resource consumption.</p>
<h3 id="chain-ra-storage-space-waste"><strong>Chain RA storage space waste?</strong></h3>
<p>Since the prediction result is correct after commit, the stack will not roll back. When the RAS predictor receives the commit message of the prediction block &ldquo;P,&rdquo; it will no longer receive the redirect message of block P, so the snapshot taken during the push operation for block P will not be used again. Therefore, the RAS stack elements can be categorized, with uncommitted elements stored in a &ldquo;linked&rdquo; structure and committed elements stored in a regular stack structure (the original RAS stack is split into two parts: the uncommitted part stored in a snapshot-saving linked structure and the committed part stored in a regular stack structure). The optimized RAS structure is shown below:</p>
<image src="RAS_Arch.png" width="800px">
<p>As shown above, based on the normal call/ret predictions and commit call/ret, the original RAS stack can be split into two independent stacks, called the &ldquo;speculative stack&rdquo; (spec_stack, linked structure) and the &ldquo;commit stack&rdquo; (commit_stack, regular structure). Due to the change in stack structure, the specific Pop/Push operations are as follows:</p>
<ol>
<li>Encounter normal call and ret:
(1) The call predicted by the prediction block is correct, and a push operation is performed on the spec_stack, specifically the linked stack Push process mentioned above.</li>
</ol>
<p>(2) The ret predicted by the prediction block is correct, and the stack top of the spec_stack is used as the prediction value, then a pop operation is performed. If the spec_stack is empty, the stack top element of the commit_stack is used as the prediction result (no pop operation is performed).</p>
<ol start="2">
<li>Commit operation:
(1) The FTQ execution result is call correct, and a regular push operation is performed on the commit_stack.</li>
</ol>
<p>(2) The FTQ execution result is ret correct, and a regular pop operation is performed on the commit_stack.</p>
<ol start="3">
<li>Redirect operation:
(1) Obtain the stack pointers (BOS, TOSR, TOSW, ssp) from the redirect message during the previous prediction and cover the current pointer values to complete the speculative stack rollback.</li>
</ol>
<p>(2) This operation does not affect the commit stack.</p>
<h3 id="how-to-handle-when-the-s3-prediction-result-is-inconsistent-with-s2-at-the-input-end"><strong>How to handle when the S3 prediction result is inconsistent with S2 at the input end?</strong></h3>
<p>Since the S3 result is assumed to be better than S2, the RAS stack needs to be repaired again in case of inconsistency. The specific inconsistency and corresponding repair operations are shown in the table below:</p>
<table>
<thead>
<tr>
<th>S2 Pred. Res.</th>
<th>S3 Pred. Res.</th>
<th>Repair Operation</th>
</tr>
</thead>
<tbody>
<tr>
<td>push</td>
<td>keep</td>
<td>pop</td>
</tr>
<tr>
<td>keep</td>
<td>pop</td>
<td>pop</td>
</tr>
<tr>
<td>pop</td>
<td>keep</td>
<td>push</td>
</tr>
<tr>
<td>keep</td>
<td>push</td>
<td>push</td>
</tr>
</tbody>
</table>
<p>S2 and S3 operations do not exist, pop/push or push/pop scenarios (Why not exist?)</p>
<h2 id="other-optimizations">Other Optimizations</h2>
<ol>
<li>Each element in the RAS stack has a counter, which is used to save repeated values (for recursive calls). For example, when the address pushed for the first time is 0xff00, and the address pushed for the second time is also 0xff00, only the counter of the top element of the stack needs to be incremented, and there is no need to actually push the address onto the stack.</li>
</ol>
<h2 id="interface-description">Interface Description</h2>
<p>In the RAS predictor, the core component is the <strong>RASStack</strong>, with the following interface:</p>
<table>
<thead>
<tr>
<th><strong>接口名称</strong></th>
<th><strong>功能描述</strong></th>
<th><strong>接口名称</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>in.spec_push_valid</td>
<td>预测有Call指令，Spec压栈</td>
<td>in.s2_fire</td>
<td>s2信号有效</td>
</tr>
<tr>
<td>in.spec_pop_valid</td>
<td>预测有Ret指令，Spec出栈</td>
<td>in.s3_fire</td>
<td>s3信号有效</td>
</tr>
<tr>
<td>in.spec_push_addr</td>
<td>Ret地址</td>
<td>in.s3_cancel</td>
<td>s3和s2的预测结果不一样，需要撤销s2的操作</td>
</tr>
<tr>
<td>out.spec_pop_addr</td>
<td>RAS的栈顶数据</td>
<td>in.s3_meta</td>
<td>s3需要的s2时的现场信息</td>
</tr>
<tr>
<td>out.ssp</td>
<td>commit栈顶指针</td>
<td>in.s3_missed_pop</td>
<td>s3判断需要再次进行pop</td>
</tr>
<tr>
<td>out.sctr</td>
<td>commit栈顶重复元素计数器</td>
<td>in.s3_missed_push</td>
<td>s3判断需要再次进行push</td>
</tr>
<tr>
<td>out.nsp</td>
<td>commit栈顶，会被ssp覆盖</td>
<td>in.s3_pushAddr</td>
<td>需要再次push时的地址</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>out.TOSR</td>
<td>spec栈栈顶指针</td>
<td>in.redirect_valid</td>
<td>需要重定向</td>
</tr>
<tr>
<td>out.TOSW</td>
<td>spec栈数据分配指针</td>
<td>in.redirect_isCall</td>
<td>真实执行情况是Call</td>
</tr>
<tr>
<td>out.BOS</td>
<td>spec栈栈低指针</td>
<td>in.redirect_isRet</td>
<td>真实执行情况是Return</td>
</tr>
<tr>
<td>in.commit_push_valid</td>
<td>push操作正确</td>
<td>in.redirect_meta_ssp</td>
<td>之前预测时的现场信息ssp</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>in.commit_pop_valid</td>
<td>FTQ执行结果为Call正确</td>
<td>in.redirect_meta_sctr</td>
<td>之前预测时的现场信息sctr</td>
</tr>
<tr>
<td>in.commit_push_addr</td>
<td>更新信息中的Ret地址</td>
<td>in.redirect_meta_TOSW</td>
<td>之前预测时的现场信息TOSW</td>
</tr>
<tr>
<td>in.commit_meta_TOSW</td>
<td>更新信息中的TOSW</td>
<td></td>
<td></td>
</tr>
<tr>
<td>in.redirect_meta_TOSR</td>
<td>之前预测时的现场信息TOSR</td>
<td></td>
<td></td>
</tr>
<tr>
<td>in.commit_meta_TOSR</td>
<td>更新信息中的TOSR</td>
<td>in.redirect_meta_NOS</td>
<td>之前预测时的现场信息NOS</td>
</tr>
<tr>
<td>in.commit_meta_ssp</td>
<td>更新信息中的现场信息SSP</td>
<td>in.redirect_callAddr</td>
<td>重定向地址</td>
</tr>
<tr>
<td>in.commit_meta_sctr</td>
<td>更新信息中的现场信息SCTR</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The relationship between the RASStack module and the BasePredictor interface is as follows:</p>
<table>
<thead>
<tr>
<th><strong>stack接口</strong></th>
<th><strong>转换过程</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>s.spec_push_valid</td>
<td>io.s2_fire(2) &amp;&amp; s2_full_pred.hit_taken_on_call &amp;&amp; !io.s3_redirect(2)</td>
<td>s2输入有效，且上级预测为call跳转</td>
</tr>
<tr>
<td>s.spec_pop_valid</td>
<td>io.s2_fire(2) &amp;&amp; s2_full_pred.hit_taken_on_ret  &amp;&amp; !io.s3_redirect(2)</td>
<td>s2输入有效，且上级预测为ret跳转</td>
</tr>
<tr>
<td>s.spec_push_addr</td>
<td>s2_full_pred.fallThroughAddr + Mux(s2_full_pred.last_may_be_rvi_call, 2.U, 0.U)</td>
<td>上级预测器s2预测的fallThroughAddr（即PC+2），判断是否压缩指令是否需要 +2</td>
</tr>
<tr>
<td>s.redirect_isCall</td>
<td>redirect.bits.level === 0.U &amp;&amp; recover_cfi.pd.isCall</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>s.redirect_isRet</td>
<td>redirect.bits.level === 0.U &amp;&amp; recover_cfi.pd.isRet</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>s.redirect_meta_*</td>
<td>redirect.bits.cfiUpdate.*</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>s.commit_push_valid</td>
<td>io.update.is_call_taken</td>
<td>call指令预测正确</td>
</tr>
<tr>
<td>s.commit_push_valid</td>
<td>io.update.is_ret_taken</td>
<td>ret指令预测正确</td>
</tr>
<tr>
<td>s.commit_push_addr</td>
<td>update.ftb_entry.getFallThrough(update.pc) + Mux(update.ftb_entry.last_may_be_rvi_call, 2.U, 0.U)</td>
<td>根据是否为压缩指令，进行地址+2或者+0</td>
</tr>
<tr>
<td>s.commit_meta_*</td>
<td>io.update.bits.meta.asTypeOf(new RASMeta)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>io.out.last_stage_spec_info.*</td>
<td>s3_meta.*</td>
<td>s3_meta = RegEnable(s2_meta, io.s2_fire(2))由s2_meta延迟一怕得到</td>
</tr>
<tr>
<td>io.out.last_stage_meta</td>
<td>s3_meta</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>io.out.s2.full_pred.*.jalr_target</td>
<td>:=stack.spec_pop_addr</td>
<td>预测地址（栈顶地址，只预测ret）</td>
</tr>
<tr>
<td>io.out.s3.full_pred.*.jalr_target</td>
<td>:=RegEnable(stack.spec_pop_addr, io.s2_fire(2))</td>
<td>由s2延迟一拍得到</td>
</tr>
<tr>
<td>io.out.s2/3.full_pred.targets.last</td>
<td>:=Mux(s2/3_is_jalr, s2/3_jalr_target, s2/3_last_target_in)</td>
<td>如果时call执行，更新targets.last的结果</td>
</tr>
</tbody>
</table>
<h2 id="timing-description">Timing Description</h2>
<p>In RAS, there are only 2 stages, S2 and S3.</p>
<p><strong>Main tasks in S2</strong></p>
<ol>
<li>Based on the S2 prediction result of the previous predictor, complete the prediction through the push/pop process and obtain the result spec_pop_addr.</li>
<li>Perform update operations based on commit signal.</li>
</ol>
<p><strong>Main tasks in S3</strong></p>
<ol>
<li>
<p>Based on the prediction result in the previous predictor S3 and the operations in S2, determine whether to undo the Pop/Push operation. The predictor assumes that the S3 prediction result is better than S2. If S2 and S3 predictions are inconsistent, the RAS predictor accepts the S3 result for stack operation.</p>
</li>
<li>
<p>The prediction process in S3 is the same as in S2, but the data is different.</p>
</li>
<li>
<p>Perform redirection operations (redirection information obtained from the previous cycle).</p>
</li>
</ol>
<p>Since the RASStack appears to complete its tasks within a cycle, data bypassing is needed inside the stack to cache data for processing.</p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-0d502bffe5d3814d3a2b8b0dc801ebcc">4 - Feature List</h1>
    <div class="lead">The Feature List in hardware verification lists various functions and characteristics of the design that need to be verified. This section provides a basic feature list for each verification task for reference.</div>
	<p>The <strong>Feature List</strong> in hardware verification lists various functions and characteristics of the design that need to be verified. Before starting verification, we generally list the features of the design to clarify which features need to be verified in this task.</p>
<p>To verify a feature in the feature list, we will build the necessary test points for this feature and write test cases to cover these test points. Therefore, the feature list is not only a description of the features of the design to be verified but also a guide for our verification direction and a simple summary of the verification task.</p>
<p>In this verification, we provide a basic feature list for each verification task (i.e., the top-level BPU and each sub-predictor), which only covers the basic functions of the corresponding module. In your verification, you must ensure that this verification covers these features. Additionally, you can supplement features not covered in the list to ensure the final delivery quality.</p>
<p>In this document section, you only need to refer to the document corresponding to the module you will verify.</p>

</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3bdbfd3a06696b3b719281b018d22240">4.1 - BPU Top Feature List</h1>
    
	<h2 id="feature-list">Feature List</h2>
<ol>
<li>upport uFTB sub-predictor</li>
<li>Support TAGE-SC sub-predictor</li>
<li>Support FTB sub-predictor</li>
<li>Support ITTAGE sub-predictor</li>
<li>Support RAS sub-predictor</li>
<li>Support three-stage prediction result and other information output</li>
<li>Support prediction result redirection signal generation</li>
<li>Support pipeline control signal generation</li>
<li>Support PC generation</li>
<li>Support global branch history maintenance</li>
<li>Support branch folding history maintenance</li>
<li>Support redirection request response, state restoration</li>
<li>Support update request response</li>
</ol>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-4c5f88e228be33ede010163fdda3986d">4.2 - uFTB Feature List</h1>
    
	<h2 id="feature-list">Feature List</h2>
<ol>
<li>Support prediction based on FTB entry</li>
<li>Support two-bit saturating counter</li>
<li>Support basic prediction result output and meta information output for the s1 channel</li>
<li>Support update request response, updating internal FTB and two-bit saturating counter.</li>
</ol>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d041069efc990462d9eb15082e47df69">4.3 - FTB Feature List</h1>
    
	<h2 id="feature-list">Feature List</h2>
<ol>
<li>Support FTB entry storage</li>
<li>Support basic prediction result output and meta information output for the s2, s3 channels</li>
<li>Support update request response, updating internal FTB entries</li>
</ol>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-68c7ba0b5bb8da4bd19e6f7957d9e15c">4.4 - TAGE-SC Feature List</h1>
    
	<h2 id="feature-list">Feature List</h2>
<ol>
<li>s2 TAGE outputs prediction results</li>
<li>s3 SC outputs prediction results</li>
<li>s2 TAGE outputs meta information</li>
<li>s3 SC outputs meta information</li>
<li>TAGE performs update training</li>
<li>Check for new table entry requests</li>
<li>Globally reset useful</li>
<li>SC performs update training</li>
</ol>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c333c9631e4a9b4b84765548c49a916e">4.5 - ITTAGE Feature List</h1>
    
	<h2 id="feature-list">Feature List</h2>
<ol>
<li>s2 ITTAGE determines whether to generate a prediction result</li>
<li>s3 ITTAGE reads the predicted target for a branch</li>
<li>s3 ITTAGE outputs meta information</li>
<li>ITTAGE performs update training</li>
<li>Check for new table entry requests</li>
<li>Globally reset useful</li>
<li>Prediction direction</li>
</ol>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1132c27c26acab41c5da9b539026d07d">4.6 - RAS Feature List</h1>
    
	<h2 id="feature-list">Feature List</h2>
<ol>
<li>Supports enabling and disabling of the predictor</li>
<li>Supports s3 prediction result overriding s2 prediction result</li>
<li>Supports push and pop operations of the RAS stack</li>
<li>Supports redirect operation of the RAS stack</li>
<li>Supports update operation of the RAS stack</li>
<li>Supports base predictor interface</li>
<li>Conforms to the standard RAS predictor prediction process</li>
</ol>

</div>



    
	
  

    
	
  



          </main>
        </div>
      </div>
      <footer class="td-footer row d-print-none">
  <div class="container-fluid">
    <div class="row mx-md-2">
      <div class="td-footer__left col-6 col-sm-4 order-sm-1">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="User mailing list" aria-label="User mailing list">
    <a target="_blank" rel="noopener" href="https://example.org/mail" aria-label="User mailing list">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__right col-6 col-sm-4 order-sm-3">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="GitHub" aria-label="GitHub">
    <a target="_blank" rel="noopener" href="https://github.com/google/docsy" aria-label="GitHub">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2">
        <span class="td-footer__copyright">&copy;
    2025
    <span class="td-footer__authors">BOSC</span></span><span class="td-footer__all_rights_reserved">All Rights Reserved</span><span class="ms-2"><a href="https://policies.google.com/privacy" target="_blank" rel="noopener">Privacy Policy</a></span>
      </div>
    </div>
  </div>
</footer>

    </div>
    <script src="/xs-bpu/js/main.min.fc653db1f3d4f4a8b4eacd389f96d8afe966937ba9dded8b07d3a1b17d967d22.js" integrity="sha256-/GU9sfPU9Ki06s04n5bYr&#43;lmk3up3e2LB9OhsX2WfSI=" crossorigin="anonymous"></script>
<script defer src="/xs-bpu/js/click-to-copy.min.f724d3de49218995223b7316aa2e53e2b34bf42026bf399ebb21bb02212402d1.js" integrity="sha256-9yTT3kkhiZUiO3MWqi5T4rNL9CAmvzmeuyG7AiEkAtE=" crossorigin="anonymous"></script>
<script src='/xs-bpu/js/tabpane-persist.js'></script>

  </body>
</html>
