<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OpenVerify Courses – Branch Prediction Unit (BPU)</title>
    <link>https://xs-mlvp.github.io/xs-bpu/en/categories/branch-prediction-unit-bpu/</link>
    <description>Recent content in Branch Prediction Unit (BPU) on OpenVerify Courses</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    
	  <atom:link href="https://xs-mlvp.github.io/xs-bpu/en/categories/branch-prediction-unit-bpu/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: uFTB Branch Predictor</title>
      <link>https://xs-mlvp.github.io/xs-bpu/en/docs/modules/01_uftb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/en/docs/modules/01_uftb/</guid>
      <description>
        
        
        &lt;h2 id=&#34;introduction-to-uftb&#34;&gt;Introduction to uFTB&lt;/h2&gt;
&lt;p&gt;uFTB is the first predictor among all the predictors in Xiangshan, and it serves as the cornerstone for other predictors to generate prediction results. uFTB works in the s1 stage. It can generate prediction results within the current cycle after obtaining s1_pc and output them in the s1 channel, without modifying other channels. It provides the position of the branch instruction and the target of the instruction. Subsequent predictors will further predict based on this result.&lt;/p&gt;
&lt;p&gt;Its essence is an FTB item cache, which stores FTB items, and the basic prediction result will be directly generated from the read-out FTB item.&lt;/p&gt;
&lt;p&gt;Therefore, before you start reading the document, make sure you understand the FTB items and their meanings, as well as the specific details of the prediction result interface.&lt;/p&gt;
&lt;h2 id=&#34;functionality-of-uftb&#34;&gt;Functionality of uFTB&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cache FTB items and generate one-cycle prediction results&lt;/strong&gt;: uFTB maintains a small FTB item cache. After receiving PC, it reads out the FTB item corresponding to the PC within one cycle and generates an s1 stage prediction result from the FTB item.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Maintain two-bit saturating counters to provide basic conditional branch results&lt;/strong&gt;: uFTB maintains two-bit saturating counters for each line of the FTB item cache. The direction prediction result is reflected in the prediction result output of uFTB.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Update the FTB cache and two-bit saturating counters based on update requests&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;uftb-cache-structure&#34;&gt;uFTB Cache Structure&lt;/h2&gt;
&lt;p&gt;As mentioned above, uFTB is essentially a small cache that stores FTB items. Its approximate structure is shown in the figure below.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;1.png&#34; width=&#34;400px&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;In the current version of Xiangshan, uFTB has a total of 32 cache lines, each cache line is called &lt;code&gt;FauFTBWay&lt;/code&gt;, and one FTB item can be stored in each cache line.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;When s1 pipeline is valid&lt;/strong&gt;, uFTB will use &lt;code&gt;s1_pc&lt;/code&gt; to determine which item of the uFTB cache to read out. The cache is indexed based on the tag field in PC, which is defined as pc[16:1], i.e., taking 16 bits from PC as an identifier to match a certain line in the cache.&lt;/p&gt;
&lt;p&gt;Each line in the cache, i.e., the data request interface in &lt;code&gt;FauFTBWay&lt;/code&gt;, has three items:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;req_tag&lt;/strong&gt;: Input tag identifier extracted from pc&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;resp&lt;/strong&gt;: Output the FTB item stored in this line&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;resp_hit&lt;/strong&gt;: Output indicates whether the FTB item in this line matches req_tag
uFTB connects the tag to the data request interface of each line in the cache and selects the hit FTB item based on the &lt;code&gt;resp_hit&lt;/code&gt; signal. Subsequent steps will generate a complete prediction result based on this FTB item.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;two-bit-saturating-counters&#34;&gt;Two-Bit Saturating Counters&lt;/h2&gt;
&lt;p&gt;uFTB maintains two-bit saturating counters for each line of the FTB item cache. As we know, an FTB item can store up to two conditional branch instructions, so each line&amp;rsquo;s two-bit saturating counters also have two, responsible for providing rough prediction results for the conditional branch instructions in them.&lt;/p&gt;
&lt;p&gt;When indexing the FTB item, uFTB also indexes the corresponding two-bit saturating counters.&lt;/p&gt;
&lt;p&gt;When the prediction result is generated, it will be based on the FTB item and the contents of the two two-bit saturating counters corresponding to it.&lt;/p&gt;
&lt;h2 id=&#34;prediction-result-generation&#34;&gt;Prediction Result Generation&lt;/h2&gt;
&lt;p&gt;After indexing the corresponding FTB item and two two-bit saturating counters based on s1_pc, uFTB needs to generate a prediction result based on them. The prediction result generated by uFTB will be outputted through the s1 channel when s1 pipeline is valid, and will not be modified for s2 and s3 channels.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The signal generation method in the s1 prediction result can refer to the following list:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;hit&lt;/strong&gt;Whether the FTB item hits
&lt;ul&gt;
&lt;li&gt;Generation method: &lt;code&gt;resp_hit&lt;/code&gt; signal in &lt;code&gt;FauFTBWay&lt;/code&gt;, one of them is valid&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;slot_valids&lt;/strong&gt;: Slot valid bit, indicating whether each slot in the ftb item is valid&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;targets&lt;/strong&gt;: Jump target address corresponding to each slot&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;offsets&lt;/strong&gt;: The offset of each instruction in the slot relative to the starting address of the prediction block&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;is_jal&lt;/strong&gt;: Whether the prediction block contains a jal instruction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;is_jalr&lt;/strong&gt;: Whether the prediction block contains a jalr instruction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;is_call&lt;/strong&gt;: Whether the prediction block contains a call instruction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;is_ret&lt;/strong&gt;: Whether the prediction block contains a ret instruction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;last_may_be_rvi_call&lt;/strong&gt;: Signal indicating that the last slot in the prediction block may be an RVI type call instruction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;is_br_sharing&lt;/strong&gt;: The signal stored in the last slot (tailSlot) indicates a conditional branch instruction.
&lt;ul&gt;
&lt;li&gt;Generation: Exported from the corresponding field in the FTB entry.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fallThroughErr&lt;/strong&gt;: The &lt;code&gt;pftAddr&lt;/code&gt; recorded in the FTB entry is incorrect.
&lt;ul&gt;
&lt;li&gt;Generation: Compare whether the end address represented by &lt;code&gt;pftAddr&lt;/code&gt; is greater than the start address of the predicted block. If it is smaller, an error has occurred, and this signal is set to valid. This situation may occur when the PC indexes an incorrect FTB entry.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fallThroughAddr&lt;/strong&gt;: The end address of the predicted block.
&lt;ul&gt;
&lt;li&gt;Generation: If &lt;code&gt;fallThroughErr&lt;/code&gt; is invalid, it is generated based on &lt;code&gt;pftAddr&lt;/code&gt;. Otherwise, it is set to the start address + prediction width.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;br_taken_mask&lt;/strong&gt;: Branch prediction result, with each branch (slot) corresponding to a bit indicating whether the branch is predicted as taken.
&lt;ul&gt;
&lt;li&gt;Generation: Generated based on the &lt;code&gt;always_taken&lt;/code&gt; field in the FTB entry and the result indicated by the two-bit saturating counter.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;jalr_target&lt;/strong&gt;: The jump target of the jalr in this predicted block.
-Generation: From the jump target in the tailSlot of the FTB entry.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;uftb-update&#34;&gt;uFTB Update&lt;/h2&gt;
&lt;p&gt;The update of uFTB involves updating the FTB entry cache and the two-bit saturating counter, with the update content obtained through the update interface.&lt;/p&gt;
&lt;p&gt;In the uFTB predictor, the reading and writing of the cache and the two-bit saturating counter do not conflict, so we do not need to consider timing conflicts between reading and updating and can consider them as two independent parts.&lt;/p&gt;
&lt;h3 id=&#34;ftb-cache-update&#34;&gt;FTB Cache Update&lt;/h3&gt;
&lt;p&gt;The update process of the FTB cache is simple. The update channel has already specified the PC and the newly generated FTB entry, so it only needs to be written to the specified position in the cache.&lt;/p&gt;
&lt;p&gt;FTB cache updating requires two cycles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the first cycle, calculate the following based on the signals in the update:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Which row in the cache corresponds to the update request&lt;/strong&gt; The PC extracted from the update request is sent to the update request channel of FauFTBWay, and the hit signal returned by each row is calculated.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In the second cycle, update according to the position calculated in the first cycle. If no row is hit, uFTB will use a &lt;strong&gt;pseudo-LRU replacement algorithm&lt;/strong&gt; to select the row to be written.
Specifically, the ftb_entry signal group in the update channel contains the complete information of the new FTB entry, which is sent to the cache row that needs to be updated.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;two-bit-saturating-counter-update&#34;&gt;Two-Bit Saturating Counter Update&lt;/h3&gt;
&lt;p&gt;The update of the two-bit saturating counter needs to be combined with the actual execution of the subsequent program and the branch instruction information recorded in the FTB entry, which can be obtained from the update channel.&lt;/p&gt;
&lt;p&gt;The update of the two-bit saturating counter also requires two cycles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the first cycle, calculate which two-bit saturating counter corresponding to the conditional branch instruction in the slot needs to be updated, which needs to meet the following conditions:
&lt;ul&gt;
&lt;li&gt;The current branch instruction slot is valid and contains a conditional branch instruction.&lt;/li&gt;
&lt;li&gt;The current branch instruction slot is not marked as always_taken. (Because after being marked as always_taken, the result of the two-bit saturating counter will not be used.)&lt;/li&gt;
&lt;li&gt;The current branch instruction slot is not after the branch instruction slot where an actual jump occurred.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In the second cycle, update the saturating counter based on the mask generated in the first cycle and the &lt;code&gt;br_taken_mask&lt;/code&gt; information in the update channel.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;interface-list&#34;&gt;Interface List&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;信号类型&lt;/th&gt;
&lt;th&gt;信号位&lt;/th&gt;
&lt;th&gt;信号名&lt;/th&gt;
&lt;th&gt;信号描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;clock&lt;/td&gt;
&lt;td&gt;输入时钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;reset&lt;/td&gt;
&lt;td&gt;复位信号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[35:0]&lt;/td&gt;
&lt;td&gt;io_reset_vector&lt;/td&gt;
&lt;td&gt;用于reset时，reset s1_pc_dup_0 提供的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_0&lt;/td&gt;
&lt;td&gt;输入位s0_pc 的 第0个复制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_1&lt;/td&gt;
&lt;td&gt;同上 第1个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_2&lt;/td&gt;
&lt;td&gt;同上 第2个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_3&lt;/td&gt;
&lt;td&gt;同上 第3个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_pc_0&lt;/td&gt;
&lt;td&gt;输出s1_pc 的 第0个复制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_pc_1&lt;/td&gt;
&lt;td&gt;同上 第1个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_pc_2&lt;/td&gt;
&lt;td&gt;同上 第2个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_pc_3&lt;/td&gt;
&lt;td&gt;同上 第3个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;solt 0 是否被预测为 always taken&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;solt 1 是否被预测为 always taken&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_slot_valids_0&lt;/td&gt;
&lt;td&gt;solt 0 是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_slot_valids_1&lt;/td&gt;
&lt;td&gt;solt 1 是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_targets_0&lt;/td&gt;
&lt;td&gt;solt 0 对应的跳转目标地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_targets_1&lt;/td&gt;
&lt;td&gt;solt 1 对应的跳转目标地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_offsets_0&lt;/td&gt;
&lt;td&gt;solt 0 中分支指令相对于地址块起始pc的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_offsets_1&lt;/td&gt;
&lt;td&gt;solt 1 中分支指令相对于地址块起始pc的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_fallThroughAddr&lt;/td&gt;
&lt;td&gt;预测块的结束地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_is_br_sharing&lt;/td&gt;
&lt;td&gt;solt 1（无条件跳转）是否被共享为有条件跳转指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;类似 io_out_s1_pc_1 io_out_s1_full_pred_0的复制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_fallThroughErr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[222:0]&lt;/td&gt;
&lt;td&gt;io_out_last_stage_meta&lt;/td&gt;
&lt;td&gt;输出最后阶段的元信息 io_out_last_stage_meta = {213&amp;rsquo;h0, resp_meta_pred_way_r_1, resp_meta_hit_r_1}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_ctrl_ubtb_enable&lt;/td&gt;
&lt;td&gt;控制ubtb是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s0_fire_0&lt;/td&gt;
&lt;td&gt;输入s0_fire_0，与 io_out_s1_pc_0 &amp;lt;= io_in_bits_s0_pc_0 的时钟门控相关&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s0_fire_1&lt;/td&gt;
&lt;td&gt;输入s0_fire_1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s0_fire_2&lt;/td&gt;
&lt;td&gt;输入s0_fire_2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s0_fire_3&lt;/td&gt;
&lt;td&gt;输入s0_fire_3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s1_fire_0&lt;/td&gt;
&lt;td&gt;输入s1_fire_0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s2_fire_0&lt;/td&gt;
&lt;td&gt;输入s2_fire_0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_valid&lt;/td&gt;
&lt;td&gt;更新有效性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_pc&lt;/td&gt;
&lt;td&gt;传回的预测块pc（用于指示更新的预测块）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_brSlots_0_offset&lt;/td&gt;
&lt;td&gt;solt 0 中分支指令相对于地址块起始pc的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[11:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_brSlots_0_lower&lt;/td&gt;
&lt;td&gt;跳转目标地址的低位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[1:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_brSlots_0_tarStat&lt;/td&gt;
&lt;td&gt;跳转后的 pc 高位是否进退位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_brSlots_0_valid&lt;/td&gt;
&lt;td&gt;是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_offset&lt;/td&gt;
&lt;td&gt;solt 1 中分支指令相对于地址块起始pc的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[19:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_lower&lt;/td&gt;
&lt;td&gt;跳转目标地址的低位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[1:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_tarStat&lt;/td&gt;
&lt;td&gt;跳转后的 pc 高位是否进退位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_sharing&lt;/td&gt;
&lt;td&gt;无条件跳转指令槽中存储条件分支指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_valid&lt;/td&gt;
&lt;td&gt;是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_pftAddr&lt;/td&gt;
&lt;td&gt;Partial Fallthrough Addr 如果预测块中没有跳转，那么程序将会顺序执行到达的地址，预测块的结束地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_carry&lt;/td&gt;
&lt;td&gt;pc+pft时是否产生进位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_always_taken_0&lt;/td&gt;
&lt;td&gt;是否预测为总是跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_always_taken_1&lt;/td&gt;
&lt;td&gt;是否预测为总是跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;是否跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;是否跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: TAGE-SC Branch Predictor</title>
      <link>https://xs-mlvp.github.io/xs-bpu/en/docs/modules/02_tage_sc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/en/docs/modules/02_tage_sc/</guid>
      <description>
        
        
        &lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;TAGE-SC is the &lt;strong&gt;primary predictor&lt;/strong&gt; for conditional branches in the Kunming Lake architecture, classified as an Accurate Predictor (APD). TAGE-SC can be seen as two relatively independent components: the prediction part TAGE and the verification part SC.&lt;/p&gt;
&lt;p&gt;The Tagged Geometric History Length Predictor (TAGE) utilizes &lt;strong&gt;multiple prediction tables with different history lengths&lt;/strong&gt; to exploit &lt;strong&gt;extensive branch history information&lt;/strong&gt;. TAGE predicts whether a branch instruction will be taken or not taken. It consists of a base prediction table and multiple history tables. It first predicts using multiple history tables. If there is no prediction, it uses the prediction from the base table.
The Statistical Corrector (SC) is a statistical corrector. SC references the prediction results of TAGE and &lt;strong&gt;statistical bias results&lt;/strong&gt;. Based on these two results, it &lt;strong&gt;corrects&lt;/strong&gt; the final prediction result.&lt;/p&gt;
&lt;p&gt;In Kunming Lake, each prediction block can have up to 2 branch instructions, so TAGE can predict &lt;strong&gt;up to 2 conditional branch instructions simultaneously&lt;/strong&gt;. When accessing the various history tables in TAGE, the starting address of the prediction block is used as the PC, and two prediction results are retrieved based on the &lt;strong&gt;same global history&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;tage-branch-predictor-in-kunming-lake&#34;&gt;TAGE Branch Predictor in Kunming Lake&lt;/h2&gt;
&lt;h3 id=&#34;basic-functionality&#34;&gt;Basic Functionality&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; src=&#34;tage.PNG&#34;&gt;&lt;/p&gt;
&lt;p&gt;The core idea of the TAGE predictor is to provide prediction results with different history lengths and select the most appropriate result for feedback. In the TAGE predictor, there are a total of &lt;strong&gt;1+N&lt;/strong&gt; history record tables, where N is a configurable option. In Kunming Lake, N=4.&lt;/p&gt;
&lt;p&gt;The base predictor based on the T0 table is the &lt;strong&gt;baseline predictor&lt;/strong&gt;. During prediction, it directly looks up the &amp;ldquo;2-bit saturated counter representing the jump history information&amp;rdquo; corresponding to the address in the T0 table, and then makes a prediction based on the history information. The T0 table has only 2 bits per entry, so the history states it can record are limited.&lt;/p&gt;
&lt;p&gt;For tables other than T0, we use &lt;strong&gt;Tn&lt;/strong&gt; to represent them. During table lookup, in addition to the PC, it is also necessary to use the &lt;strong&gt;global jump history information H&lt;/strong&gt; for the lookup. When a match is found, the prediction is made based on the &amp;ldquo;3-bit saturated predictor&amp;rdquo; to jump or not to jump. The higher the value of n for the Tn table, the longer the history information it uses, i.e., x&amp;lt;y.&lt;/p&gt;
&lt;p&gt;For each prediction, TAGE selects the table entry with the &lt;strong&gt;longest global jump history&lt;/strong&gt; among all the hit Tn entries.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If the table entry exists and the prediction result confidence is high, it is used as the final prediction result.&lt;/li&gt;
&lt;li&gt;If the confidence is low, another internal counter is used to determine whether to select that entry or T0 as the final prediction.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To save space, when retrieving the Tn table, the input jump history information H needs to be &lt;strong&gt;compressed&lt;/strong&gt;, a process also known as &lt;strong&gt;history folding&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The table entries of each prediction table include the following elements:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;T0 table indexed directly by PC
&lt;ol&gt;
&lt;li&gt;2-bit pred &lt;strong&gt;unsigned&lt;/strong&gt; saturated counter (indicating prediction direction and confidence level)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Tn table indexed by XOR of PC and folded global history
&lt;ol&gt;
&lt;li&gt;1-bit valid bit&lt;/li&gt;
&lt;li&gt;3-bit pred &lt;strong&gt;unsigned&lt;/strong&gt; saturated counter&lt;/li&gt;
&lt;li&gt;8-bit tag (used for verifying whether the hit is intentional, not coincidental)&lt;/li&gt;
&lt;li&gt;1-bit useful bit for controlling expiration
For a prediction block, all tables may generate prediction results, requiring a selection process. Typically, the higher the Tn table number, the higher its priority.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;pipeline&#34;&gt;Pipeline&lt;/h3&gt;
&lt;p&gt;TAGE contains two pipeline stages: the first stage calculates the index, and the second stage reads the results from the SRAM table.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Stage 0 (s0): Input to the first pipeline stage, usually the pc and folded history.
&lt;strong&gt;First pipeline stage operation&lt;/strong&gt;: Calculate the index. Output to s1 via registers.&lt;/li&gt;
&lt;li&gt;Stage 1 (s1): Input to the second pipeline stage, consisting of the index and other calculated data from the first stage.
&lt;strong&gt;Second pipeline stage operation&lt;/strong&gt;: Memory access to SRAM, reading the prediction result. Output to s2 via registers.&lt;/li&gt;
&lt;li&gt;Stage 2 (s2): Actual prediction result. TAGE uses 2 stages for prediction, with the prediction result ready for use in the third stage after 2 stages.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;data-structures&#34;&gt;Data Structures&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;In Kunming Lake&amp;rsquo;s implementation, the T0 and Tn table structures are as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;预测器&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;表项构成&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;项数&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;基准预测器T0&lt;/td&gt;
&lt;td&gt;用于在其他预测器的预测结果都无效时输出预测结果&lt;/td&gt;
&lt;td&gt;2 bit ctr 饱和计数器最高位决定跳转方向&lt;/td&gt;
&lt;td&gt;2路各2048项，每路对于一条分支指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;预测表T1-T4&lt;/td&gt;
&lt;td&gt;对每个预测块的输入，所有Tn表都进行预测，在所有预测有效的结果中，选择历史记录最长的结果作为最后预测结果。历史记录长度由输入的H决定&lt;/td&gt;
&lt;td&gt;1 bit valid 有效位 3 bit ctr 饱和计数器8 bit tag 校验命中1 bit us 作为usefulness计数器&lt;/td&gt;
&lt;td&gt;4096项、奇数项对应第一条分支指令，偶数项对应第二条分支指令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For each table Tn, the length of its input &amp;ldquo;global branch history data H&amp;rdquo; varies during querying. Assuming the total prediction history length is S, Tn and Tn+1 may use the low x, low y bits of S (&lt;strong&gt;the lower bits are the newer history&lt;/strong&gt;) as query inputs. Generally, the larger the n of table Tn, the longer the history information used, i.e., x&amp;lt;y.&lt;/p&gt;
&lt;p&gt;During the query of table Tn, since the historical data H is &amp;ldquo;compressed,&amp;rdquo; it may lead to a situation where the result of one PC1^H1 matches another PC2^H2 (similar to a Hash collision), resulting in indexing into invalid data (predicting PC1 indexes to predicted PC2&amp;rsquo;s data). Therefore, TAGE provides a tag identifier for each table, using an 8-bit tag in the Kunming Lake implementation to reduce the probability of collisions. The calculation method and index method for tags are different; &lt;strong&gt;only when the tag calculation is the same, the query result is valid&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In the Tn table entry, in addition to the saturation counter ctr and tag, there is also a 1-bit &lt;strong&gt;usefulness counter&lt;/strong&gt;. When this counter is 0, it is a weak entry, indicating that the entry can be reallocated for other uses; when it is not 0, it is a strong entry, indicating that the entry cannot be reallocated for other uses.&lt;/p&gt;
&lt;p&gt;To &lt;strong&gt;try to avoid&lt;/strong&gt; the situation where all table entries are 1 and no new table entries can be allocated, TAGE expects to use the counter bankTickCtrs to clear all usefulness to 0.&lt;/p&gt;
&lt;h3 id=&#34;retrieval-method-for-t0-and-tn-tables&#34;&gt;Retrieval Method for T0 and Tn Tables&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;For table T0, indexing is done using the PC[11:1] bits to index 2048 table entries, so for T0, there is no possibility of not finding a match.&lt;/li&gt;
&lt;li&gt;For table Tn, in addition to PC[11:1], retrieval also requires searching based on the global branch history. In Kunming Lake, the top-level branch predictor maintains a 256-bit global history record GH, which can fold the GH&amp;rsquo;s most recent n bits of history information based on the required number of bits x for the sub-predictor. That is, n is divided into ceil(x/n) units of length x, and then XOR is performed bitwise. This folded history is denoted as FH (Folded History), and the specific process can be found in the [Branch Folding History section](../00_bpu_top/#Branch Folding History). When the TAGE predictor searches for a table entry in Tn, it uses the index and tag, calculated as follows:&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Calculation Formula&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;index = FH ^ ((pc&amp;raquo;1)低位)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tag = FH1 ^ FH2 ^ ((pc&amp;raquo;1)低位)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Where FH, FH1, FH2 represent the folded global branch history according to certain rules. For Tn, FH, FH1, and FH2 each have their own folding bit numbers, which may not be the same. In the Kunming Lake implementation, the configurations of the T0 and Tn tables are as follows:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;表名称&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;FH长度&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;FH1长度&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;FH2长度&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;最近历史长度（用到GH中的位数）&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;7比特&lt;/td&gt;
&lt;td&gt;低8位，即把最新8位历史，折叠成FH、FH1、FH2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;11比特&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;7比特&lt;/td&gt;
&lt;td&gt;低13位，即把最新13位历史，折叠成FH、FH1、FH2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T3&lt;/td&gt;
&lt;td&gt;11比特&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;7比特&lt;/td&gt;
&lt;td&gt;低32位，即把最新32位历史，折叠成FH、FH1、FH2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T4&lt;/td&gt;
&lt;td&gt;11比特&lt;/td&gt;
&lt;td&gt;8比特&lt;/td&gt;
&lt;td&gt;7比特&lt;/td&gt;
&lt;td&gt;低119位，即把最新119位历史，折叠成FH、FH1、FH2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Note: pc&amp;raquo;1 is used because RISC-C extension is used, with 2-byte alignment, and PC itself is already aligned to 1 byte, so only 1 bit is used.&lt;/p&gt;
&lt;h3 id=&#34;alternative-predictor&#34;&gt;Alternative Predictor&lt;/h3&gt;
&lt;p&gt;Since the Tn table uses saturation counters for prediction, there may be situations where the output result is &amp;ldquo;not confident.&amp;rdquo; For example, in Kunming Lake, for a 3-bit saturation counter, both 100 and 011 indicate a &lt;strong&gt;weak prediction&lt;/strong&gt;. To provide more choices as references for this state, the TAGE predictor also provides an &amp;ldquo;alternative predictor&amp;rdquo; mechanism, which determines whether to select the prediction result of Tn or T0 when the Tn table predicts with low confidence.&lt;/p&gt;
&lt;p&gt;In the Kunming Lake implementation, the &amp;ldquo;alternative predictor&amp;rdquo; is implemented based on the register group &lt;strong&gt;useAltOnNaCtrs&lt;/strong&gt;. It consists of two paths of 128 &lt;strong&gt;4-bit saturation counters&lt;/strong&gt; each, initialized to &lt;strong&gt;0b1000&lt;/strong&gt;. When TAGE makes a prediction, it uses &lt;strong&gt;PC(7,1)&lt;/strong&gt; to index the corresponding saturation counter. If the value of this counter is greater than or equal to the preset value and the prediction result of Tn is not confident, it selects the result of T0; otherwise, it selects the result of Tn.&lt;/p&gt;
&lt;h3 id=&#34;prediction-process&#34;&gt;Prediction Process&lt;/h3&gt;
&lt;p&gt;In summary, the prediction steps of the TAGE predictor in Kunming Lake are as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Parallel&lt;/strong&gt; indexing of T0 and Tn tables, selecting which table to use based on the hit result:
&lt;ol&gt;
&lt;li&gt;If a match to the tag of a Tn table is found, the potential prediction result is given by the saturation counter of the longest history Tn table.&lt;/li&gt;
&lt;li&gt;If no match to a Tn table is found, the final prediction result is given by the saturation counter of the T0 table.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;If the potential prediction result of the matched Tn table is a weak prediction (100,011), and the value of the corresponding 4-bit counter in the alternative prediction for PC is greater than or equal to a threshold, the result of the T0 table is used as the final result; otherwise, the prediction result of the Tn table is used as the final prediction result.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;training-process&#34;&gt;Training Process&lt;/h3&gt;
&lt;p&gt;Since the prediction process of TAGE involves many counters and tags, they need to be updated according to certain rules, a process known as training. This training process occurs in the BPU&amp;rsquo;s update stage, where the PC, branch history, and prediction correctness information are input. The training process for branch prediction in Kunming Lake is divided into several steps based on different conditions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Update when &lt;strong&gt;T0&lt;/strong&gt; is the final prediction result: If a jump occurs (i.e., taken), increment the ctr saturation counter indexed by the pc; otherwise, decrement it.&lt;/li&gt;
&lt;li&gt;When &lt;strong&gt;only T0&lt;/strong&gt; is hit, the following operations are performed:
&lt;ol&gt;
&lt;li&gt;If T0 is &lt;strong&gt;predicted correctly&lt;/strong&gt;, no additional update is performed.&lt;/li&gt;
&lt;li&gt;If T0 is &lt;strong&gt;predicted incorrectly&lt;/strong&gt;, attempt to randomly allocate a new table entry in a Tn table. To allocate a new table entry, the original entry&amp;rsquo;s usefulness at the corresponding index must be 0. The new entry is initialized as a weak prediction with usefulness 0, and its tag is set to the newly calculated tag.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;When &lt;strong&gt;both T0 and Tn are hit&lt;/strong&gt;, the following operations are performed:
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Tn&lt;/strong&gt; is always updated: If a jump occurs, increment the ctr saturation counter indexed by the pc; otherwise, decrement it. It is important to note that &amp;ldquo;hit&amp;rdquo; means that the tag of the indexed entry matches the calculated tag.&lt;/li&gt;
&lt;li&gt;If &lt;strong&gt;T0 and Tn produce the same result&lt;/strong&gt;:
&lt;ol&gt;
&lt;li&gt;If &lt;strong&gt;predicted correctly&lt;/strong&gt;, no additional update is performed.&lt;/li&gt;
&lt;li&gt;If &lt;strong&gt;predicted incorrectly&lt;/strong&gt;, attempt to allocate a new table entry in a table with a longer history than Tn. To allocate a new entry, the usefulness of the original entry at the corresponding index must be 0. The new entry is initialized as a weak prediction with usefulness 0, and its tag is set to the tag calculated using the new history information.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;If &lt;strong&gt;T0 and Tn produce different results&lt;/strong&gt;:
&lt;ol&gt;
&lt;li&gt;If &lt;strong&gt;Tn is correct&lt;/strong&gt;, the entry&amp;rsquo;s usefulness is incremented.
&lt;ol&gt;
&lt;li&gt;If the result is still a &lt;strong&gt;weak prediction&lt;/strong&gt;, the counter in the alternative prediction for T0 is decremented.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;If &lt;strong&gt;Tn is incorrect&lt;/strong&gt;, the entry&amp;rsquo;s usefulness is decremented, and a new entry is allocated in a table with a longer history than Tn, as in 3.2.2.
&lt;ol&gt;
&lt;li&gt;If the result is still a &lt;strong&gt;weak prediction&lt;/strong&gt;, the counter in the alternative prediction for T0 is incremented.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;When a new table &lt;strong&gt;needs to be allocated&lt;/strong&gt;, dynamic reset of the usefulness flag is performed.
&lt;ol&gt;
&lt;li&gt;Using a 7-bit bankTickCtrs register and calculating:
&lt;ol&gt;
&lt;li&gt;The number of allocatable tables &lt;strong&gt;a&lt;/strong&gt; (with a longer history length than the current and corresponding index usefulness is 0)&lt;/li&gt;
&lt;li&gt;The number of unallocatable tables &lt;strong&gt;b&lt;/strong&gt; (with a longer history length than the current and corresponding index usefulness is not 0)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Update&lt;/strong&gt; bankTickCtrs += Δ (saturated counter), Δ = b - a,&lt;/li&gt;
&lt;li&gt;When bankTickCtrs reaches its &lt;strong&gt;maximum&lt;/strong&gt; value, &lt;strong&gt;reset all usefulness to 0&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;kunming-lake-sc-branch-predictor&#34;&gt;Kunming Lake SC Branch Predictor&lt;/h2&gt;
&lt;h3 id=&#34;basic-function-introduction&#34;&gt;Basic Function Introduction&lt;/h3&gt;
&lt;p&gt;The SC (Statistics counter) branch predictor is a branch predictor based on historical statistical information. Similar to TAGE, SC typically has multiple tables Tn, each corresponding to different lengths of historical jump statistics. The difference is that in SC, when predicting based on the PC, each table Tn is accessed, and then SC adds up each hit table entry to calculate the total &amp;ldquo;saturated counter&amp;rdquo; jump information, and finally determines whether to jump based on the total jump information. Generally, SC uses &amp;ldquo;signed saturated counters&amp;rdquo;, where a counter value greater than 0 indicates a jump, and less than 0 indicates no jump. The larger the absolute value of the counter, the higher the prediction confidence.&lt;/p&gt;
&lt;p&gt;In the SC predictor, SC is also composed of multiple tables (e.g., T1, T2, T3, T4), but with fewer basic prediction tables T0 compared to the TAGE predictor. The Tn tables in SC have 6-bit signed saturated counters. The indexing method for SC tables is as follows:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Calculation Method&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Index = (FH) ^ ((pc&amp;raquo;1)低位)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;For each table, the number of entries and the folded history length used are as follows:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Table&lt;/th&gt;
&lt;th&gt;Number of Entries&lt;/th&gt;
&lt;th&gt;FH Length&lt;/th&gt;
&lt;th&gt;Folded History Range&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;不折叠&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;把历史信息的低4位，折叠成FH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T3&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;把历史信息的低10位，折叠成FH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T4&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;把历史信息的低16位，折叠成FH&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The formula for calculating the total statistical prediction result is as follows:&lt;/p&gt;

&lt;div class=&#34;math&#34;&gt;$$scCtrSum=\sum_{i=0}^{i&lt;4}( (ctr_{sc} &lt;&lt; 1) +1)$$&lt;/div&gt;&lt;p&gt;Where ctr_sc represents the signed saturated counter for each table. Left-shifting and adding one is for weight adjustment. The accumulated scCtrSum is the final prediction result of SC. If this value is greater than zero, the prediction is a jump; if it is less than zero, the prediction is no jump. The larger the absolute value, the higher the prediction confidence.&lt;/p&gt;
&lt;p&gt;Typical data conversion results are as follows (extended to 9 bits to prevent overflow during calculation):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;All are 6b100000 (strong no-jump), resulting in 9b100000100, with a value of -252.&lt;/li&gt;
&lt;li&gt;All are 6b011111 (strong jump), resulting in 9b011111100, with a value of 252.&lt;/li&gt;
&lt;li&gt;All are 6b000000 (weak jump), resulting in 9b000000100, with a value of 4.&lt;/li&gt;
&lt;li&gt;All are 6b111111 (weak no-jump), resulting in 9b111111100, with a value of -4.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;prediction-process-1&#34;&gt;Prediction Process&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Calculate the index of table Tn using the PC and historical information.&lt;/li&gt;
&lt;li&gt;Query the index to obtain the saturation counters for all tables.&lt;/li&gt;
&lt;li&gt;Sum up all the saturation counters obtained from all tables to get the final prediction result (take a jump for values greater than 0, no jump for values less than 0).&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;training-process-1&#34;&gt;Training Process&lt;/h3&gt;
&lt;p&gt;Update the saturation counters during the update phase.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If the real instruction corresponding to PC jumps, increment the saturation counters corresponding to all tables.&lt;/li&gt;
&lt;li&gt;If the real instruction corresponding to PC does not jump, decrement the saturation counters corresponding to all tables.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;kunming-lake-tage-sc-branch-predictor&#34;&gt;Kunming Lake TAGE-SC Branch Predictor&lt;/h2&gt;
&lt;h3 id=&#34;why-sc-is-needed-with-tage&#34;&gt;Why SC is Needed with TAGE&lt;/h3&gt;
&lt;p&gt;In some applications, some branch behaviors have a weak correlation with branch history or paths, showing a statistical prediction bias. For these branches, using counters to capture statistical biases is more effective than history-based branch prediction.&lt;/p&gt;
&lt;p&gt;TAGE is very effective in predicting branches that are highly correlated with history, but it performs poorly for branches with statistical biases. For example, branches that have a small bias in one direction but are not strongly correlated with historical paths. To avoid this problem, an SC predictor can be added to the traditional TAGE predictor.&lt;/p&gt;
&lt;h3 id=&#34;tage-sc-functionality&#34;&gt;TAGE-SC Functionality&lt;/h3&gt;
&lt;p&gt;In the Kunming Lake TAGE-SC predictor, both the TAGE and SC prediction results P1 and P2 are obtained simultaneously, and then their results are accumulated P = P1 + P2. If the absolute value of P is greater than the 8-bit threshold sc_bank_thres, the predictor result P is used; otherwise, P1 is used as the final prediction result.&lt;/p&gt;
&lt;p&gt;For dynamic adaptation, the threshold sc_thres needs to be dynamically changed. Therefore, in the implementation, TAGE-SC uses a 5-bit sc_bank_ctr counter to adjust the threshold sc_bank_thres. Additionally, since Kunming Lake supports the simultaneous prediction of 2 branch instructions, the threshold register and corresponding control counter are also duplicated.&lt;/p&gt;
&lt;h3 id=&#34;pipeline-1&#34;&gt;Pipeline&lt;/h3&gt;
&lt;p&gt;The TAGE-SC predictor contains 3 pipeline stages, where the 2-stage pipeline of TAGE has been introduced, and the pipeline of the SC part is as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Stage 0: Read PC and folded history into s0.
&lt;strong&gt;First Stage&lt;/strong&gt;: Calculate the index from pc and FH to obtain s0_idx.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stage 1: Read s0_idx from s0.
&lt;strong&gt;Second Stage&lt;/strong&gt;: Find the counter data corresponding to s1_idx in SCTable and output to s1_scResps.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stage 2: Read s1_scResps from s1.
&lt;strong&gt;Third Stage&lt;/strong&gt;: Select whether to invert the prediction result based on s2_scResps and output to s2_disagree.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stage 3: Read the result from s2_disagree as s3_disagree.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;prediction-process-2&#34;&gt;Prediction Process&lt;/h3&gt;
&lt;p&gt;In TAGE-SC prediction, the prediction result P1 of TAGE is represented by tage_ctr, and the prediction result P2 of SC is represented by scCtrSum. The prediction is divided into four steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Execute the SC predictor to get the prediction result scCtrSum.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Simultaneously obtain the prediction result tage_ctr of the TAGE predictor.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Since the prediction result of TAGE is an unsigned saturation counter, and the prediction result of SC is a signed saturation counter, if they are added together, data conversion is required.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kunming Lake adopts a conversion for the result of TAGE. The converted result is represented by tageCtrCentered, and the specific conversion process is as follows:&lt;/p&gt;

&lt;div class=&#34;math&#34;&gt;$$tageCtrCentered=((((ctr_{tage} -4)&lt;&lt;1)+1)&lt;&lt;3) $$&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Conversion of a 3-bit unsigned saturation counter to an 8-bit signed saturation counter result is illustrated as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;3b100 Weak jump =&amp;gt; 8b00001000 = 8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3b011 Weak non-jump =&amp;gt; 8b11111000 = -8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3b111 Strong jump =&amp;gt; 8b00111000 = 56&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3b000 Strong non-jump =&amp;gt; 8b11001000 = -56&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add the prediction results of TAGE and SC to get the final prediction result P, represented by totalSum.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&#34;math&#34;&gt;$$totalSum = scCtrSum + tageCtrCentered$$&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;Determine the final prediction direction based on &lt;code&gt;totalSum&lt;/code&gt; and &lt;code&gt;sc_bank_thres&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Jump if totalSum &amp;gt; 0 and its absolute value exceeds the threshold: If scCtrSum &amp;gt; sc_bank_thres - tageCtrCentered, it can also be understood as totalSum &amp;gt; sc_bank_thres. The above expression can reduce the maximum bit width (ensuring no overflow requires 10 bits to become 9 bits).&lt;/li&gt;
&lt;li&gt;No jump if totalSum &amp;lt; 0 and its absolute value exceeds the threshold: If scCtrSum &amp;lt; -sc_bank_thres - tageCtrCentered, it can also be understood as |totalSum| &amp;gt; sc_bank_thres.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;training-process-2&#34;&gt;Training Process&lt;/h3&gt;
&lt;p&gt;After combining TAGE and SC, TAGE-SC adds an sc_bank_ctr counter to control the threshold sc_bank_thres. Therefore, during training, in addition to the training of TAGE and SC themselves, the newly added counter needs to be updated.&lt;/p&gt;
&lt;p&gt;During the update phase, the specific update process is as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TAGE-SC uses the prediction result P (i.e., the prediction result after TAGE + SC). If |totalSum| is in the range [sc_bank_thres -4, sc_bank_thres -2], update the threshold-related register group.
&lt;ol&gt;
&lt;li&gt;Update sc_bank_ctr, the saturation counter: If the prediction is correct, sc_bank_ctr +=1; if the prediction is incorrect, sc_bank_ctr -=1.&lt;/li&gt;
&lt;li&gt;Update sc_bank_thres, limited saturation operation: If the updated value of sc_bank_ctr reaches 0b11111 and sc_bank_thres &amp;lt;= 31, then sc_bank_thres +=2; if the updated value of sc_bank_ctr is 0 and sc_bank_thres &amp;gt;=6, then sc_bank_thres -=2. For all other cases, thres remains unchanged.&lt;/li&gt;
&lt;li&gt;After the update judgment of sc_bank_thres is completed, another judgment is made on sc_bank_ctr. If the updated sc_bank_ctr is 0b11111 or 0, thres_ctr is reset to the initial value 0b10000.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;TAGE-SC uses the prediction result P1 (i.e., the prediction result of TAGE) and does not perform any operations.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;interface-list&#34;&gt;Interface List&lt;/h2&gt;
&lt;h3 id=&#34;tagesc&#34;&gt;TageSC&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;信号类型&lt;/th&gt;
&lt;th&gt;信号宽度&lt;/th&gt;
&lt;th&gt;信号名&lt;/th&gt;
&lt;th&gt;信号描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;clock&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;reset&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[35:0]&lt;/td&gt;
&lt;td&gt;io_reset_vector&lt;/td&gt;
&lt;td&gt;用于reset时，reset s1_pc_dup_0 提供的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_0&lt;/td&gt;
&lt;td&gt;复制的s0_pc的dup数组的第1个，给顶层BPU的PC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_1&lt;/td&gt;
&lt;td&gt;复制的s0_pc第2个，给Tage的PC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_3&lt;/td&gt;
&lt;td&gt;复制的s0_pc的第4个，给SC的PC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[10:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_17_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 2 用到的11bits 折叠历史 从多长历史范围折叠到11bit见前文所述的表 注意TageTable下标+1，此处 T2 是前文 T3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[10:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_16_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 3 用到的11bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_15_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 1 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_14_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 0 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_9_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 2 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_8_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 3 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_7_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 0 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_5_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 3 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_4_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 1 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_3_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 2 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[10:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_1_hist_1_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 1 用到的11bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[3:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_3_hist_12_folded_hist&lt;/td&gt;
&lt;td&gt;SCTable 1 用到的 4bit 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_3_hist_11_folded_hist&lt;/td&gt;
&lt;td&gt;SCTable 2 用到的 8bit 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_folded_hist_3_hist_2_folded_hist&lt;/td&gt;
&lt;td&gt;SCTable 3 用到的 8bit 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_{i}&lt;em&gt;br_taken_mask&lt;/em&gt;{j} Tage 在 s2流水级输出的，复制4份 预测块中第 j 条分支指令TAGE预测结果  这里不该叫mask吧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_0_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_1_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_2_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s2_full_pred_3_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_0_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_{i}&lt;em&gt;br_taken_mask&lt;/em&gt;{j} Tage 在 s3流水级输出的，复制4份 预测块中第 j 条分支指令SC预测结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_0_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_1_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_1_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_2_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_out_s3_full_pred_3_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*[222:0]&lt;/td&gt;
&lt;td&gt;io_out_last_stage_meta&lt;/td&gt;
&lt;td&gt;见附表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_ctrl_tage_enable&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_ctrl_sc_enable&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s0_fire_0&lt;/td&gt;
&lt;td&gt;s0 阶段流水线控制 相同信号复制多份，0给BPU，1给Tage，3给SC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s0_fire_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s0_fire_3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s1_fire_0&lt;/td&gt;
&lt;td&gt;s1 阶段流水线控制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s1_fire_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s1_fire_2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s1_fire_3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s2_fire_0&lt;/td&gt;
&lt;td&gt;s2 阶段流水线控制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s2_fire_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s2_fire_2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s2_fire_3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_s1_ready&lt;/td&gt;
&lt;td&gt;tage的所有表，可以执行读取结果的操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_valid&lt;/td&gt;
&lt;td&gt;从FTQ发向BPU的后端执行结果（更新信号）是否有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[40:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_pc&lt;/td&gt;
&lt;td&gt;（后端执行过的）预测块的PC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[10:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_17_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 2 用到的11bits 折叠历史 预测时使用的分支历史结果，没有更新，转了一圈回来了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[10:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_16_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 3 用到的11bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_15_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 1 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_14_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 0 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[3:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_12_folded_hist&lt;/td&gt;
&lt;td&gt;SCTable 1 用到的 4bit 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_11_folded_hist&lt;/td&gt;
&lt;td&gt;SCTable 2 用到的 8bit 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_9_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 2 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_8_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 3 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_7_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 0 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[6:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_5_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 3 用到的7bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_4_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 1 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_3_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 2 用到的8bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[7:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_2_folded_hist&lt;/td&gt;
&lt;td&gt;SCTable 3 用到的 8bit 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[10:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_spec_info_folded_hist_hist_1_folded_hist&lt;/td&gt;
&lt;td&gt;TageTable 1 用到的11bits 折叠历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_brSlots_0_valid&lt;/td&gt;
&lt;td&gt;FTB 表项的第一个slot是否有效（存储了跳转指令）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_sharing&lt;/td&gt;
&lt;td&gt;FTB 表项的最后一个slot是否存储了条件分支而非无条件跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_valid&lt;/td&gt;
&lt;td&gt;FTB 表项的最后一个slot是否有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_always_taken_0&lt;/td&gt;
&lt;td&gt;历史上slot 0 指令总是跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_always_taken_1&lt;/td&gt;
&lt;td&gt;历史上slot 1 指令总是跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;solt 0 是否 taken&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;solt 1 是否 taken&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_mispred_mask_0&lt;/td&gt;
&lt;td&gt;solt 0 是否预测正确&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;io_update_bits_mispred_mask_1&lt;/td&gt;
&lt;td&gt;solt 1 是否预测正确&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;*[222:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_meta&lt;/td&gt;
&lt;td&gt;见附表&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;io_out_last_stage_meta&#34;&gt;io_out_last_stage_meta&lt;/h3&gt;
&lt;p&gt;需要设计参与优化！&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;信号类型&lt;/th&gt;
&lt;th&gt;信号位&lt;/th&gt;
&lt;th&gt;信号名&lt;/th&gt;
&lt;th&gt;信号描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[218:88]&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;占位，全为0，传递到composer时会忽略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;87&lt;/td&gt;
&lt;td&gt;resp_meta_providers_1_valid_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[86:85]&lt;/td&gt;
&lt;td&gt;resp_meta_providers_1_bits_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;84&lt;/td&gt;
&lt;td&gt;resp_meta_providers_0_valid_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[83:82]&lt;/td&gt;
&lt;td&gt;resp_meta_providers_0_bits_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[81:79]&lt;/td&gt;
&lt;td&gt;resp_meta_providerResps_1_r_ctr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;78&lt;/td&gt;
&lt;td&gt;resp_meta_providerResps_1_r_u&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;77&lt;/td&gt;
&lt;td&gt;resp_meta_providerResps_1_r_unconf&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[76:74]&lt;/td&gt;
&lt;td&gt;resp_meta_providerResps_0_r_ctr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;73&lt;/td&gt;
&lt;td&gt;resp_meta_providerResps_0_r_u&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;72&lt;/td&gt;
&lt;td&gt;resp_meta_providerResps_0_r_unconf&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;71&lt;/td&gt;
&lt;td&gt;resp_meta_altUsed_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;70&lt;/td&gt;
&lt;td&gt;resp_meta_altUsed_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;69&lt;/td&gt;
&lt;td&gt;resp_meta_altDiffers_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;68&lt;/td&gt;
&lt;td&gt;resp_meta_altDiffers_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[67:66]&lt;/td&gt;
&lt;td&gt;resp_meta_basecnts_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[65:64]&lt;/td&gt;
&lt;td&gt;resp_meta_basecnts_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[63:60]&lt;/td&gt;
&lt;td&gt;resp_meta_allocates_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[59:56]&lt;/td&gt;
&lt;td&gt;resp_meta_allocates_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;55&lt;/td&gt;
&lt;td&gt;resp_meta_takens_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;54&lt;/td&gt;
&lt;td&gt;resp_meta_takens_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;53&lt;/td&gt;
&lt;td&gt;resp_meta_scMeta_tageTakens_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;52&lt;/td&gt;
&lt;td&gt;resp_meta_scMeta_tageTakens_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;51&lt;/td&gt;
&lt;td&gt;resp_meta_scMeta_scUsed_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;resp_meta_scMeta_scUsed_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;49&lt;/td&gt;
&lt;td&gt;resp_meta_scMeta_scPreds_1_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;48&lt;/td&gt;
&lt;td&gt;resp_meta_scMeta_scPreds_0_r&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[47:42]&lt;/td&gt;
&lt;td&gt;r_1_3&lt;/td&gt;
&lt;td&gt;scMeta(预测时的状态)中第2路的第4个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[41:36]&lt;/td&gt;
&lt;td&gt;r_1_2&lt;/td&gt;
&lt;td&gt;scMeta中第2路的第3个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[35:30]&lt;/td&gt;
&lt;td&gt;r_1_1&lt;/td&gt;
&lt;td&gt;scMeta中第2路的第2个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[29:24]&lt;/td&gt;
&lt;td&gt;r_1_0&lt;/td&gt;
&lt;td&gt;scMeta中第2路的第1个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[23:18]&lt;/td&gt;
&lt;td&gt;r_3&lt;/td&gt;
&lt;td&gt;scMeta中第1路的第4个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[17:12]&lt;/td&gt;
&lt;td&gt;r_2&lt;/td&gt;
&lt;td&gt;scMeta中第1路的第3个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[11:6]&lt;/td&gt;
&lt;td&gt;r_1&lt;/td&gt;
&lt;td&gt;scMeta中第1路的第2个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[5:0]&lt;/td&gt;
&lt;td&gt;r_0&lt;/td&gt;
&lt;td&gt;scMeta中第1路的第1个sc_ctr的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;io_update_bits_meta&#34;&gt;io_update_bits_meta&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;信号类型&lt;/th&gt;
&lt;th&gt;信号位&lt;/th&gt;
&lt;th&gt;信号名&lt;/th&gt;
&lt;th&gt;信号描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[218:94]&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;FTB, ITAGE, RAS 模块传给 FTQ 的 META 信息，忽略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[93:6]&lt;/td&gt;
&lt;td&gt;io_out_last_stage_meta[87:0] 偏移 6bit 后的结果&lt;/td&gt;
&lt;td&gt;TAGE 输出给 FTQ 的 META&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;[5:0]&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;uFTB 输出给 FTQ 的 META&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
    
  </channel>
</rss>
