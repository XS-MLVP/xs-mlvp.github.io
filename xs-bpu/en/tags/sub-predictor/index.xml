<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sub-Predictor on OpenVerify Courses</title>
    <link>https://open-verify.cc/xs-bpu/en/tags/sub-predictor/</link>
    <description>Recent content in Sub-Predictor on OpenVerify Courses</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://open-verify.cc/xs-bpu/en/tags/sub-predictor/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>uFTB Branch Predictor</title>
      <link>https://open-verify.cc/xs-bpu/en/docs/modules/01_uftb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/en/docs/modules/01_uftb/</guid>
      <description>Introduction to uFTB uFTB is the first predictor among all the predictors in Xiangshan, and it serves as the cornerstone for other predictors to generate prediction results. uFTB works in the s1 stage. It can generate prediction results within the current cycle after obtaining s1_pc and output them in the s1 channel, without modifying other channels. It provides the position of the branch instruction and the target of the instruction. Subsequent predictors will further predict based on this result.</description>
    </item>
    <item>
      <title>Base Predictor Class and Sub Predictor Interface</title>
      <link>https://open-verify.cc/xs-bpu/en/docs/ports/03_subpredictor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/en/docs/ports/03_subpredictor/</guid>
      <description>In the Xiangshan branch prediction unit, all its sub-predictors and the class implementations of Composer are inherited from the sub-predictor base class (BasePredictor). The sub-predictor interface (BasePredictorIO) is also defined in the sub-predictor base class. Therefore, we can consider that Composer and all sub-predictors have the same interface.&#xA;In the understanding and verification of sub-prediction, our most direct external interaction occurs in the sub-predictor interface and some variables defined in the sub-predictor base class.</description>
    </item>
    <item>
      <title>FTB Branch Predictor</title>
      <link>https://open-verify.cc/xs-bpu/en/docs/modules/03_ftb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/en/docs/modules/03_ftb/</guid>
      <description>Introduction to FTB FTB is the third sub-predictor of the Xiangshan BPU, and it can also get the outputs of uFTB and TAGE-SC together. In the input interface of FTB, the s1 channel contains the basic prediction results of uFTB, and the s2 and s3 channels are filled with only one group of signals, br_taken_mask, by TAGE-SC, without the basic prediction results generated by the FTB entry. The function of FTB is to provide basic prediction results for the s2 and s3 channels.</description>
    </item>
    <item>
      <title>RAS Branch Predictor</title>
      <link>https://open-verify.cc/xs-bpu/en/docs/modules/05_ras/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/en/docs/modules/05_ras/</guid>
      <description>RAS介绍 RAS stands for &amp;ldquo;Return Address Stack.&amp;rdquo; It helps determine branch behavior in programs by tracking return addresses. As previously mentioned, there are many branches in a program: if/else, switch/case, while/for loop, iteration, call/return, etc. The RAS branch predictor specifically targets call/return types.&#xA;function _add(a, b){ return (a &amp;gt; 0 ? a : 0) + (b &amp;gt; 0? b : 0); } function add(a, b){ return a + b; } function sub(a, b){ return a - b; } function main(){ a = 1; b = 2; c = add(a, b); d = sub(a, b); } As shown above, the main function calls add and sub, and add calls the function _add.</description>
    </item>
  </channel>
</rss>
