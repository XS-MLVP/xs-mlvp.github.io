<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>项目文档 on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</title>
    <link>https://open-verify.cc/xs-bpu/</link>
    <description>Recent content in 项目文档 on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/xs-bpu/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>BPU Top 功能列表</title>
      <link>https://open-verify.cc/xs-bpu/docs/feature/00_bpufeature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/feature/00_bpufeature/</guid>
      <description>&lt;h2 id=&#34;功能列表feature-list&#34;&gt;功能列表（Feature List）&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;支持 uFTB 子预测器&lt;/li&gt;&#xA;&lt;li&gt;支持 TAGE-SC 子预测器&lt;/li&gt;&#xA;&lt;li&gt;支持 FTB 子预测器&lt;/li&gt;&#xA;&lt;li&gt;支持 ITTAGE 子预测器&lt;/li&gt;&#xA;&lt;li&gt;支持 RAS 子预测器&lt;/li&gt;&#xA;&lt;li&gt;支持三阶段预测结果及其他信息输出&lt;/li&gt;&#xA;&lt;li&gt;支持预测结果重定向信号生成&lt;/li&gt;&#xA;&lt;li&gt;支持流水线控制信号生成&lt;/li&gt;&#xA;&lt;li&gt;支持 PC 生成&lt;/li&gt;&#xA;&lt;li&gt;支持全局分支历史维护&lt;/li&gt;&#xA;&lt;li&gt;支持分支折叠历史维护&lt;/li&gt;&#xA;&lt;li&gt;支持重定向请求响应，恢复状态&lt;/li&gt;&#xA;&lt;li&gt;支持更新请求响应&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>BPU 顶层模块</title>
      <link>https://open-verify.cc/xs-bpu/docs/modules/00_bpu_top/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/modules/00_bpu_top/</guid>
      <description>&lt;p&gt;BPU 顶层整体的功能和结构已经在之前的文档中粗略的描述，对于验证 BPU 顶层的同学来说，可能还需要更加细致的描述。由于 BPU 顶层功能较多，本节将 BPU 划分为了几大功能点进行更进一步的描述。但由于 BPU 顶层细节过多，更进一步的细节需参照代码进行理解。&lt;/p&gt;&#xA;&lt;h2 id=&#34;生成器维护方法&#34;&gt;生成器维护方法&lt;/h2&gt;&#xA;&lt;p&gt;通过香山的基础设计文档，我们知道，BPU 顶层是通过一个个生成器来维护 s0 周期的各类变量的，例如 PC、分支历史等，并且其核心概念是，通过预测结果重定向信号决定采用哪个流水级的结果。&lt;/p&gt;&#xA;&lt;p&gt;BPU 顶层中所有的生成器共有 6 个：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;npcGen&lt;/strong&gt; 维护 pc&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ghistPtrGen&lt;/strong&gt; 维护全局历史指针&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ghvBitWriteGens&lt;/strong&gt; 维护全局历史写入数据&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;foledGhGen&lt;/strong&gt; 维护折叠历史&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;lastBrNumOHGen&lt;/strong&gt; 维护上周期最后一个生效的分支指令位置&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;aheadFhObGen&lt;/strong&gt; 维护分支历史最老位&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;其中，除了 &lt;code&gt;npcGen&lt;/code&gt; 以外，其余生成器都会在本文档中进行介绍。本节中我们着重探讨一下生成器的产生下一次预测的方法。&lt;/p&gt;&#xA;&lt;p&gt;在代码中你可以看到生成器用类似下面这种方式进行定义：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;PhyPriorityMuxGenerator&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，代码通过多条语句对生成器的数据来源进行注册：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;B&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;reg&lt;/span&gt;&lt;span style=&#34;color:#a40000&#34;&gt;，&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;s1_valid&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s1_target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;s2_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;s3_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3_target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;do_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;valid&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;do_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;bits&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cfiUpdate&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每一行被称作一次注册，在一次注册中第一个信号参数是数据有效信号，第二个信号参数包含具体的数据。 生成器的优先级也是按照注册的顺序来决定，越往后优先级越高，因此，同一时刻的优先级从低到高依次为：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;s0 阻塞的数据&lt;/li&gt;&#xA;&lt;li&gt;根据 s1 预测结果更新后的数据&lt;/li&gt;&#xA;&lt;li&gt;根据 s2 预测结果更新后的数据&lt;/li&gt;&#xA;&lt;li&gt;根据 s3 预测结果更新后的数据&lt;/li&gt;&#xA;&lt;li&gt;BPU 外部重定向中的数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这样一来，我们就可以在预测结果重定向有效时，避免采用较早流水级的预测结果，而采用纠正后的预测结果。也使得我们可以将外部重定向请求作为最高优先级去处理。&lt;/p&gt;&#xA;&lt;p&gt;我们可以得出所有生成器产生 s0 信号的方法：&lt;strong&gt;在所有数据有效信号中，如果只有一个有效的，则选取它对应的数据，如果有多个数据有效信号生效，则选取优先级最高的数据。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;全局分支历史&#34;&gt;全局分支历史&lt;/h2&gt;&#xA;&lt;p&gt;我们知道，全局分支历史在 BPU 顶层进行维护，维护的策略与 PC 的维护策略一致。即在每个阶段流水级预测结果产生之后，会根据相应信号对全局分支历史进行更新。&lt;/p&gt;&#xA;&lt;p&gt;顶层为了维护全局分支历史定义了两组信号&lt;/p&gt;</description>
    </item>
    <item>
      <title>FTB项与完整预测结果接口</title>
      <link>https://open-verify.cc/xs-bpu/docs/ports/00_ftb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/ports/00_ftb/</guid>
      <description>&lt;h2 id=&#34;ftb-项&#34;&gt;FTB 项&lt;/h2&gt;&#xA;&lt;p&gt;FTB 项是香山中分支预测块的核心数据结构，它存储了生成一个分支预测块所需的信息。在BPU进行预测时，初始的分支预测块首先由一个读出的 FTB 项生成。然后，这个分支预测块会传递到后续的预测器中，后续的预测器会读取其中的信息并加以修改，生成最终的预测结果。&lt;/p&gt;&#xA;&lt;p&gt;因此，要理解分支预测块的结构，首先需要理解FTB项的结构。一个FTB项对应着一个分支预测块，其大致结构如下：&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;1.png&#34; width=&#34;750px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;首先，需要明确一个信息：无论是分支预测块还是FTB项，它们可以容纳的指令数量都被设定为一个特定的上限（在香山当前版本中为16条RVC指令），被称为&lt;strong&gt;最大预测长度&lt;/strong&gt;。这意味着，如果我们需要记录分支预测块内某一条指令的位置，可以使用一个固定长度的位向量，来指定这条指令相对于预测块起始地址的偏移量。&lt;/p&gt;&#xA;&lt;p&gt;分支预测块执行流程的决定因素是其中的分支指令信息。其余的指令都被视为普通指令，不影响程序的执行流。因此，在一个分支预测块中，我们只需记录下其中的分支指令位置即可，而普通指令的位置我们并不关心。&lt;/p&gt;&#xA;&lt;p&gt;因此，FTB项中定义了两种类型的&lt;strong&gt;分支指令槽（slot）&lt;/strong&gt;——&lt;code&gt;brSlots&lt;/code&gt;和&lt;code&gt;tailSlot&lt;/code&gt;，用于存储分支预测块中的分支指令。目前香山版本中，&lt;code&gt;brSlots&lt;/code&gt;只含有一个 slot，而 &lt;code&gt;tailSlot&lt;/code&gt; 则是一个单独的 slot，总计含有两个 slot。&lt;/p&gt;&#xA;&lt;p&gt;在最大预测长度内的指令中，如果出现了分支指令，FTB项会将其记录在对应的slot内，并将该slot置为有效。如果分支指令出现过多，达到了FTB项的容纳上限，那么超出上限的分支指令则会交给下一个FTB项来存储。在每个 slot中，我们会记录一条分支指令相对于预测块起始地址的偏移量（offset），同时还会记录其跳转目标地址等信息。&lt;/p&gt;&#xA;&lt;h3 id=&#34;唯一的-tailslot&#34;&gt;唯一的 tailSlot&lt;/h3&gt;&#xA;&lt;p&gt;在RISC-V中，分支指令主要分为两种类型：条件分支和无条件跳转。因此，&lt;strong&gt;对于一个分支预测块来说，最多只会包含一条无条件跳转指令&lt;/strong&gt;。因为一旦执行到这条指令，程序的执行流就会发生改变，后续的指令将不再执行。因此，我们定义了一种类型的 slot 叫做 &lt;code&gt;tailSlot&lt;/code&gt;，专门用来存储这条无条件跳转指令。而对于条件分支指令，则将它们存储在&lt;code&gt;brSlots&lt;/code&gt;中。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;tailSlot&lt;/code&gt;如其名，位于整个预测块中的最后一个 slot。这也是因为一旦填充了无条件跳转指令，程序必定跳转，之后的指令就由其他预测块进行处理，因此后续的指令情况我们无需关心。但在无条件跳转指令之前的指令中，我们需要关心是否存在条件分支指令，因为条件分支指令既有可能跳转，也有可能不跳转。因此，我们需要记录下条件分支指令的相关信息。&lt;/p&gt;&#xA;&lt;h3 id=&#34;tailslot-共享&#34;&gt;tailSlot 共享&lt;/h3&gt;&#xA;&lt;p&gt;考虑一种情况：如果从预测块起始PC开始直到最大预测长度，都没有出现无条件跳转指令，反而出现了两条条件分支指令，这样一来，&lt;code&gt;tailSlot&lt;/code&gt; 就会空闲，而第二条条件分支指令又无法存储，造成空间的浪费。&lt;/p&gt;&#xA;&lt;p&gt;为了解决这个问题，香山采用了一种方法：设置一个 &lt;code&gt;sharing&lt;/code&gt; 标记。我们可以直接将第二条分支指令存储到&lt;code&gt;tailSlot&lt;/code&gt; 中，并将sharing标记设置为真，表示第二条条件分支指令共享了无条件跳转指令的 &lt;code&gt;tailSlot&lt;/code&gt;。这样，就有效利用了tailSlot的空间。&lt;/p&gt;&#xA;&lt;p&gt;预测块中的 &lt;code&gt;isCall&lt;/code&gt;、&lt;code&gt;isRet&lt;/code&gt;和&lt;code&gt;isJalr&lt;/code&gt;字段是为&lt;code&gt;tailSlot&lt;/code&gt;服务的。如果tailSlot中记录的是无条件跳转指令，这几个字段会进一步指示该跳转指令的类型。在FTB项中还有一个字段 &lt;code&gt;always_taken&lt;/code&gt;，用来记录每个Slot中存储的条件分支指令是否总是被预测为跳转。如果是的话，后续的预测器可以直接采用这一预测结果。&lt;/p&gt;&#xA;&lt;p&gt;通过FTB项，我们可以得知一个分支预测块中的指令情况，包括分支指令的位置、类型等。这些信息会交给后续的预测器，由后续的预测器来预测更为精确的跳转目标、是否跳转等信息。&lt;/p&gt;&#xA;&lt;h2 id=&#34;ftb-项完整结构-ftbentry&#34;&gt;FTB 项完整结构 （FTBEntry）&lt;/h2&gt;&#xA;&lt;p&gt;接口定义: &lt;code&gt;src/main/scala/xiangshan/frontend/FTB.scala&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;本节中描述了 FTB 项的完整结构定义，其所含的信号如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;valid&lt;/strong&gt;: FTB表项是否有效。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;brSlots&lt;/strong&gt;: 条件分支指令槽。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Vec(numBrSlot, new FtbSlot(BR_OFFSET_LEN))&lt;/code&gt; （接口列表详见FtbSlot）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;tailSlot&lt;/strong&gt;: 无条件跳转指令槽。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;new FtbSlot(JMP_OFFSET_LEN, Some(BR_OFFSET_LEN))&lt;/code&gt; （接口列表详见FtbSlot）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;pftAddr&lt;/strong&gt;: 预测块的结束地址。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt(log2Up(PredictWidth).W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;carry&lt;/strong&gt;: 预测块的结束地址进位。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;isCall&lt;/strong&gt;: 无条件跳转指令槽中的指令为 call 指令。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;isRet&lt;/strong&gt;: 无条件跳转指令槽中的指令为 ret 指令。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;isJalr&lt;/strong&gt;: 无条件跳转指令槽中的指令为 jalr 指令。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;last_may_be_rvi_call&lt;/strong&gt;:  无条件跳转指令槽中的指令可能为一个 RVI 类型的 call 指令信号。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;always_taken&lt;/strong&gt;: 该预测块中的每个分支指令是否总是被预测为 Taken。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Vec(numBr, Bool())&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;说明：pftAddr 和 carry&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>何为分支预测</title>
      <link>https://open-verify.cc/xs-bpu/docs/basic/00_bp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/basic/00_bp/</guid>
      <description>&lt;h2 id=&#34;为何需要分支预测&#34;&gt;为何需要分支预测？&lt;/h2&gt;&#xA;&lt;p&gt;分支预测主要有两方面的原因：一是&lt;strong&gt;程序的执行流中含有分支指令&lt;/strong&gt;，二是&lt;strong&gt;高性能处理器使用流水线设计&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;程序的执行流中含有分支指令&#34;&gt;程序的执行流中含有分支指令&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;20&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述是一段C语言代码，这段代码首先定义了三个变量 x, y 和 result，然后根据 x 和 y 值的大小情况对result进行赋值。可以发现，程序在前三行对变量进行赋值时是顺序往下执行的，而在第 5 行时，由于 if 指令的出现，程序产生了分支，从第 5 行直接跳转到了第 8 行继续运行，这就造成了程序执行的&lt;strong&gt;分支&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;翻译成 RISC-V 汇编之后的代码如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;li&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;a0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;10&lt;/span&gt;               &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# x = 10&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;li&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;a1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;20&lt;/span&gt;               &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# y = 20&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;li&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;a2&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;                &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# result = 0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;blt&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;else_branch&lt;/span&gt;  &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 如果 x &amp;lt; y，则跳转到 else_branch&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;add&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a2&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a1&lt;/span&gt;           &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 否则执行 result = x + y&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;end&lt;/span&gt;                    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 跳转到 end&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f57900&#34;&gt;else_branch:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a2&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a1&lt;/span&gt;           &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# result = x - y&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f57900&#34;&gt;end:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以发现程序依然保持着先前的分支行为，在代码的前三行，指令顺序执行，之后，在程序的第 5 行，出现了一条特殊指令blt ，我们称之为分支指令，它会根据 x 和 y 的大小关系决定指令流顺序往下执行还是跳转到其他地方，该指令的出现导致程序的执行出现了分支。&lt;/p&gt;</description>
    </item>
    <item>
      <title>uFTB 分支预测器</title>
      <link>https://open-verify.cc/xs-bpu/docs/modules/01_uftb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/modules/01_uftb/</guid>
      <description>&lt;h2 id=&#34;uftb-简介&#34;&gt;uFTB 简介&lt;/h2&gt;&#xA;&lt;p&gt;uFTB 是香山所有预测器中第一个预测器，也是其他预测器产生预测结果的基石。uFTB 工作在 s1 阶段，它获取到 s1_pc 后能在本周期内产生预测结果，并在 s1 通道输出，其他通道不予更改。分支指令的位置、指令的跳转目标都是由它来提供，后续预测器也将会根据这一预测结果进行进一步的预测。&lt;/p&gt;&#xA;&lt;p&gt;而其本质则是一个 FTB 项缓存，其中存储了 FTB 项，基础的预测结果将直接由读出的 FTB 项生成。&lt;/p&gt;&#xA;&lt;p&gt;因此，在你开始文档的阅读之前，请确保你理解了 FTB 项和含义以及预测结果接口的具体细节。&lt;/p&gt;&#xA;&lt;h2 id=&#34;uftb-功能简介&#34;&gt;uFTB 功能简介&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;缓存FTB项，生成一周期预测结果&lt;/strong&gt;    uFTB 中维护了一个小型的 FTB 项缓存，拿到 PC 之后，会在一周期之内读出 PC 所对应的 FTB 项，并从 FTB 项生成 s1 阶段预测结果。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;维护两比特饱和计数器，提供基础条件分支结果&lt;/strong&gt;   uFTB 中为 FTB项缓存的每一行都维护了对应的两比特饱和计数器，其方向预测结果会反映在 uFTB 的预测结果输出中。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;根据更新请求更新 FTB 缓存和两比特饱和计数器&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;uftb-缓存结构&#34;&gt;uFTB 缓存结构&lt;/h2&gt;&#xA;&lt;p&gt;如上所述，uFTB 本质上是一个存储了 FTB 项的小型缓存，其大致结构如下图所示。&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;1.png&#34; width=&#34;400px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;在当前版本的香山中，uFTB 共有 32 个缓存行，每个缓存行被称作 &lt;code&gt;FauFTBWay&lt;/code&gt;，一个缓存行中可以存储一个 FTB 项。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;当 s1 流水有效时&lt;/strong&gt;，uFTB 会使用 &lt;strong&gt;s1_pc&lt;/strong&gt; 来决定读出 uFTB 缓存的哪一项。缓存是根据 PC 中的 tag 字段来索引，tag 字段被定义为 pc[16: 1]，即在 PC 中截取了 16 比特作为标识来匹配缓存中的某一行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>uFTB 功能列表</title>
      <link>https://open-verify.cc/xs-bpu/docs/feature/01_uftbfeature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/feature/01_uftbfeature/</guid>
      <description>&lt;h2 id=&#34;功能列表feature-list&#34;&gt;功能列表（Feature List）&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;支持基于 FTB 项的预测&lt;/li&gt;&#xA;&lt;li&gt;支持两比特饱和计数器&lt;/li&gt;&#xA;&lt;li&gt;支持 s1 通道基础预测结果输出及 meta 信息输出&lt;/li&gt;&#xA;&lt;li&gt;支持更新请求响应，更新内部 FTB 及两比特饱和计数器。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>香山分支预测单元基础</title>
      <link>https://open-verify.cc/xs-bpu/docs/basic/01_xsbpu_basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/basic/01_xsbpu_basic/</guid>
      <description>&lt;h2 id=&#34;分支预测块思想&#34;&gt;分支预测块思想&lt;/h2&gt;&#xA;&lt;p&gt;对于一般的分支预测器来说，通常会根据给定的 PC  预测出该 PC 所对应的指令的相关信息，如是否是条件分支指令、是否是跳转指令。对于条件分支指令，会预测出是否会跳转，而对于跳转指令，则会预测出跳转目标。然而，这种一条一条地预测指令的方法效率较低，导致前端指令供给过慢。&lt;/p&gt;&#xA;&lt;p&gt;相比之下，香山采用的预测方法是每次预测一个指令块。也就是说，&lt;strong&gt;给定一个 PC，香山会预测出以这个PC开始的一个分支预测块，包括了接下来若干条指令的情况，如是否存在分支指令、分支指令的位置、是否跳转以及跳转目标等信息&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;这样的预测方法可以一次性地预测出多条指令，并将预测结果送往取指单元（IFU），指导IFU进行取指。此外，由于IFU需要考虑缓存行的性能问题，它可以根据预测块一次性地取出多条指令，从而提高吞吐效率。&lt;/p&gt;&#xA;&lt;p&gt;在预测块产生后，&lt;strong&gt;分支预测块还会生成执行完本预测块后跳转到的 PC，接着 BPU 会根据该 PC 继续产生下一个分支预测块&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;举个简单的例子&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;1.png&#34; width=&#34;700px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;如上图所示，当 PC 执行到 0x20000118 时，BPU会经历如下几个步骤：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;BPU得知PC 0x20000118&lt;/li&gt;&#xA;&lt;li&gt;BPU产生以 0x20000118 为开始的分支预测块，内容大致如下&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在接下来的若干条指令中&lt;/li&gt;&#xA;&lt;li&gt;第三条是一个条件分支指令&lt;/li&gt;&#xA;&lt;li&gt;对于这个条件分支指令，预测他将会跳转&lt;/li&gt;&#xA;&lt;li&gt;跳转后的地址为 0x20000110&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;BPU将PC设置为 0x20000110，并继续产生下一个分支预测块&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这便是采用了分支预测块的香山 BPU 的基本预测流程&lt;/p&gt;&#xA;&lt;h2 id=&#34;多预测器多流水线结构&#34;&gt;多预测器、多流水线结构&lt;/h2&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;2.png&#34; width=&#34;500px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;上图展示了香山BPU的总体架构，其中我们需要关注两个主要方面：&lt;/p&gt;&#xA;&lt;h3 id=&#34;多预测器&#34;&gt;多预测器&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;为了确保预测的准确性，香山 BPU 采用了多个预测器，并且这些预测器共同产生 BPU 的预测结果。例如，FTB 会生成基础的预测结果供后续预测器使用，而 TAGE 则对条件分支指令产生更精准的预测结果等。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;多流水线&#34;&gt;多流水线&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;为了满足高性能的需求，香山 BPU 采用了流水线设计。各个预测器处于不同的流水线级别。其中，uFTB（即图中的uBTB）预测器位于第一流水线级别，能够在一个周期内产生预测结果。而其余预测器则需要2-3个周期才能生成预测结果，尽管预测时间较长，但预测结果相对更精确。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;但是，如果在第三个周期才能获取到预测结果，并基于新的结果重新开始预测，这样的设计难免导致性能损失。因为这样一来，需要耗费三个时钟周期才可以完成一次预测。&lt;/p&gt;&#xA;&lt;p&gt;为了在第一和第二周期就能够获取到某些预测器的预测结果，我们设置了三个预测结果通道，并将三个流水线级别的预测结果同时输出，如下图所示。&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;3.png&#34; width=&#34;600px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;h2 id=&#34;取指目标队列ftq&#34;&gt;取指目标队列（FTQ）&lt;/h2&gt;&#xA;&lt;h3 id=&#34;分支预测结果暂存&#34;&gt;分支预测结果暂存&lt;/h3&gt;&#xA;&lt;p&gt;尽管 BPU 可以以分支预测块的形式提供预测结果，IFU 也可以一次性取指多条指令，但它们之间仍然存在性能上的差距。通常情况下，BPU产生预测结果的速度更快。&lt;/p&gt;&#xA;&lt;p&gt;因此，在 BPU 与 IFU 之间添加了一个取指目标队列（FTQ）作为缓冲。FTQ 本质上是一个队列，用于存储一个个数据项。BPU产生的预测结果会先暂存到FTQ中，然后由 IFU 从 FTQ 中获取预测结果，如下图所示。&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;4.png&#34; width=&#34;400px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;每当 BPU 产生一个预测块，该预测块会被放入 FTQ 的队首。当 IFU 处于空闲状态时，它会从 FTQ 队尾获取下一个预测块。下方的示意图展示了这一过程。&lt;/p&gt;</description>
    </item>
    <item>
      <title>重定向与更新接口</title>
      <link>https://open-verify.cc/xs-bpu/docs/ports/01_redirect_and_update/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/ports/01_redirect_and_update/</guid>
      <description>&lt;h2 id=&#34;分支预测重定向branchpredictionredirect&#34;&gt;&lt;strong&gt;分支预测重定向（BranchPredictionRedirect）&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;接口定义：&lt;/strong&gt;&lt;code&gt;src/main/scala/xiangshan/frontend/FrontendBundle.scala&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;接口类型：&lt;/strong&gt;&lt;code&gt;BranchPredictionRedirect&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;该接口定义了分支预测单元的重定向请求，主要用于重定向分支预测器的状态。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;BranchPredictionRedirct&lt;/code&gt; 接口继承自 &lt;code&gt;Redirct&lt;/code&gt; 接口，所含信号较多，BPU 重定向只会用到其中一部分接口，文档描述的结构中只包含 BPU 用到的接口内容。&lt;/p&gt;&#xA;&lt;p&gt;重定向请求有两种来源，与 IFU 预译码信息对比生成的重定向请求，后端执行过程中的重定向请求。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;在重定向请求中，关键信息是&lt;/strong&gt;&lt;code&gt;cfiUpdate&lt;/code&gt;，&lt;strong&gt;即控制流指令信息。这一信息对应着一条指令，也就是BPU发生预测错误的指令&lt;/strong&gt;。举例来说，如果 BPU 在预测块中指示第三条指令为普通指令不发生跳转，但预译码显示第三条指令是一条无条件跳转指令，必定会跳转。在这种情况下，BPU 发生了预测错误，FTQ 产生了重定向请求。在重定向请求中，&lt;code&gt;cfiUpdate&lt;/code&gt; 将会对应这条无条件跳转指令。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;cfiUpdate&lt;/code&gt; 中的信息可大致分为三种类型的信息：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;对应指令的信息及执行情况&lt;/strong&gt;。其中会说明该指令在预测块中位于那个槽 (shift) 及 pc； 会指示这条指令的类型相关信息 (pd)；还有这条指令的执行情况，例如跳转目标、是否跳转等&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;历史维护相关信息&lt;/strong&gt;。重定向请求中包含了该条指令所处的预测块对应的分支历史信息，以帮助BPU恢复分支历史信息。&lt;code&gt;foleded_hist&lt;/code&gt; 代表全局折叠历史，&lt;code&gt;histPtr&lt;/code&gt; 代表全局历史指针，而其余信息则是维护分支历史的辅助信息。要详细了解这些信息的含义，请参阅 &lt;code&gt;BPU顶层模块&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RAS维护相关信息&lt;/strong&gt;。详细含义请参阅 RAS 子预测器文档。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;code&gt;level&lt;/code&gt; 信息的含义是，重定向是否包含本条指令，如果不包含，重定向请求的接收方将认为这条指令已经被执行了，下次预测将从下一条指令开始。&lt;code&gt;BPU&lt;/code&gt; 顶层会默认不包含本条指令，收到重定向请求后，会将本条指令的执行情况统计到分支历史当中。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;以下为重定向接口的详细信号列表：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;level&lt;/strong&gt;: 重定向请求是否包括本位置，低表示在本位置后重定向，高表示在本位置重定向。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt(1.W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;cfiUpdate&lt;/strong&gt;: 控制流指令更新信息&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;接口类型: &lt;code&gt;CfiUpdateInfo&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;接口列表&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;pc&lt;/strong&gt;: 重定向请求对应的指令 PC&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt(VaddrBits.W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;pd&lt;/strong&gt;: 重定向指令的预译码信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;isRVC&lt;/strong&gt;: 是否是压缩指令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;isCall&lt;/strong&gt;: 是否是函数调用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;isRet&lt;/strong&gt;: 是否是函数返回&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;target&lt;/strong&gt;: 重定向请求指令的目标地址。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt(VaddrBits.W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;taken&lt;/strong&gt;: 重定向请求指令是否发生跳转。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;shift&lt;/strong&gt;: 重定向请求指令位于哪个槽，如果是普通指令则为0.&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt((log2Ceil(numBr)+1).W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;addIntoHist&lt;/strong&gt;: 重定向请求指令执行信息是否要加入分支历史。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;folded_hist&lt;/strong&gt;: 重定向请求对应的折叠历史。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;AllFoldedHistories(foldedGHistInfos)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;afhob&lt;/strong&gt;: 重定向请求指令对应的分支历史最老位。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;AllAheadFoldedHistoryOldestBits(foldedGHistInfos)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;lastBrNumOH&lt;/strong&gt;: 重定向请求对应的上次跳转位置。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt((numBr+1).W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;histPtr&lt;/strong&gt;: 重定向请求需要恢复的全局历史指针。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;CGHPtr&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;ssp&lt;/strong&gt;: 重定向请求指令对应的 RAS 推测栈栈顶在提交栈位置的指针。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt(log2Up(RasSize).W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;sctr&lt;/strong&gt;: 重定向请求指令对应的 RAS 推测栈栈顶递归计数 Counter。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt(log2Up(RasCtrSize).W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;TOSW&lt;/strong&gt;: 重定向请求指令对应的 RAS 推测栈（队列）写指针。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;CGHPtr&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;TOSR&lt;/strong&gt;: 重定向请求指令对应的 RAS 推测栈（队列）读指针。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;CGHPtr&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;NOS&lt;/strong&gt;: 重定向请求指令的 RAS 栈顶 Counter。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;CGHPtr&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;分支预测更新branchpredictionupdate&#34;&gt;&lt;strong&gt;分支预测更新（BranchPredictionUpdate）&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;接口定义: &lt;code&gt;src/main/scala/xiangshan/frontend/FrontendBundle.scala&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>BPU 全局接口</title>
      <link>https://open-verify.cc/xs-bpu/docs/ports/02_global_ports/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/ports/02_global_ports/</guid>
      <description>&lt;h2 id=&#34;bpu-模块整体对外接口-predirectio&#34;&gt;&lt;strong&gt;BPU 模块整体对外接口 (PredirectIO)&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;接口定义: &lt;code&gt;src/main/scala/xiangshan/frontend/BPU.scala&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;PredirectIO 是分支预测器整体的对外接口，它主要处理了分支预测器（BPU）与取指目标队列（FTQ）之间的交互，主要包含以下几个部分：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;bpu_to_ftq&lt;/strong&gt;: BPU 向 FTQ 发送的信息，主要用于 BPU 向 FTQ 发送分支预测结果&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型： &lt;code&gt;BpuToFtqIO&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;resp&lt;/strong&gt;: BPU 向 FTQ 发送的全局分支预测信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;DecoupledIO(new BpuToFtqBundle())&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;BpuToFtqBundle&lt;/code&gt; 继承自 &lt;code&gt;BranchPredictionResp&lt;/code&gt;，没有额外的信号&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;信号列表：详见 (&lt;code&gt;BranchPredictionResp&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ftq_to_bpu&lt;/strong&gt;: FTQ 向 BPU 发送的信息，主要用于处理重定向及更新请求&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型： &lt;code&gt;FtqToBpuIO&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;redirect&lt;/strong&gt;: FTQ 向 BPU 发送的重定向请求&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型： &lt;code&gt;Valid(new BranchPredictionRedirect)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;接口列表：详见（&lt;code&gt;BranchPredictionRedirect&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;update&lt;/strong&gt;: FTQ 向 BPU 发送的更新请求&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Valid(new BranchPredictionUpdate)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;接口列表：详见（&lt;code&gt;BranchPredictionUpdate&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;enq_ptr&lt;/strong&gt;: FTQ发送给BPU的FTQ指针，告诉BPU下一次需要写到哪个FTQ表项&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;FtqPtr&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ctrl&lt;/strong&gt;: BPU 控制信号，主要用于控制各预测器的使能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;BPUCtrl&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;接口列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;ubtb_enable&lt;/strong&gt;: UBTB 预测器使能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;btb_enable&lt;/strong&gt;: BTB 预测器使能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;bim_enable&lt;/strong&gt;: BIM 预测器使能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;tage_enable&lt;/strong&gt;: TAGE 预测器使能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;sc_enable&lt;/strong&gt;: SC 预测器使能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ras_enable&lt;/strong&gt;: RAS 预测器使能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;loop_enable&lt;/strong&gt;: LOOP 预测器使能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;reset_vector&lt;/strong&gt;: 重置向量，reset 时 BPU 的 pc 会被重置为该值&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;UInt(PAddrBits.W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;全局分支预测信息-branchpredictionresp&#34;&gt;&lt;strong&gt;全局分支预测信息 (BranchPredictionResp)&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;接口定义: &lt;code&gt;src/main/scala/xiangshan/frontend/FrontendBundle.scala&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>FTB 功能列表</title>
      <link>https://open-verify.cc/xs-bpu/docs/feature/02_ftbfeature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/feature/02_ftbfeature/</guid>
      <description>&lt;h2 id=&#34;功能列表feature-list&#34;&gt;功能列表（Feature List）&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;支持 FTB 项存储&lt;/li&gt;&#xA;&lt;li&gt;支持 s2, s3 通道基础预测结果输出以及 meta 信息输出&lt;/li&gt;&#xA;&lt;li&gt;支持更新请求响应，更新内部 FTB 项&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>TAGE-SC 分支预测器</title>
      <link>https://open-verify.cc/xs-bpu/docs/modules/02_tage_sc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/modules/02_tage_sc/</guid>
      <description>&lt;h2 id=&#34;功能介绍&#34;&gt;功能介绍&lt;/h2&gt;&#xA;&lt;p&gt;TAGE-SC 是南湖架构条件分支的&lt;strong&gt;主预测器&lt;/strong&gt;，属于精确预测器（Accurate Predictor，简称 APD）。TAGE-SC 可以看作两个功能相对独立的组件：预测部分 TAGE 和 校验部分 SC。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标记几何历史长度预测器 TAGE （Tagged Geometric History Length Predictor）利用&lt;strong&gt;历史长度不同的多个预测表&lt;/strong&gt;，可以挖掘&lt;strong&gt;极长的分支历史信息&lt;/strong&gt;。TAGE功能是预测一个跳转指令是跳转（Taken），还是不跳转（不Taken）， 它由一个基预测表和多个历史表组成，首先通过多个历史表进行分支预测，如果没有预测结果，则再采用基础预测表的预测结果。&lt;/li&gt;&#xA;&lt;li&gt;SC (Statistical Corrector) 是统计校正器。当 SC 会参考 TAGE 的预测结果和&lt;strong&gt;统计偏向的结果&lt;/strong&gt;。并根据这两个结果，&lt;strong&gt;矫正&lt;/strong&gt;最终的预测结果。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在昆明湖中，由于每个预测块，最多可以有2条跳转指令，因此TAGE在每次预测最多&lt;strong&gt;同时预测 2 条&lt;/strong&gt;条件分支指令。在访问 TAGE 的各个历史表时，用预测块的起始地址作为 PC，同时取出两个预测结果，并&lt;strong&gt;基于相同的全局历史&lt;/strong&gt;进行预测。&lt;/p&gt;&#xA;&lt;h2 id=&#34;昆明湖tage分支预测器&#34;&gt;昆明湖Tage分支预测器&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基本功能&#34;&gt;基本功能&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;tage.PNG&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;TAGE预测器的核心思路是提供不同历史长度的预测结果，并选择最合适的结果进行反馈。在TAGE预测器中，一共有 &lt;strong&gt;1+N&lt;/strong&gt; 个表历史记录表，N 为可配置选项。以昆明湖为例，N=4。&lt;/p&gt;&#xA;&lt;p&gt;基于 T0 表的预测器为&lt;strong&gt;基础预测器&lt;/strong&gt;。在预测时，直接通过预测块的 PC 地址在 T0 表中查找到该地址对应的 “2 bit 饱和计数器表示的跳转历史信息” ，然后根据历史信息做出预测结果。T0表的表项只有2bit，所以能记录的历史状态有限。&lt;/p&gt;&#xA;&lt;p&gt;对于 T0 以外的表，我们用 &lt;strong&gt;Tn&lt;/strong&gt; &lt;strong&gt;进行表示&lt;/strong&gt;。在查表时除了 PC 外，还需要用到&lt;strong&gt;全局跳转历史信息H&lt;/strong&gt;进行查找。&lt;strong&gt;查找命中后&lt;/strong&gt;，根据 “3bit饱和预测器” 进行跳转或者不跳转的预测。Tn 表的n越大，其用到的H中的位数越多。&lt;/p&gt;&#xA;&lt;p&gt;对于每一次预测，TAGE 从所有 Tn 命中表项中选择&lt;strong&gt;全局跳转历史最长&lt;/strong&gt;的表项。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果该表项存在，且预测结果置信度高就用该项作为最终预测结果。&lt;/li&gt;&#xA;&lt;li&gt;如果置信度低，就通过另外一个内部计数器来判断选择该项还是 T0 作为最后预测。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;在实现上，为了节约空间，检索 Tn 表时，输入的跳转历史信息H需要进行&lt;strong&gt;压缩&lt;/strong&gt;，该过程也称为&lt;strong&gt;历史折叠&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>香山分支预测单元结构介绍</title>
      <link>https://open-verify.cc/xs-bpu/docs/basic/02_xsbpu_structure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/basic/02_xsbpu_structure/</guid>
      <description>&lt;h2 id=&#34;bpu-是如何整合内部子预测器的&#34;&gt;BPU 是如何整合内部子预测器的？&lt;/h2&gt;&#xA;&lt;p&gt;我们已经知道香山 BPU 采用的是多预测器，多流水线方案。其中为了适配多流水线，BPU 采用了三通道结果输出接口。但是又是如何适配多预测器的呢？这就要求我们进一步深入 BPU，探究其内部结构。&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;1.png&#34; width=&#34;600px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;上图为香山文档中的 BPU 架构图，目前我们只需要关心这样一个信息，内部的所有子预测器都被包在了一个叫做 &lt;code&gt;Composer&lt;/code&gt; 的结构中。BPU只需要和 &lt;code&gt;Composer&lt;/code&gt; 交互。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Composer&lt;/code&gt; 是什么？我们不妨先看一下香山代码中对于他们的定义。&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;2.png&#34; width=&#34;700px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;可以发现，&lt;code&gt;Composer&lt;/code&gt; 以及五个子预测器有一个共同的特点，他们全部继承于 &lt;code&gt;BasePredictor&lt;/code&gt; 基类。并且接口已经在 &lt;code&gt;BasePredictor&lt;/code&gt; 类中定义好。换句话说就是，&lt;code&gt;Composer&lt;/code&gt;&lt;strong&gt;和五个子预测器都拥有相同的接口&lt;/strong&gt;！BPU 顶层可以直接把 &lt;code&gt;Composer&lt;/code&gt; 也当做一个子预测器，而无需关心内部是怎么连接子预测器的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;子预测器接口&#34;&gt;子预测器接口&lt;/h2&gt;&#xA;&lt;p&gt;接下来我们会查看子预测器接口是怎样的。该接口将涉及到 &lt;code&gt;Composer&lt;/code&gt; 与 BPU 顶层的交互，还会涉及到各子预测器与 &lt;code&gt;Composer&lt;/code&gt; 的交互。&lt;/p&gt;&#xA;&lt;p&gt;我们先以 &lt;code&gt;Composer&lt;/code&gt; 为例，说明子预测器接口的结构&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;3.png&#34; width=&#34;400px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;如上图所示，&lt;code&gt;Composer&lt;/code&gt; 的三通道预测结果被直接输出至 BPU 外部，并且还有一组三通道预测结果从BPU内部连接至 &lt;code&gt;Composer&lt;/code&gt; ，但由于预测结果是由 &lt;code&gt;Composer&lt;/code&gt; 产生，因此 BPU 会将一个空的预测结果传递给 &lt;code&gt;Composer&lt;/code&gt; ，这样做的意义是，使子预测器形成了一个“加工”的作用，子预测器会将输入的预测结果进行加工，然后再输出加工过后的预测结果。&lt;/p&gt;&#xA;&lt;p&gt;接下来，BPU 顶层会为流水线提供预测所需要的信息。首先是 &lt;strong&gt;PC&lt;/strong&gt; 和&lt;strong&gt;分支历史记录&lt;/strong&gt;（包括全局历史和全局折叠历史），接下来 BPU 会和 &lt;code&gt;Composer&lt;/code&gt; 之间连接一些&lt;strong&gt;流水线控制信号&lt;/strong&gt;，最后 BPU 将外部输入的&lt;strong&gt;重定向请求接口&lt;/strong&gt;和&lt;strong&gt;更新接口&lt;/strong&gt;直接连接至 &lt;code&gt;Composer&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;最终可以简单给出子预测器接口的定义（详细定义请前往接口文档进行查看）：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;in&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;(s1, s2, s3)&lt;/strong&gt; 预测信息输入&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;s0_pc&lt;/strong&gt;         需要预测的PC&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ghist&lt;/strong&gt;            全局分支历史&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;folded_hist&lt;/strong&gt; 全局折叠历史&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;out  (s1, s2, s3)&lt;/strong&gt; 预测信息输出&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;流水线控制信号&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;s0_fire, s1_fire, s2_fire, s3_fire&lt;/strong&gt; 相应流水级是否工作&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;s2_redirect, s3_redirect&lt;/strong&gt;              后续流水级发现预测错误时重定向信号&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;s1_ready, s2_ready, s3_ready&lt;/strong&gt;    子预测器相应流水级是否就绪&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;update&lt;/strong&gt;        更新请求&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;redirect&lt;/strong&gt;        重定向请求&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;子预测器之间的连接&#34;&gt;子预测器之间的连接&lt;/h2&gt;&#xA;&lt;p&gt;我们已经清楚各个子预测器之间的接口与&lt;code&gt;Composer&lt;/code&gt; 的接口是相同的，并且我们也已经知道了 &lt;code&gt;Composer&lt;/code&gt;是如何连向顶层 BPU 的，本小节将会说明子预测器是如何在 &lt;code&gt;Composer&lt;/code&gt; 内部进行连接的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>FTB 分支预测器</title>
      <link>https://open-verify.cc/xs-bpu/docs/modules/03_ftb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/modules/03_ftb/</guid>
      <description>&lt;h2 id=&#34;ftb-简介&#34;&gt;FTB 简介&lt;/h2&gt;&#xA;&lt;p&gt;FTB 是香山 BPU 的第三个子预测器，它也能一并获取到 uFTB 和 TAGE-SC 的输出。在 FTB 的输入接口中，s1 通道含有 uFTB 的基础预测结果，s2 通道和 s3 通道中仅有 &lt;code&gt;br_taken_mask&lt;/code&gt; 一组信号被 TAGE-SC 填充，并无 FTB 项生成的基础预测结果。FTB 的工作便是为 s2 和 s3 通道提供基础预测结果。&lt;/p&gt;&#xA;&lt;p&gt;FTB 在功能和结构上都与 uFTB 类似，其主要区别就是 FTB 能够容纳更多的 FTB 项，并且 FTB 的预测结果是在 s2 与 s3 通道输出。正是由于容量大，其读出的速度上会比 uFTB 慢，无法被放置在第一周期产生预测结果，但大容量也使它能够获得更加精准的预测结果。&lt;/p&gt;&#xA;&lt;h2 id=&#34;uftb-功能简介&#34;&gt;uFTB 功能简介&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;缓存更多 FTB 项，为 s2 和 s3 通道提供基础预测结果。&lt;/strong&gt; FTB 预测器的本质是一个较大容量的存储器，其会根据当前预测的 PC 读出对应的 FTB 项，并在 s2 阶段产出预测结果。与此同时该 FTB 项还会被再保存一个周期，生成 s3 阶段预测结果。生成结果需要注意的点是要考虑到上一预测器输入的 &lt;code&gt;br_taken_mask&lt;/code&gt; 字段，避免在生成时丢失。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;根据更新请求，更新存储中的 FTB 项。&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;ftb-存储结构&#34;&gt;FTB 存储结构&lt;/h2&gt;&#xA;&lt;p&gt;FTB 预测器中 FTB 项被放置在了一个专门的存储结构中，叫做 &lt;code&gt;FTBBank&lt;/code&gt; ，在进一步查看 &lt;code&gt;FTBBank&lt;/code&gt; 的结构之前，我们先来看一下 &lt;code&gt;FTBBank&lt;/code&gt; 是怎样使用的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>TAGE-SC 功能列表</title>
      <link>https://open-verify.cc/xs-bpu/docs/feature/03_tagescfeature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/feature/03_tagescfeature/</guid>
      <description>&lt;h2 id=&#34;功能列表feature-list&#34;&gt;功能列表（Feature List）&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;s2 TAGE 输出预测结果&lt;/li&gt;&#xA;&lt;li&gt;s3 SC 输出预测结果&lt;/li&gt;&#xA;&lt;li&gt;s2 TAGE 输出meta信息&lt;/li&gt;&#xA;&lt;li&gt;s3 SC 输出meta信息&lt;/li&gt;&#xA;&lt;li&gt;TAGE 进行更新训练&lt;/li&gt;&#xA;&lt;li&gt;检查申请新表项&lt;/li&gt;&#xA;&lt;li&gt;全局重置useful&lt;/li&gt;&#xA;&lt;li&gt;SC 进行更新训练&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>香山分支预测单元时序介绍</title>
      <link>https://open-verify.cc/xs-bpu/docs/basic/03_xsbpu_timing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/basic/03_xsbpu_timing/</guid>
      <description>&lt;h2 id=&#34;一周期无空泡预测&#34;&gt;一周期无空泡预测&lt;/h2&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;1.png&#34; width=&#34;500px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;uFTB&lt;/code&gt; 是香山 BPU 中唯一一个可以在一周期便可以产生预测结果的预测器，上图中展示了 &lt;code&gt;uFTB&lt;/code&gt; 的预测过程。&lt;code&gt;s0_pc&lt;/code&gt; 由 BPU 顶层送入，s1 周期生效时，&lt;code&gt;s1_pc&lt;/code&gt; 保存了上一周期 &lt;code&gt;s0_pc&lt;/code&gt; 的值，依次类推。也就是说传入的 &lt;code&gt;s0_pc&lt;/code&gt; 的值会随流水线向下移动。&lt;/p&gt;&#xA;&lt;p&gt;在 s1 周期生效时，&lt;code&gt;uFTB&lt;/code&gt; 会接收到本周期传来的 &lt;code&gt;s1_fire&lt;/code&gt; 信号，并根据 &lt;code&gt;s1_pc&lt;/code&gt; 指示的地址，在本周期生成预测结果，在预测结果中可以获取新的 PC 值。&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;2.png&#34; width=&#34;500px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;如图所示，BPU 顶层根据 s1 预测结果通道，分析出下一个 PC 值的位置（即图中的 target），并将其送往 &lt;code&gt;npc_Gen&lt;/code&gt; （即新PC生成器）中，用于产生下一个周期的 s0_pc。&lt;/p&gt;&#xA;&lt;p&gt;于是下一周期，&lt;code&gt;uFTB&lt;/code&gt; 获取到了新的 PC 值，并开始了新 PC 值预测块的产生。由此可见，仅凭借 s1 周期，便可以以一周期一个预测块的速度来产生预测结果。&lt;/p&gt;&#xA;&lt;h2 id=&#34;预测结果重定向&#34;&gt;预测结果重定向&lt;/h2&gt;&#xA;&lt;p&gt;但除了 &lt;code&gt;uFTB&lt;/code&gt; 以外，其他预测器都需要 2-3 个周期才可以产生预测结果，如何利用起他们的预测结果？又如何生成预测结果重定向信号呢？&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;3.png&#34; width=&#34;500px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;如图中所示，一个两周期产生预测结果的 &lt;code&gt;Predirector 2&lt;/code&gt; ，可以在 s2 周期，向 s2 预测结果通道内输出它的预测结果。BPU 顶层拿到预测结果后，分析出预测块的跳转目标地址 &lt;code&gt;target&lt;/code&gt; 并连向 &lt;code&gt;npc_Gen&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;此时连向 &lt;code&gt;npc_Gen&lt;/code&gt; 的信号中，既有 s2 产生的旧 PC 的预测结果，又有 s1 产生的新 PC 的预测结果，该如何抉择新 PC 用哪一个呢？&lt;/p&gt;</description>
    </item>
    <item>
      <title>子预测器基类与子预测器接口</title>
      <link>https://open-verify.cc/xs-bpu/docs/ports/03_subpredictor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/ports/03_subpredictor/</guid>
      <description>&lt;p&gt;在香山分支预测单元中，其所有子预测器以及 Composer 的类实现都是继承自子预测器基类（BasePredictor），并且子预测器接口（BasePredictorIO）也是在子预测器基类中进行定义。因此我们可以认为，Compser 和所有子预测器都含有相同的接口。&lt;/p&gt;&#xA;&lt;p&gt;在子预测的理解及验证当中，我们最直接的外界交互是发生在子预测器接口，以及子预测器基类中定义的一些变量，因此在子预测器的验证之前，强烈建议你阅读并理解本节文档。&lt;/p&gt;&#xA;&lt;p&gt;子分支预测器接口的大致内容及使用方法，已在&lt;code&gt;香山分支预测单元（BPU）基础设计&lt;/code&gt;中进行了介绍，本节文档将专注于接口的信号细节。&lt;/p&gt;&#xA;&lt;h2 id=&#34;子分支预测器接口-basepredictorio&#34;&gt;&lt;strong&gt;子分支预测器接口 (BasePredictorIO)&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;接口定义: &lt;code&gt;src/main/scala/xiangshan/frontend/BPU.scala&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;每个子分支预测器都需要实现该接口，该接口定义了子分支预测器的输入输出接口。&lt;/p&gt;&#xA;&lt;p&gt;注意：其中某些信号被定义为了 &lt;code&gt;numDup&lt;/code&gt; 个数量，其中每个信号完全一样，多个相同信号是为其他因素考虑。&lt;/p&gt;&#xA;&lt;p&gt;详细的信号列表如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;reset_vector&lt;/strong&gt; 重置向量，reset 时 BPU 的 pc 会被重置为该值&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;UInt(PAddrBits.W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;in&lt;/strong&gt; BPU 向子分支预测器发送的信息&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;DecoupledIO(new BasePredictorInput)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;信号列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;s0_pc&lt;/strong&gt; s0流水级的pc&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Vec(numDup, UInt(VAddrBits.W))&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;folded_hist&lt;/strong&gt; 全局折叠历史信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Vec(numDup, new AllFoldedHistories(foldedGHistInfos))&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;信号列表：详见（&lt;code&gt;AllFoldedHistories&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ghist&lt;/strong&gt; 全局分支历史信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;UInt(HistoryLength.W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;resp_in&lt;/strong&gt; 全局分支预测信息（包含s1, s2, s3 预测结果信息）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;BranchPredictionResp&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;信号列表：详见（&lt;code&gt;BranchPredictionResp&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;out&lt;/strong&gt; 子分支预测器向 BPU 发送的信息（包含s1, s2, s3 预测结果信息）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;new BasePredictorOutput&lt;/code&gt; 继承自 &lt;code&gt;BranchPredictionResp&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;信号列表：详见（&lt;code&gt;BranchPredictionResp&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;ctrl&lt;/strong&gt; BPU 子预测器使能控制信号，主要用于控制各预测器是否开启&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;BPUCtrl&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;接口列表：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;ubtb_enable&lt;/strong&gt;: UBTB 预测器使能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;btb_enable&lt;/strong&gt;: BTB 预测器使能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;bim_enable&lt;/strong&gt;: BIM 预测器使能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;tage_enable&lt;/strong&gt;: TAGE 预测器使能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;sc_enable&lt;/strong&gt;: SC 预测器使能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ras_enable&lt;/strong&gt;: RAS 预测器使能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;loop_enable&lt;/strong&gt;: LOOP 预测器使能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型：&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;s0_fire&lt;/strong&gt; s0阶段握手成功信号&lt;/p&gt;</description>
    </item>
    <item>
      <title>ITTAGE 分支预测器</title>
      <link>https://open-verify.cc/xs-bpu/docs/modules/04_ittage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/modules/04_ittage/</guid>
      <description>&lt;h2 id=&#34;功能介绍&#34;&gt;功能介绍&lt;/h2&gt;&#xA;&lt;p&gt;对于一般条件分支指令，只需要预测跳转（taken），或者不跳转（no taken），但是对于&lt;strong&gt;间接跳转&lt;/strong&gt;，如call/jump等指令，需要预测跳转&lt;strong&gt;到哪里去&lt;/strong&gt;（Target）。为了让TAGE支持预测跳转地址，ITTAGE（Indirect Target TAGE）应运而生。&lt;/p&gt;&#xA;&lt;p&gt;ITTAGE 与 TAGE 的&lt;strong&gt;主要区别&lt;/strong&gt;在于，在T0和Tn表中，多了 Target PC 数据。预测时，ITTAGE选择匹配到的、历史最长的表项中的 Target 作为预测结果，并利用 2bit 饱和计数器决定是否输出该结果，或选用替代预测结果。TAGE 预测器说明，请参考 &lt;a href=&#34;../02_tage_sc/&#34;&gt;TAGE-SC分支预测器&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;昆明湖-ittage-分支预测器&#34;&gt;昆明湖 ITTAGE 分支预测器&lt;/h2&gt;&#xA;&lt;p&gt;由于在昆明湖的BPU设计中，采用多预测器级联的方式进行预测，因此在子预测器实现上，会与原始预测器有所不同，其中多数表现在默认预测结果上。&lt;/p&gt;&#xA;&lt;h3 id=&#34;基本功能&#34;&gt;基本功能&lt;/h3&gt;&#xA;&lt;p&gt;ITTAGE基本功能类似 TAGE 分支预测器，但存在以下不同点：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在表项中增加了 Target 作为跳转的目标地址项，用于预测跳转目标地址。&lt;/li&gt;&#xA;&lt;li&gt;饱和计数器ctr也不再提供预测方向，而改为决定是否输出结果（只是预测信息）。&lt;/li&gt;&#xA;&lt;li&gt;由于每个分支预测块中只有一个间接跳转指令，所以ITTAGE也只考虑一条指令。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;流水线&#34;&gt;流水线&lt;/h3&gt;&#xA;&lt;p&gt;ITTAGE &lt;strong&gt;内含三个流水级&lt;/strong&gt;，第一级计算索引，第二级通过索引读出SRAM表中的结果&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;第0拍，s0：第一个流水级的输入，一般是pc和折叠历史。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;第一流水级运行&lt;/strong&gt;：计算index。通过寄存器输出到s1&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;第1拍，s1：第二个流水级的输入，为第一级阶段计算好的index等数据。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;第二流水级运行&lt;/strong&gt;：访存SRAM，读取预测用信息。通过寄存器输出到s2&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;第2拍，s2：第三个流水级的输入，为第二级从SRAM中读出的&lt;strong&gt;原始预测信息&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;**第三流水级运行：**处理原始预测信息，决定是否输出预测结果。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;第3拍，s3：预测结果就绪，此时已经可以使用&lt;strong&gt;预测结果&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;数据结构&#34;&gt;数据结构&lt;/h3&gt;&#xA;&lt;p&gt;在昆明湖的实现中，T0与Tn的表结构如下所示：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&lt;strong&gt;预测器&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;表项构成&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;项数&lt;/strong&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;基准预测器T0&lt;/td&gt;&#xA;          &lt;td&gt;用于在其他预测器的预测结果都无效时输出预测结果&lt;/td&gt;&#xA;          &lt;td&gt;虚表，不存在。 直接将上级预测器FTB 的预测结果作为表项结果&lt;/td&gt;&#xA;          &lt;td&gt;虚表，不存在。 直接将上级预测器FTB结果作为索引到的结果&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;预测表T1-T2&lt;/td&gt;&#xA;          &lt;td&gt;对每个预测块的输入，所有Tn表都进行预测，在所有预测有效的结果中，选择历史记录最长的结果作为 原始预测信息。历史记录长度由输入的H决定&lt;/td&gt;&#xA;          &lt;td&gt;target: 41 bits; valid: 1bit; tag: 9bits; ctr: 2bits; us: 1bit（usefulness计数器）&lt;/td&gt;&#xA;          &lt;td&gt;256项&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;预测表T3-T5&lt;/td&gt;&#xA;          &lt;td&gt;512项&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;t0tn表的检索方法&#34;&gt;T0，Tn表的检索方法&lt;/h3&gt;&#xA;&lt;p&gt;检索方法与 TAGE 分支预测器一致，只是各表的配置选项不同。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ITTAGE 功能列表</title>
      <link>https://open-verify.cc/xs-bpu/docs/feature/04_ittagefeature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/feature/04_ittagefeature/</guid>
      <description>&lt;h2 id=&#34;功能列表feature-list&#34;&gt;功能列表（Feature List）&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;s2 ITTAGE 决定是否产生预测结果&lt;/li&gt;&#xA;&lt;li&gt;s3 ITTAGE 读取预测的跳转目标&lt;/li&gt;&#xA;&lt;li&gt;s3 ITTAGE 输出meta信息&lt;/li&gt;&#xA;&lt;li&gt;ITTAGE 进行更新训练&lt;/li&gt;&#xA;&lt;li&gt;检查申请新表项&lt;/li&gt;&#xA;&lt;li&gt;全局重置useful&lt;/li&gt;&#xA;&lt;li&gt;预测方向&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>RAS 分支预测器</title>
      <link>https://open-verify.cc/xs-bpu/docs/modules/05_ras/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/modules/05_ras/</guid>
      <description>&lt;h2 id=&#34;ras介绍&#34;&gt;RAS介绍&lt;/h2&gt;&#xA;&lt;p&gt;RAS 指的是 &amp;ldquo;Return Address Stack&amp;rdquo;，即返回地址栈。它通过跟踪程序的返回地址，帮助确定程序中的分支行为。由前所述，在程序中存在很多分支：if/else、 switch/case、while/for loop、iteration、call/return&lt;/p&gt;&#xA;&lt;p&gt;等。RAS分支预测器则专门针对 call/return类型。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;_add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#a40000&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;  &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#a40000&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sub&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(){&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;d&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sub&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上图所示，在main函数中调用了add和sub，add又调用了函数_add。在该过程中，每次调用（call）的跳转地址和返回的地址固定，且在call的时候，就可以同时得到返回地址。函数的调用过程是一个“栈的出入”过程，因此可以通过“栈”结构进行分支预测：每遇到call指令，把当前PC+4（压缩指令和普通指令的偏移不同）进行压栈push操作；遇到return指令，则进行进行pop操作，得到的地址即为目标跳转地址。在基于“预测块”的BPU中，RAS无法知道当前块是否是call或者ret，因此需要依赖其他预测器，利用前级预测器的结果进行RAS操作。&lt;/p&gt;&#xA;&lt;p&gt;具体的，在香山的RAS预测器中，其s2阶段，需要判断上一级s2的输出是否预测为call或者ret（即输入信号io.s2_full_pred.hit_taken_on_call/ret有效 ），如果是call则push其后续指令地址入栈，是ret则从栈中pop出地址作为预测结果。因为在BPU的预测器中，人为假定s3阶段得到的结果比s2阶段好，所以RAS预测器在s3阶段需要进行检查，如果上一级的s3预测结果与s2不一致，则采信s3的结果，并按需求判断是否需要撤销或者补齐之前s2阶段的栈操作。例如s2阶段预测为call指令，进行了push操作，而s3为普通分支指令，不需要进行任何操作，此时就需要撤销push；如果s2预测为普通分支指令，s3预测为call，则需要进行push操作补齐。&lt;/p&gt;&#xA;&lt;h2 id=&#34;ras的栈操作&#34;&gt;RAS的栈操作&lt;/h2&gt;&#xA;&lt;p&gt;在普通的RAS设计中，通过栈进行预测函数返回地址。在理想情况下，本节假定RAS可进行随时备份，栈顶指针用sp表示，预测地址用paddr表示。RAS的基本操作有以下4种：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;h3 id=&#34;push&#34;&gt;PUSH&lt;/h3&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;由于预测可能会出错，出错时需要回到原始状态，因此在push时需要对当前栈的状态进行备份（在软件领域，通常称为“快照”，本文在后继内容中也用快照进行称呼），标记为s。当遇到call指令时，获取call指令的返回地址 addr = 当前pc + 4（如果是压缩指令则addr = pc+2），然后压栈：sp = addr；sp += 1。&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;h3 id=&#34;pop&#34;&gt;POP&lt;/h3&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;原因同上，对当前栈进行快照，标记为s。当遇到ret指令时，预测的跳转地址 paddr = sp，然后进行出栈， sp = sp - 1。对当前栈进行快照，标记为s。&lt;/p&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;h3 id=&#34;重定向操作&#34;&gt;重定向操作&lt;/h3&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;由于BPU是对程序的分支进行预测，因此就有“预测对”和“预测错”两种情况，当CPU后端发现分支预测错误，就会进行重定向（redirect）操作，告诉BPU哪个地方预测错误，正确结果是多少。重定向时RAS模块会收到正确的分支和当时预测时RAS栈信息。根据正确分支指令类型不同，首先恢复快照s有如下情形：&lt;/p&gt;&#xA;&lt;p&gt;（1）之前被预测的指令，实际是 call指令，根据redirect中给的addr地址，执行push操作；&lt;/p&gt;&#xA;&lt;p&gt;（2）之前被预测的指令，实际是 ret指令，执行pop操作；&lt;/p&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;h3 id=&#34;提交操作&#34;&gt;提交操作&lt;/h3&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;提交（Commit）操作即后端告诉前端，之前预测的结果正确。理想情况下，RAS预测器此时不需要进行任何操作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;昆明湖中ras的实现&#34;&gt;昆明湖中RAS的实现&lt;/h2&gt;&#xA;&lt;p&gt;由于处理器在执行过程中可能会进行错误的猜测，导致数据污染，RAS需要通过恢复机制来确保数据的准确性。特别是在昆明湖的实际电路设计中，不可能有无限大的栈，也无法随时备份数据。因此，昆明湖的RAS实现中，使用了基于持久化栈的返回地址预测器。具体来说，将RAS分为提交栈（commit stack）和推测栈（spec queue）两个部分，推测栈利用了香山BPU的预测结果来进行预测，然后根据后端返回的信息将数据压入提交栈中。下面详细介绍昆明湖的RAS设计：&lt;/p&gt;&#xA;&lt;h3 id=&#34;每次预测时ras栈的快照如何获得&#34;&gt;&lt;strong&gt;每次预测时，RAS栈的快照如何获得？&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;为了实现对RAS栈进行快照的功能，昆明湖的&lt;strong&gt;RAS推测栈&lt;/strong&gt;采用了基于循环数组的 &lt;strong&gt;&amp;ldquo;链式表示“&lt;/strong&gt; 。设计具体如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>RAS 功能列表</title>
      <link>https://open-verify.cc/xs-bpu/docs/feature/05_rasfeature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/feature/05_rasfeature/</guid>
      <description>&lt;h2 id=&#34;功能列表feature-list&#34;&gt;功能列表（Feature List）&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;支持预测器的开启关闭操作&lt;/li&gt;&#xA;&lt;li&gt;支持s3预测结果覆盖s2预测结果&lt;/li&gt;&#xA;&lt;li&gt;支持ras栈的push、pop操作&lt;/li&gt;&#xA;&lt;li&gt;支持ras栈的redirect操作&lt;/li&gt;&#xA;&lt;li&gt;支持ras栈的update操作&lt;/li&gt;&#xA;&lt;li&gt;支持base predictor接口&lt;/li&gt;&#xA;&lt;li&gt;符合标准RAS预测器预测流程&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>搜索结果</title>
      <link>https://open-verify.cc/xs-bpu/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/search/</guid>
      <description></description>
    </item>
  </channel>
</rss>
