<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>重定向请求 on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</title>
    <link>https://open-verify.cc/xs-bpu/tags/%E9%87%8D%E5%AE%9A%E5%90%91%E8%AF%B7%E6%B1%82/</link>
    <description>Recent content in 重定向请求 on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/xs-bpu/tags/%E9%87%8D%E5%AE%9A%E5%90%91%E8%AF%B7%E6%B1%82/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>香山分支预测单元基础</title>
      <link>https://open-verify.cc/xs-bpu/docs/basic/01_xsbpu_basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/basic/01_xsbpu_basic/</guid>
      <description>&lt;h2 id=&#34;分支预测块思想&#34;&gt;分支预测块思想&lt;/h2&gt;&#xA;&lt;p&gt;对于一般的分支预测器来说，通常会根据给定的 PC  预测出该 PC 所对应的指令的相关信息，如是否是条件分支指令、是否是跳转指令。对于条件分支指令，会预测出是否会跳转，而对于跳转指令，则会预测出跳转目标。然而，这种一条一条地预测指令的方法效率较低，导致前端指令供给过慢。&lt;/p&gt;&#xA;&lt;p&gt;相比之下，香山采用的预测方法是每次预测一个指令块。也就是说，&lt;strong&gt;给定一个 PC，香山会预测出以这个PC开始的一个分支预测块，包括了接下来若干条指令的情况，如是否存在分支指令、分支指令的位置、是否跳转以及跳转目标等信息&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;这样的预测方法可以一次性地预测出多条指令，并将预测结果送往取指单元（IFU），指导IFU进行取指。此外，由于IFU需要考虑缓存行的性能问题，它可以根据预测块一次性地取出多条指令，从而提高吞吐效率。&lt;/p&gt;&#xA;&lt;p&gt;在预测块产生后，&lt;strong&gt;分支预测块还会生成执行完本预测块后跳转到的 PC，接着 BPU 会根据该 PC 继续产生下一个分支预测块&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;举个简单的例子&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;1.png&#34; width=&#34;700px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;如上图所示，当 PC 执行到 0x20000118 时，BPU会经历如下几个步骤：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;BPU得知PC 0x20000118&lt;/li&gt;&#xA;&lt;li&gt;BPU产生以 0x20000118 为开始的分支预测块，内容大致如下&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在接下来的若干条指令中&lt;/li&gt;&#xA;&lt;li&gt;第三条是一个条件分支指令&lt;/li&gt;&#xA;&lt;li&gt;对于这个条件分支指令，预测他将会跳转&lt;/li&gt;&#xA;&lt;li&gt;跳转后的地址为 0x20000110&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;BPU将PC设置为 0x20000110，并继续产生下一个分支预测块&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这便是采用了分支预测块的香山 BPU 的基本预测流程&lt;/p&gt;&#xA;&lt;h2 id=&#34;多预测器多流水线结构&#34;&gt;多预测器、多流水线结构&lt;/h2&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;2.png&#34; width=&#34;500px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;上图展示了香山BPU的总体架构，其中我们需要关注两个主要方面：&lt;/p&gt;&#xA;&lt;h3 id=&#34;多预测器&#34;&gt;多预测器&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;为了确保预测的准确性，香山 BPU 采用了多个预测器，并且这些预测器共同产生 BPU 的预测结果。例如，FTB 会生成基础的预测结果供后续预测器使用，而 TAGE 则对条件分支指令产生更精准的预测结果等。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;多流水线&#34;&gt;多流水线&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;为了满足高性能的需求，香山 BPU 采用了流水线设计。各个预测器处于不同的流水线级别。其中，uFTB（即图中的uBTB）预测器位于第一流水线级别，能够在一个周期内产生预测结果。而其余预测器则需要2-3个周期才能生成预测结果，尽管预测时间较长，但预测结果相对更精确。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;但是，如果在第三个周期才能获取到预测结果，并基于新的结果重新开始预测，这样的设计难免导致性能损失。因为这样一来，需要耗费三个时钟周期才可以完成一次预测。&lt;/p&gt;&#xA;&lt;p&gt;为了在第一和第二周期就能够获取到某些预测器的预测结果，我们设置了三个预测结果通道，并将三个流水线级别的预测结果同时输出，如下图所示。&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;3.png&#34; width=&#34;600px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;h2 id=&#34;取指目标队列ftq&#34;&gt;取指目标队列（FTQ）&lt;/h2&gt;&#xA;&lt;h3 id=&#34;分支预测结果暂存&#34;&gt;分支预测结果暂存&lt;/h3&gt;&#xA;&lt;p&gt;尽管 BPU 可以以分支预测块的形式提供预测结果，IFU 也可以一次性取指多条指令，但它们之间仍然存在性能上的差距。通常情况下，BPU产生预测结果的速度更快。&lt;/p&gt;&#xA;&lt;p&gt;因此，在 BPU 与 IFU 之间添加了一个取指目标队列（FTQ）作为缓冲。FTQ 本质上是一个队列，用于存储一个个数据项。BPU产生的预测结果会先暂存到FTQ中，然后由 IFU 从 FTQ 中获取预测结果，如下图所示。&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;4.png&#34; width=&#34;400px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;每当 BPU 产生一个预测块，该预测块会被放入 FTQ 的队首。当 IFU 处于空闲状态时，它会从 FTQ 队尾获取下一个预测块。下方的示意图展示了这一过程。&lt;/p&gt;</description>
    </item>
    <item>
      <title>重定向与更新接口</title>
      <link>https://open-verify.cc/xs-bpu/docs/ports/01_redirect_and_update/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/ports/01_redirect_and_update/</guid>
      <description>&lt;h2 id=&#34;分支预测重定向branchpredictionredirect&#34;&gt;&lt;strong&gt;分支预测重定向（BranchPredictionRedirect）&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;接口定义：&lt;/strong&gt;&lt;code&gt;src/main/scala/xiangshan/frontend/FrontendBundle.scala&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;接口类型：&lt;/strong&gt;&lt;code&gt;BranchPredictionRedirect&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;该接口定义了分支预测单元的重定向请求，主要用于重定向分支预测器的状态。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;BranchPredictionRedirct&lt;/code&gt; 接口继承自 &lt;code&gt;Redirct&lt;/code&gt; 接口，所含信号较多，BPU 重定向只会用到其中一部分接口，文档描述的结构中只包含 BPU 用到的接口内容。&lt;/p&gt;&#xA;&lt;p&gt;重定向请求有两种来源，与 IFU 预译码信息对比生成的重定向请求，后端执行过程中的重定向请求。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;在重定向请求中，关键信息是&lt;/strong&gt;&lt;code&gt;cfiUpdate&lt;/code&gt;，&lt;strong&gt;即控制流指令信息。这一信息对应着一条指令，也就是BPU发生预测错误的指令&lt;/strong&gt;。举例来说，如果 BPU 在预测块中指示第三条指令为普通指令不发生跳转，但预译码显示第三条指令是一条无条件跳转指令，必定会跳转。在这种情况下，BPU 发生了预测错误，FTQ 产生了重定向请求。在重定向请求中，&lt;code&gt;cfiUpdate&lt;/code&gt; 将会对应这条无条件跳转指令。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;cfiUpdate&lt;/code&gt; 中的信息可大致分为三种类型的信息：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;对应指令的信息及执行情况&lt;/strong&gt;。其中会说明该指令在预测块中位于那个槽 (shift) 及 pc； 会指示这条指令的类型相关信息 (pd)；还有这条指令的执行情况，例如跳转目标、是否跳转等&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;历史维护相关信息&lt;/strong&gt;。重定向请求中包含了该条指令所处的预测块对应的分支历史信息，以帮助BPU恢复分支历史信息。&lt;code&gt;foleded_hist&lt;/code&gt; 代表全局折叠历史，&lt;code&gt;histPtr&lt;/code&gt; 代表全局历史指针，而其余信息则是维护分支历史的辅助信息。要详细了解这些信息的含义，请参阅 &lt;code&gt;BPU顶层模块&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RAS维护相关信息&lt;/strong&gt;。详细含义请参阅 RAS 子预测器文档。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;code&gt;level&lt;/code&gt; 信息的含义是，重定向是否包含本条指令，如果不包含，重定向请求的接收方将认为这条指令已经被执行了，下次预测将从下一条指令开始。&lt;code&gt;BPU&lt;/code&gt; 顶层会默认不包含本条指令，收到重定向请求后，会将本条指令的执行情况统计到分支历史当中。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;以下为重定向接口的详细信号列表：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;level&lt;/strong&gt;: 重定向请求是否包括本位置，低表示在本位置后重定向，高表示在本位置重定向。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt(1.W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;cfiUpdate&lt;/strong&gt;: 控制流指令更新信息&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;接口类型: &lt;code&gt;CfiUpdateInfo&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;接口列表&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;pc&lt;/strong&gt;: 重定向请求对应的指令 PC&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt(VaddrBits.W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;pd&lt;/strong&gt;: 重定向指令的预译码信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;isRVC&lt;/strong&gt;: 是否是压缩指令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;isCall&lt;/strong&gt;: 是否是函数调用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;isRet&lt;/strong&gt;: 是否是函数返回&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;target&lt;/strong&gt;: 重定向请求指令的目标地址。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt(VaddrBits.W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;taken&lt;/strong&gt;: 重定向请求指令是否发生跳转。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;shift&lt;/strong&gt;: 重定向请求指令位于哪个槽，如果是普通指令则为0.&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt((log2Ceil(numBr)+1).W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;addIntoHist&lt;/strong&gt;: 重定向请求指令执行信息是否要加入分支历史。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;folded_hist&lt;/strong&gt;: 重定向请求对应的折叠历史。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;AllFoldedHistories(foldedGHistInfos)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;afhob&lt;/strong&gt;: 重定向请求指令对应的分支历史最老位。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;AllAheadFoldedHistoryOldestBits(foldedGHistInfos)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;lastBrNumOH&lt;/strong&gt;: 重定向请求对应的上次跳转位置。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt((numBr+1).W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;histPtr&lt;/strong&gt;: 重定向请求需要恢复的全局历史指针。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;CGHPtr&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;ssp&lt;/strong&gt;: 重定向请求指令对应的 RAS 推测栈栈顶在提交栈位置的指针。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt(log2Up(RasSize).W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;sctr&lt;/strong&gt;: 重定向请求指令对应的 RAS 推测栈栈顶递归计数 Counter。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt(log2Up(RasCtrSize).W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;TOSW&lt;/strong&gt;: 重定向请求指令对应的 RAS 推测栈（队列）写指针。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;CGHPtr&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;TOSR&lt;/strong&gt;: 重定向请求指令对应的 RAS 推测栈（队列）读指针。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;CGHPtr&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;NOS&lt;/strong&gt;: 重定向请求指令的 RAS 栈顶 Counter。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;CGHPtr&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;分支预测更新branchpredictionupdate&#34;&gt;&lt;strong&gt;分支预测更新（BranchPredictionUpdate）&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;接口定义: &lt;code&gt;src/main/scala/xiangshan/frontend/FrontendBundle.scala&lt;/code&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
