<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>香山微架构开放验证第一期：昆明湖BPU模块UT验证实战 – UFTB</title>
    <link>https://open-verify.cc/xs-bpu/tags/uftb/</link>
    <description>Recent content in UFTB on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	  <atom:link href="https://open-verify.cc/xs-bpu/tags/uftb/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: uFTB 分支预测器</title>
      <link>https://open-verify.cc/xs-bpu/docs/modules/01_uftb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://open-verify.cc/xs-bpu/docs/modules/01_uftb/</guid>
      <description>
        
        
        &lt;h2 id=&#34;uftb-简介&#34;&gt;uFTB 简介&lt;/h2&gt;
&lt;p&gt;uFTB 是香山所有预测器中第一个预测器，也是其他预测器产生预测结果的基石。uFTB 工作在 s1 阶段，它获取到 s1_pc 后能在本周期内产生预测结果，并在 s1 通道输出，其他通道不予更改。分支指令的位置、指令的跳转目标都是由它来提供，后续预测器也将会根据这一预测结果进行进一步的预测。&lt;/p&gt;
&lt;p&gt;而其本质则是一个 FTB 项缓存，其中存储了 FTB 项，基础的预测结果将直接由读出的 FTB 项生成。&lt;/p&gt;
&lt;p&gt;因此，在你开始文档的阅读之前，请确保你理解了 FTB 项和含义以及预测结果接口的具体细节。&lt;/p&gt;
&lt;h2 id=&#34;uftb-功能简介&#34;&gt;uFTB 功能简介&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;缓存FTB项，生成一周期预测结果&lt;/strong&gt;    uFTB 中维护了一个小型的 FTB 项缓存，拿到 PC 之后，会在一周期之内读出 PC 所对应的 FTB 项，并从 FTB 项生成 s1 阶段预测结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;维护两比特饱和计数器，提供基础条件分支结果&lt;/strong&gt;   uFTB 中为 FTB项缓存的每一行都维护了对应的两比特饱和计数器，其方向预测结果会反映在 uFTB 的预测结果输出中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据更新请求更新 FTB 缓存和两比特饱和计数器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;uftb-缓存结构&#34;&gt;uFTB 缓存结构&lt;/h2&gt;
&lt;p&gt;如上所述，uFTB 本质上是一个存储了 FTB 项的小型缓存，其大致结构如下图所示。&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;1.png&#34; width=&#34;400px&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;在当前版本的香山中，uFTB 共有 32 个缓存行，每个缓存行被称作 &lt;code&gt;FauFTBWay&lt;/code&gt;，一个缓存行中可以存储一个 FTB 项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当 s1 流水有效时&lt;/strong&gt;，uFTB 会使用 &lt;strong&gt;s1_pc&lt;/strong&gt; 来决定读出 uFTB 缓存的哪一项。缓存是根据 PC 中的 tag 字段来索引，tag 字段被定义为 pc[16: 1]，即在 PC 中截取了 16 比特作为标识来匹配缓存中的某一行。&lt;/p&gt;
&lt;p&gt;缓存中的每一行，即 &lt;code&gt;FauFTBWay&lt;/code&gt; 中的数据请求接口有三项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;req_tag&lt;/strong&gt;   输入 pc 中截取的 tag 标识&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;resp&lt;/strong&gt;          输出本行所存储的 FTB 项&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;resp_hit&lt;/strong&gt;  输出指示本行的 FTB 项是否与 req_tag 匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;uFTB 会将 tag 连接到缓存的每一行的数据请求接口，并根据 &lt;code&gt;resp_hit&lt;/code&gt; 信号，选出命中的那一个 FTB 项。后续将会根据这一 FTB 项生成完整预测结果。&lt;/p&gt;
&lt;h2 id=&#34;两比特饱和计数器&#34;&gt;两比特饱和计数器&lt;/h2&gt;
&lt;p&gt;uFTB 中为 FTB 项缓存的每一行都维护了对应的两比特饱和计数器。我们知道，在一个 FTB 项最多可以存储两个条件分支指令，因此每一行对应的两比特饱和计数器也有两个，负责为其中的条件分支指令提供粗略的预测结果。&lt;/p&gt;
&lt;p&gt;uFTB 在索引到 FTB 项时，也会索引到对应的两比特饱和计数器。&lt;/p&gt;
&lt;p&gt;当预测结果生成时，会根据 FTB 项与其对应的两个两比特饱和计数器中的内容来产生。&lt;/p&gt;
&lt;h2 id=&#34;预测结果生成&#34;&gt;预测结果生成&lt;/h2&gt;
&lt;p&gt;uFTB 通过 s1_pc 索引到对应的 FTB 项以及两个两比饱和计数器之后，需要根据他们产生预测结果。uFTB 产生的预测结果，将在 s1 流水有效时，通过 s1 通道进行输出，对于 s2 以及 s3 通道，uFTB 不予更改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;s1 预测结果中的信号产生方式可参考以下列表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;hit&lt;/strong&gt; FTB表项是否命中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：&lt;code&gt;FauFTBWay&lt;/code&gt; 中的 &lt;code&gt;resp_hit&lt;/code&gt; 信号，存在一个有效&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;slot_valids&lt;/strong&gt; slot有效位，表示 ftb 项中的每个 slot 是否有效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;targets&lt;/strong&gt; 每个slot对应的跳转目标地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;offsets&lt;/strong&gt; 每个slot中的指令相对于预测块起始地址的偏移&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_jal&lt;/strong&gt; 预测块内包含jal指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_jalr&lt;/strong&gt; 预测块内包含jalr指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_call&lt;/strong&gt; 预测块内包含call指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_ret&lt;/strong&gt; 预测块内包含ret指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;last_may_be_rvi_call&lt;/strong&gt; 预测结果预测块末尾可能为一个RVI类型的call指令信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_br_sharing&lt;/strong&gt; 最后一个slot (tailSlot) 中存储的是条件分支指令信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式： FTB 项中对应字段导出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;fallThroughErr&lt;/strong&gt; FTB项中记录的 &lt;code&gt;pftAddr&lt;/code&gt; 有误&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：比较 &lt;code&gt;pftAddr&lt;/code&gt; 代表的预测块结束地址是否大于预测块的起始地址，如果小于，则代表出现错误，此信号置为有效。这种情况可能会发生在 pc 索引到错误的 FTB 项的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;fallThroughAddr&lt;/strong&gt; 预测块的结束地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：如果 &lt;code&gt;fallThroughErr&lt;/code&gt; 无效，则根据 &lt;code&gt;pftAddr&lt;/code&gt; 生成，否则将其设置为起始地址 + 预测宽度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;br_taken_mask&lt;/strong&gt; 分支预测结果，每个分支(slot)对应一个 bit，表示该分支是否被预测为 taken&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：根据 FTB 项中的 &lt;code&gt;always_taken&lt;/code&gt; 字段和两比特饱和计数器指示结果生成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;jalr_target&lt;/strong&gt; 本预测块中的 jalr 的跳转目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：FTB 项中 tailSlot 中的跳转目标。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;uftb-更新&#34;&gt;uFTB 更新&lt;/h2&gt;
&lt;p&gt;uFTB 的更新涉及 FTB 项缓存的更新，以及两比特饱和计数器的更新，而更新的内容都是通过更新接口来获取的。&lt;/p&gt;
&lt;p&gt;在 uFTB 预测器中，缓存和两比特饱和计数器的读与写并不冲突，因此我们无需考虑读和更新之间的时序冲突问题，可以将他们看做是独立的两部分。&lt;/p&gt;
&lt;h3 id=&#34;ftb-缓存更新&#34;&gt;FTB 缓存更新&lt;/h3&gt;
&lt;p&gt;FTB 缓存的更新过程很简单，更新通道中已经为我们指定好了 pc 以及新生成的 FTB 项，只需将其写入到缓存的指定位置即可。&lt;/p&gt;
&lt;p&gt;FTB 缓存的更新需要两个周期：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在第一周期，通过 update 中的信号计算出如下内容：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;更新请求对应的预测块在缓存的哪一行&lt;/strong&gt; 更新请求中的 pc 截取 tag 后被发送到 &lt;code&gt;FauFTBWay&lt;/code&gt; 的更新请求通道，根据每一行所返回的 hit 信号计算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在第二周期，根据第一周期求出的需要更新的位置进行更新，如果无任何一行命中，则 uFTB 会使用 &lt;strong&gt;伪 LRU 替换算法&lt;/strong&gt; 选出需要写入的行。
&lt;ul&gt;
&lt;li&gt;具体的，更新通道中的 &lt;code&gt;ftb_entry&lt;/code&gt; 信号组包含了新 FTB 项的完整信息，将该信息发送到需要更新的某一个缓存行即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;两位饱和计数器更新&#34;&gt;两位饱和计数器更新&lt;/h3&gt;
&lt;p&gt;两位饱和计数器的更新则需要结合后续程序的真实执行情况，以及 FTB 项中记录的分支指令信息来进行更新了，而这些信息都可以从更新通道中进行获取。&lt;/p&gt;
&lt;p&gt;两位饱和计数器的更新也需要两个周期：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在第一周期，计算出槽中哪些条件分支指令 对应的两位饱和计数器 需要被更新，这需要满足以下条件：
&lt;ul&gt;
&lt;li&gt;当前分支指令槽有效，并且存放了一条条件分支指令&lt;/li&gt;
&lt;li&gt;当前分支指令槽并没有被标识为 always_taken。（因为被标识为 always_taken 后不会采用两位饱和计数器的结果）&lt;/li&gt;
&lt;li&gt;当前分支指令槽不在实际发生了跳转的分支指令槽之后。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在第二周期，更新饱和计数器
&lt;ul&gt;
&lt;li&gt;根据第一周期生成的需要更新的掩码，以及更新通道中的 &lt;code&gt;br_taken_mask&lt;/code&gt; 信息进行更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;接口列表&#34;&gt;接口列表&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;信号类型&lt;/th&gt;
&lt;th&gt;信号位&lt;/th&gt;
&lt;th&gt;信号名&lt;/th&gt;
&lt;th&gt;信号描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;clock&lt;/td&gt;
&lt;td&gt;输入时钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;reset&lt;/td&gt;
&lt;td&gt;复位信号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[35:0]&lt;/td&gt;
&lt;td&gt;io_reset_vector&lt;/td&gt;
&lt;td&gt;用于reset时，reset s1_pc_dup_0 提供的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_0&lt;/td&gt;
&lt;td&gt;输入位s0_pc 的 第0个复制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_1&lt;/td&gt;
&lt;td&gt;同上 第1个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_2&lt;/td&gt;
&lt;td&gt;同上 第2个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_in_bits_s0_pc_3&lt;/td&gt;
&lt;td&gt;同上 第3个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_pc_0&lt;/td&gt;
&lt;td&gt;输出s1_pc 的 第0个复制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_pc_1&lt;/td&gt;
&lt;td&gt;同上 第1个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_pc_2&lt;/td&gt;
&lt;td&gt;同上 第2个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_pc_3&lt;/td&gt;
&lt;td&gt;同上 第3个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;solt 0 是否被预测为 always taken&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;solt 1 是否被预测为 always taken&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_slot_valids_0&lt;/td&gt;
&lt;td&gt;solt 0 是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_slot_valids_1&lt;/td&gt;
&lt;td&gt;solt 1 是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_targets_0&lt;/td&gt;
&lt;td&gt;solt 0 对应的跳转目标地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_targets_1&lt;/td&gt;
&lt;td&gt;solt 1 对应的跳转目标地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_offsets_0&lt;/td&gt;
&lt;td&gt;solt 0 中分支指令相对于地址块起始pc的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_offsets_1&lt;/td&gt;
&lt;td&gt;solt 1 中分支指令相对于地址块起始pc的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_fallThroughAddr&lt;/td&gt;
&lt;td&gt;预测块的结束地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_is_br_sharing&lt;/td&gt;
&lt;td&gt;solt 1（无条件跳转）是否被共享为有条件跳转指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_0_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;类似 io_out_s1_pc_1 io_out_s1_full_pred_0的复制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_1_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_2_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_slot_valids_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_slot_valids_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_targets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_targets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_offsets_0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_offsets_1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_fallThroughAddr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_fallThroughErr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_is_br_sharing&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_out_s1_full_pred_3_hit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;[222:0]&lt;/td&gt;
&lt;td&gt;io_out_last_stage_meta&lt;/td&gt;
&lt;td&gt;输出最后阶段的元信息 io_out_last_stage_meta = {213&amp;rsquo;h0, resp_meta_pred_way_r_1, resp_meta_hit_r_1}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_ctrl_ubtb_enable&lt;/td&gt;
&lt;td&gt;控制ubtb是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s0_fire_0&lt;/td&gt;
&lt;td&gt;输入s0_fire_0，与 io_out_s1_pc_0 &amp;lt;= io_in_bits_s0_pc_0 的时钟门控相关&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s0_fire_1&lt;/td&gt;
&lt;td&gt;输入s0_fire_1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s0_fire_2&lt;/td&gt;
&lt;td&gt;输入s0_fire_2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s0_fire_3&lt;/td&gt;
&lt;td&gt;输入s0_fire_3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s1_fire_0&lt;/td&gt;
&lt;td&gt;输入s1_fire_0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_s2_fire_0&lt;/td&gt;
&lt;td&gt;输入s2_fire_0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_valid&lt;/td&gt;
&lt;td&gt;更新有效性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[40:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_pc&lt;/td&gt;
&lt;td&gt;传回的预测块pc（用于指示更新的预测块）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_brSlots_0_offset&lt;/td&gt;
&lt;td&gt;solt 0 中分支指令相对于地址块起始pc的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[11:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_brSlots_0_lower&lt;/td&gt;
&lt;td&gt;跳转目标地址的低位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[1:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_brSlots_0_tarStat&lt;/td&gt;
&lt;td&gt;跳转后的 pc 高位是否进退位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_brSlots_0_valid&lt;/td&gt;
&lt;td&gt;是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_offset&lt;/td&gt;
&lt;td&gt;solt 1 中分支指令相对于地址块起始pc的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[19:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_lower&lt;/td&gt;
&lt;td&gt;跳转目标地址的低位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[1:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_tarStat&lt;/td&gt;
&lt;td&gt;跳转后的 pc 高位是否进退位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_sharing&lt;/td&gt;
&lt;td&gt;无条件跳转指令槽中存储条件分支指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_tailSlot_valid&lt;/td&gt;
&lt;td&gt;是否启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;[3:0]&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_pftAddr&lt;/td&gt;
&lt;td&gt;Partial Fallthrough Addr 如果预测块中没有跳转，那么程序将会顺序执行到达的地址，预测块的结束地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_carry&lt;/td&gt;
&lt;td&gt;pc+pft时是否产生进位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_always_taken_0&lt;/td&gt;
&lt;td&gt;是否预测为总是跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_ftb_entry_always_taken_1&lt;/td&gt;
&lt;td&gt;是否预测为总是跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_br_taken_mask_0&lt;/td&gt;
&lt;td&gt;是否跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;io_update_bits_br_taken_mask_1&lt;/td&gt;
&lt;td&gt;是否跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: uFTB 功能列表</title>
      <link>https://open-verify.cc/xs-bpu/docs/feature/01_uftbfeature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://open-verify.cc/xs-bpu/docs/feature/01_uftbfeature/</guid>
      <description>
        
        
        &lt;h2 id=&#34;功能列表feature-list&#34;&gt;功能列表（Feature List）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;支持基于 FTB 项的预测&lt;/li&gt;
&lt;li&gt;支持两比特饱和计数器&lt;/li&gt;
&lt;li&gt;支持 s1 通道基础预测结果输出及 meta 信息输出&lt;/li&gt;
&lt;li&gt;支持更新请求响应，更新内部 FTB 及两比特饱和计数器。&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
    
  </channel>
</rss>
