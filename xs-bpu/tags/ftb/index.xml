<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>香山微架构开放验证第一期：昆明湖BPU模块UT验证实战 – FTB</title>
    <link>https://xs-mlvp.github.io/xs-bpu/tags/ftb/</link>
    <description>Recent content in FTB on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	  <atom:link href="https://xs-mlvp.github.io/xs-bpu/tags/ftb/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: FTB 功能列表</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/feature/02_ftbfeature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/feature/02_ftbfeature/</guid>
      <description>
        
        
        &lt;h2 id=&#34;功能列表feature-list&#34;&gt;功能列表（Feature List）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;支持 FTB 项存储&lt;/li&gt;
&lt;li&gt;支持 s2, s3 通道基础预测结果输出以及 meta 信息输出&lt;/li&gt;
&lt;li&gt;支持更新请求响应，更新内部 FTB 项&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: FTB 分支预测器</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/modules/03_ftb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/modules/03_ftb/</guid>
      <description>
        
        
        &lt;h2 id=&#34;ftb-简介&#34;&gt;FTB 简介&lt;/h2&gt;
&lt;p&gt;FTB 是香山 BPU 的第三个子预测器，它也能一并获取到 uFTB 和 TAGE-SC 的输出。在 FTB 的输入接口中，s1 通道含有 uFTB 的基础预测结果，s2 通道和 s3 通道中仅有 &lt;code&gt;br_taken_mask&lt;/code&gt; 一组信号被 TAGE-SC 填充，并无 FTB 项生成的基础预测结果。FTB 的工作便是为 s2 和 s3 通道提供基础预测结果。&lt;/p&gt;
&lt;p&gt;FTB 在功能和结构上都与 uFTB 类似，其主要区别就是 FTB 能够容纳更多的 FTB 项，并且 FTB 的预测结果是在 s2 与 s3 通道输出。正是由于容量大，其读出的速度上会比 uFTB 慢，无法被放置在第一周期产生预测结果，但大容量也使它能够获得更加精准的预测结果。&lt;/p&gt;
&lt;h2 id=&#34;uftb-功能简介&#34;&gt;uFTB 功能简介&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;缓存更多 FTB 项，为 s2 和 s3 通道提供基础预测结果。&lt;/strong&gt; FTB 预测器的本质是一个较大容量的存储器，其会根据当前预测的 PC 读出对应的 FTB 项，并在 s2 阶段产出预测结果。与此同时该 FTB 项还会被再保存一个周期，生成 s3 阶段预测结果。生成结果需要注意的点是要考虑到上一预测器输入的 &lt;code&gt;br_taken_mask&lt;/code&gt; 字段，避免在生成时丢失。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据更新请求，更新存储中的 FTB 项。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ftb-存储结构&#34;&gt;FTB 存储结构&lt;/h2&gt;
&lt;p&gt;FTB 预测器中 FTB 项被放置在了一个专门的存储结构中，叫做 &lt;code&gt;FTBBank&lt;/code&gt; ，在进一步查看 &lt;code&gt;FTBBank&lt;/code&gt; 的结构之前，我们先来看一下 &lt;code&gt;FTBBank&lt;/code&gt; 是怎样使用的。&lt;/p&gt;
&lt;h3 id=&#34;ftb-读请求&#34;&gt;FTB 读请求&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;FTBBank&lt;/code&gt; 的读请求接口如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;req_pc&lt;/strong&gt;  请求的 pc
&lt;ul&gt;
&lt;li&gt;接口类型：&lt;code&gt;Flipped(DecoupledIO(UInt(VAddrBits.W)))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;read_resp&lt;/strong&gt; 读出来的FTB项
&lt;ul&gt;
&lt;li&gt;接口类型：&lt;code&gt;FTBEntry&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;read_hits&lt;/strong&gt; 命中了哪一路 (way)
&lt;ul&gt;
&lt;li&gt;接口类型：&lt;code&gt;Valid(UInt(log2Ceil(numWays).W))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 &lt;code&gt;req_pc&lt;/code&gt; 的接口是 Decoupled 的，也就是说含有 valid 和 ready 信号。 FTB 需要在 s1 阶段开始之前便获取到 pc，因此 &lt;code&gt;s0_pc&lt;/code&gt; 被送入 &lt;code&gt;req_pc&lt;/code&gt; 接口，&lt;code&gt;s0_fire&lt;/code&gt; 信号被连接至 &lt;code&gt;req_pc&lt;/code&gt; 的 valid 信号，&lt;code&gt;ready&lt;/code&gt; 信号被连接至预测器的流水控制信号 &lt;code&gt;s1_ready&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;s0_fire&lt;/code&gt; 之后进入 s1 阶段，&lt;code&gt;s0_fire&lt;/code&gt; 的下一个周期，也就是在 &lt;code&gt;s1_fire&lt;/code&gt; 的同时，FTBBank 已经将读出的 FTB 项输出至 &lt;code&gt;read_resp&lt;/code&gt; 接口，并计算好了 &lt;code&gt;read_hits&lt;/code&gt; 。但此时因为读出已经浪费了过多时延，无法在 s1 阶段进行输出了，因此该读出结果被保存在内部寄存器中。在 s2 和 s3 阶段会在寄存器中读出该 FTB 项并生成预测结果。&lt;/p&gt;
&lt;h3 id=&#34;ftbbank&#34;&gt;FTBBank&lt;/h3&gt;
&lt;p&gt;FTBBank 中定义了一个存储器来存储所有的 FTB 项，存储器采用组相联的结构（如果你不清楚组相联的含义，请自行 RTFM），共含 512 个组（Set），每组有 4 路（Way），最多能存储 2048 个 FTB 项，存储 FTB 的同时还会存储与 FTB 项对应的 tag 用于匹配 FTB 项。&lt;/p&gt;
&lt;p&gt;具体地，tag 被定义为 &lt;code&gt;pc[29:10]&lt;/code&gt;，即在 pc 中截取了 20 位用于标识 FTB 项，pc 的具体划分方式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Plain&#34; data-lang=&#34;Plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  pc: | ... |&amp;lt;-- tag(20 bits) --&amp;gt;|&amp;lt;-- idx(9 bits) --&amp;gt;|&amp;lt;-- instOffset(1 bit) --&amp;gt;|
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;读出时，向存储器提供组序号(idx)，读出该组中所有路，然后检测是否有某一路的 tag 与当前 tag 匹配，如果匹配，则表示命中，读出的 FTB 项通过 &lt;code&gt;read_resp&lt;/code&gt; 接口送出，并把命中的路编号通过 &lt;code&gt;read_hits&lt;/code&gt; 接口送出。&lt;/p&gt;
&lt;h2 id=&#34;预测结果生成&#34;&gt;预测结果生成&lt;/h2&gt;
&lt;p&gt;正如我们之前提到的，对于 FTB 预测器，它需要向 s2, s3 通道提供由 FTB 项转化来的基础预测结果，FTB 项已经在 s1 阶段被读出并保存。在 s2 和 s3 阶段只需直接读出便生成即可，但需要注意的一点就是保护 TAGE-SC 在 s2 及 s3 通道中产生的预测结果 &lt;code&gt;br_taken_mask&lt;/code&gt; 字段，这一字段为条件分支指令提供了精确的预测结果。对于 s1 通道，FTB 预测器不予更改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;s2 和 s3预测结果中的信号产生方式可参考以下列表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;hit&lt;/strong&gt; FTB表项是否命中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：&lt;code&gt;FTBBank&lt;/code&gt; 输出的 &lt;code&gt;read_hits&lt;/code&gt; 信号 valid 位有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;slot_valids&lt;/strong&gt; slot有效位，表示 ftb 项中的每个 slot 是否有效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;targets&lt;/strong&gt; 每个slot对应的跳转目标地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;offsets&lt;/strong&gt; 每个slot中的指令相对于预测块起始地址的偏移&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_jal&lt;/strong&gt; 预测块内包含jal指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_jalr&lt;/strong&gt; 预测块内包含jalr指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_call&lt;/strong&gt; 预测块内包含call指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_ret&lt;/strong&gt; 预测块内包含ret指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;last_may_be_rvi_call&lt;/strong&gt; 预测结果预测块末尾可能为一个RVI类型的call指令信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;is_br_sharing&lt;/strong&gt; 最后一个slot (tailSlot) 中存储的是条件分支指令信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式： FTB 项中对应字段导出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;fallThroughErr&lt;/strong&gt; FTB项中记录的 &lt;code&gt;pftAddr&lt;/code&gt; 有误&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：比较 &lt;code&gt;pftAddr&lt;/code&gt; 代表的预测块结束地址是否大于预测块的起始地址，如果小于，则代表出现错误，此信号置为有效。这种情况可能会发生在 pc 索引到错误的 FTB 项的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;fallThroughAddr&lt;/strong&gt; 预测块的结束地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：如果 &lt;code&gt;fallThroughErr&lt;/code&gt; 无效，则根据 &lt;code&gt;pftAddr&lt;/code&gt; 生成，否则将其设置为起始地址 + 预测宽度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;br_taken_mask&lt;/strong&gt; 分支预测结果，每个分支(slot)对应一位，表示该分支是否被预测为 taken&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：若 FTB 项命中并且 &lt;code&gt;always_taken&lt;/code&gt; 字段有效，则预测为 taken；否则由&lt;strong&gt;相应通道输入接口&lt;/strong&gt;中提供的 &lt;code&gt;br_taken_mask&lt;/code&gt; 信号来决定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;jalr_target&lt;/strong&gt; 本预测块中的 jalr 的跳转目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方式：FTB 项中 tailSlot 中的跳转目标。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ftb-meta&#34;&gt;FTB meta&lt;/h3&gt;
&lt;p&gt;在预测的第三周期，FTB 预测器会将本次预测的一些辅助信息输出至 &lt;code&gt;last_stage_meta&lt;/code&gt; 中，还会将读出的 FTB 项送到 &lt;code&gt;last_stage_ftrb_entry&lt;/code&gt; 接口中。&lt;/p&gt;
&lt;p&gt;FTB meta 中含有 &lt;code&gt;hit&lt;/code&gt; 和 &lt;code&gt;writeWay&lt;/code&gt; 两个信息，分别表示本次预测是否命中，以及在哪一路读出。之后更新通道中会产生本次预测的更新信息，这两个信息也会随之送入，来指导更新后的 FTB 项写入的位置。&lt;/p&gt;
&lt;h2 id=&#34;ftb-更新&#34;&gt;FTB 更新&lt;/h2&gt;
&lt;p&gt;update 通道中已经为我们指定好了 pc 以及新 FTB 项，并且还有 meta 信息中的 &lt;code&gt;hit&lt;/code&gt; 和 &lt;code&gt;writeWay&lt;/code&gt; 。如果 meta 中的 &lt;code&gt;hit&lt;/code&gt; 有效，说明之前这一 pc 对应的 FTB 项在存储器中是有存储的，我们只需将它写入到 writeWay 对应的路中即可。&lt;/p&gt;
&lt;p&gt;如果无效，说明以前没有存储，但现在是否存储我们并不知道，有可能在此更新请求之前，该 pc 对应的 FTB 项被另一个更新请求写入了。因此我们还需要给 FTBBank 发送一个读请求，来判断其中是否存在对应的 FTB 项。如果存在，下周期可直接写入到该位置，否则，通知 FTBBank 为其重新分配一个位置。&lt;/p&gt;
&lt;p&gt;因此 FTB 项的更新需要的周期数需随 hit 情况而定。&lt;/p&gt;
&lt;p&gt;我们首先来看一下 FTBBank是怎样处理更新的。&lt;/p&gt;
&lt;h3 id=&#34;ftbbank-更新&#34;&gt;FTBBank 更新&lt;/h3&gt;
&lt;p&gt;FTBBank 的更新接口如下，分为更新读接口和更新写接口两部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;u_req_pc&lt;/strong&gt; 更新读请求 pc&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Flipped(DecoupledIO(UInt(VAddrBits.W)))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;update_hits&lt;/strong&gt; 读出的命中情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Valid(UInt(log2Ceil(numWays).W))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;update_access&lt;/strong&gt; 有更新请求但 meta 信息指示未命中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;update_pc&lt;/strong&gt; 更新写请求 pc&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UInt(VAddrBits.W))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;update_write_data&lt;/strong&gt;  更新请求写入的数据，valid 有效的时候写&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Flipped(Valid(new FTBEntryWithTag))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;update_write_way&lt;/strong&gt;   更新请求写入的路索引&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UInt(log2Ceil(numWays).W))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;update_write_alloc&lt;/strong&gt; 是否需要分配FTB项（以前未命中）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对于更新读接口&lt;/strong&gt;，FTBBank 通过 &lt;code&gt;u_req_pc&lt;/code&gt; 信号获取更新读请求，该请求要比预测时的读请求优先级更高，在下一个周期，FTBBank 会将命中情况通过 &lt;code&gt;update_hits&lt;/code&gt; 接口送出。&lt;code&gt;update_access&lt;/code&gt; 仅用于 FTBBank 内部某些状态判断。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于更新写接口&lt;/strong&gt;，FTBBank 通过 &lt;code&gt;update_pc&lt;/code&gt; 信号获取更新写请求的 pc，并在 &lt;code&gt;update_write_data&lt;/code&gt; 有效时向 &lt;code&gt;update_write_way&lt;/code&gt; 对应的位置写入其中的数据。如果 &lt;code&gt;update_write_alloc&lt;/code&gt; 有效，说明不能直接写入请求中指定的位置，而是需要重新分配一个位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分配的策略如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果所有路均已填充，则使用伪 LRU 替换算法选取要替换的路&lt;/li&gt;
&lt;li&gt;若存在空路，否则选取空路。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;更新请求时序&#34;&gt;更新请求时序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;meta hit 有效&lt;/strong&gt;  若更新请求中 meta 指示为 hit，则我们直接根据更新请求中的信息，指定好写入的地址和数据即可，写入仅需一周期&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;meta hit 无效&lt;/strong&gt;  此时，在接收到更新请求后，我们将请求中的 pc 连接至 FTBBank 的读端口，读端口在下一周期将结果返回。由于时延问题，我们将这一结果保存，并在下一周期使用。下一周期根据结果中的命中情况指定是否需要设置 &lt;code&gt;update_write_alloc&lt;/code&gt;，并发出写请求。这时的更新过程总共花费了三个周期。&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
