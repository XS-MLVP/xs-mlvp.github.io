<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>香山微架构开放验证第一期：昆明湖BPU模块UT验证实战 – 香山</title>
    <link>https://xs-mlvp.github.io/xs-bpu/tags/%E9%A6%99%E5%B1%B1/</link>
    <description>Recent content in 香山 on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	  <atom:link href="https://xs-mlvp.github.io/xs-bpu/tags/%E9%A6%99%E5%B1%B1/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: BPU 顶层模块</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/modules/00_bpu_top/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/modules/00_bpu_top/</guid>
      <description>
        
        
        &lt;p&gt;BPU 顶层整体的功能和结构已经在之前的文档中粗略的描述，对于验证 BPU 顶层的同学来说，可能还需要更加细致的描述。由于 BPU 顶层功能较多，本节将 BPU 划分为了几大功能点进行更进一步的描述。但由于 BPU 顶层细节过多，更进一步的细节需参照代码进行理解。&lt;/p&gt;
&lt;h2 id=&#34;生成器维护方法&#34;&gt;生成器维护方法&lt;/h2&gt;
&lt;p&gt;通过香山的基础设计文档，我们知道，BPU 顶层是通过一个个生成器来维护 s0 周期的各类变量的，例如 PC、分支历史等，并且其核心概念是，通过预测结果重定向信号决定采用哪个流水级的结果。&lt;/p&gt;
&lt;p&gt;BPU 顶层中所有的生成器共有 6 个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;npcGen&lt;/strong&gt; 维护 pc&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ghistPtrGen&lt;/strong&gt; 维护全局历史指针&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ghvBitWriteGens&lt;/strong&gt; 维护全局历史写入数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;foledGhGen&lt;/strong&gt; 维护折叠历史&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lastBrNumOHGen&lt;/strong&gt; 维护上周期最后一个生效的分支指令位置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;aheadFhObGen&lt;/strong&gt; 维护分支历史最老位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，除了 &lt;code&gt;npcGen&lt;/code&gt; 以外，其余生成器都会在本文档中进行介绍。本节中我们着重探讨一下生成器的产生下一次预测的方法。&lt;/p&gt;
&lt;p&gt;在代码中你可以看到生成器用类似下面这种方式进行定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;PhyPriorityMuxGenerator&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;UInt&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，代码通过多条语句对生成器的数据来源进行注册：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;B&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;reg&lt;/span&gt;&lt;span style=&#34;color:#a40000&#34;&gt;，&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;s1_valid&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s1_target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;s2_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;s3_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3_target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;npcGen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;register&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;do_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;valid&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;do_redirect&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;bits&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cfiUpdate&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;target&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;...)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每一行被称作一次注册，在一次注册中第一个信号参数是数据有效信号，第二个信号参数包含具体的数据。 生成器的优先级也是按照注册的顺序来决定，越往后优先级越高，因此，同一时刻的优先级从低到高依次为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;s0 阻塞的数据&lt;/li&gt;
&lt;li&gt;根据 s1 预测结果更新后的数据&lt;/li&gt;
&lt;li&gt;根据 s2 预测结果更新后的数据&lt;/li&gt;
&lt;li&gt;根据 s3 预测结果更新后的数据&lt;/li&gt;
&lt;li&gt;BPU 外部重定向中的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样一来，我们就可以在预测结果重定向有效时，避免采用较早流水级的预测结果，而采用纠正后的预测结果。也使得我们可以将外部重定向请求作为最高优先级去处理。&lt;/p&gt;
&lt;p&gt;我们可以得出所有生成器产生 s0 信号的方法：&lt;strong&gt;在所有数据有效信号中，如果只有一个有效的，则选取它对应的数据，如果有多个数据有效信号生效，则选取优先级最高的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;全局分支历史&#34;&gt;全局分支历史&lt;/h2&gt;
&lt;p&gt;我们知道，全局分支历史在 BPU 顶层进行维护，维护的策略与 PC 的维护策略一致。即在每个阶段流水级预测结果产生之后，会根据相应信号对全局分支历史进行更新。&lt;/p&gt;
&lt;p&gt;顶层为了维护全局分支历史定义了两组信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ghv&lt;/strong&gt; 存储了全局分支历史（最大长度 256）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ghist_ptr&lt;/strong&gt; 全局分支历史指针，指向全局分支历史当前的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与 &lt;code&gt;s0_pc&lt;/code&gt;, &lt;code&gt;s1_pc&lt;/code&gt;, &lt;code&gt;s2_pc&lt;/code&gt; 一样，BPU 顶层为全局历史指针也维护了每一阶段的信号 &lt;code&gt;s0_ghist_ptr&lt;/code&gt;, &lt;code&gt;s1_ghist_ptr&lt;/code&gt;, &lt;code&gt;s2_ghist_ptr&lt;/code&gt; ，但 &lt;strong&gt;&lt;code&gt;ghv&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;中的内容是位置固定的，我们仅通过&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;ghist_ptr&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;来定位当前的全局分支历史从哪里开始。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;通过-ghist_ptr-计算当前全局分支历史&#34;&gt;通过 ghist_ptr 计算当前全局分支历史&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ghist_ptr&lt;/code&gt; 的使用仅在 BPU 顶层可见，而我们向子预测器传入的，是全局历史寄存器中的数据根据 &lt;code&gt;ghist_ptr&lt;/code&gt; 所移位之后的全局分支历史。&lt;strong&gt;在子预测器拿到的全局分支历史中，最低位对应全局分支历史的最新位，最高位对应全局分支历史的最老位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么是怎样进行移位的呢，我们首先来看一下全局历史是怎样在 &lt;code&gt;ghv&lt;/code&gt; 中进行存储的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Plain&#34; data-lang=&#34;Plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;|===== ghist =====&amp;gt;| =======&amp;gt;|
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;n                  ^         0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                   ghist_ptr
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上图所示，序列表示整个 &lt;code&gt;ghv&lt;/code&gt; 寄存器，&lt;code&gt;ghist_ptr&lt;/code&gt; 指向 &lt;code&gt;ghv&lt;/code&gt; 中的某个位置，这个位置代表了全局分支历史的最新位。当需要添加一位新的全局历史记录时，首先将 &lt;code&gt;ghist_ptr&lt;/code&gt; 减 1，然后将该位写在其所指向的位置。当 &lt;code&gt;ghist_ptr&lt;/code&gt; 减到 0 后，又会循环回来指向最高位，因此会覆盖之前写入的全局分支历史。&lt;/p&gt;
&lt;p&gt;但不管怎样，从 &lt;code&gt;ghist_ptr&lt;/code&gt; 所指向的位置开始，指针越增加，历史越老。因此，当&lt;strong&gt;我们需要计算当前全局分支历史时，只需要将&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;ghv&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;寄存器循环右移&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;ghist_ptr&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;位即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;全局分支历史的更新&#34;&gt;全局分支历史的更新&lt;/h3&gt;
&lt;p&gt;全局分支历史的更新策略与 &lt;code&gt;pc&lt;/code&gt; 更新的策略一致，在每一个流水级都需要根据当前流水级的预测结果生成一个 &lt;strong&gt;当前流水级的指针及&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;ghv&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;的更新说明&lt;/strong&gt;，最终都送给相关生成器来处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ghv&lt;/code&gt; 的更新说明即 用于指导 &lt;code&gt;ghv&lt;/code&gt; 寄存器的更新的某些信息。香山 BPU 中维护了两个信息来完成这一职责：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ghv_wdata&lt;/code&gt; 需要向 ghv 中写入的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ghv_wens&lt;/code&gt; 写入位掩码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终更新时，只需要将 &lt;code&gt;ghv_wens&lt;/code&gt; 所标识的位写入 &lt;code&gt;ghv_wdata&lt;/code&gt; 的对应位即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此每个流水级需要负责产生三组信息：&lt;/strong&gt;&lt;code&gt;ghist_ptr&lt;/code&gt;,&lt;code&gt;ghv_wdata&lt;/code&gt;, &lt;code&gt;ghv_wens&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;具体地，预测结果中最多含有两条分支指令，我们只需将实际情况来设置这几个信息即可，举几种情况的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有第一个槽有效，并且其中条件分支指令被预测为不跳转。则将 &lt;code&gt;ghv_wens&lt;/code&gt; 的下一个位置置 0 ，&lt;code&gt;ghv_wens&lt;/code&gt; 的对应位置置 1, 同时 &lt;code&gt;ghist_ptr&lt;/code&gt; 减一。&lt;/li&gt;
&lt;li&gt;两个槽都存放了条件分支指令，第一条被预测为不跳转, 第二条被预测为跳转。此时 &lt;code&gt;ghist_ptr&lt;/code&gt; 应该减二，并且其他两个信息应该指示向 &lt;code&gt;ghv&lt;/code&gt; 中写入 01。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此处在生成器中只维护了一个 &lt;code&gt;ghv_wdata&lt;/code&gt; 信息（通过 &lt;code&gt;ghvBitWriteGens&lt;/code&gt; 生成器维护），&lt;code&gt;ghv_wens&lt;/code&gt; 并没有通过生成器来维护。这是因为此处使用了一个小技巧，使用了生成器的 &lt;code&gt;ghv_wdata&lt;/code&gt; 最终输出的是被选中阶段的结果，而 &lt;code&gt;ghv_wens&lt;/code&gt; 将所有阶段的 &lt;code&gt;ghv_wens&lt;/code&gt; 进行&lt;strong&gt;按位或&lt;/strong&gt;来使用。&lt;/p&gt;
&lt;p&gt;这是基于如下考虑的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果较晚的流水线阶段有效。全局历史指针被恢复到较老的位置，即便被早期流水的 &lt;code&gt;ghv_wens&lt;/code&gt; 修改了较新位置的历史也没关系。&lt;/li&gt;
&lt;li&gt;如果较早的流水线阶段有效。全局历史指针继续向较新的位置更新，而后期流水线会因为 redirect 未生效而不把 &lt;code&gt;ghv_wens&lt;/code&gt; 置位。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分支折叠历史&#34;&gt;分支折叠历史&lt;/h2&gt;
&lt;p&gt;送入预测器的分支折叠历史也是由顶层 BPU 来维护的，BPU 为了缩短折叠历史的更新延迟，维护了很多变量，来支持分支折叠历史的快速更新，我们将会重点介绍这一策略，并介绍每一个变量的作用。&lt;/p&gt;
&lt;p&gt;在开始之前，我们先来看一下分支折叠历史是怎样定义的，结构又是怎样的。&lt;/p&gt;
&lt;h3 id=&#34;分支折叠历史-1&#34;&gt;分支折叠历史&lt;/h3&gt;
&lt;p&gt;如果你查看了 BPU 全局接口的文档，你就会知道，子预测器拿到的是一个不同长度位向量的数组，代表了各种长度的折叠历史，而这些&lt;strong&gt;折叠历史都是由全局分支历史压缩而成&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于全局分支历史，我们有一个存放全局分支历史的寄存器，长度为 256。为了方便举例，我们假设全局分支历史的长度为 15 位，并且经过移位之后，我们可以拿到一个这样的分支历史：最低位是最新的历史记录，最高位是最老的历史记录。&lt;/p&gt;
&lt;p&gt;此时如果我们需要用这 15 位，产生一个 6 位的折叠历史，会使用异或的策略进行压缩，具体过程是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Plain&#34; data-lang=&#34;Plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    h[5]         h[4]       h[3]    h[2]   h[1]   h[0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    h[11]        h[10]      h[9]    h[8]   h[7]   h[6]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^                                   h[14]  h[13]  h[12]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;---------------------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    h[5]^h[11]   h[4]^h[10]         ...           h[0]^h[6]^h[12]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即将其按照上面的方式排列之后，将每一位上的值进行异或，结果便是求出的长度为 6 的折叠历史。&lt;/p&gt;
&lt;h3 id=&#34;分支折叠历史更新方法&#34;&gt;分支折叠历史更新方法&lt;/h3&gt;
&lt;p&gt;此时我们想要对这一分支折叠历史进行更新，当我们向全局分支历史插入一位新历史时，是从最低位插入的，也就是说原来的 h[0] 变为了 h[1]，如果我们想求此时的分支折叠历史，只需要再进行一遍异或运算。但这样的效率太低了，因为异或的操作有可能变得特别长，我们可以来探寻一下一次更新对分支折叠历史的影响。&lt;/p&gt;
&lt;p&gt;上述例子中，插入一位新历史之前，6 位折叠历史的生成是按照下面这种排列生成的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Plain&#34; data-lang=&#34;Plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;h[5]   h[4]   h[3]  h[2]  h[1]  h[0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;h[11]  h[10]  h[9]  h[8]  h[7]  h[6]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    h[14] h[13] h[12]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;插入一位新历史之后变成了下面这样&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Plain&#34; data-lang=&#34;Plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;h[4]   h[3]   h[2]  h[1]  h[0]  h[new]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;h[10]  h[9]   h[8]  h[7]  h[6]  h[5]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;           (h[14])  h[13] h[12] h[11]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以发现一些规律&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Plain&#34; data-lang=&#34;Plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;插入前：
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;h[5]   {h[4]   h[3]  h[2]  h[1]  h[0] }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;h[11]  {h[10]  h[9]  h[8]  h[7]  h[6] }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       {             h[14] h[13] h[12]}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;插入后：
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{h[4]   h[3]   h[2]  h[1]  h[0] } h[new]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{h[10]  h[9]   h[8]  h[7]  h[6] } h[5]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{           (h[14])  h[13] h[12]} h[11]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;大括号中的内容发生了整体的左移，h[5] 和 h[11]，由最高位变到了最低位。那么表现在压缩后的历史上不就是我们常见的循环左移吗！&lt;/p&gt;
&lt;p&gt;但其中有且仅有两个位的值发生了变化，一个是新加入的 h[new]，一个是被舍弃掉的 h[14]。h[new] 肯定在第一位，被舍弃的位置也是固定的。&lt;strong&gt;因此我们想要完成一次更新，只需要知道 新插入历史的值 和 前一次历史的最老位即可&lt;/strong&gt;。循环移位后，将这两个位置根据实际情况进行一次修改便可拿到更新后的折叠历史。&lt;/p&gt;
&lt;h3 id=&#34;更新方法实现&#34;&gt;更新方法实现&lt;/h3&gt;
&lt;p&gt;BPU 顶层为了实现这种更新，正是通过维护最老位，这通过两个额外的变量来实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ahead_fh_oldest_bits&lt;/strong&gt;  全局分支历史的最老位，还额外往前存储了若干位&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;last_br_num_oh&lt;/strong&gt;  上一次预测最后一个生效的分支指令在第几个槽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里有一处为时序所优化的点，因为当流水级的预测结果出来时，全局历史指针才能通过跳转情况进行更新，等到全局历史指针更新完再来更新最老位会增加时延。因此我们将跳转情况维护起来，等到下一周期用的时候再来用跳转情况更新最老位。&lt;/p&gt;
&lt;p&gt;此时的最老位也需要多往前维护几位，因为在使用时，利用跳转情况更新后，前面较新的几位就会变成最老位了。&lt;/p&gt;
&lt;p&gt;所以与折叠历史相关的生成器共有三个：&lt;code&gt;foldedGhGen&lt;/code&gt;, &lt;code&gt;lastBrNumOhGen&lt;/code&gt;, &lt;code&gt;aheadFhObGen&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每次折叠历史更新时需要的信息分别是&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新前的折叠历史信息&lt;/li&gt;
&lt;li&gt;全局分支历史最老位(ahead_fh_oldest_bits）&lt;/li&gt;
&lt;li&gt;上次预测的跳转情况(last_br_num_oh)&lt;/li&gt;
&lt;li&gt;本次更新是否有指令跳转&lt;/li&gt;
&lt;li&gt;本次更新的跳转情况：最后一个生效的分支指令在第几个槽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每次折叠历史更新时，都需要根据 &lt;code&gt;last_br_num_oh&lt;/code&gt; 和 &lt;code&gt;ahead_fh_oldest_bits&lt;/code&gt; 求出真正的最老位，然后通过最老位与本次更新的跳转情况将其中的若干位进行修改，最后进行循环左移，便完成了更新操作。&lt;/p&gt;
&lt;h2 id=&#34;流水线控制方法&#34;&gt;流水线控制方法&lt;/h2&gt;
&lt;p&gt;流水线控制是 BPU 功能的核心，逻辑也最为复杂，BPU 顶层中所有的流水线控制信号如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;s1_valid, s2_valid, s3_valid&lt;/strong&gt; 表示对应流水数据生效&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;s1_ready, s2_ready, s3_ready&lt;/strong&gt; 表示对应流水已准备好继续上一流水级的预测&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;s1_component_ready, s2_component_ready, s3_component_ready&lt;/strong&gt; 表示对应流水子预测器的 ready 情况&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;s0_fire, s1_fire, s2_fire, s3_fire&lt;/strong&gt; 握手成功信号，表示该流水数据生效，并成功传递给了下一流水&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;s1_flush, s2_flush, s3_flush&lt;/strong&gt; 表示当前流水是否需要冲刷&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;s2_redirect, s3_redirect&lt;/strong&gt; 表示当前流水在 fire 的同时，是否预测结果不同，需要产生预测结果重定向&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;valid-ready-与-fire&#34;&gt;valid, ready 与 fire&lt;/h3&gt;
&lt;p&gt;我们会逐步来介绍每个信号的作用，首先我们来看 &lt;code&gt;fire&lt;/code&gt; 信号，这一信号表示的含义是流水线握手成功，数据成功传给了下一流水。这标志着本周期结束时，本流水级的预测也随之结束，下周期开始时，下一流水级的预测即将开始。&lt;/p&gt;
&lt;p&gt;这需要两个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;valid&lt;/code&gt; 本流水级的数据是有效的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ready&lt;/code&gt; 与 &lt;code&gt;component_ready&lt;/code&gt; 分别指示了 BPU 顶层与预测器的下一流水级是否就绪。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当这两个信号同时置高时，&lt;code&gt;fire&lt;/code&gt; 信号有效，表示握手成功。如果我们单独把一次预测拿出来，那么时序应该是这样的（实际中，大多数时间每个流水线都是一直有效的）：&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;1.png&#34; width=&#34;400px&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;上文中提到的四组信号，除了 &lt;code&gt;component_ready&lt;/code&gt; 是由预测器输出，其余信号皆需 BPU 顶层来维护，而最终暴露给子预测器的，只有 &lt;code&gt;fire&lt;/code&gt; 一组信号。&lt;/p&gt;
&lt;p&gt;我们接下来以 s2 为例分别来看每个信号是如何维护的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ready&lt;/strong&gt; &lt;strong&gt;信号&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;s2_ready&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_fire&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;s2_valid&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该赋值语句是一个组合电路赋值，也就是说，&lt;code&gt;s2_ready&lt;/code&gt; 信号是与本周期的 &lt;code&gt;s2_fire&lt;/code&gt; 和 &lt;code&gt;s2_valid&lt;/code&gt; 直接相关联的，分为以下两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;s2_valid&lt;/code&gt; 信号在本周期无效，说明 s2 流水级目前是空的，自然可以接受新的数据，则 &lt;code&gt;s2_ready&lt;/code&gt; 有效&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s2_valid&lt;/code&gt; 信号在本周期有效，说明 s2 流水级目前有数据还未传递给下一级，但如果 &lt;code&gt;s2_fire&lt;/code&gt; ，那么本周期就会传递给下一级。此时 &lt;code&gt;s2_ready&lt;/code&gt; 有效，刚好指示数据可以在下一拍流入。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;valid 信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;s2_valid&lt;/code&gt; 信号目前为止维护是相对简单的，与 &lt;code&gt;s1_fire&lt;/code&gt; 信号和 &lt;code&gt;s2_ready&lt;/code&gt; 信号相关。其关系为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;s1_fire&lt;/code&gt; 有效，说明数据传进来，下一周期 &lt;code&gt;s2_valid&lt;/code&gt; 有效。&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;s2_fire&lt;/code&gt; 有效，说明数据流出去，下一周期 &lt;code&gt;s2_valid&lt;/code&gt; 无效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;fire 信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fire 信号相对特殊，但对于中间的流水级来说，维护非常简单，例如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;s2_fire&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_valid&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3_components_ready&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3_ready&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;只需考虑当前流水级的 &lt;code&gt;valid&lt;/code&gt; 和下一流水级的 &lt;code&gt;ready&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;但对 s0_fire 来说，没有 valid 信号，因此其直接等于 &lt;code&gt;s1_components_ready &amp;amp;&amp;amp; s1_ready&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于 s3_fire 来说，没有下一级的 ready 信号，因此其直接等于 &lt;code&gt;s3_valid&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;加入-flush-和-redirect&#34;&gt;加入 flush 和 redirect&lt;/h3&gt;
&lt;p&gt;我们知道，当流水线出现预测结果不同时，需要产生预测结果重定向信号，并且将之前的流水线清空。&lt;code&gt;flush&lt;/code&gt; 和 &lt;code&gt;redirect&lt;/code&gt; 正是在做这两项工作。&lt;code&gt;redirect&lt;/code&gt; 表示当前流水级是否需要重定向，&lt;code&gt;flush&lt;/code&gt; 则表示当前流水级是否需要冲刷。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;redirect 信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;s2_redirect&lt;/code&gt; 的产生方式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;s2_redirect&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_fire&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_redirect_s1_last_pred&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;也就是说，当 &lt;code&gt;s2_fire&lt;/code&gt; 时，并且 s2 的预测结果与上一周期保存的 s1 预测结果不同时，这个信号便有效。之后该信号将会连接到子预测器的输入，与 BPU 预测结果的输出，分别指导子预测器和  FTQ  的状态恢复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flush 信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;flush 信号是用于指导流水线冲刷的，例如 s3 重定向有效时，说明错误的预测结果已经流入流水线， s1 和 s2 此时全都是基于错误的结果来预测的，因此需要进行流水线冲刷，使之前的流水级都暂停工作，等待新的预测结果流入。&lt;/p&gt;
&lt;p&gt;具体地，他们之间有如下关系：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_flush&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3_flush&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3_redirect&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#000&#34;&gt;s1_flush&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_flush&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;s2_redirect&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;也就是说，某个流水级 &lt;code&gt;redirect&lt;/code&gt; 有效，之前的流水级的 flush 全都会被置为有效。那么 flush 具有什么作用呢？答案是指导 valid 信号，如果本周期 valid 信号有效，但 fire 信号未生效，说明错误的数据没有被下一流水取走，此时 flush 有效后，在下一周期 valid 就会立即变为无效，以这种方式来避免错误数据长期存储在流水线中。&lt;/p&gt;
&lt;p&gt;但 flush 信号对 valid 信号的影响，也根据每一个流水级的不同而有一定差异。例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;s1 流水级。虽然 flush 有效，但是如果此时 &lt;code&gt;s0_fire&lt;/code&gt; 有效，说明新数据流入，那么下周期 valid 依然有效。&lt;/li&gt;
&lt;li&gt;s2 流水级。flush 有效，那么必定下周期不会 valid（因为 s1 也肯定被 flush），此时就可以直接将 valid 置为无效。但还存在一种特殊情况，&lt;code&gt;s2_redirect&lt;/code&gt; 发生时，&lt;code&gt;s2_flush&lt;/code&gt; 并没有被置为有效，此时如果发生 &lt;code&gt;s1_fire&lt;/code&gt;，s1 的错误预测结果也可能流入，此时还需根据 &lt;code&gt;s1_flush&lt;/code&gt; 信号来决定 &lt;code&gt;s2_valid&lt;/code&gt; 是否有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;flush 的使用较复杂，更详细的细节还需参考代码进行理解。&lt;/p&gt;
&lt;h2 id=&#34;重定向恢复逻辑&#34;&gt;重定向恢复逻辑&lt;/h2&gt;
&lt;p&gt;当 FTQ 发往 BPU 的重定向请求生效时就说明所有流水级的预测结果都是不正确的，此时应该将所有流水级进行冲刷，这可以通过将 &lt;code&gt;s3_flush&lt;/code&gt; 置为有效来实现。因此有&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Scala&#34; data-lang=&#34;Scala&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#000&#34;&gt;s3_flush&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;redirect_req&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;valid&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 BPU 中，重定向请求送入后被延迟一周期才正式使用，因此 &lt;code&gt;s1_valid&lt;/code&gt; 的信号也需要对 &lt;code&gt;flush&lt;/code&gt; 信号的响应做出一些改变。当重定向请求（延迟前）有效时，&lt;code&gt;s1_valid&lt;/code&gt; 下周期立即被置为无效，不需要再去参考 &lt;code&gt;s0_fire&lt;/code&gt; 信号了。&lt;/p&gt;
&lt;p&gt;此时 &lt;code&gt;npcGen&lt;/code&gt; 等生成器也需要直接去采用重定向请求中的数据来生成，这就相当于将 BPU 的状态重定向到出错之前状态的过程。但注意 BPU 默认的重定向等级为 &lt;code&gt;flushAfter&lt;/code&gt; ，即重定向请求会对应一条预测错误的指令，而 BPU 会认为这条指令虽然预测错了，但是已经被纠正并且交由后端执行了，因此下一次预测可以直接从下一条指令开始。&lt;/p&gt;
&lt;p&gt;所以在重定向恢复时，不仅需要将重定向接口中的信息恢复，还需要将这条预测错误的指令的执行情况也更新到历史中去。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 何为分支预测</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/basic/00_bp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/basic/00_bp/</guid>
      <description>
        
        
        &lt;h2 id=&#34;为何需要分支预测&#34;&gt;为何需要分支预测？&lt;/h2&gt;
&lt;p&gt;分支预测主要有两方面的原因：一是&lt;strong&gt;程序的执行流中含有分支指令&lt;/strong&gt;，二是&lt;strong&gt;高性能处理器使用流水线设计&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;程序的执行流中含有分支指令&#34;&gt;程序的执行流中含有分支指令&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;20&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述是一段C语言代码，这段代码首先定义了三个变量 x, y 和 result，然后根据 x 和 y 值的大小情况对result进行赋值。可以发现，程序在前三行对变量进行赋值时是顺序往下执行的，而在第 5 行时，由于 if 指令的出现，程序产生了分支，从第 5 行直接跳转到了第 8 行继续运行，这就造成了程序执行的&lt;strong&gt;分支&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;翻译成 RISC-V 汇编之后的代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;li&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;a0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;10&lt;/span&gt;               &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# x = 10
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;li&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;a1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;20&lt;/span&gt;               &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# y = 20
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;li&lt;/span&gt;  &lt;span style=&#34;color:#000&#34;&gt;a2&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;                &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# result = 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;blt&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;else_branch&lt;/span&gt;  &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 如果 x &amp;lt; y，则跳转到 else_branch
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;add&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a2&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a1&lt;/span&gt;           &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 否则执行 result = x + y
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;end&lt;/span&gt;                    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 跳转到 end
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f57900&#34;&gt;else_branch:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a2&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a1&lt;/span&gt;           &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# result = x - y
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f57900&#34;&gt;end:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以发现程序依然保持着先前的分支行为，在代码的前三行，指令顺序执行，之后，在程序的第 5 行，出现了一条特殊指令blt ，我们称之为分支指令，它会根据 x 和 y 的大小关系决定指令流顺序往下执行还是跳转到其他地方，该指令的出现导致程序的执行出现了分支。&lt;/p&gt;
&lt;h3 id=&#34;高性能处理器使用流水线设计&#34;&gt;高性能处理器使用流水线设计&lt;/h3&gt;

&lt;figure&gt;
    &lt;img src=&#34;f4669877-a9f9-4f5d-9fe3-8ba976973513.png&#34; width=&#34;400px&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;因此有了&lt;strong&gt;分支预测&lt;/strong&gt;的概念，如果我们可以在执行结果产生之前，精准的预测出下一条指令的地址，便可以使处理器一直高效的运行下去。&lt;/p&gt;
&lt;h2 id=&#34;分支预测的可行性&#34;&gt;分支预测的可行性&lt;/h2&gt;
&lt;p&gt;为什么可以进行分支预测呢？我们看接下来一个例子&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;128&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假设该条指令将被重复执行，并且 data 从 0 开始递增，即 data = 0, 1, 2, 3 &amp;hellip; 128, 129&amp;hellip;，接下来我们可以分析每次执行这条指令的行为。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Plain&#34; data-lang=&#34;Plain&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;T = branch taken
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;N = branch not taken
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;data   = 0, 1, 2, 3, s, ... 126, 127, 128, 129, 130, ... 250, 251, 252, ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;branch = N  N  N  N  N  ...   N    N    T    T    T  ...   T    T    T  ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       = NNNNNNNNNNNN ... NNNNNNNTTTTTTTTT ... TTTTTTTTTT  (easy to predict)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看出，在前 128 次，该分支都是 Not Taken （条件不成立）的，但在 128 次之后，分支一直都是 Taken （条件成立）的。如果我们用最简单的方法根据上一次是否 Taken，来预测本次是否 Taken，在整个预测过程中，我们只会产生一次预测错误。&lt;/p&gt;
&lt;p&gt;上述现象的产生是源于一个基本事实的——&lt;strong&gt;分支指令是否跳转与该条指令以往的跳转行为有关联&lt;/strong&gt;，我们通过总结以往跳转的规律，便可以对本次跳转产生较为精准的预测，这也使得分支预测变得可能。&lt;/p&gt;
&lt;p&gt;事实上，分支指令的跳转还会与其他分支指令的跳转情况等因素相关，充分发掘有效信息，产生精准预测结果，是分支预测的主要任务之一。&lt;/p&gt;
&lt;h2 id=&#34;分支预测的基本类型&#34;&gt;分支预测的基本类型&lt;/h2&gt;
&lt;p&gt;在RISC-V 中，分支指令包含两种类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;条件分支指令&lt;/strong&gt; &lt;strong&gt;(beq, bne, blt, bge, bltu, bgeu)&lt;/strong&gt;    对于这类指令，是否跳转时候其中的条件决定，跳转目标可以在指令中获取，因此我们需要预测该指令是否跳转&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无条件跳转指令&lt;/strong&gt; &lt;strong&gt;(jal, jalr)&lt;/strong&gt;    对于这类指令，每当执行到它时是总是跳转，但跳转目标有可能由寄存器执行，因此我们需要预测该指令的跳转地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;幸运的是，由于RISC-V架构设计的简洁，我们不需要处理条件跳转指令，每一个需要我们预测的跳转指令都是无条件的，这也给我们的设计提供了便利。&lt;/p&gt;
&lt;p&gt;上述分析中，我们可以总结出分支预测的两大基本类型——&lt;strong&gt;方向预测&lt;/strong&gt; 和 &lt;strong&gt;目标地址预测&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;分支指令的方向预测&#34;&gt;分支指令的方向预测&lt;/h3&gt;
&lt;p&gt;分支指令的方向预测对应到 RISC-V 指令就是条件分支指令，我们需要预测它是否需要跳转，也就是分支的方向，因此叫做方向预测。&lt;/p&gt;
&lt;h4 id=&#34;两位饱和计数器&#34;&gt;两位饱和计数器&lt;/h4&gt;
&lt;p&gt;方向预测有一种非常简单并且十分高效的预测方法，叫做叫做饱和计数器法，它的大致思想可以参考下图。&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;c7e5cf3e-8131-430b-a728-659fb7775f53.png&#34; width=&#34;700px&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;两位饱和计数器被视作一个状态机，我们为每一个分支指令都维护这样一个状态机器，当一条分支指令发生跳转时，对应上图中的状态向右移动，否则状态向左移动。这样在下次遇到这条分支指令时，我们首先查找到它的两位饱和计数器，如果状态更偏右则预测其跳转，否则预测其不跳转。&lt;/p&gt;
&lt;p&gt;当然，为每一条分支指令都维护一个两位饱和计数器是不现实的，因此在实际中，我们通常会采取PC部分位，或哈希的方法来索引两位饱和计数器，如下图所示。&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;e2cf0e6d-f050-4aff-bee3-c72a2b9004e1.png&#34; width=&#34;700px&#34;/&gt; 
&lt;/figure&gt;

&lt;h4 id=&#34;分支历史&#34;&gt;分支历史&lt;/h4&gt;
&lt;p&gt;分支历史是方向预测中非常常用的数据，也是大多分支预测算法的基础，因为分支历史是指令以往跳转行为最直接的展示。&lt;/p&gt;
&lt;p&gt;分支历史有以下两种基本类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;局部分支历史&lt;/strong&gt;    为每一条分支指令维护一组寄存器，记录该条指令的历史跳转情况
&lt;ul&gt;
&lt;li&gt;例如： 0101000000101   （0代表不跳转，1代表跳转）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全局分支历史&lt;/strong&gt;    所有指令共用一组寄存器，记录程序执行过程中的分支跳转情况
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    beg a0, a1, label1          不跳转  记录0
    bne a1, a2, label2          不跳转  记录0
-&amp;gt;  beq a2, a3, label4          跳转    记录1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;​执行完三条不同的分支指令后，全局分支历史变为 001&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分支指令的目标地址预测&#34;&gt;分支指令的目标地址预测&lt;/h3&gt;
&lt;p&gt;RISC-V架构中，分支指令的目标地址预测是指对无条件跳转指令（如jal、jalr）的跳转目标地址进行预测。由于这类指令总是执行跳转操作，我们需要预测其跳转的目标地址。&lt;/p&gt;
&lt;h4 id=&#34;分支目标缓存btb&#34;&gt;分支目标缓存（BTB）&lt;/h4&gt;
&lt;p&gt;BTB 是目标地址预测的一种常用方法，它的核心思想是使用一个缓存来存储以往无条件跳转指令的跳转目标，之后如果再次执行到这一条无条件跳转指令，就可以查看BTB中是存在该指令的记录，将记录的跳转目标作为本次预测的跳转目标。&lt;/p&gt;
&lt;p&gt;示意图如下&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;540d418a-2760-4724-aad4-502bd0775185.png&#34; width=&#34;500px&#34;/&gt; 
&lt;/figure&gt;

&lt;h3 id=&#34;预测指令类型&#34;&gt;预测指令类型&lt;/h3&gt;
&lt;p&gt;我们已经知道，在分支预测中，对于条件分支指令来说，我们需要预测其方向，对于无条件跳转指令来说，我们需要预测其跳转目标。但是出现了一个问题，拿到一个需要预测的PC之后，我们并不清楚这个PC所对应的指令是什么，也就是说我们根本不知道当前指令到底是一条普通指令还是一条分支指令，也就无法进行预测了。&lt;/p&gt;
&lt;p&gt;如何解决呢？可以采取的一种方法是，在取出指令之后，对这条指令的行为进行预测。但取值需要从 ICache 或 Memory 中去取，有可能会耗费多个周期，这是这种方法的一大弊端。&lt;/p&gt;
&lt;p&gt;更好的一种方法是，直接预测指令的类型，拿到一个PC之后，可以直接预测出这条指令是否是分支指令，并对指令行为进行预测。这样一来，我们就没有必要等待取值完成，并且预测出来的结果还可以指导 CPU 到什么地方去取值。&lt;/p&gt;
&lt;p&gt;类型预测的方法，可以与BTB相似，在缓存中的某个字段中加入指令的类型，以供下一次预测使用。&lt;/p&gt;
&lt;h2 id=&#34;分支预测的一般步骤&#34;&gt;分支预测的一般步骤&lt;/h2&gt;
&lt;p&gt;通过本节知识的介绍，我们可以总结出分支预测的一般步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取 PC&lt;/li&gt;
&lt;li&gt;预测是否是分支指令
&lt;ol&gt;
&lt;li&gt;如果是条件分支指令，预测其跳转方向和跳转目标&lt;/li&gt;
&lt;li&gt;如果是无条件跳转指令 ，预测其跳转目标&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意，由于在预测中需要预测指令类型，没有获取到指令具体内容，所以对于条件分支指令来说，预测它的跳转目标也变成了我们的工作。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 香山分支预测单元（BPU）基础设计</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/basic/</guid>
      <description>
        
        
        &lt;p&gt;在处理器设计中，一个设计优秀的分支预测器（BPU）是提高处理器性能的关键部件，它负责指导处理器的取值，确定处理器下一步要到哪里取出指令并执行。BPU 是一条指令生命周期最开始的地方，因此想要深入探究一个高性能处理器，从BPU开始是一个很好的选择。&lt;/p&gt;
&lt;p&gt;在香山中亦是如此，香山作为一个乱序六发射的高性能处理器，自然需要一个准确度高、预测效率高的分支预测单元。而一个分支预测单元的设计实际中往往需要考虑很多因素，例如时序、结构的复杂度、占用的硅片面积、预测的准确度、预测错误时恢复的速度等等。香山处理器的分支预测单元在这些因素之间都做到了比较好的权衡，通过许多巧妙的设计使其拥有了很高的分支预测效率与准确度，为后端的指令供给提供了基础的保障。&lt;/p&gt;
&lt;p&gt;在本节中，我们将会介绍香山预测单元的基础设计，通过阅读本节，可以掌握如下知识：&lt;/p&gt;


&lt;div class=&#34;pageinfo pageinfo-primary&#34;&gt;
&lt;ul&gt;
&lt;li&gt;分支预测的基本概念&lt;/li&gt;
&lt;li&gt;香山分支预测单元的基本预测单位——分支预测块&lt;/li&gt;
&lt;li&gt;香山分支预测单元的对外交互接口&lt;/li&gt;
&lt;li&gt;香山分支预测单元的基本结构&lt;/li&gt;
&lt;li&gt;香山分支预测单元的基础时序&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;

&lt;p&gt;任何参与BPU众包验证工作的同学，都需要率先阅读本节，以便对香山分支预测单元有基础了解。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 重要结构及接口文档</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/ports/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/ports/</guid>
      <description>
        
        
        &lt;p&gt;本文档将会对 BPU 中的重要结构以及对外接口进行描述，描述粒度将深入代码级别，文档中描述的结构将与香山分支预测单元 Chisel 版本代码保持一致，信号结构及名称亦来自于 Chisel 版本代码。&lt;/p&gt;
&lt;p&gt;文档适用于已经了解了香山分支预测单元基础设计，并想要深入了解信号细节的同学使用。可以根据验证需要的内容有选择的进行阅读，或随时进行查阅。&lt;/p&gt;
&lt;p&gt;其中，FTB项与完整预测结果接口涉及 BPU 产生预测结果的方式，建议每位同学进行阅读。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 子模块文档</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/modules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/modules/</guid>
      <description>
        
        
        &lt;p&gt;本部分文档将会详细介绍香山分支预测单元的每一个模块，包括 BPU 顶层和五个子预测器。&lt;/p&gt;
&lt;p&gt;在每一个模块的文档中，我们将会详细介绍该模块在香山分支预测单元中所发挥的作用，以及该模块的算法原理、模块结构和时序等。&lt;/p&gt;
&lt;p&gt;负责一个模块验证的同学需要重点阅读对应文档并结合代码进行理解，其他文档亦可进行阅读以帮助你对香山分支预测单元整体功能的理解。理解过程中，你可能需要时刻回顾之前文档中所描述的基础设计思想及接口信号的含义。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
