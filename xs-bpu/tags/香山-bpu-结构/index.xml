<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>香山 BPU 结构 on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</title>
    <link>https://open-verify.cc/xs-bpu/tags/%E9%A6%99%E5%B1%B1-bpu-%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 香山 BPU 结构 on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/xs-bpu/tags/%E9%A6%99%E5%B1%B1-bpu-%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>香山分支预测单元结构介绍</title>
      <link>https://open-verify.cc/xs-bpu/docs/basic/02_xsbpu_structure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/basic/02_xsbpu_structure/</guid>
      <description>&lt;h2 id=&#34;bpu-是如何整合内部子预测器的&#34;&gt;BPU 是如何整合内部子预测器的？&lt;/h2&gt;&#xA;&lt;p&gt;我们已经知道香山 BPU 采用的是多预测器，多流水线方案。其中为了适配多流水线，BPU 采用了三通道结果输出接口。但是又是如何适配多预测器的呢？这就要求我们进一步深入 BPU，探究其内部结构。&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;1.png&#34; width=&#34;600px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;上图为香山文档中的 BPU 架构图，目前我们只需要关心这样一个信息，内部的所有子预测器都被包在了一个叫做 &lt;code&gt;Composer&lt;/code&gt; 的结构中。BPU只需要和 &lt;code&gt;Composer&lt;/code&gt; 交互。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Composer&lt;/code&gt; 是什么？我们不妨先看一下香山代码中对于他们的定义。&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;2.png&#34; width=&#34;700px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;可以发现，&lt;code&gt;Composer&lt;/code&gt; 以及五个子预测器有一个共同的特点，他们全部继承于 &lt;code&gt;BasePredictor&lt;/code&gt; 基类。并且接口已经在 &lt;code&gt;BasePredictor&lt;/code&gt; 类中定义好。换句话说就是，&lt;code&gt;Composer&lt;/code&gt;&lt;strong&gt;和五个子预测器都拥有相同的接口&lt;/strong&gt;！BPU 顶层可以直接把 &lt;code&gt;Composer&lt;/code&gt; 也当做一个子预测器，而无需关心内部是怎么连接子预测器的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;子预测器接口&#34;&gt;子预测器接口&lt;/h2&gt;&#xA;&lt;p&gt;接下来我们会查看子预测器接口是怎样的。该接口将涉及到 &lt;code&gt;Composer&lt;/code&gt; 与 BPU 顶层的交互，还会涉及到各子预测器与 &lt;code&gt;Composer&lt;/code&gt; 的交互。&lt;/p&gt;&#xA;&lt;p&gt;我们先以 &lt;code&gt;Composer&lt;/code&gt; 为例，说明子预测器接口的结构&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;3.png&#34; width=&#34;400px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;如上图所示，&lt;code&gt;Composer&lt;/code&gt; 的三通道预测结果被直接输出至 BPU 外部，并且还有一组三通道预测结果从BPU内部连接至 &lt;code&gt;Composer&lt;/code&gt; ，但由于预测结果是由 &lt;code&gt;Composer&lt;/code&gt; 产生，因此 BPU 会将一个空的预测结果传递给 &lt;code&gt;Composer&lt;/code&gt; ，这样做的意义是，使子预测器形成了一个“加工”的作用，子预测器会将输入的预测结果进行加工，然后再输出加工过后的预测结果。&lt;/p&gt;&#xA;&lt;p&gt;接下来，BPU 顶层会为流水线提供预测所需要的信息。首先是 &lt;strong&gt;PC&lt;/strong&gt; 和&lt;strong&gt;分支历史记录&lt;/strong&gt;（包括全局历史和全局折叠历史），接下来 BPU 会和 &lt;code&gt;Composer&lt;/code&gt; 之间连接一些&lt;strong&gt;流水线控制信号&lt;/strong&gt;，最后 BPU 将外部输入的&lt;strong&gt;重定向请求接口&lt;/strong&gt;和&lt;strong&gt;更新接口&lt;/strong&gt;直接连接至 &lt;code&gt;Composer&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;最终可以简单给出子预测器接口的定义（详细定义请前往接口文档进行查看）：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;in&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;(s1, s2, s3)&lt;/strong&gt; 预测信息输入&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;s0_pc&lt;/strong&gt;         需要预测的PC&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ghist&lt;/strong&gt;            全局分支历史&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;folded_hist&lt;/strong&gt; 全局折叠历史&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;out  (s1, s2, s3)&lt;/strong&gt; 预测信息输出&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;流水线控制信号&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;s0_fire, s1_fire, s2_fire, s3_fire&lt;/strong&gt; 相应流水级是否工作&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;s2_redirect, s3_redirect&lt;/strong&gt;              后续流水级发现预测错误时重定向信号&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;s1_ready, s2_ready, s3_ready&lt;/strong&gt;    子预测器相应流水级是否就绪&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;update&lt;/strong&gt;        更新请求&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;redirect&lt;/strong&gt;        重定向请求&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;子预测器之间的连接&#34;&gt;子预测器之间的连接&lt;/h2&gt;&#xA;&lt;p&gt;我们已经清楚各个子预测器之间的接口与&lt;code&gt;Composer&lt;/code&gt; 的接口是相同的，并且我们也已经知道了 &lt;code&gt;Composer&lt;/code&gt;是如何连向顶层 BPU 的，本小节将会说明子预测器是如何在 &lt;code&gt;Composer&lt;/code&gt; 内部进行连接的。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
