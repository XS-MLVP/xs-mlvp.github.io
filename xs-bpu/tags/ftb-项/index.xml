<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FTB 项 on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</title>
    <link>https://open-verify.cc/xs-bpu/tags/ftb-%E9%A1%B9/</link>
    <description>Recent content in FTB 项 on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="https://open-verify.cc/xs-bpu/tags/ftb-%E9%A1%B9/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>FTB项与完整预测结果接口</title>
      <link>https://open-verify.cc/xs-bpu/docs/ports/00_ftb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://open-verify.cc/xs-bpu/docs/ports/00_ftb/</guid>
      <description>&lt;h2 id=&#34;ftb-项&#34;&gt;FTB 项&lt;/h2&gt;&#xA;&lt;p&gt;FTB 项是香山中分支预测块的核心数据结构，它存储了生成一个分支预测块所需的信息。在BPU进行预测时，初始的分支预测块首先由一个读出的 FTB 项生成。然后，这个分支预测块会传递到后续的预测器中，后续的预测器会读取其中的信息并加以修改，生成最终的预测结果。&lt;/p&gt;&#xA;&lt;p&gt;因此，要理解分支预测块的结构，首先需要理解FTB项的结构。一个FTB项对应着一个分支预测块，其大致结构如下：&lt;/p&gt;&#xA;&#xA;&lt;figure&gt;&#xA;    &lt;img src=&#34;1.png&#34; width=&#34;750px&#34;/&gt; &#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;首先，需要明确一个信息：无论是分支预测块还是FTB项，它们可以容纳的指令数量都被设定为一个特定的上限（在香山当前版本中为16条RVC指令），被称为&lt;strong&gt;最大预测长度&lt;/strong&gt;。这意味着，如果我们需要记录分支预测块内某一条指令的位置，可以使用一个固定长度的位向量，来指定这条指令相对于预测块起始地址的偏移量。&lt;/p&gt;&#xA;&lt;p&gt;分支预测块执行流程的决定因素是其中的分支指令信息。其余的指令都被视为普通指令，不影响程序的执行流。因此，在一个分支预测块中，我们只需记录下其中的分支指令位置即可，而普通指令的位置我们并不关心。&lt;/p&gt;&#xA;&lt;p&gt;因此，FTB项中定义了两种类型的&lt;strong&gt;分支指令槽（slot）&lt;/strong&gt;——&lt;code&gt;brSlots&lt;/code&gt;和&lt;code&gt;tailSlot&lt;/code&gt;，用于存储分支预测块中的分支指令。目前香山版本中，&lt;code&gt;brSlots&lt;/code&gt;只含有一个 slot，而 &lt;code&gt;tailSlot&lt;/code&gt; 则是一个单独的 slot，总计含有两个 slot。&lt;/p&gt;&#xA;&lt;p&gt;在最大预测长度内的指令中，如果出现了分支指令，FTB项会将其记录在对应的slot内，并将该slot置为有效。如果分支指令出现过多，达到了FTB项的容纳上限，那么超出上限的分支指令则会交给下一个FTB项来存储。在每个 slot中，我们会记录一条分支指令相对于预测块起始地址的偏移量（offset），同时还会记录其跳转目标地址等信息。&lt;/p&gt;&#xA;&lt;h3 id=&#34;唯一的-tailslot&#34;&gt;唯一的 tailSlot&lt;/h3&gt;&#xA;&lt;p&gt;在RISC-V中，分支指令主要分为两种类型：条件分支和无条件跳转。因此，&lt;strong&gt;对于一个分支预测块来说，最多只会包含一条无条件跳转指令&lt;/strong&gt;。因为一旦执行到这条指令，程序的执行流就会发生改变，后续的指令将不再执行。因此，我们定义了一种类型的 slot 叫做 &lt;code&gt;tailSlot&lt;/code&gt;，专门用来存储这条无条件跳转指令。而对于条件分支指令，则将它们存储在&lt;code&gt;brSlots&lt;/code&gt;中。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;tailSlot&lt;/code&gt;如其名，位于整个预测块中的最后一个 slot。这也是因为一旦填充了无条件跳转指令，程序必定跳转，之后的指令就由其他预测块进行处理，因此后续的指令情况我们无需关心。但在无条件跳转指令之前的指令中，我们需要关心是否存在条件分支指令，因为条件分支指令既有可能跳转，也有可能不跳转。因此，我们需要记录下条件分支指令的相关信息。&lt;/p&gt;&#xA;&lt;h3 id=&#34;tailslot-共享&#34;&gt;tailSlot 共享&lt;/h3&gt;&#xA;&lt;p&gt;考虑一种情况：如果从预测块起始PC开始直到最大预测长度，都没有出现无条件跳转指令，反而出现了两条条件分支指令，这样一来，&lt;code&gt;tailSlot&lt;/code&gt; 就会空闲，而第二条条件分支指令又无法存储，造成空间的浪费。&lt;/p&gt;&#xA;&lt;p&gt;为了解决这个问题，香山采用了一种方法：设置一个 &lt;code&gt;sharing&lt;/code&gt; 标记。我们可以直接将第二条分支指令存储到&lt;code&gt;tailSlot&lt;/code&gt; 中，并将sharing标记设置为真，表示第二条条件分支指令共享了无条件跳转指令的 &lt;code&gt;tailSlot&lt;/code&gt;。这样，就有效利用了tailSlot的空间。&lt;/p&gt;&#xA;&lt;p&gt;预测块中的 &lt;code&gt;isCall&lt;/code&gt;、&lt;code&gt;isRet&lt;/code&gt;和&lt;code&gt;isJalr&lt;/code&gt;字段是为&lt;code&gt;tailSlot&lt;/code&gt;服务的。如果tailSlot中记录的是无条件跳转指令，这几个字段会进一步指示该跳转指令的类型。在FTB项中还有一个字段 &lt;code&gt;always_taken&lt;/code&gt;，用来记录每个Slot中存储的条件分支指令是否总是被预测为跳转。如果是的话，后续的预测器可以直接采用这一预测结果。&lt;/p&gt;&#xA;&lt;p&gt;通过FTB项，我们可以得知一个分支预测块中的指令情况，包括分支指令的位置、类型等。这些信息会交给后续的预测器，由后续的预测器来预测更为精确的跳转目标、是否跳转等信息。&lt;/p&gt;&#xA;&lt;h2 id=&#34;ftb-项完整结构-ftbentry&#34;&gt;FTB 项完整结构 （FTBEntry）&lt;/h2&gt;&#xA;&lt;p&gt;接口定义: &lt;code&gt;src/main/scala/xiangshan/frontend/FTB.scala&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;本节中描述了 FTB 项的完整结构定义，其所含的信号如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;valid&lt;/strong&gt;: FTB表项是否有效。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;brSlots&lt;/strong&gt;: 条件分支指令槽。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Vec(numBrSlot, new FtbSlot(BR_OFFSET_LEN))&lt;/code&gt; （接口列表详见FtbSlot）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;tailSlot&lt;/strong&gt;: 无条件跳转指令槽。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;new FtbSlot(JMP_OFFSET_LEN, Some(BR_OFFSET_LEN))&lt;/code&gt; （接口列表详见FtbSlot）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;pftAddr&lt;/strong&gt;: 预测块的结束地址。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;UInt(log2Up(PredictWidth).W)&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;carry&lt;/strong&gt;: 预测块的结束地址进位。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;isCall&lt;/strong&gt;: 无条件跳转指令槽中的指令为 call 指令。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;isRet&lt;/strong&gt;: 无条件跳转指令槽中的指令为 ret 指令。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;isJalr&lt;/strong&gt;: 无条件跳转指令槽中的指令为 jalr 指令。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;last_may_be_rvi_call&lt;/strong&gt;:  无条件跳转指令槽中的指令可能为一个 RVI 类型的 call 指令信号。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Bool()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;always_taken&lt;/strong&gt;: 该预测块中的每个分支指令是否总是被预测为 Taken。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口类型: &lt;code&gt;Vec(numBr, Bool())&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;说明：pftAddr 和 carry&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
