<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>香山微架构开放验证第一期：昆明湖BPU模块UT验证实战 – RAS</title>
    <link>https://xs-mlvp.github.io/xs-bpu/tags/ras/</link>
    <description>Recent content in RAS on 香山微架构开放验证第一期：昆明湖BPU模块UT验证实战</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	  <atom:link href="https://xs-mlvp.github.io/xs-bpu/tags/ras/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: RAS 分支预测器</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/modules/05_ras/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/modules/05_ras/</guid>
      <description>
        
        
        &lt;h2 id=&#34;ras介绍&#34;&gt;RAS介绍&lt;/h2&gt;
&lt;p&gt;RAS 指的是 &amp;ldquo;Return Address Stack&amp;rdquo;，即返回地址栈。它通过跟踪程序的返回地址，帮助确定程序中的分支行为。由前所述，在程序中存在很多分支：if/else、 switch/case、while/for loop、iteration、call/return&lt;/p&gt;
&lt;p&gt;等。RAS分支预测器则专门针对 call/return类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;_add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#a40000&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;  &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#a40000&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sub&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#000&#34;&gt;d&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;sub&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上图所示，在main函数中调用了add和sub，add又调用了函数_add。在该过程中，每次调用（call）的跳转地址和返回的地址固定，且在call的时候，就可以同时得到返回地址。函数的调用过程是一个“栈的出入”过程，因此可以通过“栈”结构进行分支预测：每遇到call指令，把当前PC+4（压缩指令和普通指令的偏移不同）进行压栈push操作；遇到return指令，则进行进行pop操作，得到的地址即为目标跳转地址。在基于“预测块”的BPU中，RAS无法知道当前块是否是call或者ret，因此需要依赖其他预测器，利用前级预测器的结果进行RAS操作。&lt;/p&gt;
&lt;p&gt;具体的，在香山的RAS预测器中，其s2阶段，需要判断上一级s2的输出是否预测为call或者ret（即输入信号io.s2_full_pred.hit_taken_on_call/ret有效 ），如果是call则push其后续指令地址入栈，是ret则从栈中pop出地址作为预测结果。因为在BPU的预测器中，人为假定s3阶段得到的结果比s2阶段好，所以RAS预测器在s3阶段需要进行检查，如果上一级的s3预测结果与s2不一致，则采信s3的结果，并按需求判断是否需要撤销或者补齐之前s2阶段的栈操作。例如s2阶段预测为call指令，进行了push操作，而s3为普通分支指令，不需要进行任何操作，此时就需要撤销push；如果s2预测为普通分支指令，s3预测为call，则需要进行push操作补齐。&lt;/p&gt;
&lt;h2 id=&#34;ras的栈操作&#34;&gt;RAS的栈操作&lt;/h2&gt;
&lt;p&gt;在RAS设计中，通过栈进行预测函数返回地址。在理想情况下，本节假定RAS可进行随时备份，栈顶指针用sp表示，预测地址用paddr表示。RAS的基本操作有以下4种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h3 id=&#34;push&#34;&gt;PUSH&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于预测可能会出错，出错时需要回到原始状态，因此在push时需要对当前栈的状态进行备份（在软件领域，通常称为“快照”，本文在后继内容中也用快照进行称呼），标记为s。当遇到call指令时，获取call指令的返回地址 addr = 当前pc + 4（如果是压缩指令则addr = pc+2），然后压栈：sp = addr；sp += 1。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;h3 id=&#34;pop&#34;&gt;POP&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;原因同上，对当前栈进行快照，标记为s。当遇到ret指令时，预测的跳转地址 paddr = sp，然后进行出栈， sp = sp - 1。对当前栈进行快照，标记为s。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;h3 id=&#34;重定向操作&#34;&gt;重定向操作&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于BPU是对程序的分支进行预测，因此就有“预测对”和“预测错”两种情况，当CPU后端发现分支预测错误，就会进行重定向（redirect）操作，告诉BPU哪个地方预测错误，正确结果是多少。重定向时RAS模块会收到正确的分支和当时预测时RAS栈信息。根据正确分支指令类型不同，首先恢复快照s有如下情形：&lt;/p&gt;
&lt;p&gt;（1）之前被预测的指令，实际是 call指令，根据redirect中给的addr地址，执行push操作；&lt;/p&gt;
&lt;p&gt;（2）之前被预测的指令，实际是 ret指令，执行pop操作；&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;h3 id=&#34;提交操作&#34;&gt;提交操作&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;提交（Commit）操作即后端告诉前端，之前预测的结果正确。理想情况下，RAS预测器此时不需要进行任何操作。&lt;/p&gt;
&lt;h2 id=&#34;昆明湖中ras的实现&#34;&gt;昆明湖中RAS的实现&lt;/h2&gt;
&lt;p&gt;在实际电路设计中，不可能存在无限大的栈，且能进行时刻备份，所以在昆明湖的 RAS 实现中，需要解决的问题和应对方案如下：&lt;/p&gt;
&lt;h3 id=&#34;每次预测时ras栈的快照如何获得&#34;&gt;&lt;strong&gt;每次预测时，RAS栈的快照如何获得？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;为了实现对RAS栈进行快照的功能，昆明湖采用了基于循环数组的 &lt;strong&gt;&amp;ldquo;链式表示“&lt;/strong&gt; 。设计具体如下：&lt;/p&gt;
&lt;image src=&#34;Linked_RAS.png&#34; width=&#34;800px&#34;&gt;
&lt;p&gt;如上图所示，在该设计中，利用一个循环数组进行数据管理。循环数组有一个起始地址标记为BOS，有一个尾指针标记为TOSW，他们之间的数据为有效数据，之外的数据为空闲数据。在有效数据中，用一个链式结构对“RAS栈”进行表示，即每一个栈元素都记录其上一个数据的编号，当进行栈操作时可以通过该编号获取对应上一个元素。RAS栈的栈底指针公用BOS。如图中的初始状态S，其中RAS栈对应的元素为0，1，3，5。元素5中记录了它的上一个元素的位置3，同理元素3中记录了其上一个元素的位置1。每次需要进行push操作时，让RAS栈顶指针TOSR = TOSW，在新的TOSR位置7中存入新的元素，并在新元素中记录其上一个元素的位置5，然后TOSW后移（TOSW = TOSW+1）。在进行Pop操作时，RAS栈顶指针TOSR根据栈顶元素保存的索引移动到上一个元素的位置3。因此在栈不溢出的情况下，上述RAS栈每次都是通过TOSW在数组上分配新数据，因此在栈的正常Push/Pop中，所有过程状态和中间数据都有保存。所以当要恢复到S状态时，只需要把对应的栈指针复位即可。因此在RAS每次预测时，需要把对应的栈指针（BOS、TOSR、TOSW）也保存于预测结果中，用于之后万一发生重定向操作时恢复到原始栈状态。上述结构的优点是可以保存完整过程数据，但频繁的push操作，会导致空间资源消耗大。&lt;/p&gt;
&lt;h3 id=&#34;链式ra存储空间浪费&#34;&gt;&lt;strong&gt;链式RA存储空间浪费？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;由于预测结果在commit后即表示预测正确，不会再进行“栈”回滚，即RAS预测器收到预测块“P”的commit消息后，就不可能再收到P块的redirect消息，在对P块进行push操作时的快照也将不会被用到。因此可以对RAS栈中的元素进行分类，把还未commit的元素用“链式”结构进行存储，已经commit的元素通过普通的基于循环数组的栈表示（即把原始RAS栈拆分成了两部分进行表示，还未commit可能需要快照恢复的部分用可以保存快照的链式结构保存，已经commit不需要快速恢复的部分用普通栈结构保存）。优化后的RAS结构如下所示：&lt;/p&gt;
&lt;image src=&#34;RAS_Arch.png&#34; width=&#34;800px&#34;&gt;
&lt;p&gt;如上图所示，根据普通预测的call/ret和commit提交的call/ret，把原始的RAS栈可以拆分成两个独立的栈，分别称为“预测栈”（ spec_stack，链式结构）和“提交栈”（commit_stack，普通结构），由于栈结构发生了变化，具体的Pop/Push操作如下：&lt;/p&gt;
&lt;p&gt;1、遇到普通call和ret：&lt;/p&gt;
&lt;p&gt;（1）call指令，在spec_stack上进行push操作，具体为上述链式栈Push过程；&lt;/p&gt;
&lt;p&gt;（2）ret指令，利用spec_stack的栈顶作为预测值，然后进行pop操作。如果spec_stack为空，则使用commit_stack的栈顶元素作为预测结果（不进行pop操作）。&lt;/p&gt;
&lt;p&gt;2、Commit操作：&lt;/p&gt;
&lt;p&gt;（1）预测块为call正确，在commit_stack上进行普通push操作。&lt;/p&gt;
&lt;p&gt;（2）预测块为ret正确，在commit_stack上进行普通pop操作。&lt;/p&gt;
&lt;p&gt;3、Redirect操作：&lt;/p&gt;
&lt;p&gt;（1）从redirect消息中获取之前预测时的栈指针（BOS、TOSR、TOSW，ssp），覆盖当前值指针值完成预测栈回滚。&lt;/p&gt;
&lt;p&gt;（2）该操作不影响提交栈。&lt;/p&gt;
&lt;h3 id=&#34;输入端s3的预测结果和s2不一致时该如何处理&#34;&gt;&lt;strong&gt;输入端，S3的预测结果和S2不一致时该如何处理？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;由于假定S3的结果比S2好，因此发生不一致时，需要再次对RAS栈进行修复。具体不一致情况和对应的修复操作如下表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;S2预测结果&lt;/th&gt;
&lt;th&gt;S3预测结果&lt;/th&gt;
&lt;th&gt;修复操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;push&lt;/td&gt;
&lt;td&gt;keep&lt;/td&gt;
&lt;td&gt;pop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;keep&lt;/td&gt;
&lt;td&gt;pop&lt;/td&gt;
&lt;td&gt;pop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pop&lt;/td&gt;
&lt;td&gt;keep&lt;/td&gt;
&lt;td&gt;push&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;keep&lt;/td&gt;
&lt;td&gt;push&lt;/td&gt;
&lt;td&gt;push&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;S2和S3的操作不存在，pop/push或者push/pop情况（为什么不存在？）&lt;/p&gt;
&lt;h2 id=&#34;其他优化&#34;&gt;其他优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;每个RAS栈中的元素都有一个counter计数器，用于节约重复值（递归调用）。例如：当第一次push地址为0xff00，第二次push的也为0xff00时，则只需要把栈顶元素的 counter 进行+1，不需真的进行push操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;接口说明&#34;&gt;接口说明&lt;/h2&gt;
&lt;p&gt;在RAS预测器中，核心组件为 &lt;strong&gt;RASStack&lt;/strong&gt; ，其接口说明如下:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;接口名称&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;功能描述&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;接口名称&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;功能描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;in.spec_push_valid&lt;/td&gt;
&lt;td&gt;进行PUSH操作&lt;/td&gt;
&lt;td&gt;in.s2_fire&lt;/td&gt;
&lt;td&gt;s2信号有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.spec_pop_valid&lt;/td&gt;
&lt;td&gt;进行POP操作&lt;/td&gt;
&lt;td&gt;in.s3_fire&lt;/td&gt;
&lt;td&gt;s3信号有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.spec_push_addr&lt;/td&gt;
&lt;td&gt;PUSH地址&lt;/td&gt;
&lt;td&gt;in.s3_cancel&lt;/td&gt;
&lt;td&gt;s3的信号表示需要撤销s2的操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out.spec_pop_addr&lt;/td&gt;
&lt;td&gt;RAS的栈顶数据&lt;/td&gt;
&lt;td&gt;in.s3_meta&lt;/td&gt;
&lt;td&gt;s3需要的s2时的现场信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out.ssp&lt;/td&gt;
&lt;td&gt;commit栈顶指针&lt;/td&gt;
&lt;td&gt;in.s3_missed_pop&lt;/td&gt;
&lt;td&gt;s3判断需要再次进行pop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out.sctr&lt;/td&gt;
&lt;td&gt;commit栈顶重复元素计数器&lt;/td&gt;
&lt;td&gt;in.s3_missed_push&lt;/td&gt;
&lt;td&gt;s3判断需要再次进行push&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out.nsp&lt;/td&gt;
&lt;td&gt;commit栈顶，会被ssp覆盖&lt;/td&gt;
&lt;td&gt;in.s3_pushAddr&lt;/td&gt;
&lt;td&gt;需要再次push时的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out.TOSR&lt;/td&gt;
&lt;td&gt;spec栈栈顶指针&lt;/td&gt;
&lt;td&gt;in.redirect_valid&lt;/td&gt;
&lt;td&gt;是否发生了重定向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out.TOSW&lt;/td&gt;
&lt;td&gt;spec栈数据分配指针&lt;/td&gt;
&lt;td&gt;in.redirect_isCall&lt;/td&gt;
&lt;td&gt;真实情况是call&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out.BOS&lt;/td&gt;
&lt;td&gt;spec栈栈低指针&lt;/td&gt;
&lt;td&gt;in.redirect_isRet&lt;/td&gt;
&lt;td&gt;真实情况是return&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.commit_push_valid&lt;/td&gt;
&lt;td&gt;push操作正确&lt;/td&gt;
&lt;td&gt;in.redirect_meta_ssp&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息ssp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.commit_pop_valid&lt;/td&gt;
&lt;td&gt;pop操作正确&lt;/td&gt;
&lt;td&gt;in.redirect_meta_sctr&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息sctr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.commit_push_addr&lt;/td&gt;
&lt;td&gt;push的正确地址&lt;/td&gt;
&lt;td&gt;in.redirect_meta_TOSW&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息TOSW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.commit_meta_TOSW&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息TOSW&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.redirect_meta_TOSR&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息TOSR&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.commit_meta_TOSR&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息TOSR&lt;/td&gt;
&lt;td&gt;in.redirect_meta_NOS&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息NOS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.commit_meta_ssp&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息SSP&lt;/td&gt;
&lt;td&gt;in.redirect_callAddr&lt;/td&gt;
&lt;td&gt;重定向地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in.commit_meta_sctr&lt;/td&gt;
&lt;td&gt;之前预测时的现场信息SCTR&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;RASStack模块与BasePredictor的接口关系如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;stack接口&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;转换过程&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;s.spec_push_valid&lt;/td&gt;
&lt;td&gt;io.s2_fire(2) &amp;amp;&amp;amp; s2_full_pred.hit_taken_on_call &amp;amp;&amp;amp; !io.s3_redirect(2)&lt;/td&gt;
&lt;td&gt;s2输入有效，且上级预测为call跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.spec_pop_valid&lt;/td&gt;
&lt;td&gt;io.s2_fire(2) &amp;amp;&amp;amp; s2_full_pred.hit_taken_on_ret  &amp;amp;&amp;amp; !io.s3_redirect(2)&lt;/td&gt;
&lt;td&gt;s2输入有效，且上级预测为ret跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.spec_push_addr&lt;/td&gt;
&lt;td&gt;s2_full_pred.fallThroughAddr + Mux(s2_full_pred.last_may_be_rvi_call, 2.U, 0.U)&lt;/td&gt;
&lt;td&gt;上级预测器s2预测的fallThroughAddr（即PC+2），判断是否压缩指令是否需要 +2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.redirect_isCall&lt;/td&gt;
&lt;td&gt;redirect.bits.level === 0.U &amp;amp;&amp;amp; recover_cfi.pd.isCall&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.redirect_isRet&lt;/td&gt;
&lt;td&gt;redirect.bits.level === 0.U &amp;amp;&amp;amp; recover_cfi.pd.isRet&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.redirect_meta_*&lt;/td&gt;
&lt;td&gt;redirect.bits.cfiUpdate.*&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.commit_push_valid&lt;/td&gt;
&lt;td&gt;io.update.is_call_taken&lt;/td&gt;
&lt;td&gt;call指令预测正确&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.commit_push_valid&lt;/td&gt;
&lt;td&gt;io.update.is_ret_taken&lt;/td&gt;
&lt;td&gt;ret指令预测正确&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.commit_push_addr&lt;/td&gt;
&lt;td&gt;update.ftb_entry.getFallThrough(update.pc) + Mux(update.ftb_entry.last_may_be_rvi_call, 2.U, 0.U)&lt;/td&gt;
&lt;td&gt;根据是否为压缩指令，进行地址+2或者+0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.commit_meta_*&lt;/td&gt;
&lt;td&gt;io.update.bits.meta.asTypeOf(new RASMeta)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;io.out.last_stage_spec_info.*&lt;/td&gt;
&lt;td&gt;s3_meta.*&lt;/td&gt;
&lt;td&gt;s3_meta = RegEnable(s2_meta, io.s2_fire(2))由s2_meta延迟一怕得到&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;io.out.last_stage_meta&lt;/td&gt;
&lt;td&gt;s3_meta&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;io.out.s2.full_pred.*.jalr_target&lt;/td&gt;
&lt;td&gt;:=stack.spec_pop_addr&lt;/td&gt;
&lt;td&gt;预测地址（栈顶地址，只预测ret）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;io.out.s3.full_pred.*.jalr_target&lt;/td&gt;
&lt;td&gt;:=RegEnable(stack.spec_pop_addr, io.s2_fire(2))&lt;/td&gt;
&lt;td&gt;由s2延迟一拍得到&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;io.out.s2/3.full_pred.targets.last&lt;/td&gt;
&lt;td&gt;:=Mux(s2/3_is_jalr, s2/3_jalr_target, s2/3_last_target_in)&lt;/td&gt;
&lt;td&gt;如果时call执行，更新targets.last的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;时序说明&#34;&gt;时序说明&lt;/h2&gt;
&lt;p&gt;在RAS中，只涉及到2拍，S2和S3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;S2中的主要工作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、根据上一个预测器的S2预测结果，完成通过Push/PoP过程完成预测，并得到结果sepc_pop_addr。&lt;/p&gt;
&lt;p&gt;2、根据commit信号执行更新操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;S3中的主要工作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、根据上一个预测器S3中的预测结果，以及S2进行的操作，判断是否需要进行Pop/Push的撤销操作。预测器假定S3的预测结果比S2好，如果发生S2和S3预测不一致时，RAS预测器采信S3结果进行栈操作。&lt;/p&gt;
&lt;p&gt;2、S3和S2的预测过程一致，只是数据不同。&lt;/p&gt;
&lt;p&gt;3、执行重定向（重定向信息由前一拍获得）操作&lt;/p&gt;
&lt;p&gt;由于RASStack对外表现为当拍内就能完成任务，因此在Stack内需要进行数据旁路，对数据进行缓存。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: RAS 功能列表</title>
      <link>https://xs-mlvp.github.io/xs-bpu/docs/feature/05_rasfeature/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xs-mlvp.github.io/xs-bpu/docs/feature/05_rasfeature/</guid>
      <description>
        
        
        &lt;h2 id=&#34;功能列表feature-list&#34;&gt;功能列表（Feature List）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;支持预测器的开启关闭操作&lt;/li&gt;
&lt;li&gt;支持s3预测结果覆盖s2预测结果&lt;/li&gt;
&lt;li&gt;支持ras栈的push、pop操作&lt;/li&gt;
&lt;li&gt;支持ras栈的redirect操作&lt;/li&gt;
&lt;li&gt;支持ras栈的update操作&lt;/li&gt;
&lt;li&gt;支持base predictor接口&lt;/li&gt;
&lt;li&gt;符合标准RAS预测器预测流程&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
    
  </channel>
</rss>
