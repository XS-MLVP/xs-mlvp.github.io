<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4Z2ZY6ZE84"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4Z2ZY6ZE84")</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?6aacb1c7ca0a3ef4e3aa84c1eaa237dd",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Mulish:wght@300;400;600;700;800&family=Frank+Ruhl+Libre:wght@200;300;400;500;600&family=Encode+Sans+Semi+Condensed:wght@400&display=swap" rel=stylesheet><link rel=stylesheet type=text/css href=/css/bootstrap.min.css><link rel=stylesheet type=text/css href=/css/all.min.css><link disabled id=dark-mode-theme rel=stylesheet href=/css/dark.css><link rel=stylesheet type=text/css href=/css/style.css><link rel=stylesheet type=text/css href=/css/my_style.css><title>万众一芯开放验证 | 万众一芯黑客马拉松第一期：热身赛题(进行中)</title>
<meta name=description content="用UCAgent验证参与黑客松，实战赢奖金"></head><body style=width:100%;max-width:100%;margin:0;padding:0><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="d-flex justify-content-between align-items-center" style=width:100%><div class="d-flex align-items-center"><a class="navbar-brand navbar-brand-content" href=https://open-verify.cc/cn><img src=/images/logo.png></a><div class="collapse navbar-collapse" id=navbarNavDropdown><ul class="navbar-nav ms-auto mt-2 mt-lg-0"><li class=nav-item><a class=nav-link href=/registration_portal/>报名入口汇总</a></li><li class=nav-item><a class=nav-link href=/learningresource/>学习资源</a></li><li class=nav-item><a class=nav-link href=/about/>关于我们</a></li></ul></div></div><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarNavDropdown aria-controls=navbarNavDropdown aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" style=flex:1><ul class="navbar-nav ms-auto mt-2 mt-lg-0"><li class=nav-item><a class="btn fas fa-moon" id=dark-mode-toggle></a></li></ul></div></div></nav><div id=content><div class=container><div class="py-4 rounded-3"><div class="container-fluid py-2"><h1 class="display-2 mb-4 text-center">万众一芯黑客马拉松第一期：热身赛题(进行中)</h1></div><p class="text-center fs-4 fst-italic serif">用UCAgent验证参与黑客松，实战赢奖金</p><div class="text-center pt-4"></div></div><div class="row justify-content-center mb-5"><div class=col-12><p class="card-date m-0">Created Nov 18, 2025 -
Last updated: Nov 18, 2025</p><hr class=dropdown-divider><div class="row justify-content-between"><div class=col-sm-4></div><div class=col-sm-8 style=text-align:right></div></div></div></div><div class="container-fluid py-2 content"><div class="serif main-content"><h2 id=活动简介>活动简介</h2><p>欢迎参加本次黑客马拉松！本次黑客马拉松以“AI驱动开源芯片验证”为主题，聚焦基于大语言模型的硬件验证智能体UCAgent的实际应用。各位将在限定时间内，利用UCAgent人机协同进行模块验证，分析生成的fail case，找出题目当中的BUG或提升token效率。通过参与，您不仅能体验UCAgent工具在开源验证中的便利，还能作为开发者参与到开源芯片验证的生态中。</p><ul><li><strong>赛题任务</strong>：本次活动提供了<strong>15</strong>个手工注入的bug供大家进行发现，共有两个赛道：<strong>找bug赛道</strong>/<strong>token效率赛道</strong>，，找出bug分析并提交结果。</li><li><strong>难度分级</strong>：每个模块含有5个bug对应5个rtl文件，分为<strong>简单难度2个（每个100分）；中等难度1个（每个300分）；困难难度2个（每个500分）</strong>。</li><li><strong>排名资格</strong>：<strong>至少找到一共5个Bug</strong>才能获得排名资格。</li><li><strong>首位在origin版本中找到Bug的参与者，经验证确认有效后，将额外获得 500 至 1000 分的奖励。</strong></li></ul><p>为使大家能够高效地找到bug，我们提供了<strong>UCAgent</strong>工具。下面将以VectorIdiv模块的一个简单bug为例，演示如何使用UCAgent进行验证并提交结果。</p><h2 id=热身演示>热身演示</h2><h3 id=第一步-使用ucagent快速寻找fail-case>第一步 使用UCAgent快速寻找Fail case</h3><p>详细使用方法请参考<a href=https://open-verify.cc/mlvp/docs/ucagent>UCAgent使用手册</a>。
提示：建议先熟悉UCAgent的基本操作，再开始正式任务。</p><h3 id=第二步-基于fail-case进行bug分析>第二步 基于Fail case进行bug分析</h3><p>UCAgent会在<code>output/unity_test/tests</code>目录下生成一份<code>VectorIdiv_bug_analysis.md</code> 文档，列出所有检测到的bug并提供详细分析。例如：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span>## VectorIdiv 缺陷分析
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>### 边界与异常处理
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#111>&lt;</span><span style=color:#f92672>FG-BOUNDARY_EXCEPTION</span><span style=color:#111>&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>#### 边界值测试: &lt;FC-BOUNDARY&gt;
</span></span><span style=display:flex><span><span style=color:#00a8c8>-</span> <span style=color:#111>&lt;</span><span style=color:#f92672>CK-DIV_BY_NEG_ONE</span><span style=color:#111>&gt;</span> 检测点：有符号数除以-1
</span></span><span style=display:flex><span>  <span style=color:#00a8c8>-</span> <span style=color:#111>&lt;</span><span style=color:#f92672>BG-DIV_BY_NEG_ONE-0</span><span style=color:#111>&gt;</span> 当一个有符号数的最小负值（例如，对于8位整数是-128）除以-1时，预期的结果应该是该数的绝对值（128），但这超出了8位有符号数的表示范围（-128到127）。根据RISC-V向量规范，这种情况下商应保持为被除数（-128），余数应为0。然而，DUT的实现似乎未能正确处理此溢出情况。
</span></span><span style=display:flex><span>    <span style=color:#00a8c8>-</span> <span style=color:#111>&lt;</span><span style=color:#f92672>TC-test_VectorIdiv_templates.py::test_boundary_conditions</span><span style=color:#111>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#00a8c8>-</span> **根因分析**:
</span></span><span style=display:flex><span>    在 <span style=color:#d88200>`VectorIdiv_BUG1.v`</span> 的 <span style=color:#d88200>`I8DivNr4`</span> 模块中，对于商的计算没有特殊处理溢出情况。
</span></span><span style=display:flex><span>    ``<span style=color:#d88200>`verilog
</span></span></span><span style=display:flex><span><span style=color:#d88200>    // VectorIdiv_BUG1.v
</span></span></span><span style=display:flex><span><span style=color:#d88200>    150: assign io_div_out_q = Lkm7UANb3k7urrE;
</span></span></span><span style=display:flex><span><span style=color:#d88200>    `</span>`<span style=color:#d88200>`
</span></span></span><span style=display:flex><span><span style=color:#d88200>    `</span>Lkm7UANb3k7urrE<span style=color:#d88200>` 的计算逻辑未能考虑到 `</span>-128 / -1<span style=color:#d88200>` 的溢出。
</span></span></span><span style=display:flex><span><span style=color:#d88200>  - **修复建议**:
</span></span></span><span style=display:flex><span><span style=color:#d88200>    应在计算商的逻辑中增加一个检查，如果是有符号运算且除数为-1，并且被除数是最小负值，则商应等于被除数本身。
</span></span></span><span style=display:flex><span><span style=color:#d88200>
</span></span></span><span style=display:flex><span><span style=color:#d88200>#### 异常处理: &lt;FC-EXCEPTION&gt;
</span></span></span><span style=display:flex><span><span style=color:#d88200>- &lt;CK-DIV_BY_ZERO&gt; 检测点：除零异常
</span></span></span><span style=display:flex><span><span style=color:#d88200>  - &lt;BG-DIV_BY_ZERO-0&gt; 当除数为零时，DUT应产生一个除零异常。根据 `</span>VectorIdiv_function_coverage_def.py<span style=color:#d88200>` 中的定义，这要求 `</span>io_d_zero<span style=color:#d88200>` 信号不为零。然而，在测试中发现，即使除数为零，`</span>io_d_zero<span style=color:#d88200>` 信号仍然为零，表明异常没有被正确触发。
</span></span></span><span style=display:flex><span><span style=color:#d88200>    - &lt;TC-test_VectorIdiv_templates.py::test_boundary_conditions&gt;
</span></span></span><span style=display:flex><span><span style=color:#d88200>  - **根因分析**:
</span></span></span><span style=display:flex><span><span style=color:#d88200>    在 `</span>VectorIdiv_BUG1.v<span style=color:#d88200>` 的 `</span>I8DivNr4<span style=color:#d88200>` 模块中，`</span>YOzhvk<span style=color:#d88200>` 信号正确地识别了除数为零的情况 (`</span>bO1Bf == 8&#39;h0<span style=color:#d88200>`)。但是，这个状态没有被用来驱动 `</span>io_d_zero<span style=color:#d88200>` 输出。
</span></span></span><span style=display:flex><span><span style=color:#d88200>    `</span>`<span style=color:#d88200>`verilog
</span></span></span><span style=display:flex><span><span style=color:#d88200>    // VectorIdiv_BUG1.v
</span></span></span><span style=display:flex><span><span style=color:#d88200>    90: wire       YOzhvk = bO1Bf == 8&#39;h0;
</span></span></span><span style=display:flex><span><span style=color:#d88200>    `</span>`<span style=color:#d88200>`
</span></span></span><span style=display:flex><span><span style=color:#d88200>    `</span>io_d_zero<span style=color:#d88200>` 信号没有在 `</span>I8DivNr4<span style=color:#d88200>` 模块中被赋值，因此它保持默认值0。
</span></span></span><span style=display:flex><span><span style=color:#d88200>  - **修复建议**:
</span></span></span><span style=display:flex><span><span style=color:#d88200>    应将 `</span>YOzhvk<span style=color:#d88200>` 信号连接到 `</span>io_d_zero<span style=color:#d88200>` 输出，或者使用 `</span>YOzhvk<span style=color:#d88200>` 来设置一个在除零时会置位的寄存器，并最终驱动 `</span>io_d_zero`。
</span></span></code></pre></div><p><strong>注意</strong>：bug报告中可能包含假阳性bug（即测试用例不符合要求导致的非源码类报错），因此需要结合阅读Spec文档分析失败的测试用例，以识别真正的bug。
例如：</p><ul><li>第一个疑似bug（-128除以-1）分析：通过阅读Spec文档发现，这是由于结果超出RISC-V向量规范导致的报错，并非源码bug，可忽略。<br></li><li>第二个疑似bug（除零异常）分析：通过分析Spec文档（第12.2节）确认：整数除法在除零时应返回定义值（商为全1，余数为被除数），而不应触发硬件异常。但测试中io_d_zero信号未置位，这表明是真正的源码bug。</li></ul><h3 id=第三步-提交结果>第三步 提交结果</h3><p>找到Bug后，请提交以下内容：</p><table style=width:100%;min-width:auto><tr><th style=width:25%>所在文件名</th><th style=width:25%>Bug说明</th><th style=width:25%>Fail case文件相关</th><th style=width:25%>Spec不一致的章节内容</th></tr><tr><td>例如VectorIdiv_bug_1.v</td><td>说明触发bug的fail case、原因</td><td>output文件夹打包</td><td>该Bug对应Spec当中要求不符的章节与内容</td></tr></table><p>将以上文件上传到指定平台即可完成提交。（平台暂未开放）</p><h2 id=热身学习资源>热身学习资源</h2><p>为了帮助您快速上手，我们提供了以下资源：</p><p><strong>无bug版本rtl：</strong></p><ul><li><strong><a href=https://github.com/XS-MLVP/Hackathon/blob/main/origin_file/VectorFloatFMA_origin.v>VectorFloatFMA_origin.v：https://github.com/XS-MLVP/Hackathon/blob/main/origin_file/VectorFloatFMA_origin.v</a></strong></li><li><strong><a href=https://github.com/XS-MLVP/Hackathon/blob/main/origin_file/VectorFloatAdder_origin.v>VectorFloatAdder_origin.v：https://github.com/XS-MLVP/Hackathon/blob/main/origin_file/VectorFloatAdder_origin.v</a></strong></li><li><strong><a href=https://github.com/XS-MLVP/Hackathon/blob/main/origin_file/VectorIdiv_origin.v>VectorIdiv_origin.v：https://github.com/XS-MLVP/Hackathon/blob/main/origin_file/VectorIdiv_origin.v</a></strong></li></ul><p><strong>有bug版本rtl：</strong></p><ul><li><strong><a href=https://github.com/XS-MLVP/Hackathon/blob/main/bug_file/VectorIdiv_bug_1.v>VectorIdiv_bug_1.v：https://github.com/XS-MLVP/Hackathon/blob/main/bug_file/VectorIdiv_bug_1.v</a></strong></li></ul><p><strong>SPEC链接：</strong></p><ul><li><strong><a href=https://docs.riscv.org/reference/isa/unpriv/v-st-ext.html#vector-integer-divide-instructions>向量整数除法指令:https://docs.riscv.org/reference/isa/unpriv/v-st-ext.html#vector-integer-divide-instructions</a></strong></li><li><strong><a href=https://docs.riscv.org/reference/isa/unpriv/v-st-ext.html#sec-vector-float>向量浮点指令:https://docs.riscv.org/reference/isa/unpriv/v-st-ext.html#sec-vector-float</a></strong></li></ul><p><strong>UCAgent链接：<a href=https://github.com/XS-MLVP/UCAgent>https://github.com/XS-MLVP/UCAgent</a></strong></p><p><strong>UCAgent使用手册：<a href=https://open-verify.cc/mlvp/docs/ucagent>https://open-verify.cc/mlvp/docs/ucagent</a></strong></p></div></div></div></div><script src=/js/bootstrap.min.js></script><script src=/js/jquery.min.js></script><script src=/js/isotope.pkgd.min.js></script><script src=/js/masonry.pkgd.min.js async></script><script src=/js/dark.js></script><script>var savedTheme=localStorage.getItem("dark-mode-storage")||"light";setTheme(savedTheme)</script><script src=/js/isotope.js></script><script src=/js/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,securityLevel:"loose"})</script></body></html>