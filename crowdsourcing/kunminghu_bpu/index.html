<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Mulish:wght@300;400;600;700;800&family=Frank+Ruhl+Libre:wght@200;300;400;500;600&family=Encode+Sans+Semi+Condensed:wght@400&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/css/all.min.css">
    <link disabled id="dark-mode-theme" rel="stylesheet" href="/css/dark.css">
    <link rel="stylesheet" type="text/css" href="/css/style.css">
    <link rel="stylesheet" type="text/css" href="/css/my_style.css">
    
    
    
    <title>Open verification | 昆明湖架构（香山）UT验证——BPU</title>
    <meta name="description" content="">
</head><body><nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container">
        <a class="navbar-brand" href="https://xs-mlvp.github.io/">
            
            <b style="font-weight: 800;">首页</b>
            
        </a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNavDropdown">
            <ul class="navbar-nav ms-auto mt-2 mt-lg-0"><li class='nav-item '>
                    <a class="nav-link" href="/crowdsourcing/"> 正在进行的验证任务</a>
                </li>
            <li class='nav-item '>
                    <a class="nav-link" href="/learningresource/"> 学习资源</a>
                </li>
            <li class='nav-item '>
                    <a class="nav-link" href="/about/"> 关于我们</a>
                </li>
             
            <li class="nav-item px-2 pt-1">
                <a class="btn fas fa-moon" id="dark-mode-toggle"></a>
            </li>
            </ul>
        </div>
    </div>
</nav><div id="content">


<div class="container">
    <div class="py-5 rounded-3">
        <div class="container-fluid py-2">
            <h1 class="display-2 mb-4">昆明湖架构（香山）UT验证——BPU</h1>
            <p class="bio col-md-8 fs-4 serif">香山昆明湖架构是基于chisel开发的开源高性能第三代香山riscv处理器IP核</p>
        </div>
    </div>
    <div class="container">
        <h1 id="分支预测基础知识">分支预测基础知识</h1>
<pre><code>TBD
</code></pre>
<blockquote>
<p>可阅读《超标量处理器设计》姚永斌著 第四章分支预测
详细介绍了分支预测的相关知识</p>
</blockquote>
<p>需要了解的知识点：</p>
<ol>
<li>分支预测的基本原理</li>
<li>分支指令的方向预测</li>
<li>全局分支历史/局部分支历史</li>
<li>分支指令的目标预测</li>
<li>流水线的基本概念</li>
</ol>
<h1 id="香山分支预测器bpu基础设计">香山分支预测器（BPU）基础设计</h1>
<h2 id="分支预测块思想">分支预测块思想</h2>
<p>对于RISC-V架构来说，分支指令包含以下几种类型：</p>
<ol>
<li>条件分支指令 (beq, bne, blt, bge, bltu, bgeu)，对于这类指令，需要预测该指令是否跳转，并记录下他们的跳转地址。</li>
<li>无条件跳转指令 (jal, jalr)，对于这类指令，需要预测该指令的跳转地址。</li>
</ol>
<p>所幸的是，由于RISC-V架构设计的简介，我们不需要处理条件跳转指令，每一个需要我们预测的跳转指令都是无条件跳转的，这也给我们的设计提供了便利。</p>
<p>拿到一个PC之后，分支预测器可以选择在取指之后，得知这条指令是否是分支指令，如果是该指令是分支指令，那么预测器可以给出分支预测结果，并且对于非间接跳转指令来说可以直接从指令中获取跳转目标，如果不是分支指令则跳过。但是每次都在获取指令之后才能得知是否需要预测，需要的等待时间太长，因此分支预测器还需要提前预测这条指令是否是分支指令，如果是分支指令，还需要给出这条指令的预测结果。</p>
<p>因此对于一般的分支预测器来说，给出一个指定的PC，他们通常会预测出该PC所对应的那一条指令的相关信息，比如这条指令是不是条件分支指令、是不是跳转指令，如果是条件分支指令还会预测出该指令是否跳转，相应的，如果是跳转指令，会预测出该指令的跳转目标。但这样的预测的效率较低，我们需要一条一条的往后预测，导致流水线延迟增大，对于香山这样的高性能处理器来说，我们需要更加高效的预测方法。</p>
<p>相比于每一预测一条指令，香山采用的预测方法是，每一次预测一个指令块，即任意给定一个PC，香山会预测出以这个PC开始的一个分支预测块，这个分支预测块会预测接下来的若干条指令的情况，包括是不是存在分支指令，分支指令的位置在哪里、是否跳转、跳转目标是什么。这样我们就可以一次预测出多条指令，并送往取值单元（IFU），指导IFU进行取值。并且对于IFU来说，它需要考虑缓存行的性能问题，它的一次取值可以根据缓存行的长度取出多条指令，以预测块的形式给出预测结果，也满足了IFU的吞吐效率。下文中会详细描述香山中的预测块结构。</p>
<h2 id="多预测器结构">多预测器结构</h2>
<p>TBD</p>
<blockquote>
<p>分支预测单元采用一种多级混合预测的架构，其主要组成部分包括 下一行预测器（Next Line Predictor，以下简称 NLP）和 精确预测器（Accurate Predictor，以下简称 APD）。其中，NLP 是一个 uBTB (micro BTB)，APD 由 FTB1、TAGE-SC、ITTAGE、RAS 组成。NLP 提供无空泡的预测，在预测请求的下一拍就可以得到预测结果。APD 各组成部分的延迟在 2~3 拍之间。其中，FTB、TAGE、RAS 的延迟为 2 拍；SC、ITTAGE 的延迟为 3 拍。一次预测会经历三个流水级，每一个流水级都会产生新的预测内容。这些分布于不同流水级的预测器组成了一个覆盖预测器 (overriding predictor)。</p>
</blockquote>
<h2 id="取值目标队列ftq">取值目标队列（FTQ）</h2>
<p><img src="https://xiangshan-doc.readthedocs.io/zh-cn/latest/figs/frontend/ftq.svg" alt="FTQ"></p>
<p>尽管BPU做到了以指令块的形式提供预测结果，IFU也可以一次性取值多条指令。但是他们之间还是会存在性能上的差距，BPU产生预测结果的速度通常是会更快的。因此在BPU与IFU之间被添加了一个取值目标队列（FTQ）作为缓冲，BPU产生的预测结果会暂存到FTQ中去，当IFU空闲时，会从FTQ中获取下一个指令块。但在香山中，FTQ的职能还远不止这些，如上图所示，它还负责向ICache发送预取信息，存储BPU的各类训练信息，负责分析取值模块、后端执行模块中发来的重定向信息、更新信息，还会向BPU发送更新请求，甚至FTB预测器中的基本数据结构——FTB项都是由FTQ来更新的。</p>
<p>因此对于FTQ来说，它承担了BPU几乎所有的对外交互，因此想要理解BPU所发出的信息是怎样被下一级采用的，它是怎样获取更新、重定向请求的，还需要从FTQ开始看起。</p>
<p>FTQ在整体上可以看做一个队列，队列中的每一项存储了多种信息，包括但不限于 当前预测块取值目标信息，BPU在产生这一个预测块时的重定向恢复信息、FTB项、预测器元数据，IFU发回的预译码信息。</p>
<h3 id="bpu预测结果接口">BPU预测结果接口</h3>
<p><img src="https://xiangshan-doc.readthedocs.io/zh-cn/latest/figs/frontend/bpu.svg" alt="Alt text"></p>
<p>如上图所示，香山中的BPU被划分为了三个流水级 s1, s2 及 s3，每个预测器所处的流水级也是有一定差异的。为了效率，香山BPU在第一个流水级便能够产生出简单的预测结果，但这一预测结果仅是从 uFTB 所读出来的数据产生的，后续更高级的预测器还来不及生成精确预测结果。因此在后面的流水级，高级预测器如果发现前一个流水级中预测有错误，便会发出BPU重定向请求（非发往BPU的重定向请求），更新之前预测结果中的错误，FTQ中也会捕获这一请求，并更新之前存储的数据。</p>
<p>具体的细节我们需要从接口中得知。BPU对外预测结果的接口是一个 BranchPredirectionResp 接口，这同时存在于每一个子预测器模块中，那么他的结构是怎样的呢，其中的关键信息如下：</p>
<ul>
<li><strong>s1</strong> s1流水级的分支预测结果
<ul>
<li><strong>pc</strong> 预测起始 pc</li>
<li><strong>valid</strong> 预测结果是否有效</li>
<li><strong>hasRedirect</strong> 是否需要重定向</li>
<li><strong>ftq_idx</strong> FTQ指针，指向本次预测的FTQ表项</li>
<li><strong>full_pred</strong> 完整的分支预测结果</li>
</ul>
</li>
<li><strong>s2</strong> s2流水级的分支预测结果
<ul>
<li>同上</li>
</ul>
</li>
<li><strong>s3</strong> s3流水级的分支预测结果
<ul>
<li>同上</li>
</ul>
</li>
<li><strong>last_stage_*</strong> 最后一个流水级的输出的、在本次预测中需要发送给 FTQ 保存的信息。</li>
</ul>
<p>可以看到，对于每个流水级都有一份相同的接口，每个接口中都有着完整的预测结构，还有一些信息来指导FTQ的更新。这种更新是如何完成的呢？首先，FTQ在发往BPU的一个接口(enq_ptr)中指定了一个队列指针(bpuPtr)，指向队列首部的没有使用的表项，因此BPU便知道本轮预测需要写入到FTQ的那个队列项中。当s1预测结果中的valid被置为有效时，FTQ就会根据s1阶段接口中的 FTQ 指针以及完整预测结果，初始化这一队列项中的各种信息。</p>
<p>当预测进行到后续阶段，例如s2阶段，如果发现之前的预测结果是错误的，那么 s2 阶段会同时将 valid 和 hasRedirect 置位有效，FTQ会根据s2的预测结果和FTQ指针来更新相应FTQ项。当s1, s2, s3阶段信息存在多个有效时，FTQ会以s3, s2, s1的优先级从中选取一个，来更新FTQ项。</p>
<p>最后 last_stage_* 相关的信息，会在s3阶段valid置高时被FTQ存储。</p>
<h3 id="bpu重定向接口">BPU重定向接口</h3>
<p>无论再精确的分支预测器也不总是正确的，这种不正确会导致后续流水线中填充错误的指令，因此需要有一种机制来纠正这种错误，这种机制就是重定向。指令在被后端执行模块执行时，这条指令真正的行为才会被确定，因此在这个时候，后端执行模块如果发现分支预测错误，就会发出重定向请求，让处理器的状态恢复到执行错误指令之前的状态，对于我们来说，只需要关注BPU和FTQ在重定向时是怎样恢复状态的即可。但是如果每次都需要等到后端执行才可以检测出错误，会造成大量的性能损失，因此香山处理器中会在IFU取到指令之后对指令进行简单分析，检测出最基本的预测错误。具体的过程是这样的，FTQ向IFU发送取指请求之后，会等待IFU返回预译码信息（预译码是IFU对指令的简单解码，例如是否是跳转指令、跳转的目标是什么），FTQ会将预译码信息写回到对应FTQ项中的某个字段，同时会分析预译码信息，如果发现预测错误，便会生成一个IFU重定向请求。</p>
<p>来自后端执行模块的重定向请求不需要不需要FTQ生成，是直接由后端发往FTQ进行处理。FTQ会将生成的IFU重定向请求与后端重定向请求转发到BPU的重定向接口中去，如果二者在同一周期有效，那么FTQ会选择转发后端重定向请求。</p>
<p>一个重定向请求的结构是这样的（只列出关键信息）</p>
<ul>
<li><strong>valid</strong>: 重定向信息是否有效</li>
<li><strong>ftqIdx</strong>: 重定向对应的FTQ项索引</li>
<li><strong>ftqOffset</strong>: 错误预测的跳转指令在本预测块的索引</li>
<li><strong>level</strong>: 重定向级别</li>
<li><strong>cfiUpdate</strong> 控制流信息
<ul>
<li><strong>pc</strong>: 错误预测的跳转指令的pc</li>
<li><strong>pd</strong>: 错误预测的跳转指令的预译码信息
<ul>
<li><strong>valid</strong> 是否有效</li>
<li><strong>isRVC</strong> 是否是压缩指令</li>
<li><strong>brType</strong> 分支类型</li>
<li><strong>isCall</strong> 是否是call指令</li>
<li><strong>isRet</strong> 是否是ret指令</li>
</ul>
</li>
<li><strong>predTaken</strong>: 预测信息读出的 块内是否存在生效的控制流指令</li>
<li><strong>target</strong>: 正确的的跳转目标</li>
<li><strong>taken</strong>: 块内是否存在生效的控制流指令</li>
<li><strong>isMisPred</strong>: 是否存在错误预测的跳转指令</li>
</ul>
</li>
</ul>
<p>重定向发生时，FTQ会根据重定向信息更新内部相关状态，同时会将FTQ指针恢复到重定向信息中所制定的FTQ项上，重定向请求也会转发到BPU以便BPU恢复状态。</p>
<blockquote>
<p>这里重定向需要的恢复信息好像在提交接口中给出？具体怎么工作的还不清楚
接口中的信息是根据IFU重定向分析得来的，还有很多没有用到的接口。也不清楚后端重定向用到了什么接口，是否相同，需要进一步确认</p>
</blockquote>
<p>由于BPU的提交需要首先理解BPU预测块结构，BPU的提交过程会在后文中详细介绍。</p>
<h2 id="分支预测块结构">分支预测块结构</h2>
<p>理解了BPU是怎样给出预测结果的，但目前为止还不清楚，一个完整的预测结果是怎样的，又是怎样被BPU存储的，究竟一个分支预测块中包含了哪些信息，才能指导后续模块进行连续的取值的呢？这一部分将详细讲述香山中的分支预测块结构。</p>
<h3 id="ftb项">FTB项</h3>
<p>FTB项是香山中分支预测块的核心数据结构，它存储了产生一个分支预测块所需要的信息，BPU在进行预测时，初始的分支预测块首先由一个读出的FTB项生成，然后这一分支预测块会传递到后续的预测器中，由后续的预测器读取其中的信息，并且生成相应的预测结果。</p>
<p>因此理解想要理解分支预测块的结构，首先需要理解FTB项的结构。一个FTB项便对应了一个分支预测块，它的结构如下：</p>
<ul>
<li><strong>valid</strong> FTB表项是否有效</li>
<li><strong>brSlots</strong> 可记录一条分支指令的信息
<ul>
<li><strong>offset</strong> 该Slot中指令相对于预测块起始地址的偏移</li>
<li><strong>lower</strong> 跳转目标地址的低位</li>
<li><strong>tarStat</strong> 跳转后的pc高位是否进退位</li>
<li><strong>sharing</strong> 分支指令分享了该 slot</li>
<li><strong>valid</strong> brSlots有效位</li>
</ul>
</li>
<li><strong>tailSlot</strong> 可记录块内第二条分支指令 或 一条无条件跳转/间接跳转指令
<ul>
<li>同上</li>
</ul>
</li>
<li><strong>pftAddr</strong> 具体用途还不清楚(文档：当前预测块如果不跳转，下一条指令的PC)</li>
<li><strong>carry</strong> (文档：ftb_entry 中当前预测块不跳转的下一个 pc 预测地址进位)</li>
<li><strong>isCall</strong> 预测块内包含call指令</li>
<li><strong>isRet</strong> 预测块内包含ret指令</li>
<li><strong>isJalr</strong> 预测块内包含jalr指令</li>
<li><strong>last_may_be_rvi_call</strong> 预测结果预测块末尾可能为一个RVI类型的call指令信号</li>
<li><strong>always_taken</strong> 该预测块中的每个分支指令是否总是被预测为 taken</li>
</ul>
<p>首先需要明确一个信息，无论是分支预测块和FTB项，他们可以容纳的指令数量都被指定为一个特定的上限（一般是4条rvi指令），这样如果我们需要记录分支预测块内的某一条指令的位置，就可以使用一个固定长度的位向量，来指定这条指令相对于预测块起始地址的偏移。</p>
<p>决定一个分支预测块的执行流程最重要的其中的分支指令信息，对于其余的指令，我们都视为普通指令，不影响程序的执行流。因此FTB项中定义了两种类型的分支指令槽(slot)——brSlots和tailSlot 来存储分支预测块中的分支指令。目前香山版本中brSlots只含有一个Slot，tailSlot是一个单独的Slot，总计含有两个Slot。在每个Slot中，我们会记录一条分支指令相对于预测块起始地址的偏移，还会记录下他的跳转目标地址。</p>
<p>我们知道，RISC-V中的分支指令一共有两种类型，条件分支和无条件跳转。因此对于一个分支预测块来说，最多只会拥有一条无条件跳转指令，因为每当执行到这一条指令，程序的执行流就发生改变了，后续的指令都不会被执行了，因此我们定义了一种类型的slot叫做tailSlot，专门用来存储这一条无条件跳转指令，而对于条件分支指令则将他存储在brSlots中。tailSlot正如其名，他是整个预测块中的最后一个slot，因为一旦填充无条件跳转指令，后面无论是条件分支指令，还是无条件跳转指令，我们都不关心了。但是在无条件跳转指令之前的指令，我们需要关心是否存在条件分支指令，因为条件分支指令既有可能跳转，也有可能不跳转，在这里需要记录下条件分支指令的相关信息。</p>
<p>考虑一种情况，如果从预测块起始PC开始直到最大预测长度，都没有出现无条件跳转指令，反而出现了两条条件分支指令，这样一来，tailSlot空闲，而第二条条件分支指令又无法存储，这样就会造成空间的浪费。在这里使用了一种方法，设置一个标记sharing，我们可以直接将第二条分支指令直接存储到tailSlot中，并将sharing标记为真，表示第二条条件分支指令共享了无条件跳转指令的tailSlot。</p>
<p>预测块中isCall, isRet, isJalr这几个字段是为tailSlot服务的，如果tailSlot中记录的是无条件跳转指令，这几个字段会进一步指示该跳转指令的类型。在FTB项中还有一个字段always_taken，用来记录每一个Slot中存储的条件分支指令是否总是被预测为跳转，如果是的话，后续的预测器可以直接采用这一预测结果。</p>
<p>通过FTB项，我们就能够得知一个分支预测块中的指令情况，包括分支指令的位置、类型等，这些信息会交给后续的预测器，由后续的预测器来预测更为精确的跳转目标、是否跳转等信息。</p>
<h3 id="分支预测块完整的分支预测结果">分支预测块（完整的分支预测结果）</h3>
<p>理解了FTB项，也就理解了绝大部分完整预测结果的结构了。在这里直接给出完成预测结果的接口定义：</p>
<ul>
<li><strong>br_taken_mask</strong> 分支预测结果，每个分支(slot)对应一个 bit，表示该分支是否被预测为 taken</li>
<li><strong>slot_valids</strong> slot有效位，表示 ftb 项中的每个 slot 是否有效</li>
<li><strong>targets</strong> 每个slot对应的跳转目标地址</li>
<li><strong>jalr_target</strong> 本预测块中的 jalr 的跳转目标</li>
<li><strong>offsets</strong> 每个slot中的指令相对于预测块起始地址的偏移</li>
<li><strong>fallThroughAddr</strong> 具体用途还不清楚（文档：当前预测块不跳转的下一个 pc）</li>
<li><strong>fallThroughErr</strong> 具体用途还不清楚(文档：预测出的下一个顺序取指地址是否存在错误)</li>
<li><strong>is_jal</strong> 预测块内包含jal指令</li>
<li><strong>is_jalr</strong> 预测块内包含jalr指令</li>
<li><strong>is_call</strong> 预测块内包含call指令</li>
<li><strong>is_ret</strong> 预测块内包含ret指令</li>
<li><strong>last_may_be_rvi_call</strong> 预测结果预测块末尾可能为一个RVI类型的call指令信号</li>
<li><strong>is_br_sharing</strong> 最后一个slot (tailSlot) 中存储的是条件分支指令信号</li>
<li><strong>hit</strong> FTB表项是否命中</li>
</ul>
<p>可以看出存储的信息基本相同，两个Slot被拆分成了单独的信号：<code>slot_valids</code>, <code>targets</code>, <code>offsets</code>, <code>is_br_sharing</code> 等，另外增加了若干字段例如 <code>br_taken_mask</code>, <code>jar_target</code> 便于后续预测器提供精确预测结果。另外 <code>hit</code> 表示FTB项是否命中，这对于FTQ的更新也有重大用途，如果此轮预测没有FTB项命中，下一轮FTQ将会新生成一个FTB项返回给BPU。</p>
<h3 id="ftb-项的更新">FTB 项的更新</h3>
<p>TBD</p>
<blockquote>
<p>FTB项由FTQ块生成和更新</p>
</blockquote>
<h2 id="bpu的提交接口">BPU的提交接口</h2>
<p>TBD</p>
<h1 id="bpu-接口整理">BPU 接口整理</h1>
<h2 id="bpu-模块整体对外接口-predirectio">BPU 模块整体对外接口 (PredirectIO)</h2>
<p>接口定义: <code>src/main/scala/xiangshan/frontend/BPU.scala</code></p>
<p>PredirectIO 是分支预测器整体的对外接口，它主要处理了分支预测器（BPU）与取值目标缓冲（FTQ）之间的交互，主要包含以下几个部分：</p>
<ul>
<li><strong>bpu_to_ftq</strong>: BPU 向 FTQ 发送的信息，主要用于 BPU 向 FTQ 发送分支预测结果
<ul>
<li>接口类型： <code>BpuToFtqIO</code></li>
<li>信号列表：
<ul>
<li><strong>resp</strong>: BPU 向 FTQ 发送的信息
<ul>
<li>接口类型：<code>DecoupledIO(new BpuToFtqBundle())</code>
<ul>
<li><code>BpuToFtqBundle</code> 继承自 <code>BranchPredictionResp</code>，没有额外的信号</li>
</ul>
</li>
<li>信号列表：详见 (<code>BranchPredictionResp</code>)
<ul>
<li><strong>s1</strong> s1流水级的分支预测结果</li>
<li><strong>s2</strong> s2流水级的分支预测结果</li>
<li><strong>s3</strong> s3流水级的分支预测结果</li>
<li><strong>last_stage_meta</strong> 最后一个流水级的输出的预测器元数据</li>
<li><strong>last_stage_spec_info</strong> 最后一个流水级的输出的重定向时需要的信息</li>
<li><strong>last_stage_ftb_entry</strong> 最后一个流水级的输出的FTB表项</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>ftq_to_bpu</strong>: FTQ 向 BPU 发送的信息，主要用于处理重定向及更新请求
<ul>
<li>接口类型： <code>FtqToBpuIO</code></li>
<li>信号列表：
<ul>
<li><strong>redirect</strong>: FTQ 向 BPU 发送的重定向请求
<ul>
<li>接口类型： <code>Valid(new BranchPredictionRedirect)</code></li>
<li>接口列表：详见（<code>BranchPredictionRedirect</code>）</li>
</ul>
</li>
<li><strong>update</strong>: FTQ 向 BPU 发送的更新请求
<ul>
<li>接口类型：<code>Valid(new BranchPredictionUpdate)</code></li>
<li>接口列表：详见（<code>BranchPredictionUpdate</code>）</li>
</ul>
</li>
<li><strong>enq_ptr</strong>: FTQ发送给BPU的FTQ指针，告诉BPU下一次需要写到哪个FTQ表项
<ul>
<li>接口类型：<code>FtqPtr</code></li>
<li>接口列表：详见（<code>FtqPtr</code>）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>ctrl</strong>: BPU 控制信号，主要用于控制各预测器的使能
<ul>
<li>接口类型：<code>BPUCtrl</code></li>
<li>接口列表：
<ul>
<li><strong>ubtb_enable</strong>: UBTB使能</li>
<li><strong>btb_enable</strong>: BTB使能</li>
<li><strong>bim_enable</strong>: BIM使能</li>
<li><strong>tage_enable</strong>: TAGE使能</li>
<li><strong>sc_enable</strong>: SC使能</li>
<li><strong>ras_enable</strong>: RAS使能</li>
<li><strong>loop_enable</strong>: LOOP使能</li>
</ul>
</li>
</ul>
</li>
<li><strong>reset_vector</strong>: 重置向量，reset 时 BPU 的 pc 会被重置为该值
<ul>
<li>接口类型：<code>UInt(PAddrBits.W)</code></li>
</ul>
</li>
</ul>
<h2 id="全局分支预测信息-branchpredictionresp">全局分支预测信息 (BranchPredictionResp)</h2>
<p>接口定义: <code>src/main/scala/xiangshan/frontend/FrontendBundle.scala</code></p>
<p>该接口定义了分支预测器预测的所有结果信息，包含了每一阶段的预测结果，以及最后一个流水级输出的相关信息。</p>
<ul>
<li><strong>s1</strong> s1流水级的分支预测结果</li>
<li><strong>s2</strong> s2流水级的分支预测结果</li>
<li><strong>s3</strong> s3流水级的分支预测结果
<ul>
<li>接口类型：<code>BranchPredictionBundle</code></li>
<li>信号列表：详见（<code>BranchPredictionBundle</code>）</li>
</ul>
</li>
<li><strong>last_stage_meta</strong> 最后一个流水级的输出的预测器元数据。是一个位向量，由每个预测器生成、解析其中的数据
<ul>
<li>接口类型：<code>UInt(MaxMetaLength.W)</code></li>
<li>信号列表：详见（<code>BranchPredictionMeta</code>）</li>
</ul>
</li>
<li><strong>last_stage_spec_info</strong> 最后一个流水级的输出的重定向时需要的信息
<ul>
<li>接口类型：<code>Ftq_Redirect_SRAMEntry</code></li>
<li>接口列表：详见（<code>Ftq_Redirect_SRAMEntry</code>）</li>
</ul>
</li>
<li><strong>last_stage_ftb_entry</strong> 最后一个流水级的输出的FTB表项
<ul>
<li>接口类型：<code>FtqEntry</code></li>
<li>接口列表：详见（<code>FtqEntry</code>）</li>
</ul>
</li>
<li><strong>topdown_info</strong> 性能分析相关信息，RTL中无需考虑</li>
</ul>
<h2 id="单流水级分支预测结果-branchpredictionbundle">单流水级分支预测结果 (BranchPredictionBundle)</h2>
<p>接口定义: <code>src/main/scala/xiangshan/frontend/FrontendBundle.scala</code></p>
<p>该接口定义了每个流水级对外输出的分支预测结果信息，</p>
<ul>
<li><strong>pc</strong> 预测起始 pc
<ul>
<li>接口类型：<code>Vec(numDup, UInt(VAddrBits.W))</code> numDup仅为寄存器复制，其中信号完全相同</li>
</ul>
</li>
<li><strong>valid</strong> 预测结果是否有效
<ul>
<li>接口类型：<code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li><strong>hasRedirect</strong> 是否需要重定向
<ul>
<li>接口说明：只有s2, s3阶段会重定向，重定向发生时本阶段预测结果会覆盖之前流水级的结果</li>
<li>接口类型：<code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li><strong>ftq_idx</strong> FTQ指针，指向该阶段对应预测信息的FTQ表项
<ul>
<li>接口类型：<code>new FtqPtr</code></li>
<li>接口列表：详见（<code>FtqPtr</code>）</li>
</ul>
</li>
<li><strong>full_pred</strong> 完整的分支预测结果
<ul>
<li>接口类型：<code>Vec(numDup, new FullBranchPrediction)</code></li>
<li>接口列表：详见（<code>FullBranchPrediction</code>）</li>
</ul>
</li>
</ul>
<h2 id="完整的分支预测结果-fullbranchprediction">完整的分支预测结果 (FullBranchPrediction)</h2>
<p>接口定义: <code>src/main/scala/xiangshan/frontend/FrontendBundle.scala</code></p>
<p>该接口定义了完整的分支预测结果，每流水级预测结果中都会包含该接口。</p>
<ul>
<li><strong>br_taken_mask</strong> 分支预测结果，每个分支(slot)对应一个 bit，表示该分支是否被预测为 taken
<ul>
<li>接口类型：<code>Vec(numBr, Bool())</code></li>
</ul>
</li>
<li><strong>slot_valids</strong> slot有效位，表示 ftb 项中的每个 slot 是否有效
<ul>
<li>接口类型：<code>Vec(totalSlot, Bool())</code></li>
</ul>
</li>
<li><strong>targets</strong> 每个slot对应的跳转目标地址
<ul>
<li>接口类型：<code>Vec(totalSlot, UInt(VAddrBits.W))</code></li>
</ul>
</li>
<li><strong>jalr_target</strong> 本预测块中的 jalr 的跳转目标
<ul>
<li>接口类型：<code>UInt(VAddrBits.W)</code></li>
</ul>
</li>
<li><strong>offsets</strong> 每个slot中的指令相对于预测块起始地址的偏移
<ul>
<li>接口类型：<code>Vec(totalSlot, UInt(log2Ceil(PredictWidth).W))</code></li>
</ul>
</li>
<li><strong>fallThroughAddr</strong> 具体用途还不清楚（文档：当前预测块不跳转的下一个 pc）
<ul>
<li>接口类型：<code>UInt(VAddrBits.W)</code></li>
</ul>
</li>
<li><strong>fallThroughErr</strong> 具体用途还不清楚(文档：预测出的下一个顺序取指地址是否存在错误)
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>is_jal</strong> 预测块内包含jal指令
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>is_jalr</strong> 预测块内包含jalr指令
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>is_call</strong> 预测块内包含call指令
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>is_ret</strong> 预测块内包含ret指令
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>last_may_be_rvi_call</strong> 预测结果预测块末尾可能为一个RVI类型的call指令信号
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>is_br_sharing</strong> 最后一个slot (tailSlot) 中存储的是条件分支指令信号
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>hit</strong> FTB表项是否命中
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
</ul>
<h2 id="ftb表项-ftqentry">FTB表项 (FtqEntry)</h2>
<p>接口定义: <code>src/main/scala/xiangshan/frontend/FTB.scala</code></p>
<p>FTB表项是分支预测器的核心数据结构，FTB项可被用于生成完整预测结果</p>
<ul>
<li><strong>valid</strong> FTB表项是否有效
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>brSlots</strong> 可记录一条分支指令的信息
<ul>
<li>接口类型：<code>Vec(numBrSlot, new FtbSlot(BR_OFFSET_LEN))</code>
<ul>
<li>numBrSlot = 1</li>
</ul>
</li>
<li>接口列表：详见（<code>FtbSlot</code>）</li>
</ul>
</li>
<li><strong>tailSlot</strong> 可记录块内第二条分支指令 或 一条无条件跳转/间接跳转指令
<ul>
<li>接口类型：<code>new FtbSlot(JMP_OFFSET_LEN, Some(BR_OFFSET_LEN))</code>
<ul>
<li>JMP_OFFSET_LEN = 20</li>
<li>BR_OFFSET_LEN = 12</li>
</ul>
</li>
<li>接口列表：详见（<code>FtbSlot</code>）</li>
</ul>
</li>
<li><strong>pftAddr</strong> 具体用途还不清楚(文档：当前预测块如果不跳转，下一条指令的PC)
<ul>
<li>接口类型：<code>UInt(log2Up(PredictWidth).W)</code></li>
</ul>
</li>
<li><strong>carry</strong> (文档：ftb_entry 中当前预测块不跳转的下一个 pc 预测地址进位)
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>isCall</strong> 预测块内包含call指令
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>isRet</strong> 预测块内包含ret指令
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>isJalr</strong> 预测块内包含jalr指令
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>last_may_be_rvi_call</strong> 预测结果预测块末尾可能为一个RVI类型的call指令信号
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>always_taken</strong> 该预测块中的每个分支指令是否总是被预测为 taken
<ul>
<li>接口类型：<code>Vec(numBr, Bool())</code></li>
</ul>
</li>
</ul>
<h2 id="ftb表项中的分支指令信息-ftbslot">FTB表项中的分支指令信息 (FtbSlot)</h2>
<p>接口定义: <code>src/main/scala/xiangshan/frontend/FTB.scala</code></p>
<p>该接口定义了 FTB 表项中 Slot</p>
<ul>
<li><strong>offset</strong> 该Slot中指令相对于预测块起始地址的偏移
<ul>
<li>接口类型：<code>UInt(log2Ceil(PredictWidth).W)</code></li>
</ul>
</li>
<li><strong>lower</strong> 跳转目标地址的低位
<ul>
<li>接口说明：这里设置lower为12为或20位，因为分支指令的寻址能力为12位，而跳转指令的寻址能力为20位</li>
<li>接口类型：<code>UInt(offsetLen.W)</code></li>
</ul>
</li>
<li><strong>tarStat</strong> 跳转后的pc高位是否进退位
<ul>
<li>接口说明：为 Slot 存 offset，所以地址计算时 pc 加上 offset 可能产生进/退位，加上不进/退位的共三种情况，编码为 2 bit</li>
<li>接口类型：<code>UInt(TAR_STAT_SZ.W)</code>
<ul>
<li>TAR_STAT_SZ = 2</li>
</ul>
</li>
</ul>
</li>
<li><strong>sharing</strong> br 分享了 jal 的 slot
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>valid</strong> brSlots有效位
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
</ul>
<h2 id="分支预测更新branchpredictionupdate">分支预测更新（BranchPredictionUpdate）</h2>
<p>接口定义: <code>src/main/scala/xiangshan/frontend/FrontendBundle.scala</code></p>
<p>该接口定义了分支预测器的更新请求，主要用于更新分支预测器的状态。</p>
<ul>
<li><strong>pc</strong> 更新请求的pc (预测块起始地址)
<ul>
<li>接口类型：<code>UInt(VAddrBits.W)</code></li>
</ul>
</li>
<li><strong>spec_info</strong> FTQ存储的redirect信息
<ul>
<li>接口类型：<code>new SpeculativeInfo</code></li>
<li>接口列表：详见（<code>SpeculativeInfo</code>）</li>
</ul>
</li>
<li><strong>ftb_entry</strong> 更新后的ftb项
<ul>
<li>接口类型：<code>new FTBEntry()</code></li>
<li>接口列表：详见（<code>FTBEntry</code>）</li>
</ul>
</li>
<li><strong>cfi_idx</strong> 控制流指令索引
<ul>
<li>接口类型：<code>ValidUndirectioned(UInt(log2Ceil(PredictWidth).W))</code></li>
</ul>
</li>
<li><strong>br_taken_mask</strong> 预测块内每个slot内指令是否跳转
<ul>
<li>接口类型：<code>Vec(numBr, Bool())</code></li>
</ul>
</li>
<li><strong>br_committed</strong> 预测块内每个slot内指令是否提交
<ul>
<li>接口类型：<code>Vec(numBr, Bool())</code></li>
</ul>
</li>
<li><strong>jmp_taken</strong> 是否是跳转指令被触发
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>mispred_mask</strong> 预测块内每个slot内指令是否预测错误
<ul>
<li>接口类型：<code>Vec(numBr+1, Bool())</code></li>
</ul>
</li>
<li><strong>pred_hit</strong> ftb项的是否命中
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>false_hit</strong> ftb项是否错误命中（命中了但是预测错误）
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>new_br_insert_pos</strong> 新生效的br插入位置
<ul>
<li>接口类型：<code>Vec(numBr, Bool())</code></li>
</ul>
</li>
<li><strong>old_entry</strong> 旧的ftb项
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>meta</strong> ftq项对应的bpu meta信息
<ul>
<li>接口类型：<code>UInt(MaxMetaLength.W)</code></li>
</ul>
</li>
<li><strong>full_target</strong> 预测块的跳转目标（下一个预测块的起始地址）
<ul>
<li>接口类型：<code>UInt(VAddrBits.W)</code></li>
</ul>
</li>
<li><strong>from_stage</strong> 信息是从bpu哪个阶段得来的
<ul>
<li>接口类型：<code>UInt(2.W)</code></li>
</ul>
</li>
<li><strong>ghist</strong> 未使用
<ul>
<li>接口类型：<code>UInt(HistoryLength.W)</code></li>
</ul>
</li>
</ul>
<h2 id="分支预测重定向branchpredictionredirect">分支预测重定向（BranchPredictionRedirect）</h2>
<p>接口定义: <code>src/main/scala/xiangshan/frontend/FrontendBundle.scala</code></p>
<p>该接口定义了分支预测器的重定向请求，主要用于重定向分支预测器的状态。</p>
<ul>
<li><strong>isRVC</strong></li>
<li><strong>robIdx</strong></li>
<li><strong>ftqIdx</strong> 重定向对应的ftq索引
<ul>
<li>接口类型：<code>new FtqPtr</code></li>
<li>接口列表：详见（<code>FtqPtr</code>）</li>
</ul>
</li>
<li><strong>ftqOffset</strong> 预测错误的跳转指令索引
<ul>
<li>接口类型：<code>UInt(log2Up(PredictWidth).W)</code></li>
</ul>
</li>
<li><strong>level</strong> 重定向级别</li>
<li><strong>interrupt</strong></li>
<li><strong>cfiUpdate</strong> 控制流信息
<ul>
<li>接口类型：<code>CfiUpdateInfo</code></li>
<li>接口列表（部分）：
<ul>
<li><strong>pc</strong> 预测错误的跳转指令的pc
<ul>
<li>接口类型：<code>UInt(VAddrBits.W)</code></li>
</ul>
</li>
<li><strong>pd</strong> 预测错误的跳转指令的预测码信息
<ul>
<li>接口类型：<code>UInt(PredictWidth.W)</code></li>
</ul>
</li>
<li><strong>predTaken</strong> 预测信息中读出的 预测块是否有跳转
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>target</strong> 跳转指令的跳转目标
<ul>
<li>接口类型：<code>UInt(VAddrBits.W)</code></li>
</ul>
</li>
<li><strong>taken</strong> 根据预译码分析得来的：预测块是否有跳转
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>isMisPred</strong> 是否误预测 (含有预测错误的跳转指令)
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="子分支预测器接口-basepredictorio">子分支预测器接口 (BasePredictorIO)</h2>
<p>接口定义: <code>src/main/scala/xiangshan/frontend/BPU.scala</code></p>
<p>每个子分支预测器都需要实现该接口，该接口定义了子分支预测器的输入输出接口。</p>
<ul>
<li><strong>reset_vector</strong> 重置向量，reset 时 BPU 的 pc 会被重置为该值
<ul>
<li>接口类型：<code>UInt(PAddrBits.W)</code></li>
</ul>
</li>
<li><strong>in</strong> BPU 向子分支预测器发送的信息
<ul>
<li>接口类型：<code>DecoupledIO(new BasePredictorInput)</code></li>
<li>信号列表：
<ul>
<li><strong>s0_pc</strong> s0流水级的pc
<ul>
<li>接口类型：<code>Vec(numDup, UInt(VAddrBits.W))</code></li>
</ul>
</li>
<li><strong>folded_hist</strong> 全局折叠历史信息
<ul>
<li>接口类型：<code>Vec(numDup, new AllFoldedHistories(foldedGHistInfos))</code></li>
<li>信号列表：详见（<code>AllFoldedHistories</code>）</li>
</ul>
</li>
<li><strong>ghist</strong> 全局分支历史信息
<ul>
<li>接口类型：<code>UInt(HistoryLength.W)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>out</strong> 子分支预测器向 BPU 发送的信息
<ul>
<li>接口类型：<code>new BasePredictorOutput</code> 继承自 <code>BranchPredictionResp</code></li>
<li>信号列表：详见（<code>BranchPredictionResp</code>）</li>
</ul>
</li>
<li><strong>ctrl</strong> BPU 控制信号，主要用于控制各预测器的使能
<ul>
<li>接口类型：<code>BPUCtrl</code></li>
<li>接口列表：
<ul>
<li><strong>ubtb_enable</strong>: UBTB使能</li>
<li><strong>btb_enable</strong>: BTB使能</li>
<li><strong>bim_enable</strong>: BIM使能</li>
<li><strong>tage_enable</strong>: TAGE使能</li>
<li><strong>sc_enable</strong>: SC使能</li>
<li><strong>ras_enable</strong>: RAS使能</li>
<li><strong>loop_enable</strong>: LOOP使能</li>
</ul>
</li>
</ul>
</li>
<li><strong>s0_fire</strong> s0阶段握手成功信号
<ul>
<li>接口类型：<code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li><strong>s1_fire</strong> s1阶段握手成功信号
<ul>
<li>接口类型：<code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li><strong>s2_fire</strong> s2阶段握手成功信号
<ul>
<li>接口类型：<code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li><strong>s3_fire</strong> s3阶段握手成功信号
<ul>
<li>接口类型：<code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li><strong>s2_redirect</strong> s2阶段重定向信号
<ul>
<li>接口类型：<code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li><strong>s3_redirect</strong> s3阶段重定向信号
<ul>
<li>接口类型：<code>Vec(numDup, Bool())</code></li>
</ul>
</li>
<li><strong>s1_ready</strong> s1阶段是否准备好接收信息
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>s2_ready</strong> s2阶段是否准备好接收信息
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>s3_ready</strong> s3阶段是否准备好接收信息
<ul>
<li>接口类型：<code>Bool()</code></li>
</ul>
</li>
<li><strong>update</strong> BPU 向子分支预测器发送的更新请求
<ul>
<li>接口类型：<code>Valid(new BranchPredictionUpdate)</code></li>
<li>信号列表：详见（<code>BranchPredictionUpdate</code>）</li>
</ul>
</li>
<li><strong>redirect</strong> BPU 向子分支预测器发送的重定向请求
<ul>
<li>接口类型：<code>Valid(new BranchPredictionRedirect)</code></li>
<li>信号列表：详见（<code>BranchPredictionRedirect</code>）</li>
</ul>
</li>
</ul>

    </div>
</div>


<div class="container mb-5">

    
    <div class="btn-toolbar mb-2 bio" role="toolbar" aria-label="Toolbar with button groups">
        <i class="fas fa-filter"></i>
        <div id="filters" class="button-group">
            
            
            <input type="checkbox" class="btn-check" id=".js-iso-tag1" autocomplete="off" data-filter=".js-iso-tag1">
            <label class="button" for=".js-iso-tag1">tag1</label>  
            
            
            <input type="checkbox" class="btn-check" id=".js-iso-tag2" autocomplete="off" data-filter=".js-iso-tag2">
            <label class="button" for=".js-iso-tag2">tag2</label>  
            
        </div>
    </div>

    
    

    

</div>


<div class="container">
    <div class="row row-cols-1 row-cols-md-2 row-cols-lg-3 row-cols-xl-4 g-4" id="blogposts">
        
        

    

<div class='col  js-iso-tag2'>
    <div class="card top-highlight">
        <div class="card-body">
             
            <h4 class="card-title">BPU</h4>
            <p class="card-text pb-3">BPU</p>
            
            
            <a href="https://xs-mlvp.github.io/crowdsourcing/kunminghu_bpu/bpu/" class="stretched-link"></a>
            
            <hr class="dropdown-divider">
            <div class="row justify-content-between">
                <div class="col-6">
                    
                    
                    <span style="font-size: small"> Jan 11, 2024</span>
                </div>
                <div class="col-6" style="text-align: right">
                     
                </div>
            </div>
            
            <span class="badge tag-badge">tag2</span>
            
        </div>
    </div>
</div>

        
        

    

<div class='col  js-iso-tag1'>
    <div class="card top-highlight">
        <div class="card-body">
             
            <h4 class="card-title">uFTB 模块</h4>
            <p class="card-text pb-3">uFTB的介绍XXXX
功能点概述：
验证要求：</p>
            
            
            <a href="https://xs-mlvp.github.io/crowdsourcing/kunminghu_bpu/uftb/" class="stretched-link"></a>
            
            <hr class="dropdown-divider">
            <div class="row justify-content-between">
                <div class="col-6">
                    
                    
                    <span style="font-size: small"> Jan 11, 2024</span>
                </div>
                <div class="col-6" style="text-align: right">
                     
                </div>
            </div>
            
            <span class="badge tag-badge">tag1</span>
            
        </div>
    </div>
</div>

        
        

    

<div class='col  js-iso-tag1'>
    <div class="card top-highlight">
        <div class="card-body">
             
            <h4 class="card-title">FTB 模块</h4>
            <p class="card-text pb-3">FTB的介绍XXXX
功能点概述：
验证要求：</p>
            
            
            <a href="https://xs-mlvp.github.io/crowdsourcing/kunminghu_bpu/ftb/" class="stretched-link"></a>
            
            <hr class="dropdown-divider">
            <div class="row justify-content-between">
                <div class="col-6">
                    
                    
                    <span style="font-size: small"> Jan 11, 2024</span>
                </div>
                <div class="col-6" style="text-align: right">
                     
                </div>
            </div>
            
            <span class="badge tag-badge">tag1</span>
            
        </div>
    </div>
</div>

        
     </div>
</div>


        </div><div class="container">
    <div class="row justify-content-between">
        <div class="col-sm-4">
            <p class="footer">MLVP Group © 2024 </p>
        </div>
        <div class="col-sm-6 d-flex flex-row-reverse">
            
            <a class="footer-social px-2"  href="#" target="_blank"><i class="fab fa-weixin"></i></a>
            
            <a class="footer-social px-2"  href="#" target="_blank"><i class="fab fa-weibo"></i></a>
            
        </div>
    </div>
</div>
<script src="/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/js/jquery.min.js"></script>
<script src="/js/isotope.pkgd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha384-GNFwBvfVxBkLMJpYMOABq3c+d3KnQxudP/mGPkzpZSTYykLBNsZEnG2D9G/X/+7D" crossorigin="anonymous" async></script>
<script src="/js/dark.js"></script>
<script>


var savedTheme = localStorage.getItem("dark-mode-storage") || "light" 
setTheme(savedTheme);

</script>
<script src="/js/isotope.js"></script>
<script src="/js/mermaid.min.js"></script>
<script>mermaid.initialize({ startOnLoad: true, securityLevel: 'loose'});</script>
</body>
</html>
